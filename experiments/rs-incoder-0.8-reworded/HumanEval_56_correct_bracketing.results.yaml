language: rs
name: HumanEval_56_correct_bracketing
results:
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut bracket = String::from(brackets);\n    loop {\n        let mut next = String::from(bracket);\n\
    \        let mut is_open = false;\n        while let Some(open) = next.find(char::from('>'))\
    \ {\n            if next == open {\n                // Next closing is open\n\
    \                next = next.as_str() + '>';\n                is_open = true;\n\
    \                break;\n            }\n            next = next.as_str() + open;\n\
    \        }\n        if next == bracket {\n            // No more opening\n   \
    \         break;\n        }\n        // Found a mismatch\n        next = next.as_str()\
    \ + bracket;\n        return false;\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `String` with `usize`\n  --> /tmp/tmprl23h3ho.rs:17:21\n\
    \   |\n17 |             if next == open {\n   |                     ^^ no implementation\
    \ for `String == usize`\n   |\n   = help: the trait `PartialEq<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n         \
    \    <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0369]: cannot add `char` to `&str`\n  --> /tmp/tmprl23h3ho.rs:19:38\n\
    \   |\n19 |                 next = next.as_str() + '>';\n   |                \
    \        ------------- ^ --- char\n   |                        |\n   |       \
    \                 &str\n\nerror[E0369]: cannot add `usize` to `&str`\n  --> /tmp/tmprl23h3ho.rs:23:34\n\
    \   |\n23 |             next = next.as_str() + open;\n   |                   \
    \ ------------- ^ ---- usize\n   |                    |\n   |                \
    \    &str\n\nerror[E0369]: cannot add `String` to `&str`\n  --> /tmp/tmprl23h3ho.rs:30:30\n\
    \   |\n30 |         next = next.as_str() + bracket;\n   |                -------------\
    \ ^ ------- String\n   |                |             |\n   |                |\
    \             `+` cannot be used to concatenate a `&str` with a `String`\n   |\
    \                &str\n   |\nhelp: create an owned `String` on the left and add\
    \ a borrow on the right\n   |\n30 |         next = next.as_str().to_owned() +\
    \ &bracket;\n   |                             +++++++++++   +\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0369.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut iter = brackets.chars().enumerate();\n    let mut first = true;\n    let\
    \ mut open_brackets = String::new();\n    while let Some((idx, char)) = iter.next()\
    \ {\n        if !first {\n            open_brackets.push_str(\", \");\n      \
    \  }\n        open_brackets.push(char);\n        first = false;\n    }\n    let\
    \ mut last = String::new();\n    let mut closed_brackets = String::new();\n  \
    \  while let Some((idx, char)) = iter.next() {\n        if let Some(next_char)\
    \ = (idx + 1).checked_sub(1).unwrap() {\n            if open_brackets.contains(&char)\
    \ && closed_brackets.contains(&next_char) {\n                return false;\n \
    \           }\n        }\n        last.push(char);\n    }\n    closed_brackets.push_str(last);\n\
    \    open_brackets.push_str(last);\n    true\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkthkqnqi.rs:25:16\n   |\n\
    25 |         if let Some(next_char) = (idx + 1).checked_sub(1).unwrap() {\n  \
    \ |                ^^^^^^^^^^^^^^^   --------------------------------- this expression\
    \ has type `usize`\n   |                |\n   |                expected `usize`,\
    \ found enum `Option`\n   |\n   = note: expected type `usize`\n              found\
    \ enum `Option<_>`\n\nerror[E0277]: expected a `Fn<(char,)>` closure, found `char`\n\
    \    --> /tmp/tmpkthkqnqi.rs:26:39\n     |\n26   |             if open_brackets.contains(&char)\
    \ && closed_brackets.contains(&next_char) {\n     |                          \
    \    -------- ^^^^^ expected an `Fn<(char,)>` closure, found `char`\n     |  \
    \                            |\n     |                              required by\
    \ a bound introduced by this call\n     |\n     = help: the trait `Fn<(char,)>`\
    \ is not implemented for `char`\n     = note: required because of the requirements\
    \ on the impl of `FnOnce<(char,)>` for `&char`\n     = note: required because\
    \ of the requirements on the impl of `Pattern<'_>` for `&char`\nnote: required\
    \ by a bound in `core::str::<impl str>::contains`\nhelp: consider dereferencing\
    \ here\n     |\n26   |             if open_brackets.contains(*&char) && closed_brackets.contains(&next_char)\
    \ {\n     |                                       +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpkthkqnqi.rs:32:30\n   |\n32 |     closed_brackets.push_str(last);\n\
    \   |                              ^^^^\n   |                              |\n\
    \   |                              expected `&str`, found struct `String`\n  \
    \ |                              help: consider borrowing here: `&last`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpkthkqnqi.rs:33:28\n   |\n33 |     open_brackets.push_str(last);\n\
    \   |                            ^^^^\n   |                            |\n   |\
    \                            expected `&str`, found struct `String`\n   |    \
    \                        help: consider borrowing here: `&last`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed expla"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    //\
    \ TODO: Write a test case\n    let mut bracket_count = 0;\n    let mut opening_brackets\
    \ = String::new();\n    let mut closing_brackets = String::new();\n    let mut\
    \ stack: Vec<&str> = Vec::new();\n    stack.push(brackets.as_str());\n    while\
    \ !stack.is_empty() {\n        let mut current = stack.as_str();\n        match\
    \ current {\n            \"<\" => {\n                bracket_count++;\n      \
    \          opening_brackets.push_str(\"</>\");\n                stack.push(&mut\
    \ opening_brackets);\n            }\n            \"<\" => {\n                bracket_count++;\n\
    \                opening_brackets.push_str(\"</\");\n                stack.push(&mut\
    \ opening_brackets);\n            }\n            \">\" => {\n                bracket_count--;\n\
    \                let mut popped = stack.last().unwrap();\n                closing_brackets.push_str(popped);\n\
    \                stack.last_mut().unwrap().push_str(\"/>\");\n            }\n\
    \            \">\" => {\n                bracket_count--;\n                let\
    \ mut popped = stack.last().unwrap();\n                closing_brackets.push_str(popped);\n\
    \                stack.last_mut().unwrap().push_str(\"/>\");\n            }\n\
    \            \">\" => {\n                bracket_count--;\n                let\
    \ mut popped = stack.last().unwrap();\n                closing_brackets.push_str(popped);\n\
    \                stack.last_mut().unwrap().push_str(\"/>\");\n            }\n\
    \            \"<\" => {\n                bracket_count--;\n                let\
    \ mut popped = stack.last().unwrap();\n                closing_brackets.push_str(popped);\n\
    \                stack.last_mut().unwrap().push_str(\"/>\");\n            }\n\
    \            _ => {\n                let mut popped = stack.last().unwrap();\n\
    \                closing_brackets.push_str(popped);\n                stack.last_mut().unwrap().push_str(\"\
    />\");\n            }\n        }\n    }\n    bracket_count == 0\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp4dq53cos.rs:22:30\n\
    \   |\n22 |                 bracket_count++;\n   |                           \
    \   ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n22\
    \ |                 { let tmp = bracket_count; bracket_count += 1; tmp };\n  \
    \ |                 +++++++++++              ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n22 -\
    \                 bracket_count++;\n22 +                 bracket_count += 1;\n\
    \   | \n\nerror: Rust has no postfix increment operator\n  --> /tmp/tmp4dq53cos.rs:27:30\n\
    \   |\n27 |                 bracket_count++;\n   |                           \
    \   ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n27\
    \ |                 { let tmp = bracket_count; bracket_count += 1; tmp };\n  \
    \ |                 +++++++++++              ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n27 -\
    \                 bracket_count++;\n27 +                 bracket_count += 1;\n\
    \   | \n\nerror: expected expression, found `;`\n  --> /tmp/tmp4dq53cos.rs:32:32\n\
    \   |\n32 |                 bracket_count--;\n   |                           \
    \     ^ expected expression\n\nerror: expected expression, found `;`\n  --> /tmp/tmp4dq53cos.rs:38:32\n\
    \   |\n38 |                 bracket_count--;\n   |                           \
    \     ^ expected expression\n\nerror: expected expression, found `;`\n  --> /tmp/tmp4dq53cos.rs:44:32\n\
    \   |\n44 |                 bracket_count--;\n   |                           \
    \     ^ expected expression\n\nerror: expected expression, found `;`\n  --> /tmp/tmp4dq53cos.rs:50:32\n\
    \   |\n50 |                 bracket_count--;\n   |                           \
    \     ^ expected expression\n\nerror[E0599]: no method named `as_str` found for\
    \ struct `Vec<&str>` in the current scope\n  --> /tmp/tmp4dq53cos.rs:19:33\n \
    \  |\n19 |         let mut current = stack.as_str();\n   |                   \
    \              ^^^^^^ help: there is an associated function with a similar name:\
    \ `as_ptr`\n\nerror[E0599]: no method named `push_str` found for mutable reference\
    \ `&mut &str` in the current scope\n  --> /tmp/tmp4dq53cos.rs:58:43\n   |\n58\
    \ |                 "
  stdout: ''
  timestamp: 1659976566
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    if\
    \ brackets.len() < 2 {\n        return false;\n    }\n    let mut found = false;\n\
    \    for (i, c) in brackets.chars().enumerate() {\n        if c == '>' {\n   \
    \         if found {\n                return false;\n            }\n         \
    \   found = true;\n        } else if c == '<' {\n            if !found {\n   \
    \             return false;\n            }\n            found = false;\n     \
    \   }\n    }\n    found\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpifa0v06u.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets\n\
    \        .as_str()\n        .chars()\n        .all(|c| *c != '<' && *c != '>'\
    \ && *c != '[' && *c != ']')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpetw_g0_m.rs:15:18\n\
    \   |\n15 |         .all(|c| *c != '<' && *c != '>' && *c != '[' && *c != ']')\n\
    \   |                  ^^\n\nerror[E0614]: type `char` cannot be dereferenced\n\
    \  --> /tmp/tmpetw_g0_m.rs:15:31\n   |\n15 |         .all(|c| *c != '<' && *c\
    \ != '>' && *c != '[' && *c != ']')\n   |                               ^^\n\n\
    error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpetw_g0_m.rs:15:44\n\
    \   |\n15 |         .all(|c| *c != '<' && *c != '>' && *c != '[' && *c != ']')\n\
    \   |                                            ^^\n\nerror[E0614]: type `char`\
    \ cannot be dereferenced\n  --> /tmp/tmpetw_g0_m.rs:15:57\n   |\n15 |        \
    \ .all(|c| *c != '<' && *c != '>' && *c != '[' && *c != ']')\n   |           \
    \                                              ^^\n\nerror: aborting due to 4\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0614`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ *c == String::from('>')) && !brackets.chars().all(|c| *c == String::from('<'))\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmp83cmht9v.rs:12:30\n\
    \   |\n12 |     brackets.chars().all(|c| *c == String::from('>')) && !brackets.chars().all(|c|\
    \ *c == String::from('<'))\n   |                              ^^\n\nerror[E0614]:\
    \ type `char` cannot be dereferenced\n  --> /tmp/tmp83cmht9v.rs:12:84\n   |\n\
    12 |     brackets.chars().all(|c| *c == String::from('>')) && !brackets.chars().all(|c|\
    \ *c == String::from('<'))\n   |                                             \
    \                                       ^^\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut opens = String::new();\n    let mut closes = String::new();\n    for c in\
    \ brackets.chars() {\n        match c {\n            '<' => opens.push(c),\n \
    \           '>' => closes.push(c),\n            _ => (),\n        }\n    }\n \
    \   opens.len() == closes.len()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpht7unr34.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c < ']')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpkay9t7k0.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().any(|c|\
    \ c == b'<')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4a67pd1x.rs:12:35\n   |\n\
    12 |     brackets.chars().any(|c| c == b'<')\n   |                           \
    \        ^^^^ expected `char`, found `u8`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut s = String::new();\n    let mut open = String::new();\n    let mut close\
    \ = String::new();\n\n    for c in brackets {\n        if c.is_digit(10) {\n \
    \           s.push_str(&c.to_string());\n            continue;\n        }\n  \
    \      if c == '<' {\n            open = s.clone();\n            s.push_str(&c);\n\
    \            continue;\n        }\n        if c == '>' {\n            close =\
    \ s.clone();\n            s.push_str(&c);\n            continue;\n        }\n\
    \        if c == ']' {\n            if open == \"\" {\n                s.push_str(&c);\n\
    \                break;\n            }\n        }\n        if c == '[' {\n   \
    \         if close == \"\" {\n                s.push_str(&c);\n              \
    \  break;\n            }\n        }\n        s.push_str(&c);\n    }\n\n    let\
    \ open_index = s.find('[');\n    let close_index = s.find(']');\n    if open_index\
    \ == -1 {\n        if close_index == -1 {\n            s.push_str(&brackets[..]);\n\
    \            return true;\n        }\n        return false;\n    }\n    let mut\
    \ open = String::from(\"\");\n    let mut close = String::from(\"\");\n    for\
    \ i in open_index..(close_index + 1) {\n        open += s[i];\n    }\n    for\
    \ i in 0..(close_index - open_index + 1) {\n        close += s[i];\n    }\n  \
    \  if open == close {\n        return true;\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmppl_rdu0c.rs:16:14\n\
    \   |\n16 |     for c in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmppl_rdu0c.rs:48:22\n   |\n48 |     if open_index == -1 {\n\
    \   |                      ^^ expected enum `Option`, found integer\n   |\n  \
    \ = note: expected enum `Option<usize>`\n              found type `{integer}`\n\
    help: try wrapping the expression in `Some`\n   |\n48 |     if open_index == Some(-1)\
    \ {\n   |                      +++++  +\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmppl_rdu0c.rs:49:27\n   |\n49 |         if close_index == -1 {\n   | \
    \                          ^^ expected enum `Option`, found integer\n   |\n  \
    \ = note: expected enum `Option<usize>`\n              found type `{integer}`\n\
    help: try wrapping the expression in `Some`\n   |\n49 |         if close_index\
    \ == Some(-1) {\n   |                           +++++  +\n\nerror[E0369]: cannot\
    \ add `{integer}` to `Option<usize>`\n  --> /tmp/tmppl_rdu0c.rs:57:39\n   |\n\
    57 |     for i in open_index..(close_index + 1) {\n   |                      \
    \     ----------- ^ - {integer}\n   |                           |\n   |      \
    \                     Option<usize>\n\nerror[E0277]: the trait bound `Option<usize>:\
    \ Step` is not satisfied\n  --> /tmp/tmppl_rdu0c.rs:57:14\n   |\n57 |     for\
    \ i in open_index..(close_index + 1) {\n   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ the trait `Step` is not implemented for `Option<usize>`\n   |\n   = help: the\
    \ following other types implement trait `Step`:\n             char\n         \
    \    i128\n             i16\n             i32\n             i64\n            \
    \ i8\n             isize\n             u128\n           and 5 others\n   = note:\
    \ required because of the requirements on the impl of `Iterator` for `std::ops::Range<Option<usize>>`\n\
    \   = note: required because of the requireme"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    if\
    \ brackets == \"\" {\n        true\n    } else {\n        brackets.chars().enumerate().all(|&(_,\
    \ c)| !(c == '<' || c == '>'))\n    }\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3k0he0ln.rs:15:43\n   |\n\
    15 |         brackets.chars().enumerate().all(|&(_, c)| !(c == '<' || c == '>'))\n\
    \   |                                           ^^^^^^-\n   |                \
    \                           |     |\n   |                                    \
    \       |     expected due to this\n   |                                     \
    \      expected tuple, found reference\n   |\n   = note:  expected tuple `(usize,\
    \ char)`\n           found reference `&_`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut iter = brackets.char_indices();\n    let mut current = iter.next();\n  \
    \  let mut previous_char = None;\n\n    while let Some(index) = current {\n  \
    \      let mut current_char = match index {\n            0 => iter.next(),\n \
    \           _ => None,\n        };\n\n        if let Some(current_char) = (previous_char,\
    \ current_char) {\n            // if any pair of brackets closes the previous\
    \ opening bracket, that\n            // bracket must have the same opening bracket.\n\
    \            if current_char == Some('>') {\n                if previous_char\
    \ == Some('[') {\n                    return true;\n                }\n      \
    \          if previous_char == Some('(') {\n                    return true;\n\
    \                }\n            } else if current_char == Some('<') {\n      \
    \          if previous_char == Some('[') {\n                    return true;\n\
    \                }\n                if previous_char == Some('(') {\n        \
    \            return true;\n                }\n            }\n        }\n\n   \
    \     previous_char = current_char;\n        current = iter.next();\n    }\n\n\
    \    // we reached the end of the string without having found an opening bracket\n\
    \    // pair.\n    false\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpe9h6bceg.rs:18:13\n   |\n\
    17 |         let mut current_char = match index {\n   |                      \
    \                ----- this expression has type `(usize, char)`\n18 |        \
    \     0 => iter.next(),\n   |             ^ expected tuple, found integer\n  \
    \ |\n   = note: expected tuple `(usize, char)`\n               found type `{integer}`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpe9h6bceg.rs:22:16\n   |\n22 |\
    \         if let Some(current_char) = (previous_char, current_char) {\n   |  \
    \              ^^^^^^^^^^^^^^^^^^   ----------------------------- this expression\
    \ has type `(Option<_>, Option<(usize, char)>)`\n   |                |\n   | \
    \               expected tuple, found enum `Option`\n   |\n   = note: expected\
    \ tuple `(Option<_>, Option<(usize, char)>)`\n               found enum `Option<_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpe9h6bceg.rs:42:25\n   |\n14 |\
    \     let mut previous_char = None;\n   |                             ---- expected\
    \ due to this value\n...\n42 |         previous_char = current_char;\n   |   \
    \                      ^^^^^^^^^^^^ expected `char`, found tuple\n   |\n   = note:\
    \ expected enum `Option<char>`\n              found enum `Option<(usize, char)>`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    //\
    \ We only have one level of brackets, so we must check that every pair\n    //\
    \ of brackets is a pair, and that there are no more brackets than opening\n  \
    \  // brackets\n    for i in 0..brackets.len() - 1 {\n        if !is_opening_bracket(brackets[i..i\
    \ + 1]) {\n            return false;\n        }\n    }\n    for i in 0..brackets.len()\
    \ - 2 {\n        if is_opening_bracket(brackets[i..i + 2]) {\n            return\
    \ false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_opening_bracket` in this scope\n\
    \  --> /tmp/tmp965muxrb.rs:16:13\n   |\n16 |         if !is_opening_bracket(brackets[i..i\
    \ + 1]) {\n   |             ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `is_opening_bracket` in this scope\n  --> /tmp/tmp965muxrb.rs:21:12\n\
    \   |\n21 |         if is_opening_bracket(brackets[i..i + 2]) {\n   |        \
    \    ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets_iter = brackets.chars().nth(1).unwrap();\n    while let Some(next)\
    \ = brackets_iter.next() {\n        if next == '>' {\n            brackets_iter.next();\n\
    \        }\n        else {\n            return false;\n        }\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `next` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpa6zmolep.rs:13:42\n   |\n13 |     while let Some(next)\
    \ = brackets_iter.next() {\n   |                                          ^^^^\
    \ method not found in `char`\n\nerror[E0599]: no method named `next` found for\
    \ type `char` in the current scope\n  --> /tmp/tmpa6zmolep.rs:15:27\n   |\n15\
    \ |             brackets_iter.next();\n   |                           ^^^^ method\
    \ not found in `char`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    //\
    \ Split on brackets and count the pairs of brackets\n    let mut n = 0;\n    for\
    \ split in brackets.split('>') {\n        if split.is_empty() {\n            return\
    \ false;\n        }\n        n += 1;\n    }\n    n % 2 == 0\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpqeil1sy5.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ {\n        if c == '<' {\n            true\n        } else if c == '>' {\n \
    \           false\n        } else {\n            unreachable!()\n        }\n \
    \   })\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp3k40osec.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut iter = brackets.char_indices();\n    let mut last_opening = String::new();\n\
    \    let mut last_closer = String::new();\n    for (i, c) in iter.next() {\n \
    \       if c == '>' {\n            if i < iter.next().unwrap() {\n           \
    \     last_closer = c;\n            }\n        } else if c == '<' {\n        \
    \    if i > iter.next().unwrap() {\n                last_opening = c;\n      \
    \      }\n        } else {\n            last_opening = c;\n            last_closer\
    \ = c;\n        }\n    }\n    last_opening.len() == 0 && last_closer.len() ==\
    \ 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb4ffyut7.rs:17:20\n   |\n\
    17 |             if i < iter.next().unwrap() {\n   |                    ^^^^^^^^^^^^^^^^^^^^\
    \ expected `usize`, found tuple\n   |\n   = note: expected type `usize`\n    \
    \         found tuple `(usize, char)`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpb4ffyut7.rs:18:31\n   |\n14 |     let mut last_closer = String::new();\n\
    \   |                           ------------- expected due to this value\n...\n\
    18 |                 last_closer = c;\n   |                               ^- help:\
    \ try using a conversion method: `.to_string()`\n   |                        \
    \       |\n   |                               expected struct `String`, found\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb4ffyut7.rs:21:20\n\
    \   |\n21 |             if i > iter.next().unwrap() {\n   |                  \
    \  ^^^^^^^^^^^^^^^^^^^^ expected `usize`, found tuple\n   |\n   = note: expected\
    \ type `usize`\n             found tuple `(usize, char)`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpb4ffyut7.rs:22:32\n   |\n13 |     let mut last_opening\
    \ = String::new();\n   |                            ------------- expected due\
    \ to this value\n...\n22 |                 last_opening = c;\n   |           \
    \                     ^- help: try using a conversion method: `.to_string()`\n\
    \   |                                |\n   |                                expected\
    \ struct `String`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb4ffyut7.rs:25:28\n\
    \   |\n13 |     let mut last_opening = String::new();\n   |                  \
    \          ------------- expected due to this value\n...\n25 |             last_opening\
    \ = c;\n   |                            ^- help: try using a conversion method:\
    \ `.to_string()`\n   |                            |\n   |                    \
    \        expected struct `String`, found `char`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpb4ffyut7.rs:26:27\n   |\n14 |     let mut last_closer = String::new();\n\
    \   |                           ------------- expected due to this value\n...\n\
    26 |             last_closer = c"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut i = 0;\n    while i < brackets.len() {\n        match brackets.get_char_at_offset(i)\
    \ {\n            None => return false,\n            Some('>') => {\n         \
    \       i += 1;\n                let mut found = false;\n                while\
    \ i < brackets.len() && brackets.get_char_at_offset(i) != Some('>') {\n      \
    \              i += 1;\n                }\n                if !found {\n     \
    \               return false;\n                }\n            }\n            Some('<')\
    \ => {\n                i += 1;\n                let mut found = false;\n    \
    \            while i < brackets.len() && brackets.get_char_at_offset(i) != Some('<')\
    \ {\n                    i += 1;\n                }\n                if !found\
    \ {\n                    return false;\n                }\n            }\n   \
    \         Some(b) => panic!(\"unexpected character in bracketing pair: {}\", b),\n\
    \        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `get_char_at_offset` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp8_ck9cky.rs:14:24\n   |\n14 |         match\
    \ brackets.get_char_at_offset(i) {\n   |                        ^^^^^^^^^^^^^^^^^^\
    \ method not found in `String`\n\nerror[E0599]: no method named `get_char_at_offset`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmp8_ck9cky.rs:19:54\n\
    \   |\n19 |                 while i < brackets.len() && brackets.get_char_at_offset(i)\
    \ != Some('>') {\n   |                                                      ^^^^^^^^^^^^^^^^^^\
    \ method not found in `String`\n\nerror[E0599]: no method named `get_char_at_offset`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmp8_ck9cky.rs:29:54\n\
    \   |\n29 |                 while i < brackets.len() && brackets.get_char_at_offset(i)\
    \ != Some('<') {\n   |                                                      ^^^^^^^^^^^^^^^^^^\
    \ method not found in `String`\n\nerror: aborting due to 3 previous errors\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.replace(\"\
    <\", \"<<\").into_string().parse().unwrap() == 2\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `into_string` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmp8yrpk7oe.rs:12:33\n   |\n12 |     brackets.replace(\"\
    <\", \"<<\").into_string().parse().unwrap() == 2\n   |                       \
    \          ^^^^^^^^^^^ method not found in `String`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut s = String::new();\n    for c in brackets {\n        if c.is_ascii() {\n\
    \            s.push(c);\n        } else {\n            s.push(String::from(\"\\\
    \\\").to_ascii_lowercase().unwrap());\n            s.push(c);\n        }\n   \
    \ }\n    !s.contains(\"<<>\") && !s.contains(\"<>>>\") && !s.contains(\"<<<\"\
    )\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpmv9ctaw0.rs:13:14\n\
    \   |\n13 |     for c in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror[E0599]: no\
    \ method named `unwrap` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpmv9ctaw0.rs:17:60\n   |\n17 |             s.push(String::from(\"\\\\\
    \").to_ascii_lowercase().unwrap());\n   |                                    \
    \                        ^^^^^^ method not found in `String`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut prev = None;\n    for b in brackets.chars() {\n        if prev.is_none()\
    \ {\n            prev = Some(b);\n        } else {\n            if prev == Some(b)\
    \ {\n                prev.take();\n            } else {\n                return\
    \ false;\n            }\n        }\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpm8rnlwsd.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == '<' || c == '>')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmps928504y.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut counter = 0;\n    for i in 0..brackets.len() {\n        if brackets[counter]\
    \ == '<' {\n            counter += 1;\n        } else if brackets[counter] ==\
    \ '>' {\n            counter += 1;\n        } else if brackets[counter] == '['\
    \ {\n            counter += 1;\n        } else if brackets[counter] == ']' {\n\
    \            counter += 1;\n        } else if brackets[counter] == '{' {\n   \
    \         counter += 1;\n        } else if brackets[counter] == '}' {\n      \
    \      counter += 1;\n        } else {\n            return false;\n        }\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmp7tp1_b7m.rs:14:12\n   |\n14 |         if brackets[counter] == '<' {\n\
    \   |            ^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmp7tp1_b7m.rs:16:19\n   |\n16 |         } else if brackets[counter]\
    \ == '>' {\n   |                   ^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmp7tp1_b7m.rs:18:19\n   |\n18 |         } else if brackets[counter]\
    \ == '[' {\n   |                   ^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \       "
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars()\n\
    \        .map(|c| match c {\n            '<' => '>',\n            _ => c,\n  \
    \      })\n        .all(brackets.chars().all(|c| match c {\n            '<' =>\
    \ '>',\n            '>' => '<',\n            _ => c,\n        }))\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgjsc06vy.rs:18:20\n   |\n\
    18 |             '<' => '>',\n   |                    ^^^ expected `bool`, found\
    \ `char`\n\nerror[E0277]: expected a `FnMut<(char,)>` closure, found `bool`\n\
    \    --> /tmp/tmpgjsc06vy.rs:17:14\n     |\n17   |           .all(brackets.chars().all(|c|\
    \ match c {\n     |  __________---_^\n     | |          |\n     | |          required\
    \ by a bound introduced by this call\n18   | |             '<' => '>',\n19   |\
    \ |             '>' => '<',\n20   | |             _ => c,\n21   | |         }))\n\
    \     | |__________^ expected an `FnMut<(char,)>` closure, found `bool`\n    \
    \ |\n     = help: the trait `FnMut<(char,)>` is not implemented for `bool`\nnote:\
    \ required by a bound in `all`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    //\
    \ count the total number of opening brackets in the string.\n    let mut num_brackets\
    \ = 0;\n    for c in brackets.chars() {\n        if c == '<' {\n            num_brackets\
    \ += 1;\n        } else {\n            num_brackets -= 1;\n        }\n    }\n\
    \    // if there are multiple opening/closing brackets, return false.\n    num_brackets\
    \ == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpmap26lli.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().filter(|x|\
    \ *x == '>').count() == brackets.chars().filter(|x| *x != '<').count()\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpk4o1ls67.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|b|\n\
    \        match b {\n            '<' => {\n                let mut count = 0;\n\
    \                let mut i = 1;\n                let mut j = brackets.len() -\
    \ 1;\n\n                while i < brackets.len() {\n                    if brackets[i]\
    \ == '>' {\n                        count += 1;\n                    }\n     \
    \               if brackets[j] == '>' {\n                        count += 1;\n\
    \                    }\n                    i += 1;\n                    j -=\
    \ 1;\n                }\n\n                if count == 0 {\n                 \
    \   true\n                } else {\n                    false\n              \
    \  }\n            }\n            '>' => {\n                let mut count = 0;\n\
    \                let mut i = 1;\n                let mut j = brackets.len() -\
    \ 1;\n\n                while i < brackets.len() {\n                    if brackets[i]\
    \ == '<' {\n                        count += 1;\n                    }\n     \
    \               if brackets[j] == '<' {\n                        count += 1;\n\
    \                    }\n                    i += 1;\n                    j -=\
    \ 1;\n                }\n\n                if count == 0 {\n                 \
    \   true\n                } else {\n                    false\n              \
    \  }\n            }\n            _ => false,\n        }\n    )\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpsgjxrfo6.rs:20:24\n\
    \   |\n20 |                     if brackets[i] == '>' {\n   |                \
    \        ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpsgjxrfo6.rs:23:24\n   |\n23 |                     if brackets[j]\
    \ == '>' {\n   |                        ^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpsgjxrfo6.rs:42:24\n   |\n42 |                     if brackets[i]\
    \ == '<' {\n   |                        ^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::"
  stdout: ''
  timestamp: 1659976566
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == '<' || c == '>')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmps928504y.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut found = false;\n    for opening in brackets.chars().skip(1) {\n        let\
    \ next = brackets[opening.cmp(&opening).next()..].as_str();\n        if next !=\
    \ \"<\" {\n            return false;\n        }\n        found = true;\n    }\n\
    \    found\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `next` found for enum `std::cmp::Ordering`\
    \ in the current scope\n  --> /tmp/tmppw_at5cp.rs:14:51\n   |\n14 |         let\
    \ next = brackets[opening.cmp(&opening).next()..].as_str();\n   |            \
    \                                       ^^^^ method not found in `std::cmp::Ordering`\n\
    \nerror[E0599]: no method named `as_str` found for type `str` in the current scope\n\
    \  --> /tmp/tmppw_at5cp.rs:14:61\n   |\n14 |         let next = brackets[opening.cmp(&opening).next()..].as_str();\n\
    \   |                                                            -^^^^^^-- help:\
    \ remove this method call\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets: Vec<&str> = brackets.split('>').collect();\n    let mut close_brackets:\
    \ Vec<&str> = brackets.split('<').collect();\n    let mut has_open = false;\n\
    \    let mut has_close = false;\n    let mut is_open = false;\n    let mut is_close\
    \ = false;\n\n    loop {\n        if open_brackets.len() == 0 {\n            break;\n\
    \        }\n\n        let open = open_brackets.pop().unwrap();\n        if open\
    \ != \"<<\" {\n            is_close = true;\n        }\n\n        if open_brackets.len()\
    \ > 0 && open_brackets.last().unwrap() == \"<\" {\n            is_open = true;\n\
    \        }\n\n        if has_open {\n            if is_close && has_close {\n\
    \                break;\n            }\n        }\n\n        if has_open {\n \
    \           if is_close {\n                has_close = true;\n               \
    \ continue;\n            }\n            has_open = false;\n        }\n\n     \
    \   if close_brackets.len() == 0 {\n            break;\n        }\n\n        let\
    \ close = close_brackets.pop().unwrap();\n        if close != \">\" {\n      \
    \      is_open = true;\n        }\n\n        if close_brackets.len() > 0 && close_brackets.last().unwrap()\
    \ == \">\" {\n            is_close = true;\n        }\n\n        if has_close\
    \ {\n            if is_open && has_open {\n                break;\n          \
    \  }\n        }\n\n        if has_close {\n            if is_open {\n        \
    \        has_open = true;\n                continue;\n            }\n        \
    \    has_close = false;\n        }\n\n        if open_brackets.len() == 0 && close_brackets.len()\
    \ == 0 {\n            return true;\n        }\n    }\n\n    false\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&str` with `str`\n  --> /tmp/tmp_jtq8qsh.rs:29:69\n\
    \   |\n29 |         if open_brackets.len() > 0 && open_brackets.last().unwrap()\
    \ == \"<\" {\n   |                                                           \
    \          ^^ no implementation for `&str == str`\n   |\n   = help: the trait\
    \ `PartialEq<str>` is not implemented for `&str`\n   = help: the following other\
    \ types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n\
    \             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n   = note: required because of the requirements on the\
    \ impl of `PartialEq<&str>` for `&&str`\n\nerror[E0277]: can't compare `&str`\
    \ with `str`\n  --> /tmp/tmp_jtq8qsh.rs:56:71\n   |\n56 |         if close_brackets.len()\
    \ > 0 && close_brackets.last().unwrap() == \">\" {\n   |                     \
    \                                                  ^^ no implementation for `&str\
    \ == str`\n   |\n   = help: the trait `PartialEq<str>` is not implemented for\
    \ `&str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n   = note: required because\
    \ of the requirements on the impl of `PartialEq<&str>` for `&&str`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut count = 0;\n    let mut found = false;\n    let mut prev = 0;\n    for &c\
    \ in &brackets {\n        if c == '<' {\n            found = true;\n         \
    \   prev = count;\n        }\n        count = count + 1;\n    }\n    if found\
    \ {\n        let mut count = 0;\n        let mut found = false;\n        for &c\
    \ in &brackets[prev..] {\n            if c == '>' {\n                found = true;\n\
    \                prev = count;\n            }\n            count = count + 1;\n\
    \        }\n        if found {\n            return true;\n        }\n    }\n \
    \   false\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n  --> /tmp/tmpg7ppp0xn.rs:15:15\n\
    \   |\n15 |     for &c in &brackets {\n   |               ^^^^^^^^^ `&String`\
    \ is not an iterator\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `&String`\n   = note: required because of the requirements on the impl of\
    \ `IntoIterator` for `&String`\n\nerror[E0277]: `&str` is not an iterator\n  -->\
    \ /tmp/tmpg7ppp0xn.rs:25:19\n   |\n25 |         for &c in &brackets[prev..] {\n\
    \   |                   ^^^^^^^^^^^^^^^^^ `&str` is not an iterator; try calling\
    \ `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `&str`\n   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&str`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == String::from(\"<<\") || c == String::from(\">>\"))\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5f_j4kl1.rs:12:35\n   |\n\
    12 |     brackets.chars().all(|c| c == String::from(\"<<\") || c == String::from(\"\
    >>\"))\n   |                                   ^^^^^^^^^^^^^^^^^^ expected `char`,\
    \ found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5f_j4kl1.rs:12:62\n\
    \   |\n12 |     brackets.chars().all(|c| c == String::from(\"<<\") || c == String::from(\"\
    >>\"))\n   |                                                              ^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut opening_count = 0;\n    let mut closing_count = 0;\n    let mut closed_brackets\
    \ = false;\n    let mut first_opening = brackets.chars().filter_map(|c|\n    \
    \    if opening_count > 0 {\n            if c == '>' {\n                closing_count\
    \ += 1;\n                false\n            } else {\n                opening_count\
    \ += 1;\n                true\n            }\n        } else if c == '<' {\n \
    \           opening_count += 1;\n            false\n        } else {\n       \
    \     closing_count += 1;\n            true\n        }\n    });\n    for c in\
    \ first_opening {\n        if opening_count < closed_brackets {\n            closed_brackets\
    \ = true;\n            break;\n        }\n        if c == '>' {\n            closing_count\
    \ += 1;\n        } else {\n            opening_count += 1;\n        }\n    }\n\
    \    closed_brackets == opening_count\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: unexpected closing delimiter: `)`\n  --> /tmp/tmpe2dtewcl.rs:31:6\n\
    \   |\n15 |     let mut first_opening = brackets.chars().filter_map(|c|\n   |\
    \                                           -- block is empty, you might have\
    \ not meant to close it\n...\n31 |     });\n   |      ^ unexpected closing delimiter\n\
    \nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpe2dtewcl.rs:15:56\n\
    \   |\n15 |     let mut first_opening = brackets.chars().filter_map(|c|\n   |\
    \                                                        ^ unclosed delimiter\n\
    ...\n31 |     });\n   |     ^ mismatched closing delimiter\n\nerror: aborting\
    \ due to 2 previous errors\n\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = 0;\n    let mut close_brackets = 0;\n    for ch in brackets\
    \ {\n        if ch == '<' {\n            open_brackets += 1;\n        } else if\
    \ ch == '>' {\n            close_brackets += 1;\n        } else {\n          \
    \  if open_brackets == close_brackets {\n                return false;\n     \
    \       }\n            open_brackets = 0;\n            close_brackets = 0;\n \
    \       }\n    }\n    open_brackets == close_brackets\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp37nx87iz.rs:14:15\n\
    \   |\n14 |     for ch in brackets {\n   |               ^^^^^^^^ `String` is\
    \ not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut prev_bracket = String::from(\"<\");\n    let mut found = false;\n\n    for\
    \ c in brackets.chars() {\n        if c == prev_bracket {\n            found =\
    \ true;\n        } else {\n            prev_bracket = c;\n            found =\
    \ false;\n        }\n    }\n\n    found\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6p0fvkmi.rs:16:17\n   |\n\
    16 |         if c == prev_bracket {\n   |                 ^^^^^^^^^^^^ expected\
    \ `char`, found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6p0fvkmi.rs:19:28\n\
    \   |\n12 |     let mut prev_bracket = String::from(\"<\");\n   |            \
    \                ----------------- expected due to this value\n...\n19 |     \
    \        prev_bracket = c;\n   |                            ^- help: try using\
    \ a conversion method: `.to_string()`\n   |                            |\n   |\
    \                            expected struct `String`, found `char`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    //\
    \ O(n^2), but still O(n).\n    let mut stack = Vec::new();\n    let mut last =\
    \ 0;\n    for cur in brackets.chars() {\n        if cur == '<' {\n           \
    \ if stack.len() == 0 {\n                return false;\n            }\n      \
    \      if stack.pop().unwrap() != '>' {\n                return false;\n     \
    \       }\n            last = cur;\n        } else {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            if stack.pop().unwrap().is_none()\
    \ {\n                return false;\n            }\n            if cur != last.unwrap()\
    \ {\n                return false;\n            }\n            last = cur;\n \
    \       }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5n9o813m.rs:23:20\n   |\n\
    14 |     let mut last = 0;\n   |                    - expected due to this value\n\
    ...\n23 |             last = cur;\n   |                    ^^^ expected integer,\
    \ found `char`\n\nerror[E0599]: no method named `unwrap` found for type `{integer}`\
    \ in the current scope\n  --> /tmp/tmp5n9o813m.rs:31:28\n   |\n31 |          \
    \   if cur != last.unwrap() {\n   |                            ^^^^^^ method not\
    \ found in `{integer}`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5n9o813m.rs:34:20\n\
    \   |\n14 |     let mut last = 0;\n   |                    - expected due to this\
    \ value\n...\n34 |             last = cur;\n   |                    ^^^ expected\
    \ integer, found `char`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.contains(\"\
    <\") && (brackets.contains(\"<=\") || brackets.contains(\"<\") + brackets.contains(\"\
    <\"))\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot add `bool` to `bool`\n  --> /tmp/tmp7bgeea8c.rs:12:82\n\
    \   |\n12 |     brackets.contains(\"<\") && (brackets.contains(\"<=\") || brackets.contains(\"\
    <\") + brackets.contains(\"<\"))\n   |                                       \
    \                    ---------------------- ^ ---------------------- bool\n  \
    \ |                                                           |\n   |        \
    \                                                   bool\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0369`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut current_opening_bracket: Option<char> = None;\n    for ch in &brackets {\n\
    \        if ch.is_whitespace() {\n            continue;\n        }\n        if\
    \ current_opening_bracket.is_none() {\n            current_opening_bracket = Some(ch);\n\
    \        } else if current_opening_bracket.as_ref() == ch {\n            current_opening_bracket\
    \ = Some(ch);\n        } else if ch == '<' {\n            if current_opening_bracket.as_ref()\
    \ != ch {\n                return false;\n            }\n            current_opening_bracket\
    \ = Some('<');\n        } else {\n            if current_opening_bracket.as_ref()\
    \ != ch {\n                return false;\n            }\n            current_opening_bracket\
    \ = None;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n  --> /tmp/tmpvujyjltf.rs:13:15\n\
    \   |\n13 |     for ch in &brackets {\n   |               ^^^^^^^^^ `&String`\
    \ is not an iterator\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `&String`\n   = note: required because of the requirements on the impl of\
    \ `IntoIterator` for `&String`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut found = false;\n    let mut i = 0;\n    while i < brackets.len() {\n   \
    \     found = found || brackets[i] == '>';\n        if found {\n            i\
    \ += 1;\n            if brackets[i] == '<' {\n                i += 1;\n      \
    \          if i >= brackets.len() {\n                    return true;\n      \
    \          }\n            }\n        }\n        i += 1;\n    }\n    false\n}\n\
    \nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmptjhw0yst.rs:15:26\n\
    \   |\n15 |         found = found || brackets[i] == '>';\n   |               \
    \           ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmptjhw0yst.rs:18:16\n   |\n18 |             if brackets[i] == '<'\
    \ {\n   |                ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n \
    \  |\n   = help: the trait `Index<usize>` is not implemented for `String`\n  \
    \ = help: the following other types implement trait `Index<Idx>`:\n          \
    \   <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut opening = brackets.chars().filter_map(|c| c != '<').collect::<Vec<_>>();\n\
    \    opening.sort();\n    let mut closing = brackets.chars().filter_map(|c| c\
    \ != '>').collect::<Vec<_>>();\n    closing.sort();\n    opening.iter().zip(closing.iter()).all(|(a,\
    \ b)| a == b)\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n   \
    \ assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8n69x0u8.rs:12:55\n   |\n\
    12 |     let mut opening = brackets.chars().filter_map(|c| c != '<').collect::<Vec<_>>();\n\
    \   |                                                       ^^^^^^^^ expected\
    \ enum `Option`, found `bool`\n   |\n   = note: expected enum `Option<_>`\n  \
    \            found type `bool`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n12 |     let mut opening = brackets.chars().filter_map(|c| Some(c != '<')).collect::<Vec<_>>();\n\
    \   |                                                       +++++        +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp8n69x0u8.rs:14:55\n   |\n14 |  \
    \   let mut closing = brackets.chars().filter_map(|c| c != '>').collect::<Vec<_>>();\n\
    \   |                                                       ^^^^^^^^ expected\
    \ enum `Option`, found `bool`\n   |\n   = note: expected enum `Option<_>`\n  \
    \            found type `bool`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n14 |     let mut closing = brackets.chars().filter_map(|c| Some(c != '>')).collect::<Vec<_>>();\n\
    \   |                                                       +++++        +\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    //\
    \ we start with the assumption that brackets is valid and contains only \"<\"\
    \ and \">\"\n    let mut stack = Vec::new();\n    for ch in brackets.chars() {\n\
    \        if ch == \">\" || ch == \"<\" {\n            if stack.is_empty() {\n\
    \                // if the stack is empty then this character is not valid and\
    \ we return false\n                return false;\n            }\n            match\
    \ &stack.pop().unwrap() {\n                '>' => true,\n                '<' =>\
    \ true,\n                ch => false,\n            }\n        } else {\n     \
    \       stack.push(ch);\n        }\n    }\n    stack.is_empty()\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc_6_hjfo.rs:15:18\n   |\n\
    15 |         if ch == \">\" || ch == \"<\" {\n   |                  ^^^ expected\
    \ `char`, found `&str`\n   |\nhelp: if you meant to write a `char` literal, use\
    \ single quotes\n   |\n15 |         if ch == '>' || ch == \"<\" {\n   |      \
    \            ~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc_6_hjfo.rs:15:31\n\
    \   |\n15 |         if ch == \">\" || ch == \"<\" {\n   |                    \
    \           ^^^ expected `char`, found `&str`\n   |\nhelp: if you meant to write\
    \ a `char` literal, use single quotes\n   |\n15 |         if ch == \">\" || ch\
    \ == '<' {\n   |                               ~~~\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpc_6_hjfo.rs:20:13\n   |\n15 |  /         if ch == \">\"\
    \ || ch == \"<\" {\n16 |  |             if stack.is_empty() {\n17 |  |       \
    \          // if the stack is empty then this character is not valid and we return\
    \ false\n18 |  |                 return false;\n19 |  |             }\n20 | /|\
    \             match &stack.pop().unwrap() {\n21 | ||                 '>' => true,\n\
    22 | ||                 '<' => true,\n23 | ||                 ch => false,\n24\
    \ | ||             }\n   | ||_____________^ expected `()`, found `bool`\n25 |\
    \  |         } else {\n26 |  |             stack.push(ch);\n27 |  |         }\n\
    \   |  |_________- expected this to be `()`\n   |\nhelp: consider using a semicolon\
    \ here\n   |\n24 |             };\n   |              +\nhelp: consider using a\
    \ semicolon here\n   |\n27 |         };\n   |          +\nhelp: you might have\
    \ meant to return this value\n   |\n20 ~             return match &stack.pop().unwrap()\
    \ {\n21 |                 '>' => true,\n22 |                 '<' => true,\n23\
    \ |                 ch => false,\n24 ~             };\n   |\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ {\n        let next_char = brackets.chars().next().unwrap();\n        c != next_char\n\
    \    })\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmplexbbbmj.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    if\
    \ brackets.chars().all(|b| !matches!(b, \">>\"))\n        && brackets.chars().all(|b|\
    \ !matches!(b, \"<\"))\n    {\n        return true;\n    }\n    false\n}\n\nfn\
    \ main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnk2x768r.rs:12:46\n   |\n\
    12 |     if brackets.chars().all(|b| !matches!(b, \">>\"))\n   |             \
    \                              -  ^^^^ expected `char`, found `&str`\n   |   \
    \                                        |\n   |                             \
    \              this expression has type `char`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpnk2x768r.rs:13:50\n   |\n13 |         && brackets.chars().all(|b|\
    \ !matches!(b, \"<\"))\n   |                                               - \
    \ ^^^ expected `char`, found `&str`\n   |                                    \
    \           |\n   |                                               this expression\
    \ has type `char`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == '<') && brackets.chars().all(|c| c == '>')\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmps7l12u1y.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut last_pos = 0; // Index of last character in brackets\n    let mut has_correct_bracket\
    \ = false;\n\n    for c in brackets.chars() {\n        if c != '<' {\n       \
    \     continue;\n        }\n        if last_pos == 0 {\n            last_pos =\
    \ brackets.len() - 1;\n        }\n        last_pos--;\n        let open_pos =\n\
    \            brackets.chars().position(|c| c == '>' && brackets[last_pos - 1]\
    \ == '<');\n        let close_pos = brackets.chars().position(|c| c == '<' &&\
    \ brackets[last_pos - 1] == '>');\n        if open_pos > close_pos {\n       \
    \     has_correct_bracket = false;\n            break;\n        }\n        has_correct_bracket\
    \ = true;\n        last_pos = open_pos + 1;\n    }\n\n    has_correct_bracket\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpq9yv77cz.rs:22:19\n\
    \   |\n22 |         last_pos--;\n   |                   ^ expected expression\n\
    \nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    //\
    \ If brackets contains only brackets, return true\n    if brackets.is_empty()\
    \ {\n        return true;\n    }\n    let mut brackets = brackets.clone();\n \
    \   let mut i = 0;\n    while i < brackets.len() {\n        let c = &brackets[i\
    \ as usize];\n        if c == '<' {\n            i += 1;\n            while i\
    \ < brackets.len() {\n                if brackets[i as usize] == '>' {\n     \
    \               return true;\n                }\n                i += 1;\n   \
    \         }\n            return false;\n        }\n        if c == '>' {\n   \
    \         i += 1;\n            while i < brackets.len() {\n                if\
    \ brackets[i as usize] == '<' {\n                    return false;\n         \
    \       }\n                i += 1;\n            }\n            return true;\n\
    \        }\n        i += 1;\n    }\n    // If brackets contains only opening brackets,\
    \ return true\n    if brackets.starts_with(String::from(\"<<\")) {\n        return\
    \ true;\n    }\n    // If brackets contains only closing brackets, return false\n\
    \    if brackets.ends_with(String::from(\">>\")) {\n        return false;\n  \
    \  }\n    // If brackets contains only closing brackets and opening brackets,\
    \ return false\n    if brackets.contains(String::from(\"><<\")) {\n        return\
    \ false;\n    }\n    // If brackets contains only opening brackets and closing\
    \ brackets, return true\n    if brackets.contains(String::from(\"<<<\")) {\n \
    \       return true;\n    }\n    // Otherwise, we never found a match\n    true\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpn2cdb50w.rs:19:18\n\
    \   |\n19 |         let c = &brackets[i as usize];\n   |                  ^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: can't compare `&_` with `char`\n  --> /tmp/tmpn2cdb50w.rs:20:14\n\
    \   |\n20 |         if c == '<' {\n   |              ^^ no implementation for\
    \ `&_ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&_`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n \
    \ --> /tmp/tmpn2cdb50w.rs:23:20\n   |\n23 |                 if brackets[i as usize]\
    \ == '>' {\n   |                    ^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: can't compare `&_` with `char`\n  --> /tmp/tmpn2cdb50w.rs:30:14\n\
    \   |\n30 |         if c == '>' {\n   |              ^^ no implementation for\
    \ `&_ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&_`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n \
    \ --> /tmp/tmpn2cdb50w.rs:33:20\n   |\n33 |                 if brackets[i as usize]\
    \ == '<' {\n   |        "
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    //\
    \ Loop through opening brackets\n    brackets.chars().filter_map(|c| *c).all(|c|\
    \ c == '<')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpz3zko_b8.rs:13:37\n\
    \   |\n13 |     brackets.chars().filter_map(|c| *c).all(|c| c == '<')\n   |  \
    \                                   ^^\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut found_closing = false;\n\n    for (i, c) in brackets.chars().enumerate()\
    \ {\n        // We found a closing bracket.\n        if c == \">\" {\n       \
    \     found_closing = true;\n            continue;\n        }\n\n        // We\
    \ found an opening bracket.\n        if c == \"<\" {\n            // We found\
    \ a nested bracket, so the string isn't correct.\n            if !found_closing\
    \ {\n                return false;\n            }\n\n            // We found a\
    \ closing bracket, so the string isn't correct.\n            found_closing = false;\n\
    \        }\n    }\n\n    // The string was correct.\n    found_closing\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpypoopbop.rs:16:17\n   |\n\
    16 |         if c == \">\" {\n   |                 ^^^ expected `char`, found\
    \ `&str`\n   |\nhelp: if you meant to write a `char` literal, use single quotes\n\
    \   |\n16 |         if c == '>' {\n   |                 ~~~\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpypoopbop.rs:22:17\n   |\n22 |         if c == \"<\" {\n\
    \   |                 ^^^ expected `char`, found `&str`\n   |\nhelp: if you meant\
    \ to write a `char` literal, use single quotes\n   |\n22 |         if c == '<'\
    \ {\n   |                 ~~~\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|b|\
    \ b == '<' || b == '>')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpvwl9bay_.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets\n\
    \        .chars()\n        .filter(|c| c.is_ascii_alphanumeric())\n        .all(|c|\
    \ brackets.chars().any(|c| c == '<'))\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpgdo6rp92.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ if c == \">\" { true } else if c == \"<\" { true } else { false })\n}\n\nfn\
    \ main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxvese_qk.rs:12:38\n   |\n\
    12 |     brackets.chars().all(|c| if c == \">\" { true } else if c == \"<\" {\
    \ true } else { false })\n   |                                      ^^^ expected\
    \ `char`, found `&str`\n   |\nhelp: if you meant to write a `char` literal, use\
    \ single quotes\n   |\n12 |     brackets.chars().all(|c| if c == '>' { true }\
    \ else if c == \"<\" { true } else { false })\n   |                          \
    \            ~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxvese_qk.rs:12:64\n\
    \   |\n12 |     brackets.chars().all(|c| if c == \">\" { true } else if c == \"\
    <\" { true } else { false })\n   |                                           \
    \                     ^^^ expected `char`, found `&str`\n   |\nhelp: if you meant\
    \ to write a `char` literal, use single quotes\n   |\n12 |     brackets.chars().all(|c|\
    \ if c == \">\" { true } else if c == '<' { true } else { false })\n   |     \
    \                                                           ~~~\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets\n\
    \        .chars()\n        .enumerate()\n        .any(|(idx, &c)| {\n        \
    \    let open = c.to_ascii_lowercase();\n            brackets\n              \
    \  .chars()\n                .enumerate()\n                .any(|(idx, &c)| {\n\
    \                    if c.to_ascii_lowercase() == open {\n                   \
    \     // no match\n                        true\n                    } else {\n\
    \                        // match\n                        idx != idx\n      \
    \              }\n                })\n        })\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpiwriph1e.rs:15:21\n   |\n\
    15 |         .any(|(idx, &c)| {\n   |                     ^^- expected due to\
    \ this\n   |                     |\n   |                     expected `char`,\
    \ found reference\n   |                     help: you can probably remove the\
    \ explicit borrow: `c`\n   |\n   = note:   expected type `char`\n           found\
    \ reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpiwriph1e.rs:20:29\n\
    \   |\n20 |                 .any(|(idx, &c)| {\n   |                         \
    \    ^^- expected due to this\n   |                             |\n   |      \
    \                       expected `char`, found reference\n   |               \
    \              help: you can probably remove the explicit borrow: `c`\n   |\n\
    \   = note:   expected type `char`\n           found reference `&_`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ {\n        c != '<' &&\n        c != '>' &&\n        c != '<<' &&\n        c\
    \ != \">>' &&\n        c != \">>>\"\n    })\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: character literal may only contain one codepoint\n  --> /tmp/tmp59kn6_60.rs:15:14\n\
    \   |\n15 |         c != '<<' &&\n   |              ^^^^\n   |\nhelp: if you meant\
    \ to write a `str` literal, use double quotes\n   |\n15 |         c != \"<<\"\
    \ &&\n   |              ~~~~\n\nerror[E0765]: unterminated double quote string\n\
    \  --> /tmp/tmp59kn6_60.rs:34:56\n   |\n34 |       assert_eq!(candidate(String::from(\"\
    <><><<><>><>>><>\")), false);\n   |  ________________________________________________________^\n\
    35 | | }\n   | |__^\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_owned();\n    let mut last = 0;\n    let mut last2\
    \ = -1;\n    while last < brackets.len() {\n        let mut count = 0;\n     \
    \   let mut next = 0;\n        while next < brackets.len() {\n            if brackets[next]\
    \ == '<' {\n                let next = brackets.find('>', next);\n           \
    \     count += 1;\n            }\n            if brackets[next] == '>' {\n   \
    \             count += 1;\n            }\n            next += 1;\n        }\n\
    \        if count % 2 == 0 {\n            last2 = last;\n        } else {\n  \
    \          last = last2;\n        }\n    }\n    last != 0 || last2 != -1\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpb60lyt70.rs:19:16\n\
    \   |\n19 |             if brackets[next] == '<' {\n   |                ^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0061]: this function takes 1 argument but 2 arguments were\
    \ supplied\n    --> /tmp/tmpb60lyt70.rs:20:37\n     |\n20   |                \
    \ let next = brackets.find('>', next);\n     |                               \
    \      ^^^^ ---  ---- supplied 2 arguments\n     |                           \
    \          |\n     |                                     expected 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmpb60lyt70.rs:23:16\n   |\n23 |  \
    \           if brackets[next] == '>' {\n   |                ^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n \
    \ --> /tmp/tmpb60lyt70.rs:14:21\n   |\n14 |     let mut last2 = -1;\n   |    \
    \                 ^^ the trait `Neg` is not implemented for `usize`\n   |\n  \
    \ = help: the following other types implement trait"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut pos = 0;\n    let mut has_match = false;\n    for char in &brackets {\n\
    \        if char == '<' {\n            has_match |= !char_has_match(pos, &brackets[pos..])\n\
    \                || char_has_match(pos + 1, &brackets[pos..])\n              \
    \  || char_has_match(pos + 2, &brackets[pos..]);\n            pos += 3;\n    \
    \    } else if char == '>' {\n            has_match |= !char_has_match(pos, &brackets[pos..])\n\
    \                || char_has_match(pos + 1, &brackets[pos..])\n              \
    \  || char_has_match(pos + 2, &brackets[pos..]);\n            pos += 2;\n    \
    \    } else if char == '<' {\n            has_match |= !char_has_match(pos, &brackets[pos..])\n\
    \                || char_has_match(pos + 1, &brackets[pos..])\n              \
    \  || char_has_match(pos + 2, &brackets[pos..]);\n            pos += 3;\n    \
    \    } else {\n            pos += 1;\n        }\n    }\n    has_match\n}\n\nfn\
    \ main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `char_has_match` in this scope\n  -->\
    \ /tmp/tmp_u5d0h7s.rs:16:27\n   |\n16 |             has_match |= !char_has_match(pos,\
    \ &brackets[pos..])\n   |                           ^^^^^^^^^^^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find function `char_has_match` in this scope\n\
    \  --> /tmp/tmp_u5d0h7s.rs:17:20\n   |\n17 |                 || char_has_match(pos\
    \ + 1, &brackets[pos..])\n   |                    ^^^^^^^^^^^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find function `char_has_match` in this scope\n\
    \  --> /tmp/tmp_u5d0h7s.rs:18:20\n   |\n18 |                 || char_has_match(pos\
    \ + 2, &brackets[pos..]);\n   |                    ^^^^^^^^^^^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find function `char_has_match` in this scope\n\
    \  --> /tmp/tmp_u5d0h7s.rs:21:27\n   |\n21 |             has_match |= !char_has_match(pos,\
    \ &brackets[pos..])\n   |                           ^^^^^^^^^^^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find function `char_has_match` in this scope\n\
    \  --> /tmp/tmp_u5d0h7s.rs:22:20\n   |\n22 |                 || char_has_match(pos\
    \ + 1, &brackets[pos..])\n   |                    ^^^^^^^^^^^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find function `char_has_match` in this scope\n\
    \  --> /tmp/tmp_u5d0h7s.rs:23:20\n   |\n23 |                 || char_has_match(pos\
    \ + 2, &brackets[pos..]);\n   |                    ^^^^^^^^^^^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find function `char_has_match` in this scope\n\
    \  --> /tmp/tmp_u5d0h7s.rs:26:27\n   |\n26 |             has_match |= !char_has_match(pos,\
    \ &brackets[pos..])\n   |                           ^^^^^^^^^^^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find function `char_has_match` in this scope\n\
    \  --> /tmp/tmp_u5d0h7s.rs:27:20\n   |\n27 |                 || char_has_match(pos\
    \ + 1, &brackets[pos..])\n   |                    ^^^^^^^^^^^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find function `char_has_match` in this scope\n\
    \  --> /tmp/tmp_u5d0h7s.rs:28:20\n   |\n28 |                 || char_has_match(pos\
    \ + 2, &"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    if\
    \ brackets.len() == 0 {\n        return false;\n    }\n    let mut inside_bracket\
    \ = false;\n    for c in brackets.chars() {\n        if c == \">\" {\n       \
    \     inside_bracket = false;\n        } else if c == \"<\" {\n            inside_bracket\
    \ = true;\n        } else if c == '{' {\n            inside_bracket = true;\n\
    \        } else if c == '}' {\n            inside_bracket = false;\n        }\
    \ else {\n            if !inside_bracket {\n                return false;\n  \
    \          }\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzsmed7x4.rs:17:17\n   |\n\
    17 |         if c == \">\" {\n   |                 ^^^ expected `char`, found\
    \ `&str`\n   |\nhelp: if you meant to write a `char` literal, use single quotes\n\
    \   |\n17 |         if c == '>' {\n   |                 ~~~\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpzsmed7x4.rs:19:24\n   |\n19 |         } else if c == \"\
    <\" {\n   |                        ^^^ expected `char`, found `&str`\n   |\nhelp:\
    \ if you meant to write a `char` literal, use single quotes\n   |\n19 |      \
    \   } else if c == '<' {\n   |                        ~~~\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut last_open = String::new();\n    for c in &brackets {\n        last_open\
    \ += c;\n        if last_open < \"<<\" && last_open > \">>\" {\n            return\
    \ false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n  --> /tmp/tmp1i77h1wo.rs:13:14\n\
    \   |\n13 |     for c in &brackets {\n   |              ^^^^^^^^^ `&String` is\
    \ not an iterator\n   |\n   = help: the trait `Iterator` is not implemented for\
    \ `&String`\n   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1i77h1wo.rs:15:24\n\
    \   |\n15 |         if last_open < \"<<\" && last_open > \">>\" {\n   |      \
    \                  ^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                        |\n   |                        expected struct `String`,\
    \ found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1i77h1wo.rs:15:44\n\
    \   |\n15 |         if last_open < \"<<\" && last_open > \">>\" {\n   |      \
    \                                      ^^^^- help: try using a conversion method:\
    \ `.to_string()`\n   |                                            |\n   |    \
    \                                        expected struct `String`, found `&str`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    !brackets.is_empty()\
    \ && brackets[0..1].chars().all(|c| c == '<')\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpuvoac9hb.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut counts = Vec::new();\n    let mut open_brackets: Vec<_> = brackets.chars().filter(|c|\
    \ c != '<').collect();\n    let mut closed_brackets: Vec<_> = brackets.chars().filter(|c|\
    \ c != '>').collect();\n    while open_brackets.len() > 0 && closed_brackets.len()\
    \ > 0 {\n        let open_bracket = open_brackets.remove(0);\n        let closed_bracket\
    \ = closed_brackets.remove(0);\n        if closed_bracket < open_bracket {\n \
    \           open_brackets.push(open_bracket);\n        } else {\n            closed_brackets.push(closed_bracket);\n\
    \        }\n    }\n    for i in 0..open_brackets.len() {\n        if counts[open_brackets[i]]\
    \ > 0 {\n            return false;\n        }\n        counts[open_brackets[i]]++;\n\
    \    }\n    for i in 0..closed_brackets.len() {\n        if counts[closed_brackets[i]]\
    \ > 0 {\n            return false;\n        }\n        counts[closed_brackets[i]]++;\n\
    \    }\n    for i in 0..counts.len() {\n        if counts[i] != 0 {\n        \
    \    return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp6l6d3gbk.rs:28:33\n\
    \   |\n28 |         counts[open_brackets[i]]++;\n   |                        \
    \         ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n  \
    \ |\n28 |         { let tmp = counts[open_brackets[i]]; counts[open_brackets[i]]\
    \ += 1; tmp };\n   |         +++++++++++                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    28 -         counts[open_brackets[i]]++;\n28 +         counts[open_brackets[i]]\
    \ += 1;\n   | \n\nerror: Rust has no postfix increment operator\n  --> /tmp/tmp6l6d3gbk.rs:34:35\n\
    \   |\n34 |         counts[closed_brackets[i]]++;\n   |                      \
    \             ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n\
    \   |\n34 |         { let tmp = counts[closed_brackets[i]]; counts[closed_brackets[i]]\
    \ += 1; tmp };\n   |         +++++++++++                           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    34 -         counts[closed_brackets[i]]++;\n34 +         counts[closed_brackets[i]]\
    \ += 1;\n   | \n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp6l6d3gbk.rs:13:67\n\
    \   |\n13 |     let mut open_brackets: Vec<_> = brackets.chars().filter(|c| c\
    \ != '<').collect();\n   |                                                   \
    \                ^^ no implementation for `&char == char`\n   |\n   = help: the\
    \ trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmp6l6d3gbk.rs:14:69\n   |\n14 |     let mut closed_brackets:\
    \ Vec<_> = brackets.chars().filter(|c| c != '>').collect();\n   |            \
    \                                                         ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: the type `[_]` cannot be indexed by `char`\n  --> /tmp/tmp6l6d3gbk.rs:25:12\n\
    \   |\n25 |         if counts[open_brackets[i]] > 0 {\n   |            ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ slice in"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets\n\
    \        .chars()\n        .zip(&brackets[1..])\n        .all(|(_, b)| *b == '>')\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&str` is not an iterator\n  --> /tmp/tmp1ohf8ebm.rs:14:14\n\
    \   |\n14 |         .zip(&brackets[1..])\n   |          --- ^^^^^^^^^^^^^^ `&str`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |          |\n\
    \   |          required by a bound introduced by this call\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `&str`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `&str`\n\nerror[E0599]:\
    \ the method `all` exists for struct `Zip<Chars<'_>, &str>`, but its trait bounds\
    \ were not satisfied\n  --> /tmp/tmp1ohf8ebm.rs:15:10\n   |\n15 |           .all(|(_,\
    \ b)| *b == '>')\n   |            ^^^ method cannot be called on `Zip<Chars<'_>,\
    \ &str>` due to unsatisfied trait bounds\n   |\n   = note: the following trait\
    \ bounds were not satisfied:\n           `&str: Iterator`\n           which is\
    \ required by `Zip<Chars<'_>, &str>: Iterator`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == '<' || c == '>')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmps928504y.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars()\n\
    \        .filter(|c| c == '<' || c == '>')\n        .count() == brackets.len()\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpex1tqgmb.rs:13:23\n\
    \   |\n13 |         .filter(|c| c == '<' || c == '>')\n   |                  \
    \     ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpex1tqgmb.rs:13:35\n\
    \   |\n13 |         .filter(|c| c == '<' || c == '>')\n   |                  \
    \                 ^^ no implementation for `&char == char`\n   |\n   = help: the\
    \ trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<String> = vec![];\n    let mut opening = String::from(\"\");\n\
    \    while brackets.chars().any(|b| {\n        if b == '<' {\n            stack.unshift(opening);\n\
    \            opening = String::from(\"\");\n            true\n        } else {\n\
    \            stack.last().unwrap().push(b);\n            false\n        }\n  \
    \  }) {\n        if brackets.chars().any(|b| b == \">\") {\n            stack.pop();\n\
    \            true\n        } else {\n            opening = stack.pop().unwrap();\n\
    \            false\n        }\n    }\n    stack.len() == 0\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unshift` found for struct `Vec<String>`\
    \ in the current scope\n  --> /tmp/tmp82v5bjei.rs:16:19\n   |\n16 |          \
    \   stack.unshift(opening);\n   |                   ^^^^^^^ method not found in\
    \ `Vec<String>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp82v5bjei.rs:24:42\n\
    \   |\n24 |         if brackets.chars().any(|b| b == \">\") {\n   |          \
    \                                ^^^ expected `char`, found `&str`\n   |\nhelp:\
    \ if you meant to write a `char` literal, use single quotes\n   |\n24 |      \
    \   if brackets.chars().any(|b| b == '>') {\n   |                            \
    \              ~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp82v5bjei.rs:26:13\n\
    \   |\n24 | /         if brackets.chars().any(|b| b == \">\") {\n25 | |      \
    \       stack.pop();\n26 | |             true\n   | |             ^^^^ expected\
    \ `()`, found `bool`\n27 | |         } else {\n28 | |             opening = stack.pop().unwrap();\n\
    29 | |             false\n30 | |         }\n   | |_________- expected this to\
    \ be `()`\n   |\nhelp: you might have meant to return this value\n   |\n26 | \
    \            return true;\n   |             ++++++     +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp82v5bjei.rs:29:13\n   |\n24 | /         if brackets.chars().any(|b|\
    \ b == \">\") {\n25 | |             stack.pop();\n26 | |             true\n27\
    \ | |         } else {\n28 | |             opening = stack.pop().unwrap();\n29\
    \ | |             false\n   | |             ^^^^^ expected `()`, found `bool`\n\
    30 | |         }\n   | |_________- expected this to be `()`\n   |\nhelp: you might\
    \ have meant to return this value\n   |\n29 |             return false;\n   |\
    \             ++++++      +\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c >= '<' && c <= '>')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmplfh72zfs.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    (brackets.len()\
    \ >= 2 && brackets[..2] == \"<>\").unwrap_or(false)\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap_or` found for type `bool` in the\
    \ current scope\n  --> /tmp/tmplovnv60i.rs:12:52\n   |\n12 |     (brackets.len()\
    \ >= 2 && brackets[..2] == \"<>\").unwrap_or(false)\n   |                    \
    \                                ^^^^^^^^^ method not found in `bool`\n\nerror[E0277]:\
    \ can't compare `str` with `&str`\n  --> /tmp/tmplovnv60i.rs:12:43\n   |\n12 |\
    \     (brackets.len() >= 2 && brackets[..2] == \"<>\").unwrap_or(false)\n   |\
    \                                           ^^ no implementation for `str == &str`\n\
    \   |\n   = help: the trait `PartialEq<&str>` is not implemented for `str`\n \
    \  = help: the following other types implement trait `PartialEq<Rhs>`:\n     \
    \        <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut opening = brackets.split_whitespace();\n    let mut opening_index = 0;\n\
    \    for c in opening {\n        if c == \">\" {\n            if opening_index\
    \ < opening.len() - 1 {\n                opening_index += 1;\n            } else\
    \ {\n                return false;\n            }\n        } else if c == \"<\"\
    \ {\n            if opening_index > 0 {\n                opening_index -= 1;\n\
    \            } else {\n                return false;\n            }\n        }\n\
    \    }\n    opening.len() <= opening_index\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpy4fujykt.rs:16:40\n   |\n16 |          \
    \   if opening_index < opening.len() - 1 {\n   |                             \
    \           ^^^ method not found in `SplitWhitespace<'_>`\n\nerror[E0599]: no\
    \ method named `len` found for struct `SplitWhitespace` in the current scope\n\
    \  --> /tmp/tmpy4fujykt.rs:29:13\n   |\n29 |     opening.len() <= opening_index\n\
    \   |             ^^^ method not found in `SplitWhitespace<'_>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut count = 0;\n    brackets.chars().for_each(|c| match c {\n        '<' =>\
    \ {\n            count += 1;\n        }\n        '>' => {\n            count -=\
    \ 1;\n        }\n        _ => (),\n    });\n    count == 0\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpxgv0nkxe.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c >= '<' && c <= '>')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmplfh72zfs.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == '>' || c == '<')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmps0zkq828.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut closed = false;\n    let mut opened = false;\n    for c in &brackets {\n\
    \        if c == '<' {\n            opened = true;\n        } else {\n       \
    \     closed = true;\n        }\n        if opened == true && closed == false\
    \ {\n            return true;\n        }\n    }\n    if opened == false {\n  \
    \      return false;\n    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n  --> /tmp/tmpodwrpl8y.rs:14:14\n\
    \   |\n14 |     for c in &brackets {\n   |              ^^^^^^^^^ `&String` is\
    \ not an iterator\n   |\n   = help: the trait `Iterator` is not implemented for\
    \ `&String`\n   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().any(|c|\
    \ c == \">\" || c == \"<\" || c == \"<=\")\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2i9c8yz0.rs:12:35\n   |\n\
    12 |     brackets.chars().any(|c| c == \">\" || c == \"<\" || c == \"<=\")\n \
    \  |                                   ^^^ expected `char`, found `&str`\n   |\n\
    help: if you meant to write a `char` literal, use single quotes\n   |\n12 |  \
    \   brackets.chars().any(|c| c == '>' || c == \"<\" || c == \"<=\")\n   |    \
    \                               ~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2i9c8yz0.rs:12:47\n\
    \   |\n12 |     brackets.chars().any(|c| c == \">\" || c == \"<\" || c == \"<=\"\
    )\n   |                                               ^^^ expected `char`, found\
    \ `&str`\n   |\nhelp: if you meant to write a `char` literal, use single quotes\n\
    \   |\n12 |     brackets.chars().any(|c| c == \">\" || c == '<' || c == \"<=\"\
    )\n   |                                               ~~~\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2i9c8yz0.rs:12:59\n   |\n12 |     brackets.chars().any(|c|\
    \ c == \">\" || c == \"<\" || c == \"<=\")\n   |                             \
    \                              ^^^^ expected `char`, found `&str`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets_iter = brackets.chars().nth(0).unwrap();\n    match brackets_iter\
    \ {\n        Some(b) => bracket_match(b),\n        None => false,\n    }\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `bracket_match` in this scope\n  -->\
    \ /tmp/tmpujcltdlo.rs:14:20\n   |\n14 |         Some(b) => bracket_match(b),\n\
    \   |                    ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpujcltdlo.rs:14:9\n   |\n13 |     match brackets_iter\
    \ {\n   |           ------------- this expression has type `char`\n14 |      \
    \   Some(b) => bracket_match(b),\n   |         ^^^^^^^ expected `char`, found\
    \ enum `Option`\n   |\n   = note: expected type `char`\n              found enum\
    \ `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpujcltdlo.rs:15:9\n\
    \   |\n13 |     match brackets_iter {\n   |           ------------- this expression\
    \ has type `char`\n14 |         Some(b) => bracket_match(b),\n15 |         None\
    \ => false,\n   |         ^^^^ expected `char`, found enum `Option`\n   |\n  \
    \ = note: expected type `char`\n              found enum `Option<_>`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets\n\
    \        .split_ascii_whitespace()\n        .iter()\n        .all(|b| b == \"\
    >\")\n        && !brackets.contains(\"<\")\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `SplitAsciiWhitespace`\
    \ in the current scope\n  --> /tmp/tmp19080scn.rs:14:10\n   |\n14 |         .iter()\n\
    \   |          ^^^^ method not found in `SplitAsciiWhitespace<'_>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    //\
    \ Special cases.\n    if brackets == \"\" {\n        return true;\n    }\n   \
    \ let mut iter_string = brackets.char_indices();\n    iter_string.next();\n  \
    \  let mut close_brackets = String::new();\n    iter_string.next().unwrap(); //\
    \ Skip the opening bracket.\n    for c in iter_string.cloned() {\n        close_brackets\
    \ += &c.to_string();\n        if c == iter_string.peek() {\n            iter_string.next();\n\
    \            close_brackets += &c.to_string();\n        }\n    }\n    if close_brackets\
    \ == \"\" {\n        return true;\n    }\n\n    // Find the indices of all the\
    \ opening brackets.\n    let mut open_brackets = Vec::new();\n    let mut iter\
    \ = iter_string.clone();\n    iter.next();\n    for c in iter {\n        open_brackets.push(c);\n\
    \        if c == iter_string.peek() {\n            iter.next();\n            open_brackets.push(c);\n\
    \        }\n    }\n    if open_brackets.len() < 2 {\n        return true;\n  \
    \  }\n\n    // Check if each closing bracket exists in the correct position.\n\
    \    open_brackets.sort_unstable_by_key(|x| x.0);\n    let mut found = false;\n\
    \    for bracket in &open_brackets[1..] {\n        if bracket == &close_brackets.chars().next()\
    \ {\n            found = true;\n        }\n    }\n    found\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<CharIndices<'_> as Iterator>::Item\
    \ == &_`\n    --> /tmp/tmpipqjes65.rs:20:26\n     |\n20   |     for c in iter_string.cloned()\
    \ {\n     |                          ^^^^^^ expected reference, found tuple\n\
    \     |\n     = note: expected reference `&_`\n                    found tuple\
    \ `(usize, char)`\nnote: required by a bound in `cloned`\n\nerror[E0271]: type\
    \ mismatch resolving `<CharIndices<'_> as Iterator>::Item == &_`\n  --> /tmp/tmpipqjes65.rs:20:14\n\
    \   |\n20 |     for c in iter_string.cloned() {\n   |              ^^^^^^^^^^^^^^^^^^^^\
    \ expected tuple, found reference\n   |\n   = note:  expected tuple `(usize, char)`\n\
    \           found reference `&_`\n   = note: required because of the requirements\
    \ on the impl of `Iterator` for `Cloned<CharIndices<'_>>`\n   = note: required\
    \ because of the requirements on the impl of `IntoIterator` for `Cloned<CharIndices<'_>>`\n\
    \nerror[E0271]: type mismatch resolving `<CharIndices<'_> as Iterator>::Item ==\
    \ &_`\n  --> /tmp/tmpipqjes65.rs:20:14\n   |\n20 |     for c in iter_string.cloned()\
    \ {\n   |              ^^^^^^^^^^^^^^^^^^^^ expected tuple, found reference\n\
    \   |\n   = note:  expected tuple `(usize, char)`\n           found reference\
    \ `&_`\n   = note: required because of the requirements on the impl of `Iterator`\
    \ for `Cloned<CharIndices<'_>>`\n\nerror[E0599]: no method named `peek` found\
    \ for struct `CharIndices` in the current scope\n  --> /tmp/tmpipqjes65.rs:22:29\n\
    \   |\n22 |         if c == iter_string.peek() {\n   |                       \
    \      ^^^^ method not found in `CharIndices<'_>`\n\nerror[E0599]: no method named\
    \ `peek` found for struct `CharIndices` in the current scope\n  --> /tmp/tmpipqjes65.rs:37:29\n\
    \   |\n37 |         if c == iter_string.peek() {\n   |                       \
    \      ^^^^ method not found in `CharIndices<'_>`\n\nerror[E0277]: can't compare\
    \ `(usize, char)` with `Option<char>`\n  --> /tmp/tmpipqjes65.rs:50:20\n   |\n\
    50 |         if bracket == &close_brackets.chars().next() {\n   |            \
    \        ^^ no implementation for `(usize, char) == Option<char>`\n   |\n   "
  stdout: ''
  timestamp: 1659976566
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == '<' || c == '>')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmps928504y.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.len()\
    \ > 0\n        && brackets.chars().any(|c| c != '<' && c != '>')\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpfl5n9xv9.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut i = 0;\n    while i < brackets.len() {\n        let mut j = i;\n       \
    \ while j < brackets.len() {\n            if brackets[j] == brackets[i] {\n  \
    \              break;\n            }\n            if brackets[j] == '<' {\n  \
    \              j += 1;\n            }\n            if brackets[j] == '>' {\n \
    \               j += 1;\n            }\n            j += 1;\n        }\n     \
    \   if j - i <= 1 {\n            return true;\n        }\n        i = j;\n   \
    \ }\n    false\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n  \
    \  assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpa0eehi0d.rs:16:16\n\
    \   |\n16 |             if brackets[j] == brackets[i] {\n   |                ^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpa0eehi0d.rs:16:31\n   |\n16 |             if brackets[j] == brackets[i]\
    \ {\n   |                               ^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpa0eehi0d.rs:19:16\n   |\n19 |             if brackets[j] == '<'\
    \ {\n   |                ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n \
    \  |\n   = help: the trait `Index<usize>` is not implemented for `String`\n  \
    \ = help: the following other types implement trait `Index<Idx>`:\n          \
    \   <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut position = 0;\n    while position < brackets.len() {\n        if brackets[position]\
    \ == \">\" && brackets[position + 1] == \">\" {\n            position += 2;\n\
    \        } else if brackets[position] == \">\" && brackets[position + 1] == \"\
    <\" {\n            position += 2;\n        } else if brackets[position] == \"\
    <\" && brackets[position + 1] == \">\" {\n            position += 2;\n       \
    \ } else if brackets[position] == \"<\" && brackets[position + 1] == \"<\" {\n\
    \            position += 2;\n        } else {\n            position += 1;\n  \
    \      }\n    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpnpt9cs30.rs:14:12\n\
    \   |\n14 |         if brackets[position] == \">\" && brackets[position + 1] ==\
    \ \">\" {\n   |            ^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpnpt9cs30.rs:14:41\n   |\n14 |         if brackets[position] ==\
    \ \">\" && brackets[position + 1] == \">\" {\n   |                           \
    \              ^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpnpt9cs30.rs:16:19\n   |\n16 |         } else if brackets[position]\
    \ == \">\" && brackets[position + 1] == \"<\" {\n   |                   ^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String a"
  stdout: ''
  timestamp: 1659976566
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == '<' || c == '>')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmps928504y.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut opening_brackets = String::new();\n    let mut closing_brackets = String::new();\n\
    \n    for symbol in brackets.chars() {\n        match symbol {\n            '\
    \ ' | '>' | '<' => {}\n            _ => opening_brackets.push(symbol),\n     \
    \   }\n    }\n\n    loop {\n        if opening_brackets.len() < closing_brackets.len()\
    \ {\n            return opening_brackets.len() == closing_brackets.len();\n  \
    \      }\n\n        let mut i = 0;\n        let mut opening_bracket = opening_brackets.chars().nth(i);\n\
    \n        if opening_brackets.len() != closing_brackets.len() {\n            return\
    \ false;\n        }\n\n        match opening_bracket.next() {\n            Some('>')\
    \ => {\n                closing_brackets.push_str(&opening_bracket);\n       \
    \         i += 1;\n            }\n            Some('<') => {\n               \
    \ opening_brackets.push_str(&opening_bracket);\n                i += 1;\n    \
    \        }\n            Some('>') | Some('<') => {\n                return false;\n\
    \            }\n            _ => {\n                i += 1;\n            }\n \
    \       }\n    }\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `next` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmpnftyidix.rs:34:31\n   |\n34 |         match opening_bracket.next()\
    \ {\n   |                               ^^^^ method not found in `Option<char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpnftyidix.rs:36:43\n   |\n36 |\
    \                 closing_brackets.push_str(&opening_bracket);\n   |         \
    \                                  ^^^^^^^^^^^^^^^^ expected `str`, found enum\
    \ `Option`\n   |\n   = note: expected reference `&str`\n              found reference\
    \ `&Option<char>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnftyidix.rs:40:43\n\
    \   |\n40 |                 opening_brackets.push_str(&opening_bracket);\n   |\
    \                                           ^^^^^^^^^^^^^^^^ expected `str`, found\
    \ enum `Option`\n   |\n   = note: expected reference `&str`\n              found\
    \ reference `&Option<char>`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    //\
    \ O(n^2) algorithm, but guaranteed to have a single iteration.\n    let mut brackets\
    \ = brackets;\n    loop {\n        let mut last = 0;\n        while last != brackets.len()\
    \ {\n            if let Some(first) = brackets.find('<', last) {\n           \
    \     if first != brackets.find('>', first + 1) {\n                    return\
    \ false;\n                }\n                brackets = &brackets[first + 1..];\n\
    \                last = first;\n            }\n            else {\n          \
    \      return false;\n            }\n        }\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpquy173gx.rs:17:43\n     |\n17   |             if let Some(first)\
    \ = brackets.find('<', last) {\n     |                                       \
    \    ^^^^ ---  ---- supplied 2 arguments\n     |                             \
    \              |\n     |                                           expected 1\
    \ argument\n     |\nnote: associated function defined here\n\nerror[E0061]: this\
    \ function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpquy173gx.rs:18:38\n\
    \     |\n18   |                 if first != brackets.find('>', first + 1) {\n\
    \     |                                      ^^^^ ---  --------- supplied 2 arguments\n\
    \     |                                      |\n     |                       \
    \               expected 1 argument\n     |\nnote: associated function defined\
    \ here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpquy173gx.rs:18:29\n  \
    \ |\n18 |                 if first != brackets.find('>', first + 1) {\n   |  \
    \                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found\
    \ enum `Option`\n   |\n   = note: expected type `usize`\n              found enum\
    \ `Option<usize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpquy173gx.rs:21:28\n\
    \   |\n13 |     let mut brackets = brackets;\n   |                        --------\
    \ expected due to this value\n...\n21 |                 brackets = &brackets[first\
    \ + 1..];\n   |                            ^^^^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `String`, found `&str`\n   |\nhelp: try using a conversion method\n   |\n21\
    \ |                 brackets = (&brackets[first + 1..]).to_string();\n   |   \
    \                         +                      +++++++++++++\n\nwarning: unreachable\
    \ expression\n  --> /tmp/tmpquy173gx.rs:29:5\n   |\n14 | /     loop {\n15 | |\
    \         let mut last = 0;\n16 | |         while last != brackets.len() {\n17\
    \ | |             if let Some(first) = brackets.find('<', last) {\n...  |\n27\
    \ | |         }\n28 | |     }\n   | |_____- any code following this expression\
    \ is unreachable\n29 |       true\n   |       ^^^^ "
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_count = 1;\n    let mut close_count = 1;\n    for ch in brackets.chars()\
    \ {\n        if ch == \">\" {\n            close_count += 1;\n        } else if\
    \ ch == \"<\" {\n            open_count += 1;\n        } else {\n            //\
    \ Nothing needs to be done.\n        }\n    }\n    open_count <= close_count\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzwkhjor1.rs:15:18\n   |\n\
    15 |         if ch == \">\" {\n   |                  ^^^ expected `char`, found\
    \ `&str`\n   |\nhelp: if you meant to write a `char` literal, use single quotes\n\
    \   |\n15 |         if ch == '>' {\n   |                  ~~~\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpzwkhjor1.rs:17:25\n   |\n17 |         } else\
    \ if ch == \"<\" {\n   |                         ^^^ expected `char`, found `&str`\n\
    \   |\nhelp: if you meant to write a `char` literal, use single quotes\n   |\n\
    17 |         } else if ch == '<' {\n   |                         ~~~\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = Vec::new();\n    let mut closed_brackets = Vec::new();\n\
    \    for b in brackets.chars() {\n        match b {\n            '<' => {\n  \
    \              open_brackets.push(b);\n            },\n            '>' => {\n\
    \                closed_brackets.push(b);\n            }\n            _ => unreachable!(),\n\
    \        }\n    }\n    open_brackets.iter().all(|b| closed_brackets.contains(b))\
    \ &&\n        open_brackets.iter().all(|b| open_brackets.contains(b)) &&\n   \
    \     closed_brackets.iter().all(|b| open_brackets.contains(b))\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpocxvm0b5.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut closed = false;\n    let mut open = false;\n    let mut index = 0;\n   \
    \ while index < brackets.len() {\n        if brackets[index] == '<' {\n      \
    \      open = true;\n        }\n        if brackets[index] == '>' {\n        \
    \    closed = true;\n        }\n        if !open && !closed {\n            break;\n\
    \        }\n        open = false;\n        closed = false;\n        index += 1;\n\
    \    }\n    index != brackets.len()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp20qquhp5.rs:16:12\n\
    \   |\n16 |         if brackets[index] == '<' {\n   |            ^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp20qquhp5.rs:19:12\n   |\n19 |         if brackets[index] == '>'\
    \ {\n   |            ^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n \
    \  |\n   = help: the trait `Index<usize>` is not implemented for `String`\n  \
    \ = help: the following other types implement trait `Index<Idx>`:\n          \
    \   <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ *c == '<') && brackets.chars().all(|c| *c == '>')\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpbl75g_ws.rs:12:30\n\
    \   |\n12 |     brackets.chars().all(|c| *c == '<') && brackets.chars().all(|c|\
    \ *c == '>')\n   |                              ^^\n\nerror[E0614]: type `char`\
    \ cannot be dereferenced\n  --> /tmp/tmpbl75g_ws.rs:12:69\n   |\n12 |     brackets.chars().all(|c|\
    \ *c == '<') && brackets.chars().all(|c| *c == '>')\n   |                    \
    \                                                 ^^\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0614`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets: Vec<_> = brackets.chars().collect();\n    let mut i: usize = 0;\n\
    \    while i < brackets.len() {\n        if brackets[i] == '<' {\n           \
    \ if i >= brackets.len() || brackets[i + 1] != '>' {\n                return false;\n\
    \            }\n            i += 2;\n        } else {\n            if i >= brackets.len()\
    \ || brackets[i] != '>' {\n                return false;\n            }\n    \
    \        i += 1;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp338wye8z.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut last_bracket = String::new();\n    let mut found_bracket = false;\n    for\
    \ ch in &brackets {\n        if ch == '<' {\n            if last_bracket.len()\
    \ > 0 {\n                if last_bracket.contains(&ch) {\n                   \
    \ found_bracket = false;\n                } else {\n                    found_bracket\
    \ = true;\n                }\n            }\n            last_bracket.clear();\n\
    \            last_bracket.push_str(&ch.to_string());\n        } else {\n     \
    \       if last_bracket.len() > 0 && ch == last_bracket.chars().last().unwrap()\
    \ {\n                found_bracket = false;\n            } else {\n          \
    \      found_bracket = true;\n            }\n            last_bracket.push_str(&ch.to_string());\n\
    \        }\n    }\n    found_bracket\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n  --> /tmp/tmppi_vvgq6.rs:14:15\n\
    \   |\n14 |     for ch in &brackets {\n   |               ^^^^^^^^^ `&String`\
    \ is not an iterator\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `&String`\n   = note: required because of the requirements on the impl of\
    \ `IntoIterator` for `&String`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut counter = 0;\n    for c in brackets {\n        if c == '<' {\n         \
    \   counter += 1;\n        } else if c == '>' {\n            counter -= 1;\n \
    \       }\n        if counter == 0 {\n            return false;\n        }\n \
    \   }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n \
    \   assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp96prrrim.rs:13:14\n\
    \   |\n13 |     for c in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    //\
    \ Start with the base case\n    let mut is_correct = true;\n    \n    for opening\
    \ in brackets.chars().filter(|x| x.unwrap() == '<') {\n        // If the next\
    \ element is an opening bracket, skip the check\n        if let Some(next_opening)\
    \ = brackets.chars().next() {\n            // If next element is an opening bracket,\
    \ we are unbalanced\n            if next_opening.unwrap() == '>' {\n         \
    \       is_correct = false;\n                break;\n            }\n        }\n\
    \        // If we get here, all elements were \"<\" and we were unbalanced\n \
    \       is_correct = false;\n        break;\n    }\n    \n    return is_correct;\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap` found for reference `&char` in the\
    \ current scope\n  --> /tmp/tmpqufvwcbk.rs:15:50\n   |\n15 |     for opening in\
    \ brackets.chars().filter(|x| x.unwrap() == '<') {\n   |                     \
    \                             ^^^^^^ method not found in `&char`\n\nerror[E0599]:\
    \ no method named `unwrap` found for type `char` in the current scope\n  --> /tmp/tmpqufvwcbk.rs:19:29\n\
    \   |\n19 |             if next_opening.unwrap() == '>' {\n   |              \
    \               ^^^^^^ method not found in `char`\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    //\
    \ The two strings here are equivalent:\n    // brackets.chars().zip(brackets.chars()).all(|(a,\
    \ b)| a == b)\n    // \"<<>\" == \"<<><>>\" == \"<><><><>\" == \"<>\"\n    //\
    \ \"<><><><>\" == \"<>\"\n    // \"<>\" == \"<>\"\n    // \"<>\" == \"\"\n   \
    \ // \"<>\" == \"\"\n    // \"<><><><>\" == \"\"\n    // \"<<>\" == \"<><><><>\"\
    \ == \"\"\n    // \"<<><>>\" == \"<><><><>\" == \"\"\n    // \"<<>\" == \"\"\n\
    \    // \"<<><>>\" == \"\"\n    // \"<><><><>\" == \"\"\n    // \"<>\" == \"\"\
    \n    brackets.chars().zip(\n        brackets.chars().cloned(),\n    )\n     \
    \   .all(|(a, b)| a == b)\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmpdhejn6r2.rs:27:26\n     |\n27   |         brackets.chars().cloned(),\n\
    \     |                          ^^^^^^ expected reference, found `char`\n   \
    \  |\n     = note: expected reference `&_`\n                     found type `char`\n\
    note: required by a bound in `cloned`\n\nerror[E0271]: type mismatch resolving\
    \ `<Chars<'_> as Iterator>::Item == &_`\n  --> /tmp/tmpdhejn6r2.rs:27:9\n   |\n\
    26 |     brackets.chars().zip(\n   |                      --- required by a bound\
    \ introduced by this call\n27 |         brackets.chars().cloned(),\n   |     \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found reference\n   |\n   = note:\
    \   expected type `char`\n           found reference `&_`\n   = note: required\
    \ because of the requirements on the impl of `Iterator` for `Cloned<Chars<'_>>`\n\
    \   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `Cloned<Chars<'_>>`\n\nerror[E0599]: the method `all` exists for struct\
    \ `Zip<Chars<'_>, Cloned<Chars<'_>>>`, but its trait bounds were not satisfied\n\
    \  --> /tmp/tmpdhejn6r2.rs:29:10\n   |\n29 |            .all(|(a, b)| a == b)\n\
    \   |             ^^^ method cannot be called on `Zip<Chars<'_>, Cloned<Chars<'_>>>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `Cloned<Chars<'_>>: Iterator`\n           which\
    \ is required by `Zip<Chars<'_>, Cloned<Chars<'_>>>: Iterator`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0271, E0599.\n\
    For more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets\n\
    \        .chars()\n        .flat_map(|c| {\n            if c == \">\" {\n    \
    \            vec![\">\"]\n            } else if c == \"<\" {\n               \
    \ vec![\"<\"]\n            } else {\n                vec![\"<\", c]\n        \
    \    }\n        })\n        .all(|&b| brackets.chars().any(|c| c == '<' && b ==\
    \ c))\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp55ucvqsp.rs:15:21\n   |\n\
    15 |             if c == \">\" {\n   |                     ^^^ expected `char`,\
    \ found `&str`\n   |\nhelp: if you meant to write a `char` literal, use single\
    \ quotes\n   |\n15 |             if c == '>' {\n   |                     ~~~\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp55ucvqsp.rs:17:28\n   |\n17 |\
    \             } else if c == \"<\" {\n   |                            ^^^ expected\
    \ `char`, found `&str`\n   |\nhelp: if you meant to write a `char` literal, use\
    \ single quotes\n   |\n17 |             } else if c == '<' {\n   |           \
    \                 ~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp55ucvqsp.rs:20:27\n\
    \   |\n20 |                 vec![\"<\", c]\n   |                           ^ expected\
    \ `&str`, found `char`\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \n    for ch in brackets.chars() {\n        if ch == '<' {\n            open_brackets.push('>');\n\
    \            close_brackets.push('<');\n        } else if ch == '>' {\n      \
    \      open_brackets.push('<');\n            close_brackets.push('>');\n     \
    \   } else if ch == '>' && close_brackets.len() > 0 {\n            open_brackets.push('>');\n\
    \            close_brackets.push('<');\n        } else {\n            open_brackets.push('<');\n\
    \            close_brackets.push('<');\n        }\n    }\n\n    for ch in open_brackets.chars()\
    \ {\n        if close_brackets.contains(ch) {\n            return false;\n   \
    \     }\n    }\n\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpfn9m1xqj.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ *c == '<')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmp9drctv_u.rs:12:30\n\
    \   |\n12 |     brackets.chars().all(|c| *c == '<')\n   |                    \
    \          ^^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut iter = brackets.char_indices();\n    let mut stack = vec![];\n    loop {\n\
    \        let next = iter.next().unwrap();\n        let open = next[0];\n     \
    \   let close = next[1];\n        if open < close {\n            let mut stack\
    \ = stack.clone();\n            stack.pop();\n            stack.append(open);\n\
    \            if stack.is_empty() {\n                return true;\n           \
    \ }\n        } else if open > close {\n            let mut stack = stack.clone();\n\
    \            stack.pop();\n            stack.append(close);\n            if stack.is_empty()\
    \ {\n                return false;\n            }\n        } else {\n        \
    \    return false;\n        }\n    }\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0608]: cannot index into a value of type `(usize, char)`\n  -->\
    \ /tmp/tmpf0p95nli.rs:16:20\n   |\n16 |         let open = next[0];\n   |    \
    \                ^^^^^^^ help: to access tuple elements, use: `next.0`\n\nerror[E0608]:\
    \ cannot index into a value of type `(usize, char)`\n  --> /tmp/tmpf0p95nli.rs:17:21\n\
    \   |\n17 |         let close = next[1];\n   |                     ^^^^^^^ help:\
    \ to access tuple elements, use: `next.1`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0608`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().any(|c|\
    \ !c.is_ascii_letter() || c.is_ascii_digit())\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for type `char` in\
    \ the current scope\n  --> /tmp/tmptp99uvw6.rs:12:33\n   |\n12 |     brackets.chars().any(|c|\
    \ !c.is_ascii_letter() || c.is_ascii_digit())\n   |                          \
    \       ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name:\
    \ `is_ascii`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    loop {\n        let mut i = 0;\n \
    \       while i < brackets.len() && brackets[i] != '<' {\n            i += 1;\n\
    \        }\n        if i == brackets.len() {\n            return true;\n     \
    \   }\n        let mut i = 0;\n        while i < brackets.len() && brackets[i]\
    \ != '<' {\n            i += 1;\n        }\n        if brackets[i - 1] == '>'\
    \ {\n            return false;\n        }\n    }\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmps2kuk2ge.rs:15:37\n\
    \   |\n15 |         while i < brackets.len() && brackets[i] != '<' {\n   |   \
    \                                  ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmps2kuk2ge.rs:22:37\n   |\n22 |         while i < brackets.len()\
    \ && brackets[i] != '<' {\n   |                                     ^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmps2kuk2ge.rs:25:12\n   |\n25 |         if brackets[i - 1] == '>'\
    \ {\n   |            ^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n \
    \  |\n   = help: the trait `Index<usize>` is not implemented for `String`\n  \
    \ = help: the following other types implement trait `Index<Idx>`:\n          \
    \   <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut counter = 0;\n    let mut chars = String::new();\n    for c in brackets\
    \ {\n        if c == '<' {\n            chars.push(c);\n            counter +=\
    \ 1;\n        } else if c == '>' {\n            chars.push(c);\n            counter\
    \ += 1;\n        }\n    }\n    counter >= 2\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpcfsj8zoc.rs:14:14\n\
    \   |\n14 |     for c in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c.is_ascii())\n        && brackets.chars().all(|c| c.is_ascii_alphanumeric())\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp9ym297zy.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut counts = HashMap::new();\n    for bracket in brackets.chars().filter(|&b|\
    \ b != '>') {\n        counts.insert(bracket, 0);\n    }\n    let mut opening\
    \ = counts.iter().collect::<Vec<_>>();\n    let mut closing = counts.iter().cloned().collect::<Vec<_>>();\n\
    \    closing.push(0);\n    opening.sort_by_key(|&i| i);\n    closing.sort_by_key(|&i|\
    \ i);\n    let mut i = 0;\n    while i < opening.len() {\n        if closing[i]\
    \ == 0 {\n            i += 1;\n            continue;\n        }\n        for j\
    \ in 0..i {\n            if opening[j] == closing[i] {\n                closing[j]\
    \ += 1;\n                i += 1;\n                break;\n            }\n    \
    \    }\n    }\n    opening.iter().zip(closing.iter()).all(|&(open, ih)| open ==\
    \ ih)\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpe8gxt1ih.rs:12:22\n   |\n12 |     let mut counts = HashMap::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == '>' || c == '<')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmps0zkq828.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Stack::new();\n    for c in &brackets {\n        if c == '<' {\n\
    \            stack.push(true);\n        } else if c == '>' {\n            if !stack.pop()\
    \ {\n                return false;\n            }\n        } else {\n        \
    \    stack.push(false);\n        }\n    }\n    stack.pop().unwrap()\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Stack`\n  -->\
    \ /tmp/tmp7k7citba.rs:12:21\n   |\n12 |     let mut stack = Stack::new();\n  \
    \ |                     ^^^^^ use of undeclared type `Stack`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n  --> /tmp/tmp7k7citba.rs:13:14\n   |\n13 |  \
    \   for c in &brackets {\n   |              ^^^^^^^^^ `&String` is not an iterator\n\
    \   |\n   = help: the trait `Iterator` is not implemented for `&String`\n   =\
    \ note: required because of the requirements on the impl of `IntoIterator` for\
    \ `&String`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0433.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.replace(\"\
    <\", \"\").replace(\">\", \"\").is_empty()\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp3ay3pgsr.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = vec![];\n    for ch in brackets {\n        if let Some(open) = stack.iter().position(|&x|\
    \ x == '<') {\n            if let Some(close) = stack.iter().position(|&x| x ==\
    \ ch) {\n                stack[open] = '>';\n                stack[close + 1]\
    \ = '<';\n            } else {\n                stack.push(ch);\n            }\n\
    \        } else if let Some(close) = stack.iter().position(|&x| x == ch) {\n \
    \           stack.pop();\n        } else {\n            stack.push(ch);\n    \
    \    }\n    }\n    stack.len() == 1\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp_gwyx42z.rs:13:15\n\
    \   |\n13 |     for ch in brackets {\n   |               ^^^^^^^^ `String` is\
    \ not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ {\n        matches!(c, '<')\n    })\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpcak2g8hg.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut opens = vec![];\n    let mut closes = vec![];\n\n    for i in 0..brackets.len()\
    \ {\n        let c = &brackets[i as usize];\n        if c == '>' {\n         \
    \   closes.push(i);\n        } else if c == '<' {\n            opens.push(i);\n\
    \        }\n    }\n\n    for open of &opens {\n        for close of &closes {\n\
    \            if *close > *open {\n                return false;\n            }\n\
    \        }\n    }\n\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: missing `in` in `for` loop\n  --> /tmp/tmp3fczgtl1.rs:24:14\n  \
    \ |\n24 |     for open of &opens {\n   |              ^^ help: try using `in`\
    \ here instead\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp3fczgtl1.rs:25:19\n\
    \   |\n25 |         for close of &closes {\n   |                   ^^ help: try\
    \ using `in` here instead\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmp3fczgtl1.rs:16:18\n   |\n16 |         let c = &brackets[i\
    \ as usize];\n   |                  ^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: can't compare `&_` with `char`\n  --> /tmp/tmp3fczgtl1.rs:17:14\n\
    \   |\n17 |         if c == '>' {\n   |              ^^ no implementation for\
    \ `&_ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&_`\n\nerror[E0277]: can't compare `&_` with `char`\n  --> /tmp/tmp3fczgtl1.rs:19:21\n\
    \   |\n19 |         } else if c == '<' {\n   |                     ^^ no implementation\
    \ for `&_ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&_`\n\nerror: aborting due to 5 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets\
    \ == &\"<>\" || brackets == &\"<>[]\" || brackets == &\"<>()\"\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `String` with `&&str`\n  --> /tmp/tmpbrs_m8hc.rs:12:14\n\
    \   |\n12 |     brackets == &\"<>\" || brackets == &\"<>[]\" || brackets == &\"\
    <>()\"\n   |              ^^ no implementation for `String == &&str`\n   |\n \
    \  = help: the trait `PartialEq<&&str>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `PartialEq<Rhs>`:\n        \
    \     <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `String` with `&&str`\n  --> /tmp/tmpbrs_m8hc.rs:12:35\n   |\n12 |     brackets\
    \ == &\"<>\" || brackets == &\"<>[]\" || brackets == &\"<>()\"\n   |         \
    \                          ^^ no implementation for `String == &&str`\n   |\n\
    \   = help: the trait `PartialEq<&&str>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `PartialEq<Rhs>`:\n        \
    \     <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `String` with `&&str`\n  --> /tmp/tmpbrs_m8hc.rs:12:58\n   |\n12 |     brackets\
    \ == &\"<>\" || brackets == &\"<>[]\" || brackets == &\"<>()\"\n   |         \
    \                                                 ^^ no implementation for `String\
    \ == &&str`\n   |\n   = help: the trait `PartialEq<&&str>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as Par"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut current_opening = String::from(\"<<><>>\");\n    let mut current_closing\
    \ = String::from(\"<<><>>\");\n    let mut current_position = String::from(\"\
    <<><>>\");\n    for bracket in brackets.chars().filter_map(|c| match c {\n   \
    \     '<' => Some('>'),\n        '>' => Some('<'),\n        _ => None,\n    })\
    \ {\n        if current_opening == current_closing {\n            current_opening\
    \ += bracket;\n        }\n        else {\n            current_closing += bracket;\n\
    \            if current_opening > current_closing {\n                current_opening\
    \ = String::from(\"<<><>>\");\n                current_position += bracket;\n\
    \            }\n        }\n    }\n    !current_opening.is_empty() && current_opening.starts_with(current_position)\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprz6giasx.rs:21:32\n   |\n\
    21 |             current_opening += bracket;\n   |                           \
    \     ^^^^^^^ expected `&str`, found `char`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmprz6giasx.rs:24:32\n   |\n24 |             current_closing += bracket;\n\
    \   |                                ^^^^^^^ expected `&str`, found `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmprz6giasx.rs:27:37\n   |\n27 |  \
    \               current_position += bracket;\n   |                           \
    \          ^^^^^^^ expected `&str`, found `char`\n\nerror[E0277]: expected a `FnMut<(char,)>`\
    \ closure, found `String`\n    --> /tmp/tmprz6giasx.rs:31:64\n     |\n31   | \
    \    !current_opening.is_empty() && current_opening.starts_with(current_position)\n\
    \     |                                                    ----------- ^^^^^^^^^^^^^^^^\
    \ expected an implementor of trait `Pattern<'_>`\n     |                     \
    \                               |\n     |                                    \
    \                required by a bound introduced by this call\n     |\n     = note:\
    \ the trait bound `String: Pattern<'_>` is not satisfied\n     = note: required\
    \ because of the requirements on the impl of `Pattern<'_>` for `String`\nnote:\
    \ required by a bound in `core::str::<impl str>::starts_with`\nhelp: consider\
    \ borrowing here\n     |\n31   |     !current_opening.is_empty() && current_opening.starts_with(&current_position)\n\
    \     |                                                                +\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut bracket_stack: Vec<&str> = brackets.chars().collect();\n    bracket_stack.push(\"\
    \");\n    while bracket_stack.len() > 0 {\n        let opening_char = bracket_stack.remove(0);\n\
    \        if opening_char == \">\" {\n            bracket_stack.insert(0, \"<\"\
    );\n            continue;\n        }\n        if opening_char == \"<\" {\n   \
    \         bracket_stack.insert(0, \"<\");\n            continue;\n        }\n\
    \        if opening_char == \"\" {\n            bracket_stack.push(\"\");\n  \
    \          continue;\n        }\n        return false;\n    }\n    true\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<&str>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmp7b4nbqaa.rs:12:57\n     |\n12\
    \   |     let mut bracket_stack: Vec<&str> = brackets.chars().collect();\n   \
    \  |                                                         ^^^^^^^ value of\
    \ type `Vec<&str>` cannot be built from `std::iter::Iterator<Item=char>`\n   \
    \  |\n     = help: the trait `FromIterator<char>` is not implemented for `Vec<&str>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut pos = 0;\n    while pos < brackets.len() {\n        let open = brackets[pos].chars().next().unwrap();\n\
    \        let close = brackets[pos + 1].chars().next().unwrap();\n        pos +=\
    \ 2;\n\n        if open != close {\n            return false;\n        }\n   \
    \     pos += 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpxv7ofswl.rs:14:20\n\
    \   |\n14 |         let open = brackets[pos].chars().next().unwrap();\n   |  \
    \                  ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpxv7ofswl.rs:15:21\n\
    \   |\n15 |         let close = brackets[pos + 1].chars().next().unwrap();\n \
    \  |                     ^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets\n\
    \        .chars()\n        .filter_map(|c| {\n            match c {\n        \
    \        '<' => Some('>'),\n                '>' => Some('<'),\n              \
    \  _ => None,\n            }\n        })\n        .all(|bracket| brackets.chars().any(|c|\
    \ c == bracket))\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpon5ab5ps.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    //\
    \ TODO: Optimize for short inputs?\n    for (bra, c) in brackets.chars().zip(&[']',\
    \ '>']).skip(1).take(2) {\n        if bra == c || bra == ']' && c != '[' ||\n\
    \            bra == '>' && c != '['\n        {\n            return false;\n  \
    \      }\n    }\n\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpn31gm1k3.rs:14:19\n   |\n\
    14 |         if bra == c || bra == ']' && c != '[' ||\n   |                  \
    \ ^ expected `char`, found `&char`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n14 |         if bra == *c || bra == ']' && c != '[' ||\n   |          \
    \         +\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpn31gm1k3.rs:14:40\n\
    \   |\n14 |         if bra == c || bra == ']' && c != '[' ||\n   |           \
    \                             ^^ no implementation for `&char == char`\n   |\n\
    \   = help: the trait `PartialEq<char>` is not implemented for `&char`\n   = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare\
    \ `&char` with `char`\n  --> /tmp/tmpn31gm1k3.rs:15:29\n   |\n15 |           \
    \  bra == '>' && c != '['\n   |                             ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ *c == ' ' || c == '<' || c == '>')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmps8lov3a0.rs:12:30\n\
    \   |\n12 |     brackets.chars().all(|c| *c == ' ' || c == '<' || c == '>')\n\
    \   |                              ^^\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut i = 0;\n    while i < brackets.len() {\n        if brackets[i] == '<' {\n\
    \            if let Some(i) = brackets.find('>') {\n                brackets.insert(i\
    \ + 2, '>');\n            } else {\n                return false;\n          \
    \  }\n        }\n        i += 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpg6o5hhxc.rs:14:12\n\
    \   |\n14 |         if brackets[i] == '<' {\n   |            ^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut i = 0;\n    while i < brackets.len() {\n        if brackets[i] == '<' {\n\
    \            i += 1;\n            while i < brackets.len() && brackets[i] == '>'\
    \ {\n                i += 1;\n            }\n            if i < brackets.len()\
    \ {\n                return true;\n            }\n        }\n        i += 1;\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpzsul5dth.rs:14:12\n\
    \   |\n14 |         if brackets[i] == '<' {\n   |            ^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpzsul5dth.rs:16:41\n   |\n16 |             while i < brackets.len()\
    \ && brackets[i] == '>' {\n   |                                         ^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    if\
    \ brackets.chars().any(|c| c == '<' || c == '>') {\n        false\n    } else\
    \ {\n        true\n    }\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp7t8s6sx9.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976567
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut depth = 1;\n    let mut depths = vec![depth];\n    let mut opened = false;\n\
    \    for ch in brackets.chars() {\n        if let Some(depth) = depths.last()\
    \ {\n            if ch == '>' {\n                depths[depth]--;\n          \
    \      opened = false;\n            } else if ch == '<' {\n                depths[depth]++;\n\
    \                opened = true;\n            } else {\n                return\
    \ false;\n            }\n        } else {\n            return false;\n       \
    \ }\n    }\n\n    for depth in 0..depths.len() {\n        if depths[depth] !=\
    \ 0 {\n            return false;\n        }\n    }\n\n    opened\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpio_whbqb.rs:18:32\n\
    \   |\n18 |                 depths[depth]--;\n   |                           \
    \     ^ expected expression\n\nerror: Rust has no postfix increment operator\n\
    \  --> /tmp/tmpio_whbqb.rs:21:30\n   |\n21 |                 depths[depth]++;\n\
    \   |                              ^^ not a valid postfix operator\n   |\nhelp:\
    \ use `+= 1` instead\n   |\n21 |                 { let tmp = depths[depth]; depths[depth]\
    \ += 1; tmp };\n   |                 +++++++++++              ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    21 -                 depths[depth]++;\n21 +                 depths[depth] += 1;\n\
    \   | \n\nerror: aborting due to 2 previous errors\n\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut is_correct = true;\n    brackets.chars().for_each(|c| {\n        let mut\
    \ i = 1;\n        while i < c.len() {\n            if c == &brackets[i as usize]\
    \ {\n                i += 1;\n            } else {\n                break;\n \
    \           }\n        }\n        if i == c.len() {\n            is_correct =\
    \ false;\n        }\n    });\n    is_correct\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp2rqxvlso.rs:15:21\n   |\n15 |         while i < c.len()\
    \ {\n   |                     ^^^ method not found in `char`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp2rqxvlso.rs:16:22\n\
    \   |\n16 |             if c == &brackets[i as usize] {\n   |                \
    \      ^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2rqxvlso.rs:16:21\n   |\n16 |             if\
    \ c == &brackets[i as usize] {\n   |                     ^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found reference\n   |\n   = note:   expected type `char`\n\
    \           found reference `&_`\nhelp: consider removing the borrow\n   |\n16\
    \ -             if c == &brackets[i as usize] {\n16 +             if c == brackets[i\
    \ as usize] {\n   | \n\nerror[E0599]: no method named `len` found for type `char`\
    \ in the current scope\n  --> /tmp/tmp2rqxvlso.rs:22:19\n   |\n22 |         if\
    \ i == c.len() {\n   |                   ^^^ method not found in `char`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open = 0;\n    let mut close = 0;\n\n    for c in &brackets {\n        if\
    \ c == '<' {\n            open += 1;\n        } else {\n            close += 1;\n\
    \        }\n    }\n\n    (open == close)\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around block return value\n  --> /tmp/tmpefkmzjcx.rs:23:5\n\
    \   |\n23 |     (open == close)\n   |     ^             ^\n   |\n   = note: `#[warn(unused_parens)]`\
    \ on by default\nhelp: remove these parentheses\n   |\n23 -     (open == close)\n\
    23 +     open == close\n   | \n\nerror[E0277]: `&String` is not an iterator\n\
    \  --> /tmp/tmpefkmzjcx.rs:15:14\n   |\n15 |     for c in &brackets {\n   |  \
    \            ^^^^^^^^^ `&String` is not an iterator\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `&String`\n   = note: required because of\
    \ the requirements on the impl of `IntoIterator` for `&String`\n\nerror: aborting\
    \ due to previous error; 1 warning emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open = Vec::new();\n    let mut closed = Vec::new();\n    let mut pos =\
    \ 0;\n    while pos < brackets.len() {\n        let opening = brackets[pos].to_string();\n\
    \        if open.contains(&opening) {\n            open.remove(open);\n      \
    \      closed.push(opening);\n        } else {\n            open.push(opening);\n\
    \        }\n        pos += 1;\n    }\n    if open.is_empty() {\n        true\n\
    \    } else {\n        closed.insert(0, open);\n        false\n    }\n}\n\nfn\
    \ main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp8t0eroj0.rs:16:23\n\
    \   |\n16 |         let opening = brackets[pos].to_string();\n   |           \
    \            ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8t0eroj0.rs:18:25\n\
    \   |\n18 |             open.remove(open);\n   |                         ^^^^\
    \ expected `usize`, found struct `Vec`\n   |\n   = note: expected type `usize`\n\
    \            found struct `Vec<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8t0eroj0.rs:28:26\n\
    \   |\n28 |         closed.insert(0, open);\n   |                          ^^^^-\
    \ help: try using a conversion method: `.to_vec()`\n   |                     \
    \     |\n   |                          cyclic type of infinite size\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976567
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = vec![];\n    let mut closed_brackets = vec![];\n    brackets.chars().for_each(|c|\
    \ match c {\n        ' ' => {},\n        '>' => closed_brackets.push(0),\n   \
    \     '<' => open_brackets.push(0),\n        '>' => {\n            closed_brackets.last_mut().unwrap()\
    \ += 1;\n        },\n        '<' => {\n            open_brackets.last_mut().unwrap()\
    \ += 1;\n        },\n        _ => (),\n    });\n    open_brackets.iter().all(|o|\
    \ closed_brackets.iter().any(|c| c == o + 1))\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpwze1k51o.rs:19:13\n   |\n19 |             closed_brackets.last_mut().unwrap()\
    \ += 1;\n   |             -----------------------------------^^^^^\n   |     \
    \        |\n   |             cannot use `+=` on type `&mut {integer}`\n   |\n\
    help: `+=` can be used on `{integer}`, you can dereference `closed_brackets.last_mut().unwrap()`\n\
    \   |\n19 |             *closed_brackets.last_mut().unwrap() += 1;\n   |     \
    \        +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpwze1k51o.rs:19:49\n\
    \   |\n19 |             closed_brackets.last_mut().unwrap() += 1;\n   |      \
    \       ----------------------------------- ^^\n   |             |\n   |     \
    \        cannot assign to this expression\n\nerror[E0368]: binary assignment operation\
    \ `+=` cannot be applied to type `&mut {integer}`\n  --> /tmp/tmpwze1k51o.rs:22:13\n\
    \   |\n22 |             open_brackets.last_mut().unwrap() += 1;\n   |        \
    \     ---------------------------------^^^^^\n   |             |\n   |       \
    \      cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can be used\
    \ on `{integer}`, you can dereference `open_brackets.last_mut().unwrap()`\n  \
    \ |\n22 |             *open_brackets.last_mut().unwrap() += 1;\n   |         \
    \    +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpwze1k51o.rs:22:47\n\
    \   |\n22 |             open_brackets.last_mut().unwrap() += 1;\n   |        \
    \     --------------------------------- ^^\n   |             |\n   |         \
    \    cannot assign to this expression\n\nerror[E0277]: can't compare `&{integer}`\
    \ with `{integer}`\n  --> /tmp/tmpwze1k51o.rs:26:67\n   |\n26 |     open_brackets.iter().all(|o|\
    \ closed_brackets.iter().any(|c| c == o + 1))\n   |                          \
    \                                         ^^ no implementation for `&{integer}\
    \ == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&{integer}`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n         "
  stdout: ''
  timestamp: 1659976566
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.find(\"\
    <\") != brackets.find(\">\")\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp83eqx7jb.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976567
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets: Vec<String> = brackets.chars().map(|c|\n        match c {\n\
    \            '<' => \"<<\",\n            '>' => \">>\",\n            _ => String::from(\"\
    <<\"),\n        }).collect();\n    let mut close_brackets: Vec<String> = brackets.chars().map(|c|\n\
    \        match c {\n            '<' => \"<<\",\n            '>' => \">>\",\n \
    \           _ => String::from(\">>\"),\n        }).collect();\n    loop {\n  \
    \      let open = open_brackets.pop().unwrap();\n        let close = close_brackets.pop().unwrap();\n\
    \        if open == close {\n            return true;\n        }\n        if open_brackets.is_empty()\
    \ {\n            return false;\n        }\n    }\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: `match` arms have incompatible types\n  --> /tmp/tmpdupzyo4t.rs:16:18\n\
    \   |\n13 | /         match c {\n14 | |             '<' => \"<<\",\n   | |   \
    \                 ---- this is found to be of type `&str`\n15 | |            \
    \ '>' => \">>\",\n   | |                    ---- this is found to be of type `&str`\n\
    16 | |             _ => String::from(\"<<\"),\n   | |                  ^^^^^^^^^^^^^^^^^^\n\
    \   | |                  |\n   | |                  expected `&str`, found struct\
    \ `String`\n   | |                  help: consider borrowing here: `&String::from(\"\
    <<\")`\n17 | |         }).collect();\n   | |_________- `match` arms have incompatible\
    \ types\n\nerror[E0308]: `match` arms have incompatible types\n  --> /tmp/tmpdupzyo4t.rs:22:18\n\
    \   |\n19 | /         match c {\n20 | |             '<' => \"<<\",\n   | |   \
    \                 ---- this is found to be of type `&str`\n21 | |            \
    \ '>' => \">>\",\n   | |                    ---- this is found to be of type `&str`\n\
    22 | |             _ => String::from(\">>\"),\n   | |                  ^^^^^^^^^^^^^^^^^^\n\
    \   | |                  |\n   | |                  expected `&str`, found struct\
    \ `String`\n   | |                  help: consider borrowing here: `&String::from(\"\
    >>\")`\n23 | |         }).collect();\n   | |_________- `match` arms have incompatible\
    \ types\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ is_bracket_type(c))\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_bracket_type` in this scope\n  -->\
    \ /tmp/tmpe4krzrwr.rs:12:30\n   |\n12 |     brackets.chars().all(|c| is_bracket_type(c))\n\
    \   |                              ^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut counter = 0;\n    let mut i = 0;\n    let mut len = brackets.len();\n  \
    \  let mut current = String::new();\n\n    while counter < len {\n        // Check\
    \ if the current char is the starting char of the next bracket\n        if brackets[i]\
    \ != brackets[i + 1] {\n            // If the current char is not the starting\
    \ char of the next bracket\n            // increment the counter\n           \
    \ counter += 1;\n        } else {\n            // If the current char is the starting\
    \ char of the next bracket\n            // Increment the counter to check that\
    \ the next char is matching the\n            // previous one\n            counter\
    \ += 1;\n        }\n        // Get the next char\n        i += 1;\n    }\n   \
    \ if counter == 0 {\n        // If no brackets were opened, then return true\n\
    \        return true;\n    }\n    // Otherwise return false\n    return false;\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpqkbtj5qc.rs:19:12\n   |\n19 |         if brackets[i] != brackets[i +\
    \ 1] {\n   |            ^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpqkbtj5qc.rs:19:27\n   |\n19 |         if brackets[i] != brackets[i\
    \ + 1] {\n   |                           ^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    for b in brackets.chars() {\n    \
    \    if !(b == '<' || b == '>') {\n            return false;\n        }\n    }\n\
    \    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpeojbt2uu.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976567
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut count = 0;\n    let mut opening_bracket = String::new();\n    let mut closing_bracket\
    \ = String::new();\n    for ch in brackets {\n        if ch.is_whitespace() {\n\
    \            count += 1;\n        } else {\n            opening_bracket.push_str(&ch);\n\
    \            count += 1;\n        }\n    }\n    for ch in brackets.chars().skip(count)\
    \ {\n        if ch.is_whitespace() {\n            count += 1;\n        } else\
    \ {\n            closing_bracket.push_str(&ch);\n            count += 1;\n   \
    \     }\n    }\n    opening_bracket.chars().all(|c| closing_bracket.chars().any(|c|\
    \ c == c))\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpcu6hb3eq.rs:15:15\n\
    \   |\n15 |     for ch in brackets {\n   |               ^^^^^^^^ `String` is\
    \ not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpcu6hb3eq.rs:27:38\n   |\n27 |             closing_bracket.push_str(&ch);\n\
    \   |                                      ^^^ expected `str`, found `char`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut iter = brackets.chars().enumerate();\n    let mut stack = [bool::default()];\n\
    \    for (i, c) in iter.by_ref() {\n        if c == '<' {\n            if !stack[0]\
    \ {\n                stack[0] = true;\n                i += 1;\n            }\n\
    \        }\n        if c == '>' {\n            if stack[0] {\n               \
    \ stack[0] = false;\n                i += 1;\n            }\n        }\n     \
    \   if stack.len() > 0 {\n            stack.pop();\n        }\n        if i ==\
    \ iter.len() {\n            return false;\n        }\n        stack.append(c ==\
    \ '<');\n    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `pop` found for array `[bool; 1]` in the\
    \ current scope\n  --> /tmp/tmptdf18rjw.rs:28:19\n   |\n28 |             stack.pop();\n\
    \   |                   ^^^ method not found in `[bool; 1]`\n\nerror[E0599]: the\
    \ method `len` exists for struct `Enumerate<Chars<'_>>`, but its trait bounds\
    \ were not satisfied\n  --> /tmp/tmptdf18rjw.rs:30:22\n   |\n30 |           if\
    \ i == iter.len() {\n   |                        ^^^ method cannot be called on\
    \ `Enumerate<Chars<'_>>` due to unsatisfied trait bounds\n   |\n   = note: the\
    \ following trait bounds were not satisfied:\n           `Chars<'_>: ExactSizeIterator`\n\
    \           which is required by `Enumerate<Chars<'_>>: ExactSizeIterator`\n\n\
    error[E0599]: no method named `append` found for array `[bool; 1]` in the current\
    \ scope\n  --> /tmp/tmptdf18rjw.rs:33:15\n   |\n33 |         stack.append(c ==\
    \ '<');\n   |               ^^^^^^ method not found in `[bool; 1]`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c != '<' && c != '>')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpzv8x3f6h.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976567
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c != '<')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpvrzijjr4.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976567
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut in_bracket = false;\n    let mut bracket = brackets.chars().skip_while(|&c|\
    \ !in_bracket);\n    while bracket != String::new() && bracket.is_some() {\n \
    \       if bracket.as_str() == \">\" {\n            in_bracket = false;\n    \
    \    }\n        if bracket.as_str() == \"<\" {\n            in_bracket = true;\n\
    \        }\n        if in_bracket {\n            return false;\n        }\n  \
    \      if bracket.as_str() == \">>\" {\n            in_bracket = true;\n     \
    \   }\n        if bracket.as_str() == \"><<\" {\n            in_bracket = true;\n\
    \        }\n        if in_bracket {\n            return false;\n        }\n  \
    \      if bracket.as_str() == \"<<<\" {\n            in_bracket = true;\n    \
    \    }\n        if in_bracket {\n            return false;\n        }\n      \
    \  bracket = bracket.next();\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0369]: binary operation `!=` cannot be applied to type `SkipWhile<Chars<'_>,\
    \ [closure@/tmp/tmpnao47i4k.rs:13:51: 13:67]>`\n  --> /tmp/tmpnao47i4k.rs:14:19\n\
    \   |\n14 |     while bracket != String::new() && bracket.is_some() {\n   |  \
    \         ------- ^^ ------------- String\n   |           |\n   |           SkipWhile<Chars<'_>,\
    \ [closure@/tmp/tmpnao47i4k.rs:13:51: 13:67]>\n\nerror[E0599]: no method named\
    \ `is_some` found for struct `SkipWhile` in the current scope\n  --> /tmp/tmpnao47i4k.rs:14:47\n\
    \   |\n14 |     while bracket != String::new() && bracket.is_some() {\n   |  \
    \                                             ^^^^^^^ method not found in `SkipWhile<Chars<'_>,\
    \ [closure@/tmp/tmpnao47i4k.rs:13:51: 13:67]>`\n\nerror[E0599]: no method named\
    \ `as_str` found for struct `SkipWhile` in the current scope\n  --> /tmp/tmpnao47i4k.rs:15:20\n\
    \   |\n15 |         if bracket.as_str() == \">\" {\n   |                    ^^^^^^\
    \ method not found in `SkipWhile<Chars<'_>, [closure@/tmp/tmpnao47i4k.rs:13:51:\
    \ 13:67]>`\n\nerror[E0599]: no method named `as_str` found for struct `SkipWhile`\
    \ in the current scope\n  --> /tmp/tmpnao47i4k.rs:18:20\n   |\n18 |         if\
    \ bracket.as_str() == \"<\" {\n   |                    ^^^^^^ method not found\
    \ in `SkipWhile<Chars<'_>, [closure@/tmp/tmpnao47i4k.rs:13:51: 13:67]>`\n\nerror[E0599]:\
    \ no method named `as_str` found for struct `SkipWhile` in the current scope\n\
    \  --> /tmp/tmpnao47i4k.rs:24:20\n   |\n24 |         if bracket.as_str() == \"\
    >>\" {\n   |                    ^^^^^^ method not found in `SkipWhile<Chars<'_>,\
    \ [closure@/tmp/tmpnao47i4k.rs:13:51: 13:67]>`\n\nerror[E0599]: no method named\
    \ `as_str` found for struct `SkipWhile` in the current scope\n  --> /tmp/tmpnao47i4k.rs:27:20\n\
    \   |\n27 |         if bracket.as_str() == \"><<\" {\n   |                   \
    \ ^^^^^^ method not found in `SkipWhile<Chars<'_>, [closure@/tmp/tmpnao47i4k.rs:13:51:\
    \ 13:67]>`\n\nerror[E0599]: no method named `as_str` found for struct `SkipWhile`\
    \ in the current scope\n  --> /tmp/tmpnao47i4k.rs:33:20\n   |\n33 |         if\
    \ bracket.as_str() == \"<<<\" {\n   |            "
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut i = 1;\n    while i <= brackets.len() {\n        if brackets[brackets.len()\
    \ - i..brackets.len() - i + 1] == \">\" {\n            if brackets[i - 1] == \"\
    >\" {\n                return false;\n            }\n        }\n        i += 1;\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `str` with `&str`\n  --> /tmp/tmp8kjqwjug.rs:14:65\n\
    \   |\n14 |         if brackets[brackets.len() - i..brackets.len() - i + 1] ==\
    \ \">\" {\n   |                                                              \
    \   ^^ no implementation for `str == &str`\n   |\n   = help: the trait `PartialEq<&str>`\
    \ is not implemented for `str`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0277]: the type `String` cannot be indexed by\
    \ `usize`\n  --> /tmp/tmp8kjqwjug.rs:15:16\n   |\n15 |             if brackets[i\
    \ - 1] == \">\" {\n   |                ^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut bracket = String::from(\"\");\n    let mut has_opening = false;\n    for\
    \ ch in brackets.chars() {\n        if ch == \">\" {\n            has_opening\
    \ = false;\n            bracket += \">\";\n        } else {\n            if has_opening\
    \ {\n                bracket += \">\";\n            } else {\n               \
    \ has_opening = true;\n                bracket += ch;\n            }\n       \
    \ }\n    }\n    !bracket.contains(brackets.chars().skip_while(|ch| ch != \">\"\
    ))\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpg3117yc7.rs:15:18\n   |\n\
    15 |         if ch == \">\" {\n   |                  ^^^ expected `char`, found\
    \ `&str`\n   |\nhelp: if you meant to write a `char` literal, use single quotes\n\
    \   |\n15 |         if ch == '>' {\n   |                  ~~~\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpg3117yc7.rs:23:28\n   |\n23 |              \
    \   bracket += ch;\n   |                            ^^ expected `&str`, found\
    \ `char`\n\nerror[E0277]: can't compare `char` with `str`\n  --> /tmp/tmpg3117yc7.rs:27:59\n\
    \   |\n27 |     !bracket.contains(brackets.chars().skip_while(|ch| ch != \">\"\
    ))\n   |                                                           ^^ no implementation\
    \ for `char == str`\n   |\n   = help: the trait `PartialEq<str>` is not implemented\
    \ for `char`\n   = help: the trait `PartialEq` is implemented for `char`\n   =\
    \ note: required because of the requirements on the impl of `PartialEq<&str>`\
    \ for `&char`\n\nerror[E0277]: expected a `FnMut<(char,)>` closure, found `SkipWhile<Chars<'_>,\
    \ [closure@/tmp/tmpg3117yc7.rs:27:51: 27:65]>`\n    --> /tmp/tmpg3117yc7.rs:27:23\n\
    \     |\n27   |     !bracket.contains(brackets.chars().skip_while(|ch| ch != \"\
    >\"))\n     |              -------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected an `FnMut<(char,)>` closure, found `SkipWhile<Chars<'_>, [closure@/tmp/tmpg3117yc7.rs:27:51:\
    \ 27:65]>`\n     |              |\n     |              required by a bound introduced\
    \ by this call\n     |\n     = help: the trait `FnMut<(char,)>` is not implemented\
    \ for `SkipWhile<Chars<'_>, [closure@/tmp/tmpg3117yc7.rs:27:51: 27:65]>`\n   \
    \  = help: the following other types implement trait `Pattern<'a>`:\n        \
    \       &'b String\n               &'b [char; N]\n               &'b [char]\n\
    \               &'b str\n               &'c &'b str\n               [char; N]\n\
    \               char\n               pattern::MultiCharEqPattern<C>\n     = note:\
    \ required because of the requirements on the impl of `Pattern<'_>` for `SkipWhile<Chars<'_>,\
    \ [closure@/tmp/tmpg3117yc7.rs:27:51: 27:65]>`\nnote: required by a bound "
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<_> = brackets.chars().filter_map(|c| *c != '<').collect();\n\
    \    stack.pop_back();\n    while !stack.is_empty() {\n        let c: char = stack.remove(0);\n\
    \        if !('>' <= c && c <= '<') {\n            return false;\n        }\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpf_83ihib.rs:12:61\n\
    \   |\n12 |     let mut stack: Vec<_> = brackets.chars().filter_map(|c| *c !=\
    \ '<').collect();\n   |                                                      \
    \       ^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf_83ihib.rs:12:61\n\
    \   |\n12 |     let mut stack: Vec<_> = brackets.chars().filter_map(|c| *c !=\
    \ '<').collect();\n   |                                                      \
    \       ^^^^^^^^^ expected enum `Option`, found `bool`\n   |\n   = note: expected\
    \ enum `Option<_>`\n              found type `bool`\nhelp: try wrapping the expression\
    \ in `Some`\n   |\n12 |     let mut stack: Vec<_> = brackets.chars().filter_map(|c|\
    \ Some(*c != '<')).collect();\n   |                                          \
    \                   +++++         +\n\nerror[E0599]: no method named `pop_back`\
    \ found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpf_83ihib.rs:13:11\n\
    \   |\n13 |     stack.pop_back();\n   |           ^^^^^^^^ method not found in\
    \ `Vec<_>`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599, E0614.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    //\
    \ Iterate through the string one char at a time.\n    for ch in brackets.chars()\
    \ {\n        // If we're at a \"closing\" bracket, check if we're at an \"opening\"\
    \ bracket.\n        if ch == '<' {\n            let mut ch = String::new();\n\
    \            loop {\n                ch = ch.chars().next().unwrap();\n      \
    \          if ch != '<' {\n                    break;\n                }\n   \
    \         }\n            ch != '<' &&\n                !ch.is_ascii_digit() &&\n\
    \                !ch.is_ascii_letter() &&\n                !ch.is_ascii_symbol()\
    \ &&\n                !ch.is_ascii_punctuation()\n        }\n        // If we're\
    \ at a \"closing\" bracket, check if we're at an \"opening\" bracket.\n      \
    \  if ch == ']' {\n            let mut ch = String::new();\n            loop {\n\
    \                ch = ch.chars().next().unwrap();\n                if ch != '>'\
    \ {\n                    break;\n                }\n            }\n          \
    \  ch != '>' &&\n                !ch.is_ascii_digit() &&\n                !ch.is_ascii_letter()\
    \ &&\n                !ch.is_ascii_symbol() &&\n                !ch.is_ascii_punctuation()\n\
    \        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbb_00rdh.rs:18:22\n   |\n\
    16 |             let mut ch = String::new();\n   |                          -------------\
    \ expected due to this value\n17 |             loop {\n18 |                 ch\
    \ = ch.chars().next().unwrap();\n   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \    |\n   |                      expected struct `String`, found `char`\n\nerror[E0277]:\
    \ can't compare `String` with `char`\n  --> /tmp/tmpbb_00rdh.rs:19:23\n   |\n\
    19 |                 if ch != '<' {\n   |                       ^^ no implementation\
    \ for `String == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0599]: no method\
    \ named `is_ascii_digit` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpbb_00rdh.rs:24:21\n   |\n24 |                 !ch.is_ascii_digit() &&\n\
    \   |                     ^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `is_ascii`\n\nerror[E0277]: can't compare `String` with\
    \ `char`\n  --> /tmp/tmpbb_00rdh.rs:23:16\n   |\n23 |             ch != '<' &&\n\
    \   |                ^^ no implementation for `String == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `PartialEq<Rhs>`:\n             <&'a str\
    \ as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n     \
    \        <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as "
  stdout: ''
  timestamp: 1659976567
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    let mut bracket_map = HashMap::new();\n\
    \    let mut i = 0;\n    while i < brackets.len() {\n        bracket_map.entry(brackets[i..i+1]).or_insert(false).cloned().unwrap();\n\
    \        i += 1;\n    }\n\n    bracket_map.is_empty()\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp5ckix425.rs:13:27\n   |\n13 |     let mut bracket_map = HashMap::new();\n\
    \   |                           ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|x|\
    \ *x == '>')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpr71nmeld.rs:12:30\n\
    \   |\n12 |     brackets.chars().all(|x| *x == '>')\n   |                    \
    \          ^^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().enumerate().any(|(i,\
    \ c)| {\n        if *c >= '>' && i <= brackets.len() - 1 && brackets[i + 1] ==\
    \ '<' {\n            true\n        } else {\n            false\n        }\n  \
    \  })\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmp138hcfh8.rs:13:12\n\
    \   |\n13 |         if *c >= '>' && i <= brackets.len() - 1 && brackets[i + 1]\
    \ == '<' {\n   |            ^^\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmp138hcfh8.rs:13:52\n   |\n13 |         if *c >= '>'\
    \ && i <= brackets.len() - 1 && brackets[i + 1] == '<' {\n   |               \
    \                                     ^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0614.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut chars = String::from(brackets).chars();\n    for char in chars {\n     \
    \   let index = chars.index(char);\n        let next_index = chars.iter().position(|c|\
    \ *c == char).unwrap_or(&chars.len());\n        if index > 0 && chars[index -\
    \ 1] == '<' {\n            if next_index == chars.len() {\n                //\
    \ empty string - return false (always opened)\n                return false;\n\
    \            }\n            if chars[next_index] == '>' {\n                //\
    \ found an open > - return false (always closed but may be opened)\n         \
    \       return false;\n            }\n        }\n    }\n    // check every open\
    \ bracket has at least one corresponding closing bracket\n    for char in chars\
    \ {\n        if char == '>' {\n            return false;\n        }\n    }\n \
    \   // check every closing bracket has at least one corresponding open bracket\n\
    \    for char in chars {\n        if char == '<' {\n            return false;\n\
    \        }\n    }\n    // all brackets checked - return true (always closed)\n\
    \    return true;\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `index` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmpbx0ibkaa.rs:14:27\n   |\n14 |         let index = chars.index(char);\n\
    \   |                           ^^^^^ method not found in `Chars<'_>`\n\nerror[E0599]:\
    \ no method named `iter` found for struct `Chars` in the current scope\n  -->\
    \ /tmp/tmpbx0ibkaa.rs:15:32\n   |\n15 |         let next_index = chars.iter().position(|c|\
    \ *c == char).unwrap_or(&chars.len());\n   |                                ^^^^\
    \ private field, not a method\n\nerror[E0599]: no method named `len` found for\
    \ struct `Chars` in the current scope\n  --> /tmp/tmpbx0ibkaa.rs:15:81\n   |\n\
    15 |         let next_index = chars.iter().position(|c| *c == char).unwrap_or(&chars.len());\n\
    \   |                                                                        \
    \         ^^^ method not found in `Chars<'_>`\n\nerror[E0608]: cannot index into\
    \ a value of type `Chars<'_>`\n  --> /tmp/tmpbx0ibkaa.rs:16:25\n   |\n16 |   \
    \      if index > 0 && chars[index - 1] == '<' {\n   |                       \
    \  ^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `len` found for struct `Chars`\
    \ in the current scope\n  --> /tmp/tmpbx0ibkaa.rs:17:36\n   |\n17 |          \
    \   if next_index == chars.len() {\n   |                                    ^^^\
    \ method not found in `Chars<'_>`\n\nerror[E0608]: cannot index into a value of\
    \ type `Chars<'_>`\n  --> /tmp/tmpbx0ibkaa.rs:21:16\n   |\n21 |             if\
    \ chars[next_index] == '>' {\n   |                ^^^^^^^^^^^^^^^^^\n\nerror:\
    \ aborting due to 6 previous errors\n\nSome errors have detailed explanations:\
    \ E0599, E0608.\nFor more information about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets\n\
    \        .chars()\n        .filter_map(|c| match c {\n            '<' => Some(-1),\n\
    \            '>' => Some(+1),\n            _ => None,\n        })\n        .all(|s|\
    \ s <= 0)\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: leading `+` is not supported\n  --> /tmp/tmp6ez5yjl1.rs:16:25\n\
    \   |\n16 |             '>' => Some(+1),\n   |                         ^ unexpected\
    \ `+`\n   |\nhelp: try removing the `+`\n   |\n16 -             '>' => Some(+1),\n\
    16 +             '>' => Some(1),\n   | \n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    while brackets.len() > 0 {\n     \
    \   let mut i = brackets.find('<');\n        let mut opening = brackets.chars().nth(i).unwrap();\n\
    \        brackets = &brackets[i .. brackets.len()].to_string();\n        i +=\
    \ 1;\n        let mut closing = brackets.chars().nth(i).unwrap();\n        brackets\
    \ = &brackets[i .. brackets.len()].to_string();\n        if opening != closing\
    \ {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6m25u_98.rs:15:48\n   |\n\
    15 |         let mut opening = brackets.chars().nth(i).unwrap();\n   |       \
    \                                         ^ expected `usize`, found enum `Option`\n\
    \   |\n   = note: expected type `usize`\n              found enum `Option<usize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp6m25u_98.rs:16:35\n   |\n16 |\
    \         brackets = &brackets[i .. brackets.len()].to_string();\n   |       \
    \                            ^^^^^^^^^^^^^^ expected enum `Option`, found `usize`\n\
    \   |\n   = note: expected enum `Option<usize>`\n              found type `usize`\n\
    help: try wrapping the expression in `Some`\n   |\n16 |         brackets = &brackets[i\
    \ .. Some(brackets.len())].to_string();\n   |                                \
    \   +++++              +\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `std::ops::Range<Option<usize>>`\n  --> /tmp/tmp6m25u_98.rs:16:21\n   |\n\
    16 |         brackets = &brackets[i .. brackets.len()].to_string();\n   |    \
    \                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by\
    \ `std::ops::Range<Option<usize>>`\n   |\n   = help: the trait `Index<std::ops::Range<Option<usize>>>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0368]: binary assignment operation `+=` cannot be applied\
    \ to type `Option<usize>`\n  --> /tmp/tmp6m25u_98.rs:17:9\n   |\n17 |        \
    \ i += 1;\n   |         -^^^^^\n   |         |\n   |         cannot use `+=` on\
    \ type `Option<usize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6m25u_98.rs:18:48\n\
    \   |\n18 |         let mut closing = brackets.chars().nth(i).unwrap();\n   |\
    \                                                ^ expected `usize`, fou"
  stdout: ''
  timestamp: 1659976567
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.split('>')\n\
    \        .rev()\n        .zip(\n            brackets\n                .split('>')\n\
    \                .into_iter()\n                .map(|&x| x.trim_matches(br\"[<>]\"\
    ))\n                .collect::<Vec<_>>(),\n        )\n        .all(|(bracket,\
    \ right)| {\n            let mut it = right.rsplitn(2, \">\").map(|s| s.trim_matches(br\"\
    []\"));\n            it.next(); // ignore the leading \">>\"\n            it.next().is_ok()\
    \ && it.next().unwrap() == &bracket\n        })\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n  --> /tmp/tmp742stc3i.rs:18:24\n   |\n18 |                 .map(|&x|\
    \ x.trim_matches(br\"[<>]\"))\n   |                        ^ doesn't have a size\
    \ known at compile-time\n   |\n   = help: the trait `Sized` is not implemented\
    \ for `str`\n   = note: all local variables must have a statically known size\n\
    \   = help: unsized locals are gated as an unstable feature\n\nerror[E0277]: expected\
    \ a `Fn<(char,)>` closure, found `[u8; 4]`\n  --> /tmp/tmp742stc3i.rs:18:42\n\
    \   |\n18 |                 .map(|&x| x.trim_matches(br\"[<>]\"))\n   |      \
    \                       ------------ ^^^^^^^^ expected an `Fn<(char,)>` closure,\
    \ found `[u8; 4]`\n   |                             |\n   |                  \
    \           required by a bound introduced by this call\n   |\n   = help: the\
    \ trait `Fn<(char,)>` is not implemented for `[u8; 4]`\n   = help: the following\
    \ other types implement trait `Pattern<'a>`:\n             &'b [char; N]\n   \
    \          &'b [char]\n             [char; N]\n   = note: required because of\
    \ the requirements on the impl of `FnOnce<(char,)>` for `&[u8; 4]`\n   = note:\
    \ required because of the requirements on the impl of `Pattern<'_>` for `&[u8;\
    \ 4]`\n\nerror[E0277]: expected a `Fn<(char,)>` closure, found `[u8; 2]`\n  -->\
    \ /tmp/tmp742stc3i.rs:22:71\n   |\n22 |             let mut it = right.rsplitn(2,\
    \ \">\").map(|s| s.trim_matches(br\"[]\"));\n   |                            \
    \                              ------------ ^^^^^^ expected an `Fn<(char,)>` closure,\
    \ found `[u8; 2]`\n   |                                                      \
    \    |\n   |                                                          required\
    \ by a bound introduced by this call\n   |\n   = help: the trait `Fn<(char,)>`\
    \ is not implemented for `[u8; 2]`\n   = help: the following other types implement\
    \ trait `Pattern<'a>`:\n             &'b [char; N]\n             &'b [char]\n\
    \             [char; N]\n   = note: required because of the requirements on the\
    \ impl of `FnOnce<(char,)>` for `&[u8; 2]`\n   = note: required because of"
  stdout: ''
  timestamp: 1659976567
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    //\
    \ We use a stack to keep track of unmatched opening brackets.\n    let mut stack:\
    \ Vec<usize> = vec![];\n    // Use a flag to keep track of whether a closing bracket\
    \ is encountered.\n    let mut closing = false;\n    for bracket in brackets.chars()\
    \ {\n        // When a closing bracket is encountered, we add one to our stack\n\
    \        // and pop a corresponding opening bracket. On the other hand, when\n\
    \        // a matching opening bracket is found, we add the corresponding\n  \
    \      // closing bracket.\n        if closing {\n            stack.pop();\n \
    \           stack.pop();\n        } else {\n            if bracket != '>' {\n\
    \                stack.push(bracket);\n            } else {\n                //\
    \ A closing bracket is found, add the corresponding opening\n                //\
    \ bracket.\n                closing = true;\n                stack.push(bracket);\n\
    \            }\n        }\n    }\n\n    // The stack should be empty when there\
    \ should be no unmatched brackets.\n    stack.len() == 0\n}\n\nfn main() {\n \
    \   let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxxxpry9y.rs:26:28\n   |\n\
    26 |                 stack.push(bracket);\n   |                            ^^^^^^^\
    \ expected `usize`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxxxpry9y.rs:31:28\n\
    \   |\n31 |                 stack.push(bracket);\n   |                       \
    \     ^^^^^^^ expected `usize`, found `char`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976567
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut in_bracket = false;\n    for c in brackets {\n        if !in_bracket &&\
    \ (c == '<' || c == '>') {\n            in_bracket = true;\n        }\n      \
    \  if !in_bracket && c == '>' {\n            in_bracket = true;\n        }\n \
    \       if !in_bracket && c == '<' {\n            in_bracket = false;\n      \
    \  }\n    }\n    !in_bracket\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpz_et4e9x.rs:13:14\n\
    \   |\n13 |     for c in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: -1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets;\n    while !brackets.starts_with(\"<<<\") && brackets.ends_with(\"\
    >>>\") {\n        brackets.replace(\"<<<\", \"<\").replace(\">>>>\", \">\");\n\
    \    }\n    brackets.contains(\"<\")\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976572
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().enumerate().all(|(&idx,\
    \ c)| {\n        if !c.is_whitespace() {\n            return c == brackets[idx].chars().next().unwrap();\n\
    \        }\n        false\n    })\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpceuty6mv.rs:12:40\n   |\n\
    12 |     brackets.chars().enumerate().all(|(&idx, c)| {\n   |                \
    \                        ^^^^   - expected due to this\n   |                 \
    \                       |\n   |                                        expected\
    \ `usize`, found reference\n   |                                        help:\
    \ you can probably remove the explicit borrow: `idx`\n   |\n   = note:   expected\
    \ type `usize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut result = String::new();\n\n    for ch in brackets.chars() {\n        if\
    \ ch == '>' {\n            result.push('>');\n        } else if ch == '<' {\n\
    \            result.push('<');\n        } else {\n            result.push(ch);\n\
    \        }\n    }\n\n    !result.is_empty()\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmperafpwkx.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976567
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().filter(|c|\
    \ c == '<').all(|c| c == '>')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpjwrfaqbt.rs:12:35\n\
    \   |\n12 |     brackets.chars().filter(|c| c == '<').all(|c| c == '>')\n   |\
    \                                   ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<_> = brackets.chars().map(|c| match c {\n        '<' => stack.pop(),\n\
    \        '>' => stack.pop(),\n        _ => c,\n    }).collect();\n    stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `stack` in this scope\n  --> /tmp/tmpe0a2avn_.rs:13:16\n\
    \   |\n13 |         '<' => stack.pop(),\n   |                ^^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find value `stack` in this scope\n  --> /tmp/tmpe0a2avn_.rs:14:16\n\
    \   |\n14 |         '>' => stack.pop(),\n   |                ^^^^^ not found in\
    \ this scope\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    let mut last = char::default();\n\
    \    while brackets.len() > 0 {\n        let mut c = &mut brackets[brackets.len()\
    \ - 1];\n        if !(c == '<' && last != '<') && last != '<' && last != '>' &&\
    \ last != '>') {\n            return false;\n        }\n        last = c == '>'\
    \ ? c : last;\n        brackets = &brackets[brackets.len() - 1];\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: unexpected closing delimiter: `}`\n  --> /tmp/tmpaam_2l4i.rs:23:1\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |          \
    \                                       - this opening brace...\n...\n21 |   \
    \  }\n   |     - ...matches this closing brace\n22 |     true\n23 | }\n   | ^\
    \ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n \
    \ --> /tmp/tmpaam_2l4i.rs:14:30\n   |\n14 |     while brackets.len() > 0 {\n \
    \  |                              ^ unclosed delimiter\n15 |         let mut c\
    \ = &mut brackets[brackets.len() - 1];\n16 |         if !(c == '<' && last !=\
    \ '<') && last != '<' && last != '>' && last != '>') {\n   |                 \
    \                                                                  ^ mismatched\
    \ closing delimiter\n\nerror: aborting due to 2 previous errors\n\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == '<' || c == '>')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmps928504y.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut found_open = false;\n    let mut found_closed = false;\n    let mut first_open_bracket\
    \ = String::new();\n    let mut first_closed_bracket = String::new();\n    for\
    \ ch in brackets {\n        if ch == '<' {\n            found_open = true;\n \
    \           first_open_bracket.clear();\n        } else if ch == '>' {\n     \
    \       found_closed = true;\n            first_closed_bracket.clear();\n    \
    \    } else {\n            found_open = found_open && (ch == '>');\n         \
    \   found_closed = found_closed && (ch == '<');\n            if !found_open &&\
    \ !found_closed {\n                first_closed_bracket.clear();\n           \
    \ } else {\n                first_closed_bracket.push(brackets[0]);\n        \
    \        first_open_bracket.push(brackets[0]);\n                found_open = true;\n\
    \                found_closed = false;\n            }\n        }\n    }\n    found_open\
    \ && found_closed\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpwcqb78cw.rs:16:15\n\
    \   |\n16 |     for ch in brackets {\n   |               ^^^^^^^^ `String` is\
    \ not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpwcqb78cw.rs:29:43\n\
    \   |\n29 |                 first_closed_bracket.push(brackets[0]);\n   |    \
    \                                       ^^^^^^^^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpwcqb78cw.rs:30:41\n   |\n30 |                 first_open_bracket.push(brackets[0]);\n\
    \   |                                         ^^^^^^^^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976567
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut chars = [b'<'];\n    for ch in brackets {\n        if ch != '<' {\n    \
    \        chars.push(ch);\n        }\n    }\n    let mut open_brackets = String::with_capacity(chars.len());\n\
    \    let mut close_brackets = String::with_capacity(chars.len());\n    for ch\
    \ in chars {\n        if ch == b'>' {\n            close_brackets.push(ch);\n\
    \        } else {\n            open_brackets.push(ch);\n        }\n    }\n   \
    \ let mut count = 0;\n    let mut last = open_brackets.len() - 1;\n    while last\
    \ >= 0 {\n        if close_brackets[last] == b'<' {\n            open_brackets.insert(last,\
    \ b'<');\n            count += 1;\n        } else {\n            open_brackets.insert(last,\
    \ b'>');\n            count += 1;\n        }\n        last -= 1;\n    }\n    open_brackets.len()\
    \ == count && open_brackets.starts_with(b\"<\")\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpdzeg7zhj.rs:13:15\n\
    \   |\n13 |     for ch in brackets {\n   |               ^^^^^^^^ `String` is\
    \ not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0599]:\
    \ no method named `push` found for array `[u8; 1]` in the current scope\n  -->\
    \ /tmp/tmpdzeg7zhj.rs:15:19\n   |\n15 |             chars.push(ch);\n   |    \
    \               ^^^^ method not found in `[u8; 1]`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpdzeg7zhj.rs:22:33\n   |\n22 |             close_brackets.push(ch);\n\
    \   |                                 ^^ expected `char`, found `u8`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpdzeg7zhj.rs:24:32\n   |\n24 |             open_brackets.push(ch);\n\
    \   |                                ^^ expected `char`, found `u8`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpdzeg7zhj.rs:30:12\n\
    \   |\n30 |         if close_brackets[last] == b'<' {\n   |            ^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdzeg7zhj.rs:31:40\n\
    \   |\n31 |             open_brackets.insert(last, b'<');\n   |              \
    \                          ^^^^ expected `char`, found `u8`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpdzeg7zhj.rs:34:40\n   |\n34 |             open_brackets.insert(last,\
    \ b'>');\n   |                                        ^^^^ expected `char`, found\
    \ `u8`\n\nerror[E0277]: expected a `"
  stdout: ''
  timestamp: 1659976567
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    //\
    \ This counts the number of opening brackets first so that\n    // we don't need\
    \ to loop through the brackets string\n    let mut count = 1;\n    for (i, c)\
    \ in brackets.chars().enumerate() {\n        if c == '<' {\n            count\
    \ += 1;\n        } else if c == '>' {\n            count -= 1;\n        } else\
    \ if c == ']' {\n            if count <= 0 {\n                // If we still have\
    \ brackets, it's an error.\n                return false;\n            }\n   \
    \     } else {\n            // Any other char.\n            return false;\n  \
    \      }\n    }\n\n    // If we get here, we didn't get an error so all opening\
    \ brackets\n    // have corresponding closing brackets\n    true\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp70u24v8i.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976567
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open = brackets.chars().skip_while(|c| c != '<').count();\n    let mut close\
    \ = brackets.chars().skip_while(|c| c != '>').count();\n    let mut brackets =\
    \ brackets;\n\n    while open > close {\n        let mut i = open;\n        while\
    \ i < close {\n            if brackets[i] != brackets[open + 1] {\n          \
    \      brackets.swap(i, open + 1);\n                return false;\n          \
    \  }\n            i += 1;\n        }\n        open += 1;\n    }\n    true\n}\n\
    \nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp1ce856uo.rs:12:54\n\
    \   |\n12 |     let mut open = brackets.chars().skip_while(|c| c != '<').count();\n\
    \   |                                                      ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp1ce856uo.rs:13:55\n\
    \   |\n13 |     let mut close = brackets.chars().skip_while(|c| c != '>').count();\n\
    \   |                                                       ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp1ce856uo.rs:19:16\n\
    \   |\n19 |             if brackets[i] != brackets[open + 1] {\n   |         \
    \       ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp1ce856uo.rs:19:31\n   |\n19 |             if brackets[i] != brackets[open\
    \ + 1] {\n   |                               ^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Inde"
  stdout: ''
  timestamp: 1659976567
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets\n\
    \        .chars()\n        .zip(brackets.chars().skip(1))\n        .all(|(a, b)|\
    \ a == '<' && b == '>')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpxfin9wsa.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976567
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    //\
    \ Open brackets have to be balanced, so find all of them.\n    let mut bracket\
    \ = brackets.char_indices();\n    let mut open = Vec::new();\n    let mut close\
    \ = Vec::new();\n    bracket.for_each(|(i, j)| {\n        // Open brackets are\
    \ a subset of close brackets.\n        if j > i {\n            open.push(i);\n\
    \        }\n    });\n\n    // All of the close brackets must be followed by an\
    \ open bracket.\n    for (i, &(_, j)) in &bracket {\n        if close.is_empty()\
    \ && j == i {\n            close.push(i);\n        }\n    }\n    // They have\
    \ to be close brackets, not just a subset of them.\n    if !close.is_empty() {\n\
    \        return false;\n    }\n    // They have to be in the same order.\n   \
    \ if !open.eq(&close) {\n        return false;\n    }\n    // They have to be\
    \ open, so find them all.\n    bracket = bracket.enumerate();\n    bracket.for_each(|(i,\
    \ &(_, j))| {\n        if !open.is_empty() && j == i {\n            open.pop();\n\
    \        }\n    });\n    !open.is_empty()\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd8fx8j5k.rs:18:16\n   |\n\
    18 |         if j > i {\n   |                ^ expected `char`, found `usize`\n\
    \nerror[E0277]: `&CharIndices<'_>` is not an iterator\n  --> /tmp/tmpd8fx8j5k.rs:24:25\n\
    \   |\n24 |     for (i, &(_, j)) in &bracket {\n   |                         -^^^^^^^\n\
    \   |                         |\n   |                         `&CharIndices<'_>`\
    \ is not an iterator\n   |                         help: consider removing the\
    \ leading `&`-reference\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `&CharIndices<'_>`\n   = note: `Iterator` is implemented for `&mut std::str::CharIndices<'_>`,\
    \ but not for `&std::str::CharIndices<'_>`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `&CharIndices<'_>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpd8fx8j5k.rs:38:15\n   |\n13 |     let mut bracket\
    \ = brackets.char_indices();\n   |                       -----------------------\
    \ expected due to this value\n...\n38 |     bracket = bracket.enumerate();\n \
    \  |               ^^^^^^^^^^^^^^^^^^^ expected struct `CharIndices`, found struct\
    \ `Enumerate`\n   |\n   = note: expected struct `CharIndices<'_>`\n          \
    \    found struct `Enumerate<CharIndices<'_>>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpd8fx8j5k.rs:39:27\n   |\n39 |     bracket.for_each(|(i, &(_, j))|\
    \ {\n   |                           ^^^^^^^- expected due to this\n   |      \
    \                     |\n   |                           expected `char`, found\
    \ reference\n   |\n   = note:   expected type `char`\n           found reference\
    \ `&_`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976567
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets\
    \ == format!(\"{{{}}}\", brackets)\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpmvy_8s94.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976567
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    //\
    \ We need a non-overlapping slice\n    let mut iter: Option<String> = None;\n\
    \    for c in brackets.chars() {\n        if iter.is_none() && c == '<' {\n  \
    \          iter = Some(String::from(\"<\"));\n        } else if iter.is_some()\
    \ && c == '>' {\n            iter = Some(String::from(\">\"));\n        } else\
    \ {\n            iter = Some(c);\n        }\n    }\n    match iter.as_ref() {\n\
    \        Some(\"<\") => false,\n        Some(\">\") => true,\n        _ => false\n\
    \    }\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpup_egi62.rs:20:25\n   |\n\
    20 |             iter = Some(c);\n   |                         ^- help: try using\
    \ a conversion method: `.to_string()`\n   |                         |\n   |  \
    \                       expected struct `String`, found `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpup_egi62.rs:24:14\n   |\n23 |     match iter.as_ref()\
    \ {\n   |           ------------- this expression has type `Option<&String>`\n\
    24 |         Some(\"<\") => false,\n   |              ^^^ expected struct `String`,\
    \ found `str`\n   |\n   = note: expected reference `&String`\n              found\
    \ reference `&'static str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpup_egi62.rs:25:14\n\
    \   |\n23 |     match iter.as_ref() {\n   |           ------------- this expression\
    \ has type `Option<&String>`\n24 |         Some(\"<\") => false,\n25 |       \
    \  Some(\">\") => true,\n   |              ^^^ expected struct `String`, found\
    \ `str`\n   |\n   = note: expected reference `&String`\n              found reference\
    \ `&'static str`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976567
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets\n\
    \        .chars()\n        .filter(|c| !c.is_ascii_digit())\n        .all(|c|\
    \ match c {\n            '>' => true,\n            '<' => true,\n            _\
    \ => false,\n        })\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpriv_2njt.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976567
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut i = 0;\n    let mut found = false;\n    while i < brackets.len() {\n   \
    \     if brackets[i as usize] == '<' {\n            i += 1;\n            if brackets[i\
    \ as usize] == '<' {\n                i += 1;\n                while i < brackets.len()\
    \ {\n                    found = true;\n                    if brackets[i as usize]\
    \ != '>' {\n                        break;\n                    }\n          \
    \          i += 1;\n                }\n            }\n        } else {\n     \
    \       i += 1;\n            while i < brackets.len() {\n                found\
    \ = true;\n                if brackets[i as usize] != '>' {\n                \
    \    break;\n                }\n                i += 1;\n            }\n     \
    \   }\n    }\n    found\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpj34rgrc8.rs:15:12\n\
    \   |\n15 |         if brackets[i as usize] == '<' {\n   |            ^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpj34rgrc8.rs:17:16\n   |\n17 |             if brackets[i as usize]\
    \ == '<' {\n   |                ^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpj34rgrc8.rs:21:24\n   |\n21 |                     if brackets[i\
    \ as usize] != '>' {\n   |                        ^^^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String "
  stdout: ''
  timestamp: 1659976567
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut found = false;\n    let mut index = 0;\n    while !found {\n        if index\
    \ >= brackets.len() {\n            return found;\n        }\n        let c = brackets[index];\n\
    \        if c != '<' {\n            found = true;\n        } else {\n        \
    \    if index == 0 {\n                found = true;\n            } else {\n  \
    \              let mut new_index = index - 1;\n                while new_index\
    \ >= 0 {\n                    if brackets[new_index] == '>' {\n              \
    \          found = true;\n                        break;\n                   \
    \ }\n                    new_index -= 1;\n                }\n            }\n \
    \       }\n        index += 1;\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpov03dnjy.rs:18:17\n\
    \   |\n18 |         let c = brackets[index];\n   |                 ^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpov03dnjy.rs:27:24\n   |\n27 |                     if brackets[new_index]\
    \ == '>' {\n   |                        ^^^^^^^^^^^^^^^^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976567
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().rev().enumerate().any(|(_,\
    \ index)| {\n        let (ch, i) = &brackets[..index];\n        ch == '<' || ch\
    \ == '>'\n    })\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `RangeTo<char>`\n\
    \  --> /tmp/tmpf95son0j.rs:13:24\n   |\n13 |         let (ch, i) = &brackets[..index];\n\
    \   |                        ^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `RangeTo<char>`\n\
    \   |\n   = help: the trait `Index<RangeTo<char>>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: can't compare `&_` with `char`\n  --> /tmp/tmpf95son0j.rs:14:12\n\
    \   |\n14 |         ch == '<' || ch == '>'\n   |            ^^ no implementation\
    \ for `&_ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&_`\n\nerror[E0277]: can't compare `&_` with `char`\n  --> /tmp/tmpf95son0j.rs:14:25\n\
    \   |\n14 |         ch == '<' || ch == '>'\n   |                         ^^ no\
    \ implementation for `&_ == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&_`\n\nerror: aborting due to 3 previous errors\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976567
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c.is_ascii_alphanumeric())\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpn01mk_pj.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976567
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    //\
    \ This code assumes that brackets has length 1\n    if brackets.len() < 2 {\n\
    \        return false;\n    }\n\n    // This code assumes that brackets has length\
    \ 2\n    let mut opening = brackets[0];\n    let mut closing = brackets[1];\n\n\
    \    if opening != \"<\" || closing != \">\" {\n        return false;\n    }\n\
    \n    if brackets.len() == 2 {\n        return true;\n    }\n\n    // This code\
    \ assumes that brackets has length 3\n    // We compare the first two brackets\n\
    \    opening = brackets[2];\n    closing = brackets[3];\n\n    if opening != \"\
    <\" || closing != \">\" {\n        return false;\n    }\n\n    // This code assumes\
    \ that brackets has length 4\n    // We compare the second two brackets\n    opening\
    \ = brackets[4];\n    closing = brackets[5];\n\n    if opening != \">\" || closing\
    \ != \"<\" {\n        return false;\n    }\n\n    // This code assumes that brackets\
    \ has length 5\n    // We compare the last two brackets\n    opening = brackets[6];\n\
    \    closing = brackets[7];\n\n    if opening != \"<\" || closing != \">\" {\n\
    \        return false;\n    }\n\n    // This code assumes that brackets has length\
    \ 6\n    // We compare the last two brackets\n    opening = brackets[8];\n   \
    \ closing = brackets[9];\n\n    if opening != \"<\" || closing != \">\" {\n  \
    \      return false;\n    }\n\n    // This code assumes that brackets has length\
    \ 7\n    // We compare the last two brackets\n    opening = brackets[10];\n  \
    \  closing = brackets[11];\n\n    if opening != \"<\" || closing != \">\" {\n\
    \        return false;\n    }\n\n    // This code assumes that brackets has length\
    \ 8\n    // We compare the last two brackets\n    opening = brackets[12];\n  \
    \  closing = brackets[13];\n\n    if opening != \"<\" || closing != \">\" {\n\
    \        return false;\n    }\n\n    // This code assumes that brackets has length\
    \ 9\n    // We compare the last two brackets\n    opening = brackets[14];\n  \
    \  closing = brackets[15];\n\n    if opening != \"<\" || closing != \">\" {\n\
    \        return false;\n    }\n\n    // This code assumes that brackets has length\
    \ 10\n    // We compare the last two brackets\n    opening = brackets[16];\n \
    \   closing = brackets[17];\n\n    if opening != \"<\" || closing != \">\" {\n\
    \        return false;\n    }\n\n    // This code assumes that brackets has length\
    \ 11\n    // We compare the last two brackets\n    opening = brackets[18];\n \
    \   closing = brackets[19];\n\n    if opening \n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `}`\n   --> /tmp/tmppykpz4ix.rs:107:1\n    |\n\
    106 |     if opening \n    |     -- this `if` expression has a condition, but\
    \ no block\n107 | }\n    | ^ expected `{`\n\nerror[E0277]: the type `String` cannot\
    \ be indexed by `{integer}`\n  --> /tmp/tmppykpz4ix.rs:18:23\n   |\n18 |     let\
    \ mut opening = brackets[0];\n   |                       ^^^^^^^^^^^ `String`\
    \ cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmppykpz4ix.rs:19:23\n   |\n19 |     let mut closing = brackets[1];\n\
    \   |                       ^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmppykpz4ix.rs:31:15\n   |\n31 |     opening = brackets[2];\n   |\
    \               ^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n\
    \   = help: the trait `Index<{integer}>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <St"
  stdout: ''
  timestamp: 1659976567
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    if\
    \ !brackets.contains(\"<\") || !brackets.contains(\">\") {\n        return false;\n\
    \    }\n    let mut i = 0;\n    let mut last_open = String::new();\n    let mut\
    \ last_close = String::new();\n    while i < brackets.len() {\n        if brackets[i]\
    \ == '<' {\n            if brackets[i + 1] == '>' {\n                if last_open.len()\
    \ == 0 || last_close.len() == 0 {\n                    return false;\n       \
    \         }\n                if !last_open.contains(&brackets[i + 1]) {\n    \
    \                return false;\n                }\n                i += 2;\n \
    \           } else {\n                i += 1;\n            }\n        } else if\
    \ brackets[i] == '>' {\n            if last_open.len() == 0 || last_close.len()\
    \ == 0 {\n                return false;\n            }\n            if !last_close.contains(&brackets[i])\
    \ {\n                return false;\n            }\n            i += 1;\n     \
    \   } else {\n            if last_open.len() != 0 && last_close.len() != 0 {\n\
    \                return false;\n            }\n            last_open = String::new();\n\
    \            last_close = String::new();\n            i += 1;\n        }\n   \
    \ }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n   \
    \ assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmppoylbmoy.rs:19:12\n\
    \   |\n19 |         if brackets[i] == '<' {\n   |            ^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmppoylbmoy.rs:20:16\n   |\n20 |             if brackets[i + 1] ==\
    \ '>' {\n   |                ^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmppoylbmoy.rs:24:41\n   |\n24 |                 if !last_open.contains(&brackets[i\
    \ + 1]) {\n   |                                         ^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<s"
  stdout: ''
  timestamp: 1659976567
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = vec![];\n    for ch in brackets.chars() {\n        if ch != '>'\
    \ && ch != '<' && ch != '{' && ch != '}' && ch != ' ' {\n            return false;\n\
    \        }\n        if ch == '<' || ch == '>' {\n            if stack.len() <\
    \ 2 {\n                return false;\n            }\n            let curr = stack.pop().unwrap();\n\
    \            if ch != curr {\n                return false;\n            }\n \
    \           stack.push(ch);\n        } else {\n            stack.push(ch);\n \
    \       }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpy34tsxgx.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976567
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().filter(|&b|\
    \ b == '>' || b == '<').count() == brackets.len()\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpzout78zn.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976567
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut in_bracket = false;\n    for s in brackets.chars() {\n        if s == '<'\
    \ {\n            if in_bracket {\n                assert!(in_bracket);\n     \
    \           continue;\n            }\n            in_bracket = true;\n       \
    \ }\n        if s == '>' {\n            if !in_bracket {\n                assert!(!in_bracket);\n\
    \                continue;\n            }\n            in_bracket = false;\n \
    \       }\n        assert!(in_bracket);\n    }\n    true\n}\n\nfn main() {\n \
    \   let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''assertion failed: in_bracket'', /tmp/tmpqt5ugwyo.rs:28:9

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976567
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut found_match = false;\n    for bracketed_char in brackets.chars().filter(|&b|\
    \ b != '>') {\n        let mut found_end = false;\n        for b in 0..=chars::LENGTH\
    \ {\n            if chars::BYTES[b] <= bracketed_char {\n                if found_end\
    \ {\n                    return found_match;\n                }\n            \
    \    found_end = true;\n            } else if chars::BYTES[b] > bracketed_char\
    \ {\n                if !found_end {\n                    found_end = true;\n\
    \                }\n            }\n        }\n        found_match = true;\n  \
    \  }\n    found_match\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `chars`\n\
    \  --> /tmp/tmpr1ok_lqz.rs:15:22\n   |\n15 |         for b in 0..=chars::LENGTH\
    \ {\n   |                      ^^^^^ use of undeclared crate or module `chars`\n\
    \nerror[E0433]: failed to resolve: use of undeclared crate or module `chars`\n\
    \  --> /tmp/tmpr1ok_lqz.rs:16:16\n   |\n16 |             if chars::BYTES[b] <=\
    \ bracketed_char {\n   |                ^^^^^ use of undeclared crate or module\
    \ `chars`\n\nerror[E0433]: failed to resolve: use of undeclared crate or module\
    \ `chars`\n  --> /tmp/tmpr1ok_lqz.rs:21:23\n   |\n21 |             } else if chars::BYTES[b]\
    \ > bracketed_char {\n   |                       ^^^^^ use of undeclared crate\
    \ or module `chars`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976567
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().any(|c|\
    \ c == '<')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpc9p8i4n4.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976567
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<_> = brackets.split_whitespace().collect();\n    let mut stack_string\
    \ = String::new();\n\n    for i in stack.iter() {\n        if i.len() < 2 {\n\
    \            return false;\n        }\n\n        if i.len() == 2 {\n         \
    \   if stack_string.len() > 1 {\n                return false;\n            }\n\
    \n            stack_string += &*i;\n        } else {\n            stack_string\
    \ += &*i.to_string();\n            stack_string += &*std::char::from(\"<<\");\n\
    \            stack_string += &*std::char::from(\">>\");\n            stack_string\
    \ += &*i;\n        }\n    }\n\n    stack_string == brackets\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `from` in module `std::char`\n  -->\
    \ /tmp/tmpj77a23_7.rs:28:42\n   |\n28 |             stack_string += &*std::char::from(\"\
    <<\");\n   |                                          ^^^^ not found in `std::char`\n\
    \nerror[E0425]: cannot find function `from` in module `std::char`\n  --> /tmp/tmpj77a23_7.rs:29:42\n\
    \   |\n29 |             stack_string += &*std::char::from(\">>\");\n   |     \
    \                                     ^^^^ not found in `std::char`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976567
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = brackets.chars().skip_while(|c| c != '<').count();\n   \
    \ let mut close_brackets = brackets.chars().skip_while(|c| c != '>').count();\n\
    \n    if open_brackets != close_brackets {\n        return false;\n    }\n\n \
    \   let mut last_open_bracket = 0;\n    let mut last_close_bracket = 0;\n\n  \
    \  for open_bracket in &brackets {\n        if open_bracket == '>' {\n       \
    \     last_close_bracket += 1;\n        } else if open_bracket == '<' {\n    \
    \        last_open_bracket += 1;\n        } else {\n            last_open_bracket\
    \ += 1;\n            last_close_bracket += 1;\n        }\n\n        if last_open_bracket\
    \ != last_close_bracket {\n            return false;\n        }\n    }\n\n   \
    \ true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp2xsj2tvs.rs:12:63\n\
    \   |\n12 |     let mut open_brackets = brackets.chars().skip_while(|c| c != '<').count();\n\
    \   |                                                               ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp2xsj2tvs.rs:13:64\n\
    \   |\n13 |     let mut close_brackets = brackets.chars().skip_while(|c| c !=\
    \ '>').count();\n   |                                                        \
    \        ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: `&String` is not an iterator\n  -->\
    \ /tmp/tmp2xsj2tvs.rs:22:25\n   |\n22 |     for open_bracket in &brackets {\n\
    \   |                         ^^^^^^^^^ `&String` is not an iterator\n   |\n \
    \  = help: the trait `Iterator` is not implemented for `&String`\n   = note: required\
    \ because of the requirements on the impl of `IntoIterator` for `&String`\n\n\
    error: aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976567
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut i = 0;\n    let mut brackets: Vec<_> = brackets\n        .chars()\n    \
    \    .filter(|c| *c != '<')\n        .take_while(|c| *c != '>')\n        .collect();\n\
    \    let mut brackets = brackets.into_iter();\n    while brackets.next().unwrap()\
    \ != Some(0) {\n        if brackets.next() == Some(0) {\n            i += 1;\n\
    \        }\n        else {\n            return false;\n        }\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpx6yi9j5z.rs:19:39\n   |\n\
    19 |     while brackets.next().unwrap() != Some(0) {\n   |                   \
    \                    ^^^^^^^ expected `char`, found enum `Option`\n   |\n   =\
    \ note: expected type `char`\n              found enum `Option<{integer}>`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpx6yi9j5z.rs:20:36\n   |\n20 |  \
    \       if brackets.next() == Some(0) {\n   |                                \
    \    ^ expected `char`, found `u8`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976567
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut in_bracket = false;\n    let mut cur_char = String::from(brackets.chars().next().unwrap());\n\
    \    for c in &brackets {\n        if cur_char == c {\n            in_bracket\
    \ = true;\n        } else if in_bracket && c == \">\" {\n            in_bracket\
    \ = false;\n        }\n        cur_char = c\n    }\n    in_bracket\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n  --> /tmp/tmp0yai4t61.rs:14:14\n\
    \   |\n14 |     for c in &brackets {\n   |              ^^^^^^^^^ `&String` is\
    \ not an iterator\n   |\n   = help: the trait `Iterator` is not implemented for\
    \ `&String`\n   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976567
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == '>' || c == '<')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmps0zkq828.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Stack::new();\n    for c in &brackets {\n        if c == '<' {\n\
    \            stack.push(c);\n        } else if c == '>' {\n            if stack.len()\
    \ > 0 {\n                stack.pop();\n            } else {\n                return\
    \ false;\n            }\n        } else {\n            if stack.len() > 0 {\n\
    \                stack.pop();\n            } else {\n                return false;\n\
    \            }\n        }\n    }\n\n    stack.is_empty()\n}\n\nfn main() {\n \
    \   let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Stack`\n  -->\
    \ /tmp/tmpawkf__19.rs:12:21\n   |\n12 |     let mut stack = Stack::new();\n  \
    \ |                     ^^^^^ use of undeclared type `Stack`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n  --> /tmp/tmpawkf__19.rs:13:14\n   |\n13 |  \
    \   for c in &brackets {\n   |              ^^^^^^^^^ `&String` is not an iterator\n\
    \   |\n   = help: the trait `Iterator` is not implemented for `&String`\n   =\
    \ note: required because of the requirements on the impl of `IntoIterator` for\
    \ `&String`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0433.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976567
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == '<' || c == '>')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmps928504y.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976566
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \n    for bracket in brackets.chars().collect::<String>() {\n        if bracket\
    \ == '<' {\n            open_brackets += \"</>\".to_string();\n            closed_brackets\
    \ += \"</>\".to_string();\n        } else if bracket == '>' {\n            open_brackets\
    \ += \"</\".to_string();\n            closed_brackets += \"</\".to_string();\n\
    \        } else if bracket == '&' {\n            open_brackets += \"</&\".to_string();\n\
    \            closed_brackets += \"</&\".to_string();\n        } else if bracket\
    \ == '|' {\n            open_brackets += \"</|\".to_string();\n            closed_brackets\
    \ += \"</|\".to_string();\n        } else {\n            open_brackets += bracket.to_string();\n\
    \            closed_brackets += bracket.to_string();\n        }\n    }\n\n   \
    \ open_brackets == closed_brackets\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpb51m7nqv.rs:15:20\n\
    \   |\n15 |     for bracket in brackets.chars().collect::<String>() {\n   |  \
    \                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` is not an iterator;\
    \ try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator`\
    \ is not implemented for `String`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpb51m7nqv.rs:17:30\n   |\n17 |             open_brackets += \"</>\"\
    .to_string();\n   |                              ^^^^^^^^^^^^^^^^^\n   |     \
    \                         |\n   |                              expected `&str`,\
    \ found struct `String`\n   |                              help: consider borrowing\
    \ here: `&\"</>\".to_string()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb51m7nqv.rs:18:32\n\
    \   |\n18 |             closed_brackets += \"</>\".to_string();\n   |        \
    \                        ^^^^^^^^^^^^^^^^^\n   |                             \
    \   |\n   |                                expected `&str`, found struct `String`\n\
    \   |                                help: consider borrowing here: `&\"</>\"\
    .to_string()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb51m7nqv.rs:20:30\n\
    \   |\n20 |             open_brackets += \"</\".to_string();\n   |           \
    \                   ^^^^^^^^^^^^^^^^\n   |                              |\n  \
    \ |                              expected `&str`, found struct `String`\n   |\
    \                              help: consider borrowing here: `&\"</\".to_string()`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpb51m7nqv.rs:21:32\n   |\n21 |\
    \             closed_brackets += \"</\".to_string();\n   |                   \
    \             ^^^^^^^^^^^^^^^^\n   |                                |\n   |  \
    \                              expected `&str`, found struct `String`\n   |  \
    \                              help: consider borrowing here: `&\"</\".to_string()`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpb51m7nqv.rs:23:30\n   |\n23 |\
    \             open_brackets += \"</&\".to_string();\n   |   "
  stdout: ''
  timestamp: 1659976567
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.chars();\n    let mut current = false;\n    while !brackets.next().is_some()\
    \ {\n        if current {\n            current = false;\n        } else {\n  \
    \          current = brackets.next().unwrap() == '<';\n        }\n    }\n\n  \
    \  while !brackets.next().is_some() {\n        if !current {\n            current\
    \ = false;\n        } else {\n            current = brackets.next().unwrap() ==\
    \ '<';\n        }\n    }\n\n    current == false\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4p8x9zzf.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976567
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == ']' || c == '<')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpxk4_z12m.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976567
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets\n\
    \        .chars()\n        .filter(|c| !c.is_ascii_letter())\n        .all(|c|\
    \ brackets.chars().any(|c2| c2 != c))\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpt8y0lifp.rs:14:24\n   |\n14 |         .filter(|c|\
    \ !c.is_ascii_letter())\n   |                        ^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `is_ascii`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976567
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets\n\
    \        .split_ascii_whitespace()\n        .map(|s| s.chars())\n        .fold(false,\
    \ |a, s| a || s.is_empty())\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_empty` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmp8a00elt2.rs:15:36\n   |\n15 |         .fold(false,\
    \ |a, s| a || s.is_empty())\n   |                                    ^^^^^^^^\
    \ method not found in `Chars<'_>`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976567
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<Vec<char>> = vec![vec!['<']; brackets.len()];\n    let mut bracket_stack:\
    \ Vec<bool> = vec![false; brackets.len()];\n    \n    stack.push(vec!['<']);\n\
    \    bracket_stack.push(true);\n    \n    while stack.len() > 0 {\n        \n\
    \        if bracket_stack.last().unwrap() {\n            \n            if stack.last().unwrap().len()\
    \ == 1 {\n                stack.pop();\n                bracket_stack.pop();\n\
    \            } else {\n                stack.last().unwrap().pop();\n        \
    \    }\n        } else {\n            \n            if stack.last().unwrap().len()\
    \ == 0 {\n                bracket_stack.pop();\n                stack.pop();\n\
    \            } else {\n                stack.last().unwrap().pop();\n        \
    \    }\n        }\n    }\n    \n    bracket_stack.last().unwrap()\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgd0axvuy.rs:20:12\n   |\n\
    20 |         if bracket_stack.last().unwrap() {\n   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `bool`, found `&bool`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n20 |         if *bracket_stack.last().unwrap() {\n   |            +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpgd0axvuy.rs:39:5\n   |\n11 | fn\
    \ correct_bracketing(brackets: String) -> bool {\n   |                       \
    \                     ---- expected `bool` because of return type\n...\n39 | \
    \    bracket_stack.last().unwrap()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `bool`, found `&bool`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    39 |     *bracket_stack.last().unwrap()\n   |     +\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976567
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = 0;\n    let mut closed_brackets = 0;\n\n    for c in brackets\
    \ {\n        if c == '<' {\n            open_brackets += 1;\n        } else {\n\
    \            closed_brackets += 1;\n        }\n    }\n    open_brackets == closed_brackets\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp9kih4yi6.rs:15:14\n\
    \   |\n15 |     for c in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976567
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = 0;\n    let mut closed_brackets = 0;\n    let mut open_brackets_idx\
    \ = 0;\n    for &c in &brackets {\n        if c == '<' {\n            if open_brackets\
    \ < closed_brackets {\n                return false;\n            }\n        \
    \    open_brackets++;\n        } else if c == '>' {\n            if open_brackets\
    \ > closed_brackets {\n                return false;\n            }\n        \
    \    closed_brackets++;\n        } else {\n            closed_brackets = 0;\n\
    \            open_brackets = 0;\n        }\n    }\n    closed_brackets > open_brackets\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpfw5nc1oc.rs:20:26\n\
    \   |\n20 |             open_brackets++;\n   |                          ^^ not\
    \ a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n20 |       \
    \      { let tmp = open_brackets; open_brackets += 1; tmp };\n   |           \
    \  +++++++++++              ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n20 -             open_brackets++;\n\
    20 +             open_brackets += 1;\n   | \n\nerror: Rust has no postfix increment\
    \ operator\n  --> /tmp/tmpfw5nc1oc.rs:25:28\n   |\n25 |             closed_brackets++;\n\
    \   |                            ^^ not a valid postfix operator\n   |\nhelp:\
    \ use `+= 1` instead\n   |\n25 |             { let tmp = closed_brackets; closed_brackets\
    \ += 1; tmp };\n   |             +++++++++++                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    25 -             closed_brackets++;\n25 +             closed_brackets += 1;\n\
    \   | \n\nerror[E0277]: `&String` is not an iterator\n  --> /tmp/tmpfw5nc1oc.rs:15:15\n\
    \   |\n15 |     for &c in &brackets {\n   |               ^^^^^^^^^ `&String`\
    \ is not an iterator\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `&String`\n   = note: required because of the requirements on the impl of\
    \ `IntoIterator` for `&String`\n\nerror: aborting due to 3 previous errors\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976567
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ *c == \">\")\n        && !brackets.chars().any(|c| *c != \">\" && c != \"<\"\
    )\n        && brackets.chars().all(|c| *c != \"<\" && c != \">\")\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpwscvo88s.rs:12:30\n\
    \   |\n12 |     brackets.chars().all(|c| *c == \">\")\n   |                  \
    \            ^^\n\nerror[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpwscvo88s.rs:13:38\n\
    \   |\n13 |         && !brackets.chars().any(|c| *c != \">\" && c != \"<\")\n\
    \   |                                      ^^\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpwscvo88s.rs:13:56\n   |\n13 |         && !brackets.chars().any(|c|\
    \ *c != \">\" && c != \"<\")\n   |                                           \
    \             ^^^ expected `char`, found `&str`\n   |\nhelp: if you meant to write\
    \ a `char` literal, use single quotes\n   |\n13 |         && !brackets.chars().any(|c|\
    \ *c != \">\" && c != '<')\n   |                                             \
    \           ~~~\n\nerror[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpwscvo88s.rs:14:37\n\
    \   |\n14 |         && brackets.chars().all(|c| *c != \"<\" && c != \">\")\n \
    \  |                                     ^^\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpwscvo88s.rs:14:55\n   |\n14 |         && brackets.chars().all(|c|\
    \ *c != \"<\" && c != \">\")\n   |                                           \
    \            ^^^ expected `char`, found `&str`\n   |\nhelp: if you meant to write\
    \ a `char` literal, use single quotes\n   |\n14 |         && brackets.chars().all(|c|\
    \ *c != \"<\" && c != '>')\n   |                                             \
    \          ~~~\n\nerror: aborting due to 5 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0614.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976567
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut current = String::from(brackets);\n    let mut current_pos = 0;\n    while\
    \ current_pos < current.len() {\n        if let Some(next_pos) = current.char_indices()\n\
    \            .find(|&(_, pos)| pos > current_pos)\n            .map(|(_, pos)|\
    \ pos)\n        {\n            current.insert(current_pos, next_pos);\n      \
    \      current_pos = next_pos + 1;\n        } else {\n            break;\n   \
    \     }\n    }\n\n    current.chars().all(|c| c.is_whitespace())\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzdcdn9dx.rs:16:37\n   |\n\
    16 |             .find(|&(_, pos)| pos > current_pos)\n   |                  \
    \                   ^^^^^^^^^^^ expected `char`, found `usize`\n\nerror[E0369]:\
    \ cannot add `{integer}` to `char`\n  --> /tmp/tmpzdcdn9dx.rs:20:36\n   |\n20\
    \ |             current_pos = next_pos + 1;\n   |                           --------\
    \ ^ - {integer}\n   |                           |\n   |                      \
    \     char\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976567
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut opening_brackets = String::new();\n    let mut closing_brackets = String::new();\n\
    \    for (i, c) in brackets.chars().enumerate() {\n        if c == '<' {\n   \
    \         opening_brackets.push_str(&*i.to_string());\n        } else if c ==\
    \ '>' {\n            closing_brackets.push_str(&*i.to_string());\n        }\n\
    \    }\n    // If there are any unclosed brackets, they should end up in the opposite\
    \ order.\n    if opening_brackets.is_empty() && closing_brackets.is_empty() {\n\
    \        return true;\n    }\n    let mut opening_brackets = opening_brackets.chars().collect::<Vec<char>>();\n\
    \    let mut closing_brackets = closing_brackets.chars().collect::<Vec<char>>();\n\
    \    if opening_brackets.len() == closing_brackets.len() {\n        for i in 0..opening_brackets.len()\
    \ {\n            if opening_brackets[i] != '<' {\n                return false;\n\
    \            }\n            if closing_brackets[i] != '>' {\n                return\
    \ false;\n            }\n        }\n        return true;\n    }\n    for i in\
    \ 0..opening_brackets.len() {\n        if opening_brackets[i] != '<' {\n     \
    \       return false;\n        }\n        if closing_brackets[i] == '>' {\n  \
    \          return false;\n        }\n    }\n    for i in 0..closing_brackets.len()\
    \ {\n        if closing_brackets[i] != '<' {\n            return false;\n    \
    \    }\n        if opening_brackets[i] == '>' {\n            return false;\n \
    \       }\n    }\n    return opening_brackets == closing_brackets;\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpml5u_fan.rs:59:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976567
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets;\n    let mut open = 0;\n    let mut last = 0;\n\n \
    \   // Find the first bracket\n    while bracket_match(brackets, &mut open, &mut\
    \ last, &mut last, &mut last)) {\n        last = 0;\n    }\n\n    bracket_match(brackets,\
    \ &mut open, &mut last, &mut last, &mut last)\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: unexpected closing delimiter: `}`\n  --> /tmp/tmp7l0fk16o.rs:22:1\n\
    \   |\n17 |     while bracket_match(brackets, &mut open, &mut last, &mut last,\
    \ &mut last)) {\n   |                                                        \
    \                        - this opening brace...\n18 |         last = 0;\n19 |\
    \     }\n   |     - ...matches this closing brace\n...\n22 | }\n   | ^ unexpected\
    \ closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmp7l0fk16o.rs:11:49\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |          \
    \                                       ^ unclosed delimiter\n...\n17 |     while\
    \ bracket_match(brackets, &mut open, &mut last, &mut last, &mut last)) {\n   |\
    \                                                                            \
    \  ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\
    \n"
  stdout: ''
  timestamp: 1659976567
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = String::new();\n    let mut opening_brackets = String::new();\n\
    \    loop {\n        if let Some(item) = brackets.next() {\n            match\
    \ item {\n                None => break,\n                Some('>') => stack.push_str(&opening_brackets),\n\
    \                Some('<') => {\n                    if opening_brackets.len()\
    \ == 0 {\n                        return false;\n                    }\n     \
    \               stack.push_str(&opening_brackets);\n                }\n      \
    \          Some(other) => stack.push_str(&other),\n            }\n        } else\
    \ {\n            if stack.len() == 0 {\n                return false;\n      \
    \      }\n            if stack.len() < 2 {\n                return false;\n  \
    \          }\n            if stack.len() > 2 {\n                return false;\n\
    \            }\n            if stack.len() > 1 {\n                let bracket\
    \ = stack.pop().unwrap();\n                if stack.len() < 2 {\n            \
    \        return false;\n                }\n                if stack.len() > 2\
    \ {\n                    return false;\n                }\n                if\
    \ stack.len() > 1 {\n                    let closing_bracket = stack.pop().unwrap();\n\
    \                    if stack.len() != 2 {\n                        return false;\n\
    \                    }\n                    stack.push(bracket);\n           \
    \         stack.push(closing_bracket);\n                } else {\n           \
    \         stack.push(bracket);\n                }\n            }\n        }\n\
    \    }\n    stack.len() == 1\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `next` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpfmd7_tjh.rs:15:38\n   |\n15 |         if let Some(item)\
    \ = brackets.next() {\n   |                                      ^^^^ method not\
    \ found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfmd7_tjh.rs:25:47\n\
    \   |\n25 |                 Some(other) => stack.push_str(&other),\n   |     \
    \                                          ^^^^^^ expected `str`, found `char`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976567
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut count = 0;\n    for ch in brackets {\n        if ch == '<' {\n         \
    \   count += 1;\n        } else if ch == '>' {\n            count -= 1;\n    \
    \    }\n    }\n    count > 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp935lgpow.rs:13:15\n\
    \   |\n13 |     for ch in brackets {\n   |               ^^^^^^^^ `String` is\
    \ not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976567
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    while let Some(open) = brackets.find('<')\
    \ {\n        if let Some(close) = brackets.find('>') {\n            if bracket_depth(open,\
    \ close) == 2 {\n                brackets.truncate(open);\n            }\n   \
    \     }\n    }\n    brackets.chars().all(|c| !bracket_depth(c, '>'))\n}\n\nfn\
    \ main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `bracket_depth` in this scope\n  -->\
    \ /tmp/tmp2zr6u33i.rs:15:16\n   |\n15 |             if bracket_depth(open, close)\
    \ == 2 {\n   |                ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `bracket_depth` in this scope\n  --> /tmp/tmp2zr6u33i.rs:20:31\n\
    \   |\n20 |     brackets.chars().all(|c| !bracket_depth(c, '>'))\n   |       \
    \                        ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976567
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut iter = brackets.char_indices();\n    for (a, b) in iter.next() {\n     \
    \   if b - a == 1 {\n            iter.next()\n                .or_insert(String::new())\n\
    \                .cloned()\n                .chars()\n                .filter(|x|\
    \ *x == a)\n                .all(|x| *x == b)\n        } else {\n            false\n\
    \        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot subtract `usize` from `char`\n  --> /tmp/tmp33f597xe.rs:14:14\n\
    \   |\n14 |         if b - a == 1 {\n   |            - ^ - usize\n   |       \
    \     |\n   |            char\n\nerror[E0599]: no method named `or_insert` found\
    \ for enum `Option` in the current scope\n  --> /tmp/tmp33f597xe.rs:16:18\n  \
    \ |\n16 |                 .or_insert(String::new())\n   |                  ^^^^^^^^^\
    \ help: there is an associated function with a similar name: `get_or_insert`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp33f597xe.rs:22:13\n   |\n14 |\
    \ /         if b - a == 1 {\n15 | |             iter.next()\n16 | |          \
    \       .or_insert(String::new())\n17 | |                 .cloned()\n...  |\n\
    22 | |             false\n   | |             ^^^^^ expected `()`, found `bool`\n\
    23 | |         }\n   | |_________- expected this to be `()`\n   |\nhelp: you might\
    \ have meant to return this value\n   |\n22 |             return false;\n   |\
    \             ++++++      +\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976567
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    let mut last_opening = false;\n  \
    \  for ch in brackets.chars() {\n        if ch == ')' {\n            if last_opening\
    \ {\n                last_opening = false;\n            } else {\n           \
    \     last_opening = true;\n            }\n        } else if ch == '<' {\n   \
    \         last_opening = false;\n        }\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp7a_5u5jn.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976567
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut current_opening = false;\n    let mut current_closing = false;\n\n    for\
    \ ch in &brackets {\n        match ch {\n            ' ' => (),\n            '>'\
    \ => current_opening = !current_opening,\n            '<' => current_closing =\
    \ !current_closing,\n            _ => (),\n        }\n    }\n\n    current_opening\
    \ && current_closing\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n  --> /tmp/tmpxo1v__4u.rs:15:15\n\
    \   |\n15 |     for ch in &brackets {\n   |               ^^^^^^^^^ `&String`\
    \ is not an iterator\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `&String`\n   = note: required because of the requirements on the impl of\
    \ `IntoIterator` for `&String`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976567
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut count = 0;\n    for c in brackets {\n        match c {\n            ' '\
    \ | '\\t' | '\\r' | '\\n' | ';' => {\n                count += 1;\n          \
    \  }\n            c => {\n                count -= 1;\n                if count\
    \ < 0 {\n                    return false;\n                }\n            }\n\
    \        }\n    }\n    count > 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpu89yip8p.rs:13:14\n\
    \   |\n13 |     for c in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976567
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    //\
    \ Look at every opening bracket\n    let mut current_open = String::new();\n \
    \   let mut current_close = String::new();\n    for i in 1..brackets.len() {\n\
    \        let c = brackets[i - 1];\n        if c == '<' {\n            current_open.push_str(&c);\n\
    \        } else if c == '>' {\n            current_close.push_str(&c);\n     \
    \   } else {\n            // Do nothing\n        }\n    }\n\n    // If there's\
    \ something open, we must close it\n    if current_open.is_empty() {\n       \
    \ return true;\n    }\n\n    // If there's nothing closed, we can't have something\
    \ open\n    if current_close.is_empty() {\n        return false;\n    }\n\n  \
    \  // Check every closing bracket\n    for j in 0..current_close.len() {\n   \
    \     if !current_open.contains(&current_close[j]) {\n            return false;\n\
    \        }\n    }\n\n    // If we made it here, we have brackets correctly nested.\n\
    \    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpp70nb2e4.rs:16:17\n\
    \   |\n16 |         let c = brackets[i - 1];\n   |                 ^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the size for values of type `str` cannot be known\
    \ at compilation time\n  --> /tmp/tmpp70nb2e4.rs:16:13\n   |\n16 |         let\
    \ c = brackets[i - 1];\n   |             ^ doesn't have a size known at compile-time\n\
    \   |\n   = help: the trait `Sized` is not implemented for `str`\n   = note: all\
    \ local variables must have a statically known size\n   = help: unsized locals\
    \ are gated as an unstable feature\nhelp: consider borrowing here\n   |\n16 |\
    \         let c = &brackets[i - 1];\n   |                 +\n\nerror[E0277]: can't\
    \ compare `str` with `char`\n  --> /tmp/tmpp70nb2e4.rs:17:14\n   |\n17 |     \
    \    if c == '<' {\n   |              ^^ no implementation for `str == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `str`\n \
    \  = help: the following other types implement trait `PartialEq<Rhs>`:\n     \
    \        <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `str` with `char`\n  --> /tmp/tmpp70nb2e4.rs:19:21\n   |\n19 |         } else\
    \ if c == '>' {\n   |                     ^^ no implementation for "
  stdout: ''
  timestamp: 1659976567
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(r\
    \ => r == '>' || r == '<')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator,\
    \ found `=>`\n  --> /tmp/tmp2nmykjed.rs:12:28\n   |\n12 |     brackets.chars().all(r\
    \ => r == '>' || r == '<')\n   |                            ^^ expected one of\
    \ 8 possible tokens\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659976567
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.iter().all(|c|\
    \ !brackets.contains(c))\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpilybg80_.rs:12:14\n   |\n12 |     brackets.iter().all(|c|\
    \ !brackets.contains(c))\n   |              ^^^^ method not found in `String`\n\
    \   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator`\
    \ over each of its codepoint use method `chars`\n   |\n12 |     brackets.chars().all(|c|\
    \ !brackets.contains(c))\n   |              ~~~~~\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976567
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    for c in brackets {\n        if c == '<' {\n  \
    \          stack.push(c);\n        } else if c == '>' {\n            stack.pop();\n\
    \        }\n    }\n    stack.len() == 0 && false\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpxlkn91zt.rs:13:14\n\
    \   |\n13 |     for c in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976567
