language: rs
name: HumanEval_120_maximum
results:
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr: Vec<isize> = vec![];\n    for\
    \ i in 0..k {\n        if i < arr.len() {\n            max_arr.push(arr[i]);\n\
    \        }\n    }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyyun3t2m.rs:19:16\n   |\n\
    19 |         if i < arr.len() {\n   |                ^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n19 |         if i < arr.len().try_into().unwrap()\
    \ {\n   |                         ++++++++++++++++++++\n\nerror[E0277]: the type\
    \ `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpyyun3t2m.rs:20:26\n  \
    \ |\n20 |             max_arr.push(arr[i]);\n   |                          ^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    arr.sort_by(|a, b| b.partial_cmp(a))\n      \
    \  .take_while(|&a| a > k)\n        .collect()\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqvdzimnf.rs:17:24\n   |\n\
    17 |     arr.sort_by(|a, b| b.partial_cmp(a))\n   |                        ^^^^^^^^^^^^^^^^\
    \ expected enum `std::cmp::Ordering`, found enum `Option`\n   |\n   = note: expected\
    \ enum `std::cmp::Ordering`\n              found enum `Option<std::cmp::Ordering>`\n\
    \nerror[E0599]: `()` is not an iterator\n  --> /tmp/tmpqvdzimnf.rs:18:10\n   |\n\
    18 |         .take_while(|&a| a > k)\n   |          ^^^^^^^^^^ `()` is not an\
    \ iterator\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `(): Iterator`\n           which is required by `&mut (): Iterator`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max = i32::MAX;\n    let mut ret: Vec<isize>\
    \ = vec![];\n    for i in arr {\n        if i > max {\n            max = i;\n\
    \        }\n        if ret.len() >= k {\n            break;\n        }\n     \
    \   ret.push(i);\n    }\n    ret\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf3dsesea.rs:20:16\n   |\n\
    20 |         if i > max {\n   |                ^^^ expected `isize`, found `i32`\n\
    \   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |         if i > max.try_into().unwrap() {\n   |\
    \                   ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpf3dsesea.rs:21:19\n   |\n17 |     let mut max = i32::MAX;\n   |\
    \                   -------- expected due to this value\n...\n21 |           \
    \  max = i;\n   |                   ^ expected `i32`, found `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpf3dsesea.rs:23:25\n   |\n23 |         if ret.len()\
    \ >= k {\n   |                         ^ expected `usize`, found `isize`\n   |\n\
    help: you can convert an `isize` to a `usize` and panic if the converted value\
    \ doesn't fit\n   |\n23 |         if ret.len() >= k.try_into().unwrap() {\n  \
    \ |                          ++++++++++++++++++++\n\nerror: aborting due to 3\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 {\n        return arr;\n    }\n   \
    \ let len = arr.len();\n    if len == 0 {\n        return vec![];\n    }\n   \
    \ let mut maxs = vec![];\n    for i in 0..k {\n        if arr[i] > maxs.last()\
    \ {\n            maxs.push(arr[i]);\n        } else {\n            assert!(arr[i]\
    \ < maxs.last());\n        }\n    }\n    maxs\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp_tzw6hus.rs:26:12\n\
    \   |\n26 |         if arr[i] > maxs.last() {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp_tzw6hus.rs:27:23\n   |\n27 |            \
    \ maxs.push(arr[i]);\n   |                       ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp_tzw6hus.rs:29:21\n   |\n29 |            \
    \ assert!(arr[i] < maxs.last());\n   |                     ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if arr.len() > k {\n        arr\n    } else {\n\
    \        arr.iter().take(k).collect()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptv3ipn_p.rs:17:20\n   |\n\
    17 |     if arr.len() > k {\n   |                    ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if arr.len() > k.try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmptv3ipn_p.rs:20:25\n   |\n20 |         arr.iter().take(k).collect()\n\
    \   |                         ^ expected `usize`, found `isize`\n   |\nhelp: you\
    \ can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n20 |         arr.iter().take(k.try_into().unwrap()).collect()\n \
    \  |                          ++++++++++++++++++++\n\nerror[E0277]: a value of\
    \ type `Vec<isize>` cannot be built from an iterator over elements of type `&isize`\n\
    \    --> /tmp/tmptv3ipn_p.rs:20:28\n     |\n20   |         arr.iter().take(k).collect()\n\
    \     |                            ^^^^^^^ value of type `Vec<isize>` cannot be\
    \ built from `std::iter::Iterator<Item=&isize>`\n     |\n     = help: the trait\
    \ `FromIterator<&isize>` is not implemented for `Vec<isize>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 || arr.is_empty() {\n        return\
    \ arr;\n    }\n    let mut result = vec![arr.first().unwrap() as isize; k];\n\
    \    let mut maximum_idx = vec![];\n    let mut maximum = arr.first().unwrap()\
    \ as isize;\n    for v in arr.iter().skip(1) {\n        let m = maximum - v;\n\
    \        if m > maximum_idx.len() {\n            maximum_idx = vec![];\n     \
    \   }\n        maximum_idx.push((m));\n        if m > maximum { maximum = m }\n\
    \    }\n    if maximum_idx.len() > 0 {\n        maximum_idx = maximum_idx.reverse();\n\
    \        result.par_iter_mut().enumerate().for_each(|(i, v)| {\n            if\
    \ v == maximum_idx {\n                result[i] = maximum;\n            }\n  \
    \      });\n    } else {\n        result.par_iter_mut().enumerate().for_each(|(i,\
    \ v)| {\n            result[i] = v;\n        });\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around method argument\n  --> /tmp/tmp4tva18if.rs:28:26\n\
    \   |\n28 |         maximum_idx.push((m));\n   |                          ^ ^\n\
    \   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n\
    \   |\n28 -         maximum_idx.push((m));\n28 +         maximum_idx.push(m);\n\
    \   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4tva18if.rs:20:58\n  \
    \ |\n20 |     let mut result = vec![arr.first().unwrap() as isize; k];\n   | \
    \                                                         ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n20 |     let mut result = vec![arr.first().unwrap()\
    \ as isize; k.try_into().unwrap()];\n   |                                    \
    \                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp4tva18if.rs:25:16\n   |\n25 |         if m > maximum_idx.len()\
    \ {\n   |                ^^^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n \
    \  |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n25 |         if m > maximum_idx.len().try_into().unwrap()\
    \ {\n   |                                 ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp4tva18if.rs:32:23\n   |\n21 |     let mut maximum_idx\
    \ = vec![];\n   |                           ------ expected due to this value\n\
    ...\n32 |         maximum_idx = maximum_idx.reverse();\n   |                 \
    \      ^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror[E0599]:\
    \ no method named `par_iter_mut` found for struct `Vec<isize>` in the current\
    \ scope\n  --> /tmp/tmp4tva18if.rs:33:16\n   |\n33 |         result.par_iter_mut().enumerate().for_each(|(i,\
    \ v)| {\n   |                ^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `iter_mut`\n\nerror[E0599]: no method named `par_iter_mut`\
    \ found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmp4tva18if.rs:39:1"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let len = arr.len();\n    let mut max_nums =\
    \ arr;\n\n    for i in 0..k {\n        max_nums = max_nums.iter().max_by(|&x,\
    \ &y| x.cmp(y)).collect();\n    }\n\n    for i in 0..len {\n        max_nums[i].unwrap()\n\
    \    }\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: `Option<&isize>` is not an iterator\n   --> /tmp/tmpva291s3b.rs:21:62\n\
    \    |\n21  |           max_nums = max_nums.iter().max_by(|&x, &y| x.cmp(y)).collect();\n\
    \    |                                                                ^^^^^^^\
    \ `Option<&isize>` is not an iterator\n    |\n    = note: the following trait\
    \ bounds were not satisfied:\n            `Option<&isize>: Iterator`\n       \
    \     which is required by `&mut Option<&isize>: Iterator`\n\nerror[E0599]: no\
    \ method named `unwrap` found for type `isize` in the current scope\n  --> /tmp/tmpva291s3b.rs:25:21\n\
    \   |\n25 |         max_nums[i].unwrap()\n   |                     ^^^^^^ method\
    \ not found in `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpva291s3b.rs:24:5\n\
    \   |\n16 |   fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |    \
    \                                        ---------- expected `Vec<isize>` because\
    \ of return type\n...\n24 | /     for i in 0..len {\n25 | |         max_nums[i].unwrap()\n\
    26 | |     }\n   | |_____^ expected struct `Vec`, found `()`\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if arr.len() <= k {\n        arr\n    } else\
    \ {\n        let mut max = arr.iter().cloned().max();\n        let mut pos = 0;\n\
    \        for i in 1..k {\n            if arr[i] > max {\n                max =\
    \ arr[i];\n                pos = i;\n            }\n        }\n        vec.iter_mut().take(pos).cloned().collect::<Vec<isize>>()\n\
    \    }\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0423]: expected value, found macro `vec`\n  --> /tmp/tmp69n6iie9.rs:28:9\n\
    \   |\n28 |         vec.iter_mut().take(pos).cloned().collect::<Vec<isize>>()\n\
    \   |         ^^^ not a value\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp69n6iie9.rs:17:21\n\
    \   |\n17 |     if arr.len() <= k {\n   |                     ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n17 |     if arr.len() <= k.try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0277]: the type\
    \ `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp69n6iie9.rs:23:16\n  \
    \ |\n23 |             if arr[i] > max {\n   |                ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp69n6iie9.rs:24:23\n   |\n24 |            \
    \     max = arr[i];\n   |                       ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308, E0423.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 || k == 1 {\n        return arr;\n\
    \    }\n    let mut largest = arr[0];\n    for i in 1..k {\n        if arr[i]\
    \ > largest {\n            largest = arr[i];\n        }\n    }\n    largest.iter().cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp1ubfj9rw.rs:22:12\n\
    \   |\n22 |         if arr[i] > largest {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp1ubfj9rw.rs:23:23\n   |\n23 |            \
    \ largest = arr[i];\n   |                       ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0599]: no method named `iter` found\
    \ for type `isize` in the current scope\n  --> /tmp/tmp1ubfj9rw.rs:26:13\n   |\n\
    26 |     largest.iter().cloned().collect()\n   |             ^^^^ method not found\
    \ in `isize`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max: isize = *arr.clone();\n    if k\
    \ > 0 && k <= arr.len() {\n        max = arr[k - 1];\n        for ix in k..arr.len()\
    \ {\n            if arr[ix] > max {\n                max = arr[ix];\n        \
    \    }\n        }\n    }\n    vec![max]\n}\n\nfn main() {\n    let candidate =\
    \ maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5dkmiz86.rs:17:26\n   |\n\
    17 |     let mut max: isize = *arr.clone();\n   |                  -----   ^^^^^^^^^^^^\
    \ expected `isize`, found slice `[isize]`\n   |                  |\n   |     \
    \             expected due to this\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5dkmiz86.rs:18:22\n\
    \   |\n18 |     if k > 0 && k <= arr.len() {\n   |                      ^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n18 |     if k >\
    \ 0 && k <= arr.len().try_into().unwrap() {\n   |                            \
    \   ++++++++++++++++++++\n\nerror[E0277]: the type `[isize]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmp5dkmiz86.rs:19:15\n   |\n19 |         max = arr[k\
    \ - 1];\n   |               ^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5dkmiz86.rs:20:22\n\
    \   |\n20 |         for ix in k..arr.len() {\n   |                      ^^^^^^^^^\
    \ expected `isize`, found `usize`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp5dkmiz86.rs:21:16\n   |\n21 |            \
    \ if arr[ix] > max {\n   |                ^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp5dkmiz86.rs:22:23\n   |\n22 |            \
    \     max = arr[ix];\n   |                       ^^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n "
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    assert_eq!(k < arr.len(), ());\n    let len =\
    \ arr.len();\n    let mut max = vec![0; k as usize];\n    let mut max_count =\
    \ 0;\n    for e in arr.iter() {\n        if e > max[max_count as usize] {\n  \
    \          max = vec![e; k as usize];\n            max_count = 0;\n        }\n\
    \        if max_count < k {\n            max = vec![e; k as usize];\n        \
    \    max_count += 1;\n        }\n    }\n    max\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0y9n8g68.rs:17:20\n   |\n\
    17 |     assert_eq!(k < arr.len(), ());\n   |                    ^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     assert_eq!(k <\
    \ arr.len().try_into().unwrap(), ());\n   |                             ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp0y9n8g68.rs:17:5\n   |\n17 | \
    \    assert_eq!(k < arr.len(), ());\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `bool`, found `()`\n   |\n   = note: this error originates in the macro `assert_eq`\
    \ (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp0y9n8g68.rs:22:16\n   |\n22 |         if e >\
    \ max[max_count as usize] {\n   |                ^^^^^^^^^^^^^^^^^^^^^^^\n   |\
    \                |\n   |                expected `&isize`, found integer\n   |\
    \                help: consider borrowing here: `&max[max_count as usize]`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp0y9n8g68.rs:23:24\n   |\n23 |  \
    \           max = vec![e; k as usize];\n   |                        ^ expected\
    \ integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    23 |             max = vec![*e; k as usize];\n   |                        +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp0y9n8g68.rs:27:24\n   |\n27 |  \
    \           max = vec![e; k as usize];\n   |                        ^ expected\
    \ integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    27 |             max = vec![*e; k as usize];\n   |                        +\n\n\
    error: aborting due to 5 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut result = Vec::with_capacity(k);\n   \
    \ let mut i = 0;\n    while i < arr.len() {\n        if arr[i] > arr[i + k] {\n\
    \            result.resize(i, 1);\n            result.push(i);\n            i\
    \ += 1;\n        } else {\n            result[i] = arr[i];\n            i += 1;\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpa6b9hfwl.rs:17:41\n   |\n\
    17 |     let mut result = Vec::with_capacity(k);\n   |                       \
    \                  ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    17 |     let mut result = Vec::with_capacity(k.try_into().unwrap());\n   |   \
    \                                       ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpa6b9hfwl.rs:20:29\n   |\n20 |         if arr[i]\
    \ > arr[i + k] {\n   |                             ^ expected `usize`, found `isize`\n\
    \nerror[E0277]: cannot add `isize` to `usize`\n  --> /tmp/tmpa6b9hfwl.rs:20:27\n\
    \   |\n20 |         if arr[i] > arr[i + k] {\n   |                           ^\
    \ no implementation for `usize + isize`\n   |\n   = help: the trait `Add<isize>`\
    \ is not implemented for `usize`\n   = help: the following other types implement\
    \ trait `Add<Rhs>`:\n             <&'a f32 as Add<f32>>\n             <&'a f64\
    \ as Add<f64>>\n             <&'a i128 as Add<i128>>\n             <&'a i16 as\
    \ Add<i16>>\n             <&'a i32 as Add<i32>>\n             <&'a i64 as Add<i64>>\n\
    \             <&'a i8 as Add<i8>>\n             <&'a isize as Add<isize>>\n  \
    \         and 48 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpa6b9hfwl.rs:25:25\n\
    \   |\n25 |             result[i] = arr[i];\n   |             ---------   ^^^^^^\
    \ expected `usize`, found `isize`\n   |             |\n   |             expected\
    \ due to the type of this binding\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpa6b9hfwl.rs:29:5\n\
    \   |\n16 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |      \
    \                                    ---------- expected `Vec<isize>` because\
    \ of return type\n...\n29 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ `usize`\n   |\n   = note: expected struct `Vec<isize>`\n              found\
    \ struct `Vec<usize>`\n\nerror: aborting due to 5 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    assert!(k <= arr.len());\n    let mut result\
    \ = vec![];\n    result.extend_from_slice(arr);\n    result.sort_unstable();\n\
    \    result[k..].cloned()\n}\n\nfn main() {\n    let candidate = maximum;\n  \
    \  assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpuxu2kzs5.rs:17:18\n   |\n\
    17 |     assert!(k <= arr.len());\n   |                  ^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n17 |     assert!(k <= arr.len().try_into().unwrap());\n\
    \   |                           ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpuxu2kzs5.rs:19:30\n   |\n19 |     result.extend_from_slice(arr);\n\
    \   |                              ^^^\n   |                              |\n\
    \   |                              expected `&[_]`, found struct `Vec`\n   | \
    \                             help: consider borrowing here: `&arr`\n   |\n  \
    \ = note: expected reference `&[_]`\n                 found struct `Vec<isize>`\n\
    \nerror[E0277]: the type `[_]` cannot be indexed by `RangeFrom<isize>`\n  -->\
    \ /tmp/tmpuxu2kzs5.rs:21:5\n   |\n21 |     result[k..].cloned()\n   |     ^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[_]>` is not implemented for `RangeFrom<isize>`\n   = help:\
    \ the following other types implement trait `SliceIndex<T>`:\n             <RangeFrom<usize>\
    \ as SliceIndex<[T]>>\n             <RangeFrom<usize> as SliceIndex<str>>\n  \
    \ = note: required because of the requirements on the impl of `Index<RangeFrom<isize>>`\
    \ for `Vec<_>`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k > arr.len() {\n        return vec![];\n\
    \    }\n    let mut max = arr[0];\n    for x in arr.iter().skip(1) {\n       \
    \ if x > max {\n            max = x;\n        }\n    }\n    let mut result = vec![];\n\
    \    while result.len() < k {\n        result.push(max);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjdo_d0pz.rs:17:12\n   |\n\
    17 |     if k > arr.len() {\n   |            ^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if k > arr.len().try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpjdo_d0pz.rs:22:16\n   |\n22 |         if x > max {\n  \
    \ |                ^^^\n   |                |\n   |                expected `&isize`,\
    \ found `isize`\n   |                help: consider borrowing here: `&max`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpjdo_d0pz.rs:23:19\n   |\n20 |  \
    \   let mut max = arr[0];\n   |                   ------ expected due to this\
    \ value\n...\n23 |             max = x;\n   |                   ^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n23 |  \
    \           max = *x;\n   |                   +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpjdo_d0pz.rs:27:26\n   |\n27 |     while result.len() < k {\n  \
    \ |                          ^ expected `usize`, found `isize`\n   |\nhelp: you\
    \ can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n27 |     while result.len() < k.try_into().unwrap() {\n   |     \
    \                      ++++++++++++++++++++\n\nerror: aborting due to 4 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    assert!(k <= arr.len(), \"k is greater than array\
    \ size\");\n    if k == 0 {\n        vec![]\n    } else {\n        let max_num\
    \ = arr[0];\n        let max_idx = 1;\n        for idx in 1..arr.len() {\n   \
    \         if max_num < arr[idx] {\n                max_num = arr[idx];\n     \
    \           max_idx = idx;\n            }\n        }\n        vec![max_num]\n\
    \    }\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpagumrf94.rs:17:18\n   |\n\
    17 |     assert!(k <= arr.len(), \"k is greater than array size\");\n   |    \
    \              ^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n17 |     assert!(k <= arr.len().try_into().unwrap(), \"k is greater than\
    \ array size\");\n   |                           ++++++++++++++++++++\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut result = vec![];\n    let len = arr.len();\n\
    \    if len < k || k > len {\n        result\n    } else {\n        // get max\
    \ element in arr\n        let max_idx = arr.iter().enumerate().max_by_key(|(_,\
    \ v)| {\n            v\n        });\n\n        let mut temp_arr = vec![];\n  \
    \      // check max element and append to temp_arr\n        for i in 0..(max_idx.1\
    \ - 1) {\n            temp_arr.push(arr[(max_idx.1 - i)]);\n        }\n\n    \
    \    // check if there is any larger element\n        if max_idx.1 != len {\n\
    \            let mut temp_arr = vec![];\n            // get max element in temp_arr\n\
    \            let mut max_idx = temp_arr.iter().enumerate().max_by_key(|(_, v)|\
    \ {\n                v\n            });\n\n            // check max element and\
    \ append to temp_arr\n            for i in 0..(max_idx.1 - 1) {\n            \
    \    temp_arr.push(temp_arr[(max_idx.1 - i)]);\n            }\n            temp_arr\n\
    \        } else {\n            temp_arr\n        }\n    }\n}\n\nfn main() {\n\
    \    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp32ynlpo5.rs:19:14\n   |\n\
    19 |     if len < k || k > len {\n   |              ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n19 |     if len < k.try_into().unwrap() ||\
    \ k > len {\n   |               ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp32ynlpo5.rs:19:23\n   |\n19 |     if len < k || k > len\
    \ {\n   |                       ^^^ expected `isize`, found `usize`\n   |\nhelp:\
    \ you can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n19 |     if len < k || k > len.try_into().unwrap() {\n   |      \
    \                    ++++++++++++++++++++\n\nerror[E0609]: no field `1` on type\
    \ `Option<(usize, &isize)>`\n  --> /tmp/tmp32ynlpo5.rs:29:30\n   |\n29 |     \
    \    for i in 0..(max_idx.1 - 1) {\n   |                              ^\n\nerror[E0609]:\
    \ no field `1` on type `Option<(usize, &isize)>`\n  --> /tmp/tmp32ynlpo5.rs:30:40\n\
    \   |\n30 |             temp_arr.push(arr[(max_idx.1 - i)]);\n   |           \
    \                             ^\n\nerror[E0609]: no field `1` on type `Option<(usize,\
    \ &isize)>`\n  --> /tmp/tmp32ynlpo5.rs:34:20\n   |\n34 |         if max_idx.1\
    \ != len {\n   |                    ^\n\nerror[E0609]: no field `1` on type `Option<(usize,\
    \ &_)>`\n  --> /tmp/tmp32ynlpo5.rs:42:34\n   |\n42 |             for i in 0..(max_idx.1\
    \ - 1) {\n   |                                  ^\n\nerror[E0609]: no field `1`\
    \ on type `Option<(usize, &_)>`\n  --> /tmp/tmp32ynlpo5.rs:43:49\n   |\n43 | \
    \                temp_arr.push(temp_arr[(max_idx.1 - i)]);\n   |             \
    \                                    ^\n\nerror: aborting due to 7 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0609.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_elements = vec![];\n    for i in\
    \ 0..arr.len() {\n        if arr[i] > max_elements[k] {\n            max_elements[k]\
    \ = arr[i];\n        }\n    }\n    max_elements\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[_]` cannot be indexed by `isize`\n  --> /tmp/tmpf0xc9rnv.rs:19:21\n\
    \   |\n19 |         if arr[i] > max_elements[k] {\n   |                     ^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[_]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<_>`\n\nerror[E0277]:\
    \ the type `[_]` cannot be indexed by `isize`\n  --> /tmp/tmpf0xc9rnv.rs:20:13\n\
    \   |\n20 |             max_elements[k] = arr[i];\n   |             ^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[_]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<_>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 { vec![] }\n    else if k == 1 {\n\
    \        vec![arr[0]]\n    }\n    else {\n        let mut cur_max = vec![];\n\
    \        let mut cur_max_index = -1;\n        for (i, elem) in arr.iter().enumerate()\
    \ {\n            if i > k {\n                break;\n            }\n         \
    \   if elem > cur_max[cur_max_index] {\n                cur_max = vec![elem];\n\
    \                cur_max_index = i;\n            }\n        }\n        cur_max\n\
    \    }\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2oswykkw.rs:25:20\n   |\n\
    25 |             if i > k {\n   |                    ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n25 |             if i > k.try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0277]: the trait\
    \ bound `usize: Neg` is not satisfied\n  --> /tmp/tmp2oswykkw.rs:23:33\n   |\n\
    23 |         let mut cur_max_index = -1;\n   |                               \
    \  ^^ the trait `Neg` is not implemented for `usize`\n   |\n   = help: the following\
    \ other types implement trait `Neg`:\n             &f32\n             &f64\n \
    \            &i128\n             &i16\n             &i32\n             &i64\n\
    \             &i8\n             &isize\n           and 8 others\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2oswykkw.rs:33:9\n   |\n16 | fn maximum(arr:\
    \ Vec<isize>, k: isize) -> Vec<isize> {\n   |                                \
    \          ---------- expected `Vec<isize>` because of return type\n...\n33 |\
    \         cur_max\n   |         ^^^^^^^ expected `isize`, found `&isize`\n   |\n\
    \   = note: expected struct `Vec<isize>`\n              found struct `Vec<&isize>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == arr.len() {\n        arr\n    } else\
    \ {\n        let mut max = arr.iter().cloned().max().unwrap();\n        let mut\
    \ max_pos = 0;\n        for (i, v) in arr.iter().enumerate() {\n            if\
    \ v > max {\n                max = v;\n                max_pos = i;\n        \
    \    }\n        }\n        let mut arr = arr.split_at(max_pos + k - 1).collect();\n\
    \        arr.pop(k);\n        arr\n    }\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl1i9qi9b.rs:17:13\n   |\n\
    17 |     if k == arr.len() {\n   |             ^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if k == arr.len().try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpl1i9qi9b.rs:23:20\n   |\n23 |             if v > max {\n\
    \   |                    ^^^\n   |                    |\n   |                \
    \    expected `&isize`, found `isize`\n   |                    help: consider\
    \ borrowing here: `&max`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl1i9qi9b.rs:24:23\n\
    \   |\n20 |         let mut max = arr.iter().cloned().max().unwrap();\n   |  \
    \                     ---------------------------------- expected due to this\
    \ value\n...\n24 |                 max = v;\n   |                       ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    24 |                 max = *v;\n   |                       +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpl1i9qi9b.rs:28:46\n   |\n28 |         let mut\
    \ arr = arr.split_at(max_pos + k - 1).collect();\n   |                       \
    \                       ^ expected `usize`, found `isize`\n\nerror[E0277]: cannot\
    \ add `isize` to `usize`\n  --> /tmp/tmpl1i9qi9b.rs:28:44\n   |\n28 |        \
    \ let mut arr = arr.split_at(max_pos + k - 1).collect();\n   |               \
    \                             ^ no implementation for `usize + isize`\n   |\n\
    \   = help: the trait `Add<isize>` is not implemented for `usize`\n   = help:\
    \ the following other types implement trait `Add<Rhs>`:\n             <&'a f32\
    \ as Add<f32>>\n             <&'a f64 as Add<f64>>\n             <&'a i128 as\
    \ Add<i128>>\n             <&'a i16 as Add<i16>>\n             <&'a i32 as Add<i32>>\n\
    \             <&'a i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n      \
    \       <&'a isize as Add<isize>>\n           and 48 others\n\nerror[E0599]: `(&[isize],\
    \ &[isize])` is not an iterator\n  --> /tmp/tmpl1i9qi9b.rs:28:53\n   |"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    arr.sort_by_key(|&a| a.partial_cmp(&k).unwrap().reverse());\n\
    \    let mut v = arr;\n    while v.len() > k {\n        v.pop();\n    }\n    v\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpny2ym1w2.rs:19:21\n   |\n\
    19 |     while v.len() > k {\n   |                     ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n19 |     while v.len() > k.try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k > arr.len() {\n        arr\n    } else {\n\
    \        arr.windows(k).flat_map(|window| window.max())\n    }\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7cfnksh3.rs:17:12\n   |\n\
    17 |     if k > arr.len() {\n   |            ^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if k > arr.len().try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp7cfnksh3.rs:20:21\n   |\n20 |         arr.windows(k).flat_map(|window|\
    \ window.max())\n   |                     ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |         arr.windows(k.try_into().unwrap()).flat_map(|window|\
    \ window.max())\n   |                      ++++++++++++++++++++\n\nerror[E0061]:\
    \ this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmp7cfnksh3.rs:20:49\n\
    \    |\n20  |         arr.windows(k).flat_map(|window| window.max())\n    |  \
    \                                               ^^^- supplied 0 arguments\n  \
    \  |                                                 |\n    |                \
    \                                 expected 1 argument\n    |\nnote: associated\
    \ function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7cfnksh3.rs:20:9\n\
    \   |\n16 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |      \
    \                                    ---------- expected `Vec<isize>` because\
    \ of return type\n...\n20 |         arr.windows(k).flat_map(|window| window.max())\n\
    \   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`,\
    \ found struct `FlatMap`\n   |\n   = note: expected struct `Vec<isize>`\n    \
    \          found struct `FlatMap<Windows<'_, isize>, &[isize], [closure@/tmp/tmp7cfnksh3.rs:20:33:\
    \ 20:54]>`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0061, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0061`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k >= arr.len() {\n        return arr;\n  \
    \  }\n    let mut min_pos = arr.len() - 1;\n    for pos in arr.iter().rev().skip(1).rev()\
    \ {\n        if *pos > arr[min_pos] {\n            min_pos = pos - 1;\n      \
    \  }\n    }\n    let mut max_pos = 0;\n    for pos in arr.iter().skip(1).rev()\
    \ {\n        if *pos > arr[max_pos] {\n            max_pos = pos + 1;\n      \
    \  }\n    }\n    if max_pos - min_pos == k {\n        return arr;\n    }\n   \
    \ let mut ret_vec = vec![0; k];\n    let mut cur_max = arr[0];\n    for pos in\
    \ arr.iter().rev().skip(1).rev() {\n        if *pos > cur_max {\n            cur_max\
    \ = pos;\n        }\n    }\n    let mut cur_pos = 0;\n    for pos in arr.iter().skip(1).rev()\
    \ {\n        if *pos == cur_max {\n            ret_vec[cur_pos] = pos;\n     \
    \       cur_pos += 1;\n        }\n    }\n    ret_vec\n}\n\nfn main() {\n    let\
    \ candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_g7_2cb7.rs:17:13\n   |\n\
    17 |     if k >= arr.len() {\n   |             ^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if k >= arr.len().try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_g7_2cb7.rs:23:23\n   |\n20 |     let mut min_pos = arr.len()\
    \ - 1;\n   |                       ------------- expected due to this value\n\
    ...\n23 |             min_pos = pos - 1;\n   |                       ^^^^^^^ expected\
    \ `usize`, found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_g7_2cb7.rs:29:23\n\
    \   |\n26 |     let mut max_pos = 0;\n   |                       - expected due\
    \ to this value\n...\n29 |             max_pos = pos + 1;\n   |              \
    \         ^^^^^^^ expected `usize`, found `isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_g7_2cb7.rs:32:29\n   |\n32 |     if max_pos - min_pos\
    \ == k {\n   |                             ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n32 |     if max_pos - min_pos == k.try_into().unwrap()\
    \ {\n   |                              ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_g7_2cb7.rs:35:31\n   |\n35 |     let mut ret_vec = vec![0;\
    \ k];\n   |                               ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n35 |     let mut ret_vec = vec![0; k.try_into().unwrap()];\n\
    \   |                                ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_g7_2cb7.rs:39:23\n   |\n36 |     let mut cur_max = arr[0];\n\
    \   |                       ------ expected due to this value\n...\n39 |     \
    \        cur_max = pos;\n   |                       ^^^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n39 |        \
    \     cur_max = *pos;\n   |               "
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k > arr.len() {\n        vec![]\n    } else\
    \ if k == 1 {\n        arr.iter().cloned().collect::<Vec<isize>>()\n    } else\
    \ {\n        arr.iter().skip(k).take(k).cloned().collect::<Vec<isize>>()\n   \
    \ }\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvbsqihrs.rs:17:12\n   |\n\
    17 |     if k > arr.len() {\n   |            ^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if k > arr.len().try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpvbsqihrs.rs:22:25\n   |\n22 |         arr.iter().skip(k).take(k).cloned().collect::<Vec<isize>>()\n\
    \   |                         ^ expected `usize`, found `isize`\n   |\nhelp: you\
    \ can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n22 |         arr.iter().skip(k.try_into().unwrap()).take(k).cloned().collect::<Vec<isize>>()\n\
    \   |                          ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpvbsqihrs.rs:22:33\n   |\n22 |         arr.iter().skip(k).take(k).cloned().collect::<Vec<isize>>()\n\
    \   |                                 ^ expected `usize`, found `isize`\n   |\n\
    help: you can convert an `isize` to a `usize` and panic if the converted value\
    \ doesn't fit\n   |\n22 |         arr.iter().skip(k).take(k.try_into().unwrap()).cloned().collect::<Vec<isize>>()\n\
    \   |                                  ++++++++++++++++++++\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    arr.sort_by(|a, b| b.cmp(&a))\n        .take(k)\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: `()` is not an iterator\n  --> /tmp/tmp90ktuqqc.rs:18:10\n\
    \   |\n18 |         .take(k)\n   |          ^^^^ `()` is not an iterator\n   |\n\
    \   = note: the following trait bounds were not satisfied:\n           `(): Iterator`\n\
    \           which is required by `&mut (): Iterator`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max = 0isize;\n    let mut new_arr =\
    \ arr.clone();\n    new_arr.sort_unstable();\n    for i in 0..k {\n        if\
    \ arr[i] > max {\n            max = arr[i];\n        }\n    }\n    for i in 0..k\
    \ {\n        if new_arr[i] > max {\n            new_arr[i] = max;\n        }\n\
    \    }\n    new_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpr86tnjhh.rs:21:12\n\
    \   |\n21 |         if arr[i] > max {\n   |            ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpr86tnjhh.rs:22:19\n   |\n22 |            \
    \ max = arr[i];\n   |                   ^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpr86tnjhh.rs:26:12\n   |\n26 |         if new_arr[i]\
    \ > max {\n   |            ^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpr86tnjhh.rs:27:13\n   |\n27 |             new_arr[i] = max;\n \
    \  |             ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_v = arr[0];\n    for i in arr {\n\
    \        if i > max_v {\n            max_v = i;\n        }\n    }\n    if max_v\
    \ == 0 {\n        return vec![];\n    }\n    if k == 1 {\n        return vec![max_v];\n\
    \    }\n    let mut len = arr.len();\n    if len < k {\n        k = len;\n   \
    \ }\n    let mut ans = vec![];\n    for i in 0..k {\n        let j = len - k +\
    \ i;\n        let max_k = max_v;\n        for j in 0..j {\n            if arr[j]\
    \ > max_k {\n                max_k = arr[j];\n            }\n        }\n     \
    \   ans.push(*max_k);\n    }\n    ans\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphazy_tzw.rs:30:14\n   |\n\
    30 |     if len < k {\n   |              ^ expected `usize`, found `isize`\n \
    \  |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n30 |     if len < k.try_into().unwrap() {\n   |   \
    \            ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphazy_tzw.rs:31:13\n\
    \   |\n16 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |      \
    \                          ----- expected due to this parameter type\n...\n31\
    \ |         k = len;\n   |             ^^^ expected `isize`, found `usize`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmphazy_tzw.rs:35:23\n   |\n35 |  \
    \       let j = len - k + i;\n   |                       ^ expected `usize`, found\
    \ `isize`\n\nerror[E0277]: cannot subtract `isize` from `usize`\n  --> /tmp/tmphazy_tzw.rs:35:21\n\
    \   |\n35 |         let j = len - k + i;\n   |                     ^ no implementation\
    \ for `usize - isize`\n   |\n   = help: the trait `Sub<isize>` is not implemented\
    \ for `usize`\n   = help: the following other types implement trait `Sub<Rhs>`:\n\
    \             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n    \
    \         <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n      \
    \       <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n          \
    \   <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n           and\
    \ 48 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphazy_tzw.rs:35:27\n\
    \   |\n35 |         let j = len - k + i;\n   |                           ^ expected\
    \ `usize`, found `isize`\n\nerror[E0277]: cannot add `isize` to `usize`\n  -->\
    \ /tmp/tmphazy_tzw.rs:35:25\n   |\n35 |         let j = len - k + i;\n   |   \
    \                      ^ no implementation for `usize + isize`\n   |\n   = help:\
    \ the trait `Add<isize>` is not implemented for `usize`\n   = help: the following\
    \ other types implement trait `Add<Rhs>`:\n             <&'a f32 as Add<f32>>\n\
    \             <&'a f64 as Add<f64>>\n             <&'a i128 as Add<i128>>\n  \
    \           <&'a i16 as Add<i16>>\n            "
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k <= arr.len() {\n        arr.iter().take(k).max().collect()\n\
    \    } else {\n        arr\n    }\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwwl1a6o8.rs:17:13\n   |\n\
    17 |     if k <= arr.len() {\n   |             ^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if k <= arr.len().try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpwwl1a6o8.rs:18:25\n   |\n18 |         arr.iter().take(k).max().collect()\n\
    \   |                         ^ expected `usize`, found `isize`\n   |\nhelp: you\
    \ can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n18 |         arr.iter().take(k.try_into().unwrap()).max().collect()\n\
    \   |                          ++++++++++++++++++++\n\nerror[E0599]: `Option<&isize>`\
    \ is not an iterator\n   --> /tmp/tmpwwl1a6o8.rs:18:34\n    |\n18  |         \
    \  arr.iter().take(k).max().collect()\n    |                                 \
    \   ^^^^^^^ `Option<&isize>` is not an iterator\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `Option<&isize>: Iterator`\n \
    \           which is required by `&mut Option<&isize>: Iterator`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    arr.iter().take(k).collect()\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkr0b9ak7.rs:17:21\n   |\n\
    17 |     arr.iter().take(k).collect()\n   |                     ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n17 |     arr.iter().take(k.try_into().unwrap()).collect()\n\
    \   |                      ++++++++++++++++++++\n\nerror[E0277]: a value of type\
    \ `Vec<isize>` cannot be built from an iterator over elements of type `&isize`\n\
    \    --> /tmp/tmpkr0b9ak7.rs:17:24\n     |\n17   |     arr.iter().take(k).collect()\n\
    \     |                        ^^^^^^^ value of type `Vec<isize>` cannot be built\
    \ from `std::iter::Iterator<Item=&isize>`\n     |\n     = help: the trait `FromIterator<&isize>`\
    \ is not implemented for `Vec<isize>`\n     = help: the trait `FromIterator<T>`\
    \ is implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max = vec![vec![-1000; k]; k];\n    for\
    \ i in 0..k {\n        for j in 0..arr.len() {\n            if arr[j] >= max[j][i]\
    \ {\n                max[j][i] = arr[j];\n            }\n        }\n    }\n  \
    \  max\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvh7eiw_j.rs:17:36\n   |\n\
    17 |     let mut max = vec![vec![-1000; k]; k];\n   |                        \
    \            ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an\
    \ `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n17\
    \ |     let mut max = vec![vec![-1000; k.try_into().unwrap()]; k];\n   |     \
    \                                ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpvh7eiw_j.rs:17:40\n   |\n17 |     let mut max = vec![vec![-1000;\
    \ k]; k];\n   |                                        ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     let mut max = vec![vec![-1000; k];\
    \ k.try_into().unwrap()];\n   |                                         ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpvh7eiw_j.rs:20:26\n\
    \   |\n20 |             if arr[j] >= max[j][i] {\n   |                       \
    \   ^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n \
    \  = help: the trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\
    \nerror[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpvh7eiw_j.rs:21:17\n\
    \   |\n21 |                 max[j][i] = arr[j];\n   |                 ^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpvh7eiw_j.rs:25:5\n   |\n16 | fn maximum(arr:\
    \ Vec<isize>, k: isize) -> Vec<isize> {\n   |                                \
    \          ---------- expected `Vec<isize>` because of return type\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let n = arr.len();\n    if k < n {\n        return\
    \ arr;\n    }\n    if k == n {\n        return arr;\n    }\n    let mut max =\
    \ arr[k - 1];\n    for i in k..(n-1) {\n        if arr[i] > max {\n          \
    \  max = arr[i];\n        }\n    }\n    if k > 0 {\n        arr[n - 1]\n    }\
    \ else {\n        vec![n]\n    }\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8cnrg472.rs:18:12\n   |\n\
    18 |     if k < n {\n   |            ^ expected `isize`, found `usize`\n   |\n\
    help: you can convert a `usize` to an `isize` and panic if the converted value\
    \ doesn't fit\n   |\n18 |     if k < n.try_into().unwrap() {\n   |           \
    \  ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8cnrg472.rs:21:13\n\
    \   |\n21 |     if k == n {\n   |             ^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n21 |     if k == n.try_into().unwrap() {\n   |    \
    \          ++++++++++++++++++++\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp8cnrg472.rs:24:19\n   |\n24 |     let mut\
    \ max = arr[k - 1];\n   |                   ^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8cnrg472.rs:25:17\n\
    \   |\n25 |     for i in k..(n-1) {\n   |                 ^^^^^ expected `isize`,\
    \ found `usize`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmp8cnrg472.rs:26:12\n   |\n26 |         if arr[i] > max {\n   | \
    \           ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp8cnrg472.rs:27:19\n\
    \   |\n27 |             max = arr[i];\n   |                   ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is im"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    assert!(k <= arr.len());\n    let mut max_val\
    \ = 0;\n    let mut max_idx = 0;\n    for idx in 0..k {\n        if arr[max_idx]\
    \ > arr[idx] {\n            max_val = arr[max_idx];\n            max_idx = idx;\n\
    \        }\n    }\n    vec![arr[max_idx]]\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptp2skmle.rs:17:18\n   |\n\
    17 |     assert!(k <= arr.len());\n   |                  ^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n17 |     assert!(k <= arr.len().try_into().unwrap());\n\
    \   |                           ++++++++++++++++++++\n\nerror[E0277]: the type\
    \ `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmptp2skmle.rs:21:27\n  \
    \ |\n21 |         if arr[max_idx] > arr[idx] {\n   |                         \
    \  ^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   =\
    \ help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help:\
    \ the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmptp2skmle.rs:23:23\n   |\n19 |\
    \     let mut max_idx = 0;\n   |                       - expected due to this\
    \ value\n...\n23 |             max_idx = idx;\n   |                       ^^^\
    \ expected `usize`, found `isize`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k > arr.len() {\n        return vec![]\n \
    \   }\n\n    let mut l = arr.len();\n    let mut max_k = k;\n    let mut min_k\
    \ = k + 1;\n    let mut min_val = arr[k];\n    let mut max_val = arr[k];\n\n \
    \   while l > 1 {\n        // l is still greater than k, so divide and swap arr[k]\
    \ and arr[l]\n        if arr[k] < arr[l] {\n            arr[k] = arr[l];\n   \
    \     } else {\n            arr[l] = arr[k];\n        }\n\n        // Keep track\
    \ of the minimum and maximum values so far\n        if l == min_k {\n        \
    \    arr[k] = arr[l];\n            min_k = k;\n            l -= 1;\n        }\
    \ else {\n            min_k = l;\n        }\n\n        if l == max_k {\n     \
    \       arr[k] = arr[l];\n            max_k = k;\n            l -= 1;\n      \
    \  } else {\n            max_k = l;\n        }\n    }\n\n    // Now that arr[k]\
    \ == arr[l] is the max so far, swap arr[k] with arr[l]\n    if arr[k] != arr[l]\
    \ {\n        arr[k] = arr[l];\n    }\n\n    arr\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5qt7n10p.rs:17:12\n   |\n\
    17 |     if k > arr.len() {\n   |            ^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if k > arr.len().try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp5qt7n10p.rs:24:23\n   |\n24 |  \
    \   let mut min_val = arr[k];\n   |                       ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp5qt7n10p.rs:25:23\n   |\n25 |     let mut\
    \ max_val = arr[k];\n   |                       ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp5qt7n10p.rs:29:12\n   |\n29 |         if arr[k]\
    \ < arr[l] {\n   |            ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmp5qt7n10p.rs:30:13\n   |\n30 |             arr[k] = arr[l];\n  \
    \ |             ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `Slice"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let len = arr.len();\n    if k > len {\n    \
    \    vec![]\n    } else {\n        let mut max = vec![0; k];\n        for &v in\
    \ arr.iter() {\n            if v > max[k - 1] {\n                max[k - 1] =\
    \ v;\n            }\n        }\n        max\n    }\n}\n\nfn main() {\n    let\
    \ candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7z3bz7rb.rs:18:12\n   |\n\
    18 |     if k > len {\n   |            ^^^ expected `isize`, found `usize`\n \
    \  |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n18 |     if k > len.try_into().unwrap() {\n   |   \
    \            ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7z3bz7rb.rs:21:31\n\
    \   |\n21 |         let mut max = vec![0; k];\n   |                          \
    \     ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n21 |      \
    \   let mut max = vec![0; k.try_into().unwrap()];\n   |                      \
    \          ++++++++++++++++++++\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmp7z3bz7rb.rs:23:20\n   |\n23 |         \
    \    if v > max[k - 1] {\n   |                    ^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp7z3bz7rb.rs:24:17\n   |\n24 |  \
    \               max[k - 1] = v;\n   |                 ^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    arr.iter().windows(k).max().collect()\n}\n\n\
    fn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4,\
    \ 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
    \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `windows` found for struct `std::slice::Iter`\
    \ in the current scope\n  --> /tmp/tmp9o_lk59g.rs:17:16\n   |\n17 |     arr.iter().windows(k).max().collect()\n\
    \   |                ^^^^^^^ method not found in `std::slice::Iter<'_, isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k < 1 || k > arr.len() {\n        panic!(\"\
    Invalid k.\");\n    }\n\n    let mut max = vec![Int::default(); k];\n    let mut\
    \ counter = k;\n    for &x in arr.iter() {\n        if *x > max.iter().max().unwrap()\
    \ {\n            *max = *x;\n        }\n\n        if counter == 1 {\n        \
    \    break;\n        }\n\n        counter--;\n    }\n\n    max\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmp30mpmds5.rs:32:18\n\
    \   |\n32 |         counter--;\n   |                  ^ expected expression\n\n\
    error[E0433]: failed to resolve: use of undeclared type `Int`\n  --> /tmp/tmp30mpmds5.rs:21:24\n\
    \   |\n21 |     let mut max = vec![Int::default(); k];\n   |                 \
    \       ^^^ use of undeclared type `Int`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmp30mpmds5.rs:17:21\n   |\n17 |     if k < 1 || k > arr.len() {\n\
    \   |                     ^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp:\
    \ you can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n17 |     if k < 1 || k > arr.len().try_into().unwrap() {\n   |  \
    \                            ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp30mpmds5.rs:21:40\n   |\n21 |     let mut max = vec![Int::default();\
    \ k];\n   |                                        ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n21 |     let mut max = vec![Int::default(); k.try_into().unwrap()];\n\
    \   |                                         ++++++++++++++++++++\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmp30mpmds5.rs:24:12\n   |\n\
    24 |         if *x > max.iter().max().unwrap() {\n   |            ^^\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmp30mpmds5.rs:25:20\n   |\n\
    25 |             *max = *x;\n   |                    ^^\n\nerror: aborting due\
    \ to 6 previous errors\n\nSome errors have detailed explanations: E0308, E0433,\
    \ E0614.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut m = vec![];\n    for i in 0..arr.len()\
    \ {\n        m.push((arr[i], i));\n    }\n    m.sort();\n    let mut rem = vec![0;\
    \ k];\n    let mut max = 0;\n    for i in 0..k {\n        max = cmp::max(max,\
    \ m[rem[i]].0);\n    }\n    rem.clear();\n    rem.extend(m.iter().cloned());\n\
    \    for i in 0..k {\n        if rem[i] >= max {\n            rem.swap(i, rem[i]\
    \ - max);\n            break;\n        }\n    }\n    return rem\n        .iter()\n\
    \        .map(|x| x.0)\n        .collect::<Vec<_>>()\n}\n\nfn main() {\n    let\
    \ candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmp31x980o8.rs:25:15\n   |\n25 |         max = cmp::max(max, m[rem[i]].0);\n\
    \   |               ^^^ use of undeclared crate or module `cmp`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp31x980o8.rs:22:27\n   |\n22 |     let mut rem\
    \ = vec![0; k];\n   |                           ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n22 |     let mut rem = vec![0; k.try_into().unwrap()];\n\
    \   |                            ++++++++++++++++++++\n\nerror[E0277]: the type\
    \ `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmp31x980o8.rs:25:31\n\
    \   |\n25 |         max = cmp::max(max, m[rem[i]].0);\n   |                  \
    \             ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\
    \nerror[E0277]: the trait bound `Vec<{integer}>: Extend<(isize, usize)>` is not\
    \ satisfied\n  --> /tmp/tmp31x980o8.rs:28:9\n   |\n28 |     rem.extend(m.iter().cloned());\n\
    \   |         ^^^^^^ the trait `Extend<(isize, usize)>` is not implemented for\
    \ `Vec<{integer}>`\n   |\n   = help: the following other types implement trait\
    \ `Extend<A>`:\n             <Vec<T, A> as Extend<&'a T>>\n             <Vec<T,\
    \ A> as Extend<T>>\n\nerror[E0277]: the type `[{integer}]` cannot be indexed by\
    \ `isize`\n  --> /tmp/tmp31x980o8.rs:30:12\n   |\n30 |         if rem[i] >= max\
    \ {\n   |            ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp31x980o8.rs:31:22\n   |\n31 |\
    \        "
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    \n    // write your code here\n    let mut largest\
    \ = vec![];\n    for i in 0..k {\n        if arr[i] > largest[0] {\n         \
    \   largest = vec![];\n        }\n        largest.push(arr[i]);\n    }\n    largest\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpg8q8iqs7.rs:21:12\n\
    \   |\n21 |         if arr[i] > largest[0] {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpg8q8iqs7.rs:24:22\n   |\n24 |         largest.push(arr[i]);\n\
    \   |                      ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut result = vec![];\n    let mut cur_max:\
    \ isize = 0;\n    let mut cur_pos = 0;\n    let mut cur_sum: isize = 0;\n    for\
    \ v in arr.iter() {\n        if cur_pos == k {\n            break;\n        }\n\
    \        cur_sum += v;\n        if cur_sum > cur_max {\n            cur_max =\
    \ cur_sum;\n        }\n        cur_pos++;\n    }\n    result.push(cur_max);\n\
    \    result\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpoa_pvgpc.rs:29:16\n\
    \   |\n29 |         cur_pos++;\n   |                ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n29 |         { let tmp = cur_pos; cur_pos\
    \ += 1; tmp };\n   |         +++++++++++        ~~~~~~~~~~~~~~~~~~~~~\n29 -  \
    \       cur_pos++;\n29 +         cur_pos += 1;\n   | \n\nerror: aborting due to\
    \ previous error\n\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut arr_max = vec![0; k];\n    arr_max.swap(arr,\
    \ |mut a| a.iter().max());\n    arr_max\n}\n\nfn main() {\n    let candidate =\
    \ maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppwbai8vh.rs:17:31\n   |\n\
    17 |     let mut arr_max = vec![0; k];\n   |                               ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     let mut arr_max\
    \ = vec![0; k.try_into().unwrap()];\n   |                                ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmppwbai8vh.rs:18:18\n   |\n18 |\
    \     arr_max.swap(arr, |mut a| a.iter().max());\n   |                  ^^^ expected\
    \ `usize`, found struct `Vec`\n   |\n   = note: expected type `usize`\n      \
    \      found struct `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut m = arr.len();\n    if m > k {\n    \
    \    m = k;\n    }\n    if m == 0 {\n        return vec![];\n    }\n    if m >\
    \ arr.len() {\n        m = arr.len();\n    }\n    for i in 0..k {\n        let\
    \ max = arr.iter().cloned().max().unwrap();\n        if max < i {\n          \
    \  arr[i] = max;\n        }\n    }\n    arr\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpn192bmzw.rs:18:12\n   |\n\
    18 |     if m > k {\n   |            ^ expected `usize`, found `isize`\n   |\n\
    help: you can convert an `isize` to a `usize` and panic if the converted value\
    \ doesn't fit\n   |\n18 |     if m > k.try_into().unwrap() {\n   |           \
    \  ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn192bmzw.rs:19:13\n\
    \   |\n17 |     let mut m = arr.len();\n   |                 --------- expected\
    \ due to this value\n18 |     if m > k {\n19 |         m = k;\n   |          \
    \   ^ expected `usize`, found `isize`\n\nerror[E0277]: the type `[isize]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpn192bmzw.rs:30:13\n   |\n30 |         \
    \    arr[i] = max;\n   |             ^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let len = arr.len();\n    if k > len {\n    \
    \    return vec![];\n    }\n    if k == 1 {\n        vec![arr[0]];\n    } else\
    \ {\n        let mut max = arr[0];\n        for val in arr.iter() {\n        \
    \    if val > max {\n                max = val;\n            }\n        }\n  \
    \      vec![max].extend(vec![arr[k - 1]..len]);\n    }\n}\n\nfn main() {\n   \
    \ let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_c830e4g.rs:18:12\n   |\n\
    18 |     if k > len {\n   |            ^^^ expected `isize`, found `usize`\n \
    \  |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n18 |     if k > len.try_into().unwrap() {\n   |   \
    \            ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_c830e4g.rs:21:15\n\
    \   |\n21 |       if k == 1 {\n   |  _______________^\n22 | |         vec![arr[0]];\n\
    \   | |                     - help: remove this semicolon\n23 | |     } else {\n\
    \   | |_____^ expected struct `Vec`, found `()`\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n           found unit type `()`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp_c830e4g.rs:26:22\n   |\n26 |             if val > max {\n   |\
    \                      ^^^\n   |                      |\n   |                \
    \      expected `&isize`, found `isize`\n   |                      help: consider\
    \ borrowing here: `&max`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_c830e4g.rs:27:23\n\
    \   |\n24 |         let mut max = arr[0];\n   |                       ------ expected\
    \ due to this value\n...\n27 |                 max = val;\n   |              \
    \         ^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n27 |                 max = *val;\n   |                   \
    \    +\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmp_c830e4g.rs:30:31\n   |\n30 |         vec![max].extend(vec![arr[k -\
    \ 1]..len]);\n   |                               ^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the trait bound `Vec<isize>:\
    \ Extend<std::ops::Range<usize>>` is not satisfied\n  --> /tmp/tmp_c830e4g.rs:30:19\n\
    \   |\n30 |         vec![max].extend(vec![arr[k - 1]..len]);\n   |           \
    \        ^^^^^^ the trait "
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let len = arr.len();\n    let mut max = [0; k];\n\
    \    for i in 0..k {\n        if arr[i] > max[i] {\n            max[i] = arr[i];\n\
    \        }\n    }\n    max.iter().cloned().take(len).collect()\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0435]: attempt to use a non-constant value in a constant\n  -->\
    \ /tmp/tmpgxbw7xhg.rs:18:23\n   |\n16 | fn maximum(arr: Vec<isize>, k: isize)\
    \ -> Vec<isize> {\n   |                             - this would need to be a\
    \ `const`\n17 |     let len = arr.len();\n18 |     let mut max = [0; k];\n   |\
    \                       ^\n\nerror[E0277]: the type `[isize]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpgxbw7xhg.rs:20:12\n   |\n20 |         if arr[i] >\
    \ max[i] {\n   |            ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpgxbw7xhg.rs:21:22\n   |\n21 |             max[i] = arr[i];\n  \
    \ |                      ^^^^^^ slice indices are of type `usize` or ranges of\
    \ `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0435.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k <= 0 || arr.len() <= k || arr.iter().any(|x|\
    \ *x <= 0) {\n        return vec![];\n    }\n    let mut max_element = arr.iter().max().unwrap();\n\
    \    let mut rest = vec![max_element];\n    for i in 0..k {\n        if rest ==\
    \ arr {\n            return vec![];\n        }\n        let tmp = rest.iter().max().unwrap();\n\
    \        rest = rest.filter_by(|x| *x > tmp).collect();\n        if rest == arr\
    \ {\n            return vec![];\n        }\n        rest.push(i);\n    }\n   \
    \ rest\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfj9fn4gt.rs:17:31\n   |\n\
    17 |     if k <= 0 || arr.len() <= k || arr.iter().any(|x| *x <= 0) {\n   |  \
    \                             ^ expected `usize`, found `isize`\n   |\nhelp: you\
    \ can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n17 |     if k <= 0 || arr.len() <= k.try_into().unwrap() || arr.iter().any(|x|\
    \ *x <= 0) {\n   |                                ++++++++++++++++++++\n\nerror[E0277]:\
    \ can't compare `&isize` with `isize`\n  --> /tmp/tmpfj9fn4gt.rs:23:17\n   |\n\
    23 |         if rest == arr {\n   |                 ^^ no implementation for `&isize\
    \ == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n   = note: required because of the requirements on the impl\
    \ of `PartialEq<Vec<isize>>` for `Vec<&isize>`\n\nerror[E0599]: no method named\
    \ `filter_by` found for struct `Vec<&isize>` in the current scope\n  --> /tmp/tmpfj9fn4gt.rs:27:21\n\
    \   |\n27 |         rest = rest.filter_by(|x| *x > tmp).collect();\n   |     \
    \                ^^^^^^^^^ method not found in `Vec<&isize>`\n\nerror[E0277]:\
    \ can't compare `&isize` with `isize`\n  --> /tmp/tmpfj9fn4gt.rs:28:17\n   |\n\
    28 |         if rest == arr {\n   |                 ^^ no implementation for `&isize\
    \ == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n   = note: required because of the requirements on the impl\
    \ of `PartialEq<Vec<isize>>` for `Vec<&isize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpfj9fn4gt.rs:31:19\n   |\n31 |         rest.push(i);\n   |     \
    \              ^\n   |             "
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if arr.len() < k { return arr; }\n    if k >\
    \ arr.len() { return vec![]; }\n    let mut cur = vec![];\n    let mut l = vec![];\n\
    \    for i in 0..k {\n        if arr[i] > arr[l[0]] {\n            cur = vec![cur[0]];\n\
    \            l = vec![];\n        }\n        cur.push(arr[i]);\n        l.push(arr[i]);\n\
    \    }\n    vec!l\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected one of `(`, `[`, or `{`, found `l`\n  --> /tmp/tmphvb158sv.rs:29:9\n\
    \   |\n29 |     vec!l\n   |         ^ expected one of `(`, `[`, or `{`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmphvb158sv.rs:17:20\n   |\n17 |     if arr.len()\
    \ < k { return arr; }\n   |                    ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n17 |     if arr.len() < k.try_into().unwrap() { return\
    \ arr; }\n   |                     ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmphvb158sv.rs:18:12\n   |\n18 |     if k > arr.len() { return\
    \ vec![]; }\n   |            ^^^^^^^^^ expected `isize`, found `usize`\n   |\n\
    help: you can convert a `usize` to an `isize` and panic if the converted value\
    \ doesn't fit\n   |\n18 |     if k > arr.len().try_into().unwrap() { return vec![];\
    \ }\n   |                     ++++++++++++++++++++\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmphvb158sv.rs:22:12\n   |\n22 |  \
    \       if arr[i] > arr[l[0]] {\n   |            ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmphvb158sv.rs:26:18\n   |\n26 |         cur.push(arr[i]);\n\
    \   |                  ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmphvb158sv.rs:27:16\n\
    \   |\n27 |         l.push(arr[i]);\n   |                ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help:"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if arr.len() < k {\n        vec![arr[0]]\n  \
    \  } else {\n        let mut max_arr = vec![arr[0]; k];\n        for i in 1..k\
    \ {\n            max_arr[i] = if arr[i] > max_arr[i] {\n                max_arr[i]\n\
    \            } else {\n                arr[i]\n            };\n        }\n   \
    \     max_arr\n    }\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkmmqznld.rs:17:20\n   |\n\
    17 |     if arr.len() < k {\n   |                    ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if arr.len() < k.try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpkmmqznld.rs:20:40\n   |\n20 |         let mut max_arr =\
    \ vec![arr[0]; k];\n   |                                        ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n20 |         let mut max_arr = vec![arr[0];\
    \ k.try_into().unwrap()];\n   |                                         ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpkmmqznld.rs:22:13\n\
    \   |\n22 |             max_arr[i] = if arr[i] > max_arr[i] {\n   |          \
    \   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n\
    \   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n \
    \  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpkmmqznld.rs:22:29\n\
    \   |\n22 |             max_arr[i] = if arr[i] > max_arr[i] {\n   |          \
    \                   ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpkmmqznld.rs:22:38\n\
    \   |\n22 |             max_arr[i] = if arr[i] > max_arr[i] {\n   |          \
    \                            ^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    // Do not write main() function.\n    // Do not\
    \ read input, instead use the arguments to the function.\n    // Do not print\
    \ the output, instead return values that you compute and print in main.\n    debug_assert!(k\
    \ <= arr.len());\n    let mut max: isize = arr[0];\n    for v in &arr[k..] {\n\
    \        if v > max {\n            max = v;\n        }\n    }\n    let mut ret\
    \ = vec![max];\n    let mut i = 1;\n    while i < k {\n        let mut min = arr[0];\n\
    \        for v in &arr[k..] {\n            if v < min {\n                min =\
    \ v;\n            }\n        }\n        if min > max {\n            ret.push(i);\n\
    \        }\n        i += 1;\n    }\n    ret\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpikt06a1m.rs:20:24\n   |\n\
    20 |     debug_assert!(k <= arr.len());\n   |                        ^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n20 |     debug_assert!(k\
    \ <= arr.len().try_into().unwrap());\n   |                                 ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `RangeFrom<isize>`\n \
    \ --> /tmp/tmpikt06a1m.rs:22:15\n   |\n22 |     for v in &arr[k..] {\n   |   \
    \            ^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `RangeFrom<isize>`\n\
    \   = help: the following other types implement trait `SliceIndex<T>`:\n     \
    \        <RangeFrom<usize> as SliceIndex<[T]>>\n             <RangeFrom<usize>\
    \ as SliceIndex<str>>\n   = note: required because of the requirements on the\
    \ impl of `Index<RangeFrom<isize>>` for `Vec<isize>`\n\nerror[E0277]: the type\
    \ `[isize]` cannot be indexed by `RangeFrom<isize>`\n  --> /tmp/tmpikt06a1m.rs:31:19\n\
    \   |\n31 |         for v in &arr[k..] {\n   |                   ^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `RangeFrom<isize>`\n   = help:\
    \ the following other types implement trait `SliceIndex<T>`:\n             <RangeFrom<usize>\
    \ as SliceIndex<[T]>>\n             <RangeFrom<usize> as SliceIndex<str>>\n  \
    \ = note: required because of the requirements on the impl of `Index<RangeFrom<isize>>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    assert!(arr.len() >= k && k <= arr.len());\n\
    \    let mut max = arr[k - 1];\n    for el in arr.iter().rev() {\n        if el\
    \ > max {\n            max = el;\n        }\n    }\n    arr.iter().take(k).rev().collect()\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppq_emp72.rs:17:26\n   |\n\
    17 |     assert!(arr.len() >= k && k <= arr.len());\n   |                    \
    \      ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n17 |     assert!(arr.len()\
    \ >= k.try_into().unwrap() && k <= arr.len());\n   |                         \
    \  ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppq_emp72.rs:17:36\n\
    \   |\n17 |     assert!(arr.len() >= k && k <= arr.len());\n   |             \
    \                       ^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp:\
    \ you can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n17 |     assert!(arr.len() >= k && k <= arr.len().try_into().unwrap());\n\
    \   |                                             ++++++++++++++++++++\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmppq_emp72.rs:18:19\n\
    \   |\n18 |     let mut max = arr[k - 1];\n   |                   ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmppq_emp72.rs:24:21\n   |\n24 |     arr.iter().take(k).rev().collect()\n\
    \   |                     ^ expected `usize`, found `isize`\n   |\nhelp: you can\
    \ convert an `isize` to a `usize` and panic if the converted value doesn't fit\n\
    \   |\n24 |     arr.iter().take(k.try_into().unwrap()).rev().collect()\n   | \
    \                     ++++++++++++++++++++\n\nerror[E0277]: a value of type `Vec<isize>`\
    \ cannot be built from an iterator over elements of type `&isize`\n    --> /tmp/tmppq_emp72.rs:24:30\n\
    \     |\n24   |     arr.iter().take(k).rev().collect()\n     |               \
    \               ^^^^^^^ value of type `Vec<isize>` cannot be built from `std::iter::Iterator<Item=&isize>`\n\
    \     |\n     = help: the"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let size = arr.len();\n    if k > size {\n  \
    \      return vec![];\n    }\n    let mut max = vec![];\n    let mut i = 0;\n\
    \    while i < size && arr[i] < arr[i + 1] {\n        i += 1;\n    }\n    for\
    \ i in 0..k - 1 {\n        let mut j = i;\n        while j > 0 && arr[j] > arr[j\
    \ - 1] {\n            j -= 1;\n        }\n        max = vec![max[..j] + arr[i],\
    \ max[j..i + 1]];\n    }\n    max\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpem5fcaru.rs:18:12\n   |\n\
    18 |     if k > size {\n   |            ^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n18 |     if k > size.try_into().unwrap() {\n   |  \
    \              ++++++++++++++++++++\n\nerror[E0277]: the type `[isize]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpem5fcaru.rs:28:24\n   |\n28 |         while\
    \ j > 0 && arr[j] > arr[j - 1] {\n   |                        ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpem5fcaru.rs:28:33\n   |\n28 |         while\
    \ j > 0 && arr[j] > arr[j - 1] {\n   |                                 ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]:\
    \ the type `[_]` cannot be indexed by `RangeTo<isize>`\n  --> /tmp/tmpem5fcaru.rs:31:20\n\
    \   |\n31 |         max = vec![max[..j] + arr[i], max[j..i + 1]];\n   |      \
    \              ^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[_]>` is not implemented for `RangeTo<isize>`\n\
    \   = help: the following other types implement trait `SliceIndex<T>`:\n     \
    \        <RangeTo<usize> as SliceIndex<[T]>>\n             <RangeTo<usize> as\
    \ SliceIndex<str>>\n   = note: required because of the requirements on the impl\
    \ of `Index<RangeTo<isize>>` for `Vec<_>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpem5fcaru.rs:31:31\n   |\n31 |  \
    \       max = vec![max[..j] + arr[i],"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if arr.len() <= k {\n        return arr;\n  \
    \  }\n    let mut max = vec![0; k];\n    let mut cur = arr[0];\n    for i in 1..arr.len()\
    \ {\n        if arr[i] > cur {\n            max = vec![max[k.0..<i].max(); i];\n\
    \            cur = arr[i];\n        }\n        if max[k.0..<i].len() > i {\n \
    \           max[k.0..<i].swap(max[k.0..<i].len() - i, i);\n        }\n    }\n\
    \    max.reverse();\n    arr\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `(`, `+`, `::`, `<`, `>`, or `as`, found `]`\n\
    \  --> /tmp/tmpcorl5oys.rs:27:23\n   |\n27 |         if max[k.0..<i].len() > i\
    \ {\n   |                       ^ expected one of 7 possible tokens\n\nerror:\
    \ expected one of `!`, `(`, `+`, `::`, `<`, `>`, or `as`, found `]`\n  --> /tmp/tmpcorl5oys.rs:24:35\n\
    \   |\n24 |             max = vec![max[k.0..<i].max(); i];\n   |             \
    \                      ^ expected one of 7 possible tokens\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpcorl5oys.rs:17:21\n   |\n17 |     if arr.len() <= k {\n\
    \   |                     ^ expected `usize`, found `isize`\n   |\nhelp: you can\
    \ convert an `isize` to a `usize` and panic if the converted value doesn't fit\n\
    \   |\n17 |     if arr.len() <= k.try_into().unwrap() {\n   |                \
    \      ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcorl5oys.rs:20:27\n\
    \   |\n20 |     let mut max = vec![0; k];\n   |                           ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n20 |     let mut max = vec![0;\
    \ k.try_into().unwrap()];\n   |                            ++++++++++++++++++++\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 101
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max = arr[0];\n    for i in 1..arr.len()\
    \ {\n        if arr[i] > max {\n            max = arr[i];\n        }\n    }\n\
    \    let mut vec = vec![];\n    for i in 0..k {\n        vec.push(max);\n    }\n\
    \    vec\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 5, 5]`,\n right: `[-4, -3, 5]`', /tmp/tmpt6vx_ttw.rs:32:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_num = arr[0];\n    let mut max_pos\
    \ = 0;\n    for i in arr.iter().rev() {\n        if i >= k {\n            break;\n\
    \        }\n        max_num = i;\n        if i == max_num {\n            max_pos\
    \ = i;\n        }\n    }\n    let mut result = Vec::new();\n    for pos in (0..k).rev()\
    \ {\n        if pos == max_pos {\n            result.push(max_num);\n        }\
    \ else {\n            result.push(*max_pos);\n        }\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2ops8txh.rs:20:17\n   |\n\
    20 |         if i >= k {\n   |                 ^\n   |                 |\n   |\
    \                 expected `&isize`, found `isize`\n   |                 help:\
    \ consider borrowing here: `&k`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2ops8txh.rs:23:19\n\
    \   |\n17 |     let mut max_num = arr[0];\n   |                       ------ expected\
    \ due to this value\n...\n23 |         max_num = i;\n   |                   ^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n23 |         max_num = *i;\n   |                   +\n\nerror[E0277]: can't\
    \ compare `&isize` with `isize`\n  --> /tmp/tmp2ops8txh.rs:24:14\n   |\n24 | \
    \        if i == max_num {\n   |              ^^ no implementation for `&isize\
    \ == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2ops8txh.rs:25:23\n\
    \   |\n18 |     let mut max_pos = 0;\n   |                       - expected due\
    \ to this value\n...\n25 |             max_pos = i;\n   |                    \
    \   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n25 |             max_pos = *i;\n   |                       +\n\
    \nerror[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmp2ops8txh.rs:33:25\n\
    \   |\n33 |             result.push(*max_pos);\n   |                         ^^^^^^^^\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0614.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![0; k];\n    for &n in\
    \ arr {\n        if n > max_arr[k] {\n            max_arr[k] = n;\n        }\n\
    \    }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9mqnnnv_.rs:17:31\n   |\n\
    17 |     let mut max_arr = vec![0; k];\n   |                               ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     let mut max_arr\
    \ = vec![0; k.try_into().unwrap()];\n   |                                ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp9mqnnnv_.rs:18:9\n   |\n18 | \
    \    for &n in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `n`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp9mqnnnv_.rs:19:16\n   |\n19 |  \
    \       if n > max_arr[k] {\n   |                ^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp9mqnnnv_.rs:20:13\n   |\n20 |  \
    \           max_arr[k] = n;\n   |             ^^^^^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    arr.iter()\n        .fold(vec![], |mut max, &n|\
    \ if n > max.last() { max = vec![n, *max]; } else { max.push(n) })\n        .iter()\n\
    \        .take_while(|&n| n < k)\n        .collect()\n}\n\nfn main() {\n    let\
    \ candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8o9dutgh.rs:18:44\n   |\n\
    18 |         .fold(vec![], |mut max, &n| if n > max.last() { max = vec![n, *max];\
    \ } else { max.push(n) })\n   |                                            ^^^^^^^^^^\
    \ expected `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n\
    \              found enum `Option<&_>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp8o9dutgh.rs:18:71\n   |\n18 |         .fold(vec![], |mut max, &n| if\
    \ n > max.last() { max = vec![n, *max]; } else { max.push(n) })\n   |        \
    \                                                               ^^^^ expected\
    \ `isize`, found slice\n   |\n   = note: expected type `isize`\n             found\
    \ slice `[_]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8o9dutgh.rs:18:55\n\
    \   |\n18 |         .fold(vec![], |mut max, &n| if n > max.last() { max = vec![n,\
    \ *max]; } else { max.push(n) })\n   |                                       \
    \                ^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp8o9dutgh.rs:18:87\n   |\n18 |\
    \         .fold(vec![], |mut max, &n| if n > max.last() { max = vec![n, *max];\
    \ } else { max.push(n) })\n   |                                              \
    \                                         ^^^^^^^^^^^ expected struct `Vec`, found\
    \ `()`\n   |\n   = note: expected struct `Vec<isize>`\n           found unit type\
    \ `()`\nnote: method `push` modifies its receiver in-place\n  --> /tmp/tmp8o9dutgh.rs:18:91\n\
    \   |\n18 |         .fold(vec![], |mut max, &n| if n > max.last() { max = vec![n,\
    \ *max]; } else { max.push(n) })\n   |                                       \
    \                                                --- ^^^^ this call modifies `max`\
    \ in-place\n   |                                                             \
    \                          |\n   |                                           \
    \                                            you probably want to use this value\
    \ after calling the method...\n   = note: ."
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut res = vec![];\n    for i in 0..k {\n\
    \        let tmp = maximum_by_key(arr, i, |v| v);\n        if !tmp.is_empty()\
    \ {\n            res = res.push(tmp);\n        }\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `maximum_by_key` in this scope\n  -->\
    \ /tmp/tmpwz39wm8r.rs:19:19\n   |\n19 |         let tmp = maximum_by_key(arr,\
    \ i, |v| v);\n   |                   ^^^^^^^^^^^^^^ not found in this scope\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpwz39wm8r.rs:21:19\n   |\n17 |  \
    \   let mut res = vec![];\n   |                   ------ expected due to this\
    \ value\n...\n21 |             res = res.push(tmp);\n   |                   ^^^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<_>`\n\
    \           found unit type `()`\nnote: method `push` modifies its receiver in-place\n\
    \  --> /tmp/tmpwz39wm8r.rs:21:23\n   |\n21 |             res = res.push(tmp);\n\
    \   |                   --- ^^^^ this call modifies `res` in-place\n   |     \
    \              |\n   |                   you probably want to use this value after\
    \ calling the method...\n   = note: ...instead of the `()` output of method `push`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_val = arr[0];\n    let mut max_idx\
    \ = 0;\n\n    for i in 0..k {\n        for j in 0..k {\n            if max_idx\
    \ < j {\n                if arr[i] > arr[j] {\n                    max_val = arr[i];\n\
    \                    max_idx = j;\n                }\n            }\n        }\n\
    \    }\n\n    vec![max_val]\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpyjfzt302.rs:23:20\n\
    \   |\n23 |                 if arr[i] > arr[j] {\n   |                    ^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpyjfzt302.rs:23:29\n\
    \   |\n23 |                 if arr[i] > arr[j] {\n   |                       \
    \      ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n \
    \  = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n  \
    \ = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpyjfzt302.rs:24:31\n\
    \   |\n24 |                     max_val = arr[i];\n   |                      \
    \         ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n\
    \   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n \
    \  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k > arr.len() {\n        vec![]\n    }\n \
    \   else {\n        let mut res = vec![];\n        arr.iter().take(k).for_each(|el|\
    \ {\n            if *el > res.last() {\n                res.push(*el);\n     \
    \       }\n        });\n        res\n    }\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvt1o9k7x.rs:17:12\n   |\n\
    17 |     if k > arr.len() {\n   |            ^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if k > arr.len().try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpvt1o9k7x.rs:22:25\n   |\n22 |         arr.iter().take(k).for_each(|el|\
    \ {\n   |                         ^ expected `usize`, found `isize`\n   |\nhelp:\
    \ you can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n22 |         arr.iter().take(k.try_into().unwrap()).for_each(|el|\
    \ {\n   |                          ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpvt1o9k7x.rs:23:22\n   |\n23 |             if *el > res.last()\
    \ {\n   |                      ^^^^^^^^^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected type `isize`\n              found enum `Option<&_>`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut maximum = vec![];\n    let mut current_index\
    \ = 0;\n    for i in 0..k {\n        if arr[i] > maximum[0] {\n            maximum\
    \ = arr.split_at_mut(current_index + 1);\n            current_index = 0;\n   \
    \     }\n        maximum[current_index] = arr[i];\n        current_index += 1;\n\
    \    }\n    if current_index != k {\n        maximum = arr.split_at_mut(current_index\
    \ + 1);\n    }\n    maximum\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp4dr4m27i.rs:20:12\n\
    \   |\n20 |         if arr[i] > maximum[0] {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4dr4m27i.rs:21:23\n\
    \   |\n17 |     let mut maximum = vec![];\n   |                       ------ expected\
    \ due to this value\n...\n21 |             maximum = arr.split_at_mut(current_index\
    \ + 1);\n   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found tuple\n   |\n   = note: expected struct `Vec<_>`\n     \
    \          found tuple `(&mut [isize], &mut [isize])`\n\nerror[E0277]: the type\
    \ `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp4dr4m27i.rs:24:34\n  \
    \ |\n24 |         maximum[current_index] = arr[i];\n   |                     \
    \             ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp4dr4m27i.rs:27:25\n   |\n27 |\
    \     if current_index != k {\n   |                         ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n27 |     if current_index != k.try_into().unwrap()\
    \ {\n   |                          ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp4dr4m27i.rs:28:19\n   |\n17 |     let mut maximum = vec![];\n\
    \   |                       ------ expected due to this value\n...\n28 |     \
    \    maximum = arr.split_at_mut(current_index + 1);\n   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Ve"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_idx = k;\n    let mut max_elem =\
    \ arr[0];\n    for i in 1..arr.len() {\n        if arr[i] > max_elem {\n     \
    \       max_elem = arr[i];\n            max_idx = i;\n        }\n    }\n    arr.iter().take(max_idx).collect()\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpazf23lb9.rs:22:23\n   |\n\
    17 |     let mut max_idx = k;\n   |                       - expected due to this\
    \ value\n...\n22 |             max_idx = i;\n   |                       ^ expected\
    \ `isize`, found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpazf23lb9.rs:25:21\n\
    \   |\n25 |     arr.iter().take(max_idx).collect()\n   |                     ^^^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n25 |     arr.iter().take(max_idx.try_into().unwrap()).collect()\n\
    \   |                            ++++++++++++++++++++\n\nerror[E0277]: a value\
    \ of type `Vec<isize>` cannot be built from an iterator over elements of type\
    \ `&isize`\n    --> /tmp/tmpazf23lb9.rs:25:30\n     |\n25   |     arr.iter().take(max_idx).collect()\n\
    \     |                              ^^^^^^^ value of type `Vec<isize>` cannot\
    \ be built from `std::iter::Iterator<Item=&isize>`\n     |\n     = help: the trait\
    \ `FromIterator<&isize>` is not implemented for `Vec<isize>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k <= arr.len() {\n        let mut maxs = vec![];\n\
    \        for (i, v) in arr.iter().enumerate() {\n            if v > maxs[0] {\n\
    \                maxs.clear();\n            }\n            maxs.push(v);\n   \
    \         if i == k {\n                break;\n            }\n        }\n    \
    \    if maxs.len() == 0 {\n            vec![]\n        } else {\n            maxs\n\
    \        }\n    } else {\n        vec![]\n    }\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsr2nfmfe.rs:17:13\n   |\n\
    17 |     if k <= arr.len() {\n   |             ^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if k <= arr.len().try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpsr2nfmfe.rs:24:21\n   |\n24 |             if i == k {\n\
    \   |                     ^ expected `usize`, found `isize`\n   |\nhelp: you can\
    \ convert an `isize` to a `usize` and panic if the converted value doesn't fit\n\
    \   |\n24 |             if i == k.try_into().unwrap() {\n   |                \
    \      ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsr2nfmfe.rs:31:13\n\
    \   |\n16 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |      \
    \                                    ---------- expected `Vec<isize>` because\
    \ of return type\n...\n31 |             maxs\n   |             ^^^^ expected `isize`,\
    \ found `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n            \
    \  found struct `Vec<&isize>`\n\nerror: aborting due to 3 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr: Vec<isize> = arr;\n    max_arr.pop(k);\n\
    \    max_arr.sort();\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmpp8ym4sfh.rs:18:13\n     |\n18   |     max_arr.pop(k);\n     |\
    \             ^^^ - supplied 1 argument\n     |             |\n     |        \
    \     expected 0 arguments\n     |\nnote: associated function defined here\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_num = arr[0];\n    let mut max_pos\
    \ = 0;\n    let mut max_idx = arr.len();\n    while max_idx > 0 && max_pos < max_idx\
    \ {\n        max_num = arr.get(max_pos);\n        max_pos = max_pos + 1;\n   \
    \     max_idx = max_idx - 1;\n    }\n    vec![max_num]\n}\n\nfn main() {\n   \
    \ let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppuqi8_2j.rs:21:19\n   |\n\
    17 |     let mut max_num = arr[0];\n   |                       ------ expected\
    \ due to this value\n...\n21 |         max_num = arr.get(max_pos);\n   |     \
    \              ^^^^^^^^^^^^^^^^ expected `isize`, found enum `Option`\n   |\n\
    \   = note: expected type `isize`\n              found enum `Option<&isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let len = arr.len();\n    let mut new_arr = vec![MAX_NUMBER;\
    \ k + 1];\n    let mut max_num = MAX_NUMBER;\n\n    for i in 0..k {\n        if\
    \ arr[i] > max_num {\n            max_num = arr[i];\n        }\n    }\n\n    for\
    \ i in 0..len {\n        if arr[i] > max_num {\n            new_arr[k] = arr[i];\n\
    \            k++;\n        }\n    }\n\n    new_arr[k] = max_num;\n    new_arr\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpf7yn3y89.rs:30:14\n\
    \   |\n30 |             k++;\n   |              ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n30 |             { let tmp = k; k += 1;\
    \ tmp };\n   |             +++++++++++  ~~~~~~~~~~~~~~~\n30 -             k++;\n\
    30 +             k += 1;\n   | \n\nerror[E0425]: cannot find value `MAX_NUMBER`\
    \ in this scope\n  --> /tmp/tmpf7yn3y89.rs:18:28\n   |\n18 |     let mut new_arr\
    \ = vec![MAX_NUMBER; k + 1];\n   |                            ^^^^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `MAX_NUMBER` in this scope\n\
    \  --> /tmp/tmpf7yn3y89.rs:19:23\n   |\n19 |     let mut max_num = MAX_NUMBER;\n\
    \   |                       ^^^^^^^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpf7yn3y89.rs:18:40\n   |\n18 |     let mut new_arr\
    \ = vec![MAX_NUMBER; k + 1];\n   |                                        ^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n18 |     let mut\
    \ new_arr = vec![MAX_NUMBER; (k + 1).try_into().unwrap()];\n   |             \
    \                           +     +++++++++++++++++++++\n\nerror[E0277]: the type\
    \ `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpf7yn3y89.rs:22:12\n  \
    \ |\n22 |         if arr[i] > max_num {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpf7yn3y89.rs:23:23\n   |\n23 |            \
    \ max_num = arr[i];\n   |                       ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required becaus"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut res = vec![];\n    let mut maxs = vec![];\n\
    \n    for i in 0..k {\n        maxs.push(arr[i]);\n    }\n\n    for i in 0..k\
    \ {\n        if maxs.iter().any(|&x| x > arr[i]) {\n            for j in 0..k\
    \ {\n                if maxs[j] > arr[i] {\n                    maxs[j] = arr[i];\n\
    \                }\n            }\n        }\n    }\n\n    for i in 0..k {\n \
    \       res.push(i);\n    }\n\n    for i in 0..k {\n        if maxs[i] > arr[i]\
    \ {\n            while (i < maxs.len() and maxs[i] > arr[i]) {\n             \
    \   res.push(i);\n                i += 1;\n            }\n        }\n    }\n\n\
    \    for i in 0..k {\n        res.push(i);\n    }\n\n    res\n}\n\nfn main() {\n\
    \    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: `and` is not a logical operator\n  --> /tmp/tmp9f_eksa8.rs:40:35\n\
    \   |\n40 |             while (i < maxs.len() and maxs[i] > arr[i]) {\n   |  \
    \                                 ^^^ help: use `&&` to perform logical conjunction\n\
    \   |\n   = note: unlike in e.g., python and PHP, `&&` and `||` are used for logical\
    \ operators\n\nwarning: unnecessary parentheses around `while` condition\n  -->\
    \ /tmp/tmp9f_eksa8.rs:40:19\n   |\n40 |             while (i < maxs.len() and\
    \ maxs[i] > arr[i]) {\n   |                   ^                              \
    \     ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove\
    \ these parentheses\n   |\n40 -             while (i < maxs.len() and maxs[i]\
    \ > arr[i]) {\n40 +             while i < maxs.len() and maxs[i] > arr[i] {\n\
    \   | \n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmp9f_eksa8.rs:21:19\n   |\n21 |         maxs.push(arr[i]);\n   |     \
    \              ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp9f_eksa8.rs:25:37\n\
    \   |\n25 |         if maxs.iter().any(|&x| x > arr[i]) {\n   |              \
    \                       ^^^^^^ slice indices are of type `usize` or ranges of\
    \ `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[_]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmp9f_eksa8.rs:27:20\n   |\n27 |                 if maxs[j] > arr[i]\
    \ {\n   |                    ^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<["
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if arr.len() < k {\n        return vec![];\n\
    \    }\n\n    let mut max_arr = vec![];\n    let mut max_k = k;\n    let mut last_i\
    \ = 0;\n\n    for cur_i in 0..arr.len() {\n        if cur_i > last_i + 1 {\n \
    \           max_arr.push(arr.get(cur_i).unwrap());\n            max_k -= 1;\n\
    \        }\n\n        last_i = cur_i;\n    }\n\n    if max_k == 0 {\n        return\
    \ max_arr;\n    }\n\n    let mut min_arr = vec![];\n    let mut min_k = k;\n \
    \   let mut first_i = 0;\n\n    for cur_i in 0..arr.len() {\n        if cur_i\
    \ < first_i + 1 {\n            min_arr.push(arr.get(cur_i).unwrap());\n      \
    \      min_k -= 1;\n        }\n\n        first_i = cur_i;\n    }\n\n    if min_k\
    \ == 0 {\n        return min_arr;\n    }\n\n    if max_k > min_k {\n        let\
    \ mut tmp = min_arr;\n        min_arr = max_arr;\n        max_arr = tmp;\n   \
    \ }\n\n    let mut res = vec![];\n\n    for i in 0..min_k {\n        res.push(min_arr[i]);\n\
    \    }\n\n    for i in 0..max_k {\n        res.push(max_arr[i]);\n    }\n\n  \
    \  return res\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwkqbpovn.rs:17:20\n   |\n\
    17 |     if arr.len() < k {\n   |                    ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if arr.len() < k.try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpwkqbpovn.rs:35:16\n   |\n16 | fn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n   |                                          ----------\
    \ expected `Vec<isize>` because of return type\n...\n35 |         return max_arr;\n\
    \   |                ^^^^^^^ expected `isize`, found `&isize`\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n              found struct `Vec<&isize>`\n\nerror[E0277]:\
    \ the type `[&isize]` cannot be indexed by `isize`\n  --> /tmp/tmpwkqbpovn.rs:64:18\n\
    \   |\n64 |         res.push(min_arr[i]);\n   |                  ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[&isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<&isize>`\n\nerror[E0277]:\
    \ the type `[&isize]` cannot be indexed by `isize`\n  --> /tmp/tmpwkqbpovn.rs:68:18\n\
    \   |\n68 |         res.push(max_arr[i]);\n   |                  ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[&isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<&isize>`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut arr = arr.to_vec();\n    arr.sort();\n\
    \    let size = arr.len() as isize;\n    arr.resize(size, 0);\n    let mut max\
    \ = Vec::with_capacity(size + k);\n    for i in 0..k {\n        for j in 0..size\
    \ {\n            if arr[j] >= i {\n                let mut index = j;\n      \
    \          while index < size && arr[index] < i {\n                    index +=\
    \ 1;\n                }\n                max[i] += index;\n            }\n   \
    \     }\n    }\n    vec![max[0..].iter().cloned().collect::<Vec<_>>()]\n}\n\n\
    fn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4,\
    \ 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
    \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpby0ihiux.rs:20:16\n   |\n\
    20 |     arr.resize(size, 0);\n   |                ^^^^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n20 |     arr.resize(size.try_into().unwrap(),\
    \ 0);\n   |                    ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpby0ihiux.rs:21:38\n   |\n21 |     let mut max = Vec::with_capacity(size\
    \ + k);\n   |                                      ^^^^^^^^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n21 |     let mut max = Vec::with_capacity((size\
    \ + k).try_into().unwrap());\n   |                                      +    \
    \    +++++++++++++++++++++\n\nerror[E0277]: the type `[isize]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpby0ihiux.rs:24:16\n   |\n24 |             if arr[j]\
    \ >= i {\n   |                ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpby0ihiux.rs:26:39\n   |\n26 |                 while index < size\
    \ && arr[index] < i {\n   |                                       ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[_]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpby0ihiux.rs:29:17\n   |\n29 |  \
    \               max[i] += index;\n   |                 ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>`\
    \ is not implemente"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = arr.to_vec();\n    max_arr.sort_by_key(|&a|\
    \ a.partial_cmp(&max_arr.last().unwrap()).unwrap());\n    max_arr[k..]\n}\n\n\
    fn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4,\
    \ 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
    \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `RangeFrom<isize>`\n\
    \  --> /tmp/tmpt4ad7aib.rs:19:5\n   |\n19 |     max_arr[k..]\n   |     ^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `RangeFrom<isize>`\n   =\
    \ help: the following other types implement trait `SliceIndex<T>`:\n         \
    \    <RangeFrom<usize> as SliceIndex<[T]>>\n             <RangeFrom<usize> as\
    \ SliceIndex<str>>\n   = note: required because of the requirements on the impl\
    \ of `Index<RangeFrom<isize>>` for `Vec<isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut result = vec![arr[0]];\n    for elem\
    \ in arr.iter().rev() {\n        let mut j = isize::MAX;\n        for (i, &mut\
    \ elem) in result.iter_mut().zip(arr.iter().rev()) {\n            if elem > i\
    \ {\n                elem = i;\n                j = i;\n            }\n      \
    \  }\n        result[j] = elem;\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz82lqzhi.rs:20:17\n   |\n\
    20 |         for (i, &mut elem) in result.iter_mut().zip(arr.iter().rev()) {\n\
    \   |                 ^^^^^^^^^     --------------------------------------- this\
    \ expression has type `Option<(&mut isize, &isize)>`\n   |                 |\n\
    \   |                 types differ in mutability\n   |                 help: you\
    \ can probably remove the explicit borrow: `elem`\n   |\n   = note:      expected\
    \ reference `&isize`\n           found mutable reference `&mut _`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpz82lqzhi.rs:23:21\n   |\n19 |         let mut\
    \ j = isize::MAX;\n   |                     ---------- expected due to this value\n\
    ...\n23 |                 j = i;\n   |                     ^ expected `isize`,\
    \ found `&mut isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n23\
    \ |                 j = *i;\n   |                     +\n\nerror[E0277]: the type\
    \ `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpz82lqzhi.rs:26:9\n   |\n\
    26 |         result[j] = elem;\n   |         ^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut result = vec![arr[0]];\n    let mut max_val\
    \ = arr[0];\n    let mut pos = 0;\n    for &i in arr.iter().rev() {\n        if\
    \ pos == k {\n            break;\n        }\n        if i > max_val {\n      \
    \      max_val = i;\n        }\n        result += vec![max_val];\n        pos\
    \ += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = maximum;\n \
    \   assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `Vec<isize>`\n  --> /tmp/tmpunxaxz3f.rs:27:9\n   |\n27 |         result += vec![max_val];\n\
    \   |         ------^^^^^^^^^^^^^^^^^\n   |         |\n   |         cannot use\
    \ `+=` on type `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0368`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    // Write your code here.\n    let mut max_arr:\
    \ Vec<isize> = Vec::new();\n    let mut temp_arr: Vec<isize> = arr;\n    let mut\
    \ temp_k: isize = 0;\n    while temp_k > 0 {\n        if temp_arr.len() > temp_k\
    \ {\n            max_arr.push(temp_arr[temp_k]);\n            temp_k += 1;\n \
    \       }\n        temp_arr.clear();\n    }\n    max_arr\n}\n\nfn main() {\n \
    \   let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqbyndiwq.rs:22:29\n   |\n\
    22 |         if temp_arr.len() > temp_k {\n   |                             ^^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n22 |         if\
    \ temp_arr.len() > temp_k.try_into().unwrap() {\n   |                        \
    \           ++++++++++++++++++++\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpqbyndiwq.rs:23:26\n   |\n23 |            \
    \ max_arr.push(temp_arr[temp_k]);\n   |                          ^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k <= arr.len() {\n        arr.iter().take(k).max()\n\
    \    } else {\n        vec![]\n    }\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc_94p5og.rs:17:13\n   |\n\
    17 |     if k <= arr.len() {\n   |             ^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if k <= arr.len().try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpc_94p5og.rs:18:25\n   |\n18 |         arr.iter().take(k).max()\n\
    \   |                         ^ expected `usize`, found `isize`\n   |\nhelp: you\
    \ can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n18 |         arr.iter().take(k.try_into().unwrap()).max()\n   | \
    \                         ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpc_94p5og.rs:18:9\n   |\n16 | fn maximum(arr: Vec<isize>, k: isize)\
    \ -> Vec<isize> {\n   |                                          ---------- expected\
    \ `Vec<isize>` because of return type\n17 |     if k <= arr.len() {\n18 |    \
    \     arr.iter().take(k).max()\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \                found enum `Option<&isize>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max: isize = 0;\n    for i in 0..arr.len()\
    \ {\n        if arr[i] > max {\n            max = arr[i];\n        }\n       \
    \ if k > 0 && k == i {\n            return vec![max];\n        }\n    }\n    return\
    \ vec![max];\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpla8mpt9t.rs:22:26\n   |\n\
    22 |         if k > 0 && k == i {\n   |                          ^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n22 |         if k > 0 && k == i.try_into().unwrap()\
    \ {\n   |                           ++++++++++++++++++++\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    assert!(k <= arr.len());\n    let mut max: isize\
    \ = 0;\n    let mut max_index = 0;\n    let mut min_val = arr[min_val_i_size()];\n\
    \    for (i, &val) in arr.iter().enumerate() {\n        if val > min {\n     \
    \       max = val\n            max_index = i;\n            min = val\n       \
    \ }\n        if val < min {\n            min = val\n        }\n    }\n\n    if\
    \ k == 1 {\n        Vec::from(arr[max_index..])\n    } else {\n        if max_index\
    \ < k {\n            vec![arr[max_index..k].iter().max().unwrap(), arr[max_index..max_index\
    \ + 1].iter().max().unwrap()]\n        } else {\n            vec![arr[max_index..k].iter().max().unwrap(),\
    \ arr[max_index..max_index + k].iter().max().unwrap()]\n        }\n    }\n}\n\n\
    fn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4,\
    \ 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
    \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `max_index`\n  --> /tmp/tmpku4skd3s.rs:23:22\n\
    \   |\n23 |             max = val\n   |                      ^ help: add `;` here\n\
    24 |             max_index = i;\n   |             --------- unexpected token\n\
    \nerror[E0425]: cannot find function `min_val_i_size` in this scope\n  --> /tmp/tmpku4skd3s.rs:20:27\n\
    \   |\n20 |     let mut min_val = arr[min_val_i_size()];\n   |               \
    \            ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `min` in this scope\n  --> /tmp/tmpku4skd3s.rs:22:18\n   |\n22 |     \
    \    if val > min {\n   |                  ^^^\n...\n43 | fn main() {\n   | ---------\
    \ similarly named function `main` defined here\n   |\nhelp: a function with a\
    \ similar name exists\n   |\n22 |         if val > main {\n   |              \
    \    ~~~~\nhelp: consider importing this function\n   |\n1  | use std::cmp::min;\n\
    \   |\n\nerror[E0425]: cannot find value `min` in this scope\n  --> /tmp/tmpku4skd3s.rs:25:13\n\
    \   |\n25 |             min = val\n   |             ^^^\n...\n43 | fn main() {\n\
    \   | --------- similarly named function `main` defined here\n   |\nhelp: a function\
    \ with a similar name exists\n   |\n25 |             main = val\n   |        \
    \     ~~~~\nhelp: consider importing this function\n   |\n1  | use std::cmp::min;\n\
    \   |\n\nerror[E0425]: cannot find value `min` in this scope\n  --> /tmp/tmpku4skd3s.rs:27:18\n\
    \   |\n27 |         if val < min {\n   |                  ^^^\n...\n43 | fn main()\
    \ {\n   | --------- similarly named function `main` defined here\n   |\nhelp:\
    \ a function with a similar name exists\n   |\n27 |         if val < main {\n\
    \   |                  ~~~~\nhelp: consider importing this function\n   |\n1 \
    \ | use std::cmp::min;\n   |\n\nerror[E0425]: cannot find value `min` in this\
    \ scope\n  --> /tmp/tmpku4skd3s.rs:28:13\n   |\n28 |             min = val\n \
    \  |             ^^^\n...\n43 | fn main() {\n   | --------- similarly named function\
    \ `main` defined here\n   |\nhelp: a function with a similar name exists\n   |\n\
    28 |             main = val\n   |             ~~~~\nhelp: consider importing this\
    \ function\n   |\n1  | use std::cmp::"
  stdout: ''
  timestamp: 1660009287
- exit_code: 101
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let len = arr.len();\n    let mut result = vec![arr[0]];\n\
    \    let mut largest = arr[0];\n    for i in 1..len {\n        if largest < arr[i]\
    \ {\n            largest = arr[i];\n        }\n        result[i] = largest;\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 1 but the
    index is 1'', /tmp/tmpl8_87u7u.rs:24:9

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut arr2: Vec<isize> = arr.clone();\n   \
    \ arr2.sort_by(|a, b| b.partial_cmp(&a).unwrap());\n    arr2.split_at(k).collect()\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzlev3wpe.rs:19:19\n   |\n\
    19 |     arr2.split_at(k).collect()\n   |                   ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n19 |     arr2.split_at(k.try_into().unwrap()).collect()\n\
    \   |                    ++++++++++++++++++++\n\nerror[E0599]: `(&[isize], &[isize])`\
    \ is not an iterator\n  --> /tmp/tmpzlev3wpe.rs:19:22\n   |\n19 |     arr2.split_at(k).collect()\n\
    \   |                      ^^^^^^^ `(&[isize], &[isize])` is not an iterator\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `(&[isize],\
    \ &[isize]): Iterator`\n           which is required by `&mut (&[isize], &[isize]):\
    \ Iterator`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    arr.par_iter().max_by_key(|&a| a).take(k).collect()\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `par_iter` found for struct `Vec<isize>`\
    \ in the current scope\n  --> /tmp/tmpjqcq3psw.rs:17:9\n   |\n17 |     arr.par_iter().max_by_key(|&a|\
    \ a).take(k).collect()\n   |         ^^^^^^^^ help: there is an associated function\
    \ with a similar name: `iter`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    arr.sort_by(|a, b| b.cmp(&a))\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcg1v_7t1.rs:17:5\n   |\n\
    16 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |             \
    \                             ---------- expected `Vec<isize>` because of return\
    \ type\n17 |     arr.sort_by(|a, b| b.cmp(&a))\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 || arr.len() <= k {\n        return\
    \ arr;\n    }\n    let mut arr = arr.to_vec();\n    arr.sort_unstable_by_key(|x|\
    \ x);\n    let mut res = vec![];\n    for i in 0..k {\n        if i < arr.len()\
    \ {\n            res.push(arr[i]);\n            arr.remove(i);\n        }\n  \
    \  }\n    return res.into_iter().cloned().collect();\n}\n\nfn main() {\n    let\
    \ candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpza5urckr.rs:17:31\n   |\n\
    17 |     if k == 0 || arr.len() <= k {\n   |                               ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     if k == 0 || arr.len()\
    \ <= k.try_into().unwrap() {\n   |                                ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpza5urckr.rs:24:16\n   |\n24 |\
    \         if i < arr.len() {\n   |                ^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n24 |         if i < arr.len().try_into().unwrap()\
    \ {\n   |                         ++++++++++++++++++++\n\nerror[E0277]: the type\
    \ `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpza5urckr.rs:25:22\n  \
    \ |\n25 |             res.push(arr[i]);\n   |                      ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpza5urckr.rs:26:24\n   |\n26 |             arr.remove(i);\n   |\
    \                        ^ expected `usize`, found `isize`\n   |\nhelp: you can\
    \ convert an `isize` to a `usize` and panic if the converted value doesn't fit\n\
    \   |\n26 |             arr.remove(i.try_into().unwrap());\n   |             \
    \            ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_so_far: Vec<isize> = vec![];\n  \
    \  let mut max_in_arr: isize = 0;\n    for ele in arr {\n        if ele > max_in_arr\
    \ {\n            max_in_arr = ele;\n        }\n        if ele == max_in_arr {\n\
    \            max_so_far.push(ele);\n        }\n    }\n    if max_in_arr >= k {\n\
    \        return max_so_far;\n    }\n    let mut max_so_far_slice: Vec<isize> =\
    \ max_so_far.to_vec();\n    let mut arr_slice: Vec<isize> = arr.to_vec();\n  \
    \  while max_in_arr > k {\n        max_in_arr -= 1;\n        max_so_far_slice\
    \ = max_so_far_slice.clone();\n        arr_slice = arr_slice.clone();\n      \
    \  max_so_far_slice[max_in_arr] = arr_slice[0];\n        arr_slice = arr_slice.slice(1);\n\
    \        max_so_far_slice[max_in_arr] = max_in_arr;\n    }\n    max_so_far.to_vec()\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpn0bi9nfd.rs:36:9\n\
    \   |\n36 |         max_so_far_slice[max_in_arr] = arr_slice[0];\n   |       \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of\
    \ `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0599]: no method named `slice` found for struct `Vec<isize>`\
    \ in the current scope\n  --> /tmp/tmpn0bi9nfd.rs:37:31\n   |\n37 |         arr_slice\
    \ = arr_slice.slice(1);\n   |                               ^^^^^\n   |\n   =\
    \ help: items from traits can only be used if the trait is in scope\nhelp: the\
    \ following trait is implemented but not in scope; perhaps add a `use` for it:\n\
    \   |\n1  | use std::collections::vec_deque::ring_slices::RingSlices;\n   |\n\
    help: there is an associated function with a similar name\n   |\n37 |        \
    \ arr_slice = arr_slice.as_slice(1);\n   |                               ~~~~~~~~\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpn0bi9nfd.rs:38:9\n\
    \   |\n38 |         max_so_far_slice[max_in_arr] = max_in_arr;\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    assert_eq!(arr.len(), k);\n    let mut result\
    \ = vec![std::i32::MAX; k];\n    let mut min_idx = k;\n    let mut min_val = arr[min_idx];\n\
    \    for i in 0..k {\n        let val = arr[i];\n        if val >= min_val {\n\
    \            result[i] = val;\n        } else {\n            min_idx = i;\n  \
    \          min_val = val;\n        }\n    }\n    result\n}\n\nfn main() {\n  \
    \  let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdhotsgr4.rs:17:5\n   |\n\
    17 |     assert_eq!(arr.len(), k);\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `usize`, found `isize`\n   |\n   = note: this error originates in the macro\
    \ `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpdhotsgr4.rs:18:42\n   |\n18 |\
    \     let mut result = vec![std::i32::MAX; k];\n   |                         \
    \                 ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    18 |     let mut result = vec![std::i32::MAX; k.try_into().unwrap()];\n   |  \
    \                                         ++++++++++++++++++++\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpdhotsgr4.rs:20:23\n\
    \   |\n20 |     let mut min_val = arr[min_idx];\n   |                       ^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpdhotsgr4.rs:22:19\n\
    \   |\n22 |         let val = arr[i];\n   |                   ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[i32]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpdhotsgr4.rs:24:13\n   |\n24 |            \
    \ result[i] = val;\n   |             ^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[i32]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_nums = Vec::with_capacity(k);\n \
    \   let mut min_nums = Vec::with_capacity(k);\n    let mut max_val = 0;\n    let\
    \ mut min_val = *arr.last().unwrap();\n    for i in arr.iter().rev() {\n     \
    \   let new_max = *i if *i > max_val { max_val = *i };\n        let new_min =\
    \ *i if *i < min_val { min_val = *i };\n        max_nums.push(new_max);\n    \
    \    min_nums.push(new_min);\n    }\n    max_nums\n        .iter()\n        .take_while(|&x|\
    \ x >= min_val)\n        .collect()\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `.`, `::`, `;`, `?`, `else`, `{`, or an operator,\
    \ found keyword `if`\n  --> /tmp/tmpsedbl7qo.rs:22:26\n   |\n22 |         let\
    \ new_max = *i if *i > max_val { max_val = *i };\n   |                       \
    \   ^^ expected one of 8 possible tokens\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpsedbl7qo.rs:17:43\n   |\n17 |     let mut max_nums = Vec::with_capacity(k);\n\
    \   |                                           ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n17 |     let mut max_nums = Vec::with_capacity(k.try_into().unwrap());\n\
    \   |                                            ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpsedbl7qo.rs:18:43\n   |\n18 |     let mut min_nums\
    \ = Vec::with_capacity(k);\n   |                                           ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n18 |     let mut min_nums\
    \ = Vec::with_capacity(k.try_into().unwrap());\n   |                         \
    \                   ++++++++++++++++++++\n\nerror[E0277]: can't compare `&_` with\
    \ `isize`\n  --> /tmp/tmpsedbl7qo.rs:29:28\n   |\n29 |         .take_while(|&x|\
    \ x >= min_val)\n   |                            ^^ no implementation for `&_\
    \ < isize` and `&_ > isize`\n   |\n   = help: the trait `PartialOrd<isize>` is\
    \ not implemented for `&_`\n\nerror[E0277]: a value of type `Vec<isize>` cannot\
    \ be built from an iterator over elements of type `&_`\n    --> /tmp/tmpsedbl7qo.rs:30:10\n\
    \     |\n30   |         .collect()\n     |          ^^^^^^^ value of type `Vec<isize>`\
    \ cannot be built from `std::iter::Iterator<Item=&_>`\n     |\n     = help: the\
    \ trait `FromIterator<&_>` is not implemented for `Vec<isize>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror: aborting due to 5 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rust"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k <= arr.len() {\n        arr.iter().take(k).max_by_key(|i|\
    \ i).collect()\n    } else {\n        vec![]\n    }\n}\n\nfn main() {\n    let\
    \ candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7j_mi1n0.rs:17:13\n   |\n\
    17 |     if k <= arr.len() {\n   |             ^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if k <= arr.len().try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp7j_mi1n0.rs:18:25\n   |\n18 |         arr.iter().take(k).max_by_key(|i|\
    \ i).collect()\n   |                         ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n18 |         arr.iter().take(k.try_into().unwrap()).max_by_key(|i|\
    \ i).collect()\n   |                          ++++++++++++++++++++\n\nerror[E0599]:\
    \ `Option<&isize>` is not an iterator\n   --> /tmp/tmp7j_mi1n0.rs:18:46\n    |\n\
    18  |           arr.iter().take(k).max_by_key(|i| i).collect()\n    |        \
    \                                        ^^^^^^^ `Option<&isize>` is not an iterator\n\
    \    |\n    = note: the following trait bounds were not satisfied:\n         \
    \   `Option<&isize>: Iterator`\n            which is required by `&mut Option<&isize>:\
    \ Iterator`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k <= 0 || k > arr.len() {\n        return\
    \ vec![];\n    }\n    if arr.len() <= k {\n        return vec![arr.iter().max().unwrap()];\n\
    \    }\n    let mut left = vec![arr.iter().skip(k).max().unwrap()];\n    let mut\
    \ right = vec![arr.iter().reverse().skip(k).max().unwrap()];\n    while left.len()\
    \ < k {\n        if right.len() > 0 {\n            left.push(right.pop());\n \
    \       }\n        if left.len() == k {\n            break;\n        }\n     \
    \   if right.len() > 0 {\n            left.push(right.pop());\n        }\n   \
    \ }\n    if left.len() < k {\n        left.extend(right);\n    }\n    left\n}\n\
    \nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwp4k3u15.rs:17:22\n   |\n\
    17 |     if k <= 0 || k > arr.len() {\n   |                      ^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     if k <= 0 || k\
    \ > arr.len().try_into().unwrap() {\n   |                               ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpwp4k3u15.rs:20:21\n   |\n20 |\
    \     if arr.len() <= k {\n   |                     ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n20 |     if arr.len() <= k.try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpwp4k3u15.rs:21:21\n   |\n21 |         return vec![arr.iter().max().unwrap()];\n\
    \   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n21 |         return vec![*arr.iter().max().unwrap()];\n\
    \   |                     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwp4k3u15.rs:23:41\n\
    \   |\n23 |     let mut left = vec![arr.iter().skip(k).max().unwrap()];\n   |\
    \                                         ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     let mut left = vec![arr.iter().skip(k.try_into().unwrap()).max().unwrap()];\n\
    \   |                                          ++++++++++++++++++++\n\nerror[E0599]:\
    \ no method named `reverse` found for struct `std::slice::Iter` in the current\
    \ scope\n  --> /tmp/tmpwp4k3u15.rs:24:37\n   |\n24 |     let mut right = vec![arr.iter().reverse().skip(k).max().unwrap()];\n\
    \   |                                     ^^^^^^^ method not found in `std::slice::Iter<'_,\
    \ isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwp4k3u15.rs:25:24\n\
    \   |\n25 |     while left.len() < k {\n   |                        ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_idx = 0;\n    let mut max_val = arr[0];\n\
    \    for (i, val) in arr.iter().enumerate() {\n        if val > max_val {\n  \
    \          max_idx = i;\n            max_val = val;\n        }\n    }\n    arr[max_idx..k].iter().collect()\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnw7smjfm.rs:20:18\n   |\n\
    20 |         if val > max_val {\n   |                  ^^^^^^^\n   |         \
    \         |\n   |                  expected `&isize`, found `isize`\n   |    \
    \              help: consider borrowing here: `&max_val`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpnw7smjfm.rs:22:23\n   |\n18 |     let mut max_val = arr[0];\n\
    \   |                       ------ expected due to this value\n...\n22 |     \
    \        max_val = val;\n   |                       ^^^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n22 |        \
    \     max_val = *val;\n   |                       +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpnw7smjfm.rs:25:18\n   |\n25 |     arr[max_idx..k].iter().collect()\n\
    \   |                  ^ expected `usize`, found `isize`\n\nerror[E0277]: a value\
    \ of type `Vec<isize>` cannot be built from an iterator over elements of type\
    \ `&isize`\n    --> /tmp/tmpnw7smjfm.rs:25:28\n     |\n25   |     arr[max_idx..k].iter().collect()\n\
    \     |                            ^^^^^^^ value of type `Vec<isize>` cannot be\
    \ built from `std::iter::Iterator<Item=&isize>`\n     |\n     = help: the trait\
    \ `FromIterator<&isize>` is not implemented for `Vec<isize>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k > arr.len() || k < 0 {\n        panic!(\"\
    k must be less than array len!\");\n    }\n    if k == 1 {\n        arr\n    }\
    \ else {\n        let mut max = arr[0];\n        for i in 1..k {\n           \
    \ if arr[i] > max {\n                max = arr[i];\n            }\n        }\n\
    \        vec![max]\n    }\n}\n\nfn main() {\n    let candidate = maximum;\n  \
    \  assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpg4lkfdq6.rs:17:12\n   |\n\
    17 |     if k > arr.len() || k < 0 {\n   |            ^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n17 |     if k > arr.len().try_into().unwrap()\
    \ || k < 0 {\n   |                     ++++++++++++++++++++\n\nerror[E0277]: the\
    \ type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpg4lkfdq6.rs:25:16\n\
    \   |\n25 |             if arr[i] > max {\n   |                ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpg4lkfdq6.rs:26:23\n   |\n26 |            \
    \     max = arr[i];\n   |                       ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let n = arr.len();\n    let mut max_arr = vec![0;\
    \ k];\n    for i in 0..k {\n        max_arr[i] = if arr[i] > max_arr[i] { arr[i]\
    \ } else { max_arr[i] };\n    }\n    for i in 0..k {\n        arr[i] = max_arr[i];\n\
    \    }\n    arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwt4r4md6.rs:18:31\n   |\n\
    18 |     let mut max_arr = vec![0; k];\n   |                               ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n18 |     let mut max_arr\
    \ = vec![0; k.try_into().unwrap()];\n   |                                ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpwt4r4md6.rs:20:9\n\
    \   |\n20 |         max_arr[i] = if arr[i] > max_arr[i] { arr[i] } else { max_arr[i]\
    \ };\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpwt4r4md6.rs:20:25\n\
    \   |\n20 |         max_arr[i] = if arr[i] > max_arr[i] { arr[i] } else { max_arr[i]\
    \ };\n   |                         ^^^^^^ slice indices are of type `usize` or\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[{integer}]` cannot be indexed by\
    \ `isize`\n  --> /tmp/tmpwt4r4md6.rs:20:34\n   |\n20 |         max_arr[i] = if\
    \ arr[i] > max_arr[i] { arr[i] } else { max_arr[i] };\n   |                  \
    \                ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpwt4r4md6.rs:20:47\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if arr.len() < k {\n        return arr;\n   \
    \ }\n\n    let mut max = arr[0];\n    for i in arr.iter().skip(k) {\n        if\
    \ i > max {\n            max = i;\n        }\n    }\n    \n    Vec::from(max..arr.len()\
    \ as isize)\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprnfho4k9.rs:17:20\n   |\n\
    17 |     if arr.len() < k {\n   |                    ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if arr.len() < k.try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmprnfho4k9.rs:22:30\n   |\n22 |     for i in arr.iter().skip(k)\
    \ {\n   |                              ^ expected `usize`, found `isize`\n   |\n\
    help: you can convert an `isize` to a `usize` and panic if the converted value\
    \ doesn't fit\n   |\n22 |     for i in arr.iter().skip(k.try_into().unwrap())\
    \ {\n   |                               ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmprnfho4k9.rs:23:16\n   |\n23 |         if i >\
    \ max {\n   |                ^^^\n   |                |\n   |                expected\
    \ `&isize`, found `isize`\n   |                help: consider borrowing here:\
    \ `&max`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprnfho4k9.rs:24:19\n\
    \   |\n21 |     let mut max = arr[0];\n   |                   ------ expected\
    \ due to this value\n...\n24 |             max = i;\n   |                   ^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n24 |             max = *i;\n   |                   +\n\nerror[E0277]: the\
    \ trait bound `Vec<_, _>: From<std::ops::Range<isize>>` is not satisfied\n  -->\
    \ /tmp/tmprnfho4k9.rs:28:5\n   |\n28 |     Vec::from(max..arr.len() as isize)\n\
    \   |     ^^^^^^^^^ the trait `From<std::ops::Range<isize>>` is not implemented\
    \ for `Vec<_, _>`\n   |\n   = help: the following other types implement trait\
    \ `From<T>`:\n             <Vec<T, A> as From<Box<[T], A>>>\n             <Vec<T,\
    \ A> as From<VecDeque<T, A>>>\n             <Vec<T> as From<&[T]>>\n         \
    \    <Vec<T> as From<&mut [T]>>\n             <Vec<T> as From<BinaryHeap<T>>>\n\
    \             <Vec<T> as From<Cow<'a, [T]>>>\n             <Vec<T> as From<[T;\
    \ N]>>\n             <Vec<u8> as From<&str>>\n           and 2 others\n\nerror:\
    \ abortin"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max: isize = arr[0];\n    let mut max_idx:\
    \ usize = 0;\n    let mut idx: usize = 0;\n    while idx < k {\n        let cur\
    \ = arr[idx];\n        if cur > max {\n            max = cur;\n            max_idx\
    \ = idx;\n        }\n        idx += 1;\n    }\n    let mut arr = vec![];\n   \
    \ for i in arr.iter_mut() {\n        *i = arr[max_idx];\n        arr[max_idx]\
    \ = i;\n    }\n    arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj7pzk5dj.rs:20:17\n   |\n\
    20 |     while idx < k {\n   |                 ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     while idx < k.try_into().unwrap() {\n   |\
    \                  ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpj7pzk5dj.rs:31:24\n   |\n31 |         arr[max_idx] = i;\n   |      \
    \                  ^- help: try using a conversion method: `.to_string()`\n  \
    \ |                        |\n   |                        cyclic type of infinite\
    \ size\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if arr.len() < k {\n        vec![]\n    } else\
    \ if arr.len() == k {\n        arr\n    } else if arr.len() > k {\n        arr.iter().take(k).collect()\n\
    \    } else {\n        vec![]\n    }\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6nlyofti.rs:17:20\n   |\n\
    17 |     if arr.len() < k {\n   |                    ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if arr.len() < k.try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp6nlyofti.rs:19:28\n   |\n19 |     } else if arr.len() ==\
    \ k {\n   |                            ^ expected `usize`, found `isize`\n   |\n\
    help: you can convert an `isize` to a `usize` and panic if the converted value\
    \ doesn't fit\n   |\n19 |     } else if arr.len() == k.try_into().unwrap() {\n\
    \   |                             ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp6nlyofti.rs:21:27\n   |\n21 |     } else if arr.len() >\
    \ k {\n   |                           ^ expected `usize`, found `isize`\n   |\n\
    help: you can convert an `isize` to a `usize` and panic if the converted value\
    \ doesn't fit\n   |\n21 |     } else if arr.len() > k.try_into().unwrap() {\n\
    \   |                            ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp6nlyofti.rs:22:25\n   |\n22 |         arr.iter().take(k).collect()\n\
    \   |                         ^ expected `usize`, found `isize`\n   |\nhelp: you\
    \ can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n22 |         arr.iter().take(k.try_into().unwrap()).collect()\n \
    \  |                          ++++++++++++++++++++\n\nerror[E0277]: a value of\
    \ type `Vec<isize>` cannot be built from an iterator over elements of type `&isize`\n\
    \    --> /tmp/tmp6nlyofti.rs:22:28\n     |\n22   |         arr.iter().take(k).collect()\n\
    \     |                            ^^^^^^^ value of type `Vec<isize>` cannot be\
    \ built from `std::iter::Iterator<Item=&isize>`\n     |\n     = help: the trait\
    \ `FromIterator<&isize>` is not implemented for `Vec<isize>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror: aborting due to 5 previous e"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max = vec![0; k];\n\n    for i in arr.iter().rev()\
    \ {\n        if max < i {\n            max = i;\n        }\n    }\n\n    max.rev()\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzkz2kdl6.rs:17:27\n   |\n\
    17 |     let mut max = vec![0; k];\n   |                           ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     let mut max = vec![0;\
    \ k.try_into().unwrap()];\n   |                            ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpzkz2kdl6.rs:20:18\n   |\n20 |\
    \         if max < i {\n   |                  ^ expected struct `Vec`, found `&isize`\n\
    \   |\n   = note: expected struct `Vec<{integer}>`\n           found reference\
    \ `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzkz2kdl6.rs:21:19\n\
    \   |\n17 |     let mut max = vec![0; k];\n   |                   ---------- expected\
    \ due to this value\n...\n21 |             max = i;\n   |                   ^\
    \ expected struct `Vec`, found `&isize`\n   |\n   = note: expected struct `Vec<{integer}>`\n\
    \           found reference `&isize`\n\nerror[E0599]: `Vec<{integer}>` is not\
    \ an iterator\n   --> /tmp/tmpzkz2kdl6.rs:25:9\n    |\n25  |       max.rev()\n\
    \    |           ^^^ `Vec<{integer}>` is not an iterator\n    |\n    = note: the\
    \ following trait bounds were not satisfied:\n            `Vec<{integer}>: Iterator`\n\
    \            which is required by `&mut Vec<{integer}>: Iterator`\n          \
    \  `[{integer}]: Iterator`\n            which is required by `&mut [{integer}]:\
    \ Iterator`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut result = vec![vec![0]; k];\n    if arr.len()\
    \ < k || k > arr.len() {\n        return result;\n    }\n    let mut maxnum =\
    \ arr[0];\n    for v in &arr {\n        if maxnum < v {\n            maxnum =\
    \ v;\n        }\n    }\n    for i in 0..k {\n        if maxnum < arr[i] {\n  \
    \          result[i] = maxnum;\n        } else {\n            result[i] = arr[i];\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpara71dk3.rs:17:36\n   |\n\
    17 |     let mut result = vec![vec![0]; k];\n   |                            \
    \        ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n17 |     let\
    \ mut result = vec![vec![0]; k.try_into().unwrap()];\n   |                   \
    \                  ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpara71dk3.rs:18:20\n   |\n18 |     if arr.len() < k || k > arr.len()\
    \ {\n   |                    ^ expected `usize`, found `isize`\n   |\nhelp: you\
    \ can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n18 |     if arr.len() < k.try_into().unwrap() || k > arr.len() {\n\
    \   |                     ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpara71dk3.rs:18:29\n   |\n18 |     if arr.len() < k || k > arr.len()\
    \ {\n   |                             ^^^^^^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n18 |     if arr.len() < k || k > arr.len().try_into().unwrap()\
    \ {\n   |                                      ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpara71dk3.rs:19:16\n   |\n16 | fn maximum(arr:\
    \ Vec<isize>, k: isize) -> Vec<isize> {\n   |                                \
    \          ---------- expected `Vec<isize>` because of return type\n...\n19 |\
    \         return result;\n   |                ^^^^^^ expected `isize`, found struct\
    \ `Vec`\n   |\n   = note: expected struct `Vec<isize>`\n              found struct\
    \ `Vec<Vec<{integer}>>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpara71dk3.rs:23:21\n\
    \   |\n23 |         if maxnum < v {\n   |                     ^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n23 |  \
    \       if maxnum < *v {\n   |                     +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpara71dk3.rs:24:22\n   |\n21 |     let mut maxnum = arr[0];\n\
    \   |                      ------ expected due"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    // \u5229\u7528\u6298\u534A\u67E5\u627E\n   \
    \ let mut left = 0\n    let mut right = arr.len() - k\n    while left <= right\
    \ {\n        if arr[left] > arr[right] {\n            let tmp = arr[left]\n  \
    \          arr[left] = arr[right]\n            arr[right] = tmp\n        }\n \
    \       left += 1\n        right -= 1\n    }\n    arr\n}\n\nfn main() {\n    let\
    \ candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found keyword `let`\n  --> /tmp/tmp9xjkms62.rs:18:21\n\
    \   |\n18 |     let mut left = 0\n   |                     ^ help: add `;` here\n\
    19 |     let mut right = arr.len() - k\n   |     --- unexpected token\n\nerror:\
    \ expected `;`, found keyword `while`\n  --> /tmp/tmp9xjkms62.rs:19:34\n   |\n\
    19 |     let mut right = arr.len() - k\n   |                                 \
    \ ^ help: add `;` here\n20 |     while left <= right {\n   |     ----- unexpected\
    \ token\n\nerror: expected `;`, found `arr`\n  --> /tmp/tmp9xjkms62.rs:22:32\n\
    \   |\n22 |             let tmp = arr[left]\n   |                            \
    \    ^ help: add `;` here\n23 |             arr[left] = arr[right]\n   |     \
    \        --- unexpected token\n\nerror: expected `;`, found `arr`\n  --> /tmp/tmp9xjkms62.rs:23:35\n\
    \   |\n23 |             arr[left] = arr[right]\n   |                         \
    \          ^ help: add `;` here\n24 |             arr[right] = tmp\n   |     \
    \        --- unexpected token\n\nerror: expected `;`, found `right`\n  --> /tmp/tmp9xjkms62.rs:26:18\n\
    \   |\n26 |         left += 1\n   |                  ^ help: add `;` here\n27\
    \ |         right -= 1\n   |         ----- unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp9xjkms62.rs:19:33\n   |\n19 |     let mut right = arr.len()\
    \ - k\n   |                                 ^ expected `usize`, found `isize`\n\
    \nerror[E0277]: cannot subtract `isize` from `usize`\n  --> /tmp/tmp9xjkms62.rs:19:31\n\
    \   |\n19 |     let mut right = arr.len() - k\n   |                          \
    \     ^ no implementation for `usize - isize`\n   |\n   = help: the trait `Sub<isize>`\
    \ is not implemented for `usize`\n   = help: the following other types implement\
    \ trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n             <&'a f64\
    \ as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n             <&'a i16 as\
    \ Sub<i16>>\n             <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n\
    \             <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n  \
    \         and 48 others\n\nerror: aborting due to 7 previous errors\n\nSome errors\
    \ have detailed explana"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k > arr.len() {\n        return vec![];\n\
    \    }\n    if k == 0 {\n        return vec![];\n    }\n\n    let mut maximums\
    \ = vec![];\n    for i in 0..k {\n        let max_elem = &arr[k - 1 - i];\n  \
    \      maximums.push(max_elem > arr[i] ? max_elem : arr[i]);\n    }\n    vec![maximums[0]]\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error: casts cannot be followed by indexing\n  --> /tmp/tmpu29lkkrq.rs:27:43\n\
    \   |\n27 |         maximums.push(max_elem > arr[i] ? max_elem : arr[i]);\n  \
    \ |                                           ^^^^^^^^------\n   |           \
    \                                        |\n   |                             \
    \                      help: remove the type ascription\n\nerror: expected one\
    \ of `)`, `,`, `.`, `?`, or an operator, found `max_elem`\n  --> /tmp/tmpu29lkkrq.rs:27:43\n\
    \   |\n27 |         maximums.push(max_elem > arr[i] ? max_elem : arr[i]);\n  \
    \ |                                          -^^^^^^^^ expected one of `)`, `,`,\
    \ `.`, `?`, or an operator\n   |                                          |\n\
    \   |                                          help: missing `,`\n\nerror[E0573]:\
    \ expected type, found local variable `arr`\n  --> /tmp/tmpu29lkkrq.rs:27:54\n\
    \   |\n27 |         maximums.push(max_elem > arr[i] ? max_elem : arr[i]);\n  \
    \ |                                                      ^^^ expecting a type\
    \ here because of type ascription\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpu29lkkrq.rs:17:12\n\
    \   |\n17 |     if k > arr.len() {\n   |            ^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n17 |     if k > arr.len().try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpu29lkkrq.rs:26:25\n   |\n26 |  \
    \       let max_elem = &arr[k - 1 - i];\n   |                         ^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpu29lkkrq.rs:27:34\n\
    \   |\n27 |         maximums.push(max_elem > arr[i] ? max_elem : arr[i]);\n  \
    \ |                "
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr: Vec<isize> = vec![];\n    let\
    \ len = arr.len();\n    if k > len {\n        return max_arr;\n    }\n    for\
    \ i in 0..k {\n        max_arr.push(arr[i]);\n    }\n    max_arr.sort();\n   \
    \ return max_arr;\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkte2jhvf.rs:19:12\n   |\n\
    19 |     if k > len {\n   |            ^^^ expected `isize`, found `usize`\n \
    \  |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n19 |     if k > len.try_into().unwrap() {\n   |   \
    \            ++++++++++++++++++++\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpkte2jhvf.rs:23:22\n   |\n23 |         max_arr.push(arr[i]);\n\
    \   |                      ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if arr.len() <= k {\n        return arr\n   \
    \ }\n\n    // If k >= len(arr), then we can just return arr.\n    if k >= arr.len()\
    \ {\n        return arr\n    }\n\n    // Find the max number's index.\n    let\
    \ max_index = arr.iter().enumerate().max_by(|(_, i)| i.1).unwrap().0\n    let\
    \ max_value = arr[max_index]\n    let max_k = k - 1;\n\n    // Remove all elements\
    \ in the range [max_k, max_value].\n    let mut new_arr = [max_value; k];\n  \
    \  for i in 0..k {\n        if arr[i] > max_value {\n            break;\n    \
    \    }\n        new_arr[i] = arr[i];\n    }\n\n    // Add max_value to the end\
    \ of the array.\n    new_arr[k] = max_value;\n\n    vec::from_iter(new_arr.clone())\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found keyword `let`\n  --> /tmp/tmp1aox1irg.rs:27:75\n\
    \   |\n27 |     let max_index = arr.iter().enumerate().max_by(|(_, i)| i.1).unwrap().0\n\
    \   |                                                                        \
    \   ^ help: add `;` here\n28 |     let max_value = arr[max_index]\n   |     ---\
    \ unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp1aox1irg.rs:28:35\n\
    \   |\n28 |     let max_value = arr[max_index]\n   |                         \
    \          ^ help: add `;` here\n29 |     let max_k = k - 1;\n   |     --- unexpected\
    \ token\n\nerror[E0435]: attempt to use a non-constant value in a constant\n \
    \ --> /tmp/tmp1aox1irg.rs:32:35\n   |\n16 | fn maximum(arr: Vec<isize>, k: isize)\
    \ -> Vec<isize> {\n   |                             - this would need to be a\
    \ `const`\n...\n32 |     let mut new_arr = [max_value; k];\n   |             \
    \                      ^\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ crate or module `vec`\n  --> /tmp/tmp1aox1irg.rs:43:5\n   |\n43 |     vec::from_iter(new_arr.clone())\n\
    \   |     ^^^ use of undeclared crate or module `vec`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp1aox1irg.rs:17:21\n   |\n17 |     if arr.len() <= k {\n\
    \   |                     ^ expected `usize`, found `isize`\n   |\nhelp: you can\
    \ convert an `isize` to a `usize` and panic if the converted value doesn't fit\n\
    \   |\n17 |     if arr.len() <= k.try_into().unwrap() {\n   |                \
    \      ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1aox1irg.rs:22:13\n\
    \   |\n22 |     if k >= arr.len() {\n   |             ^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n22 |     if k >= arr.len().try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0593]: closure is\
    \ expected to take 2 distinct arguments, but it takes a single 2-tuple as argument\n\
    \  --> /tmp/tmp1aox1irg.rs:27:44\n   |\n27 |     let max_index = arr.iter().enumerate().max_by(|(_,\
    \ i)| i.1).unwrap().0\n   |                           "
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut arr = arr.clone();\n    arr.sort_unstable_by(|a,\
    \ b| a.cmp(b));\n    let mut result = vec![];\n    result.extend(arr[..k].iter().cloned());\n\
    \    result\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `RangeTo<isize>`\n\
    \  --> /tmp/tmpe826tgi_.rs:20:19\n   |\n20 |     result.extend(arr[..k].iter().cloned());\n\
    \   |                   ^^^^^^^^ slice indices are of type `usize` or ranges of\
    \ `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `RangeTo<isize>`\n   = help: the following other types implement trait `SliceIndex<T>`:\n\
    \             <RangeTo<usize> as SliceIndex<[T]>>\n             <RangeTo<usize>\
    \ as SliceIndex<str>>\n   = note: required because of the requirements on the\
    \ impl of `Index<RangeTo<isize>>` for `Vec<isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    assert!(k <= arr.len(), \"invalid k\")\n    arr.iter().cloned().max_by(|a,\
    \ b| a.cmp(b))\n    .take_while(|&i| i <= k).cloned()\n}\n\nfn main() {\n    let\
    \ candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `arr`\n  --> /tmp/tmp3racx1sg.rs:17:41\n   |\n\
    17 |     assert!(k <= arr.len(), \"invalid k\")\n   |                        \
    \                 ^ help: add `;` here\n18 |     arr.iter().cloned().max_by(|a,\
    \ b| a.cmp(b))\n   |     --- unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp3racx1sg.rs:17:18\n   |\n17 |     assert!(k <= arr.len(), \"invalid\
    \ k\")\n   |                  ^^^^^^^^^ expected `isize`, found `usize`\n   |\n\
    help: you can convert a `usize` to an `isize` and panic if the converted value\
    \ doesn't fit\n   |\n17 |     assert!(k <= arr.len().try_into().unwrap(), \"invalid\
    \ k\")\n   |                           ++++++++++++++++++++\n\nerror[E0599]: `Option<isize>`\
    \ is not an iterator\n   --> /tmp/tmp3racx1sg.rs:19:6\n    |\n19  |       .take_while(|&i|\
    \ i <= k).cloned()\n    |        ^^^^^^^^^^ `Option<isize>` is not an iterator\n\
    \    |\n    = note: the following trait bounds were not satisfied:\n         \
    \   `Option<isize>: Iterator`\n            which is required by `&mut Option<isize>:\
    \ Iterator`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    assert!(k > 0 && k <= arr.len(), \"k must be\
    \ positive, be smaller than length of array\")\n    let mut maxs = arr.clone();\n\
    \    maxs.sort_unstable_by_key(|i| i);\n    \n    maxs.resize(k, maxs[0]);\n \
    \   maxs\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found keyword `let`\n  --> /tmp/tmpw9ivybek.rs:17:92\n\
    \   |\n17 |     assert!(k > 0 && k <= arr.len(), \"k must be positive, be smaller\
    \ than length of array\")\n   |                                              \
    \                                              ^ help: add `;` here\n18 |    \
    \ let mut maxs = arr.clone();\n   |     --- unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpw9ivybek.rs:17:27\n   |\n17 |     assert!(k\
    \ > 0 && k <= arr.len(), \"k must be positive, be smaller than length of array\"\
    )\n   |                           ^^^^^^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n17 |     assert!(k > 0 && k <= arr.len().try_into().unwrap(),\
    \ \"k must be positive, be smaller than length of array\")\n   |             \
    \                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpw9ivybek.rs:21:17\n   |\n21 |     maxs.resize(k, maxs[0]);\n  \
    \ |                 ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    21 |     maxs.resize(k.try_into().unwrap(), maxs[0]);\n   |                  ++++++++++++++++++++\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let len = arr.len();\n    if k >= len {\n   \
    \     arr\n    } else {\n        let max_value = arr.iter().max().unwrap();\n\
    \        let mut sorted_arr = Vec::new();\n        for v in arr.iter().take(k)\
    \ {\n            if v > max_value {\n                sorted_arr.push(max_value);\n\
    \                sorted_arr.push(v);\n            } else {\n                sorted_arr.push(v);\n\
    \            }\n        }\n        sorted_arr\n    }\n}\n\nfn main() {\n    let\
    \ candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqd3z6aoq.rs:18:13\n   |\n\
    18 |     if k >= len {\n   |             ^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n18 |     if k >= len.try_into().unwrap() {\n   |  \
    \              ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqd3z6aoq.rs:23:34\n\
    \   |\n23 |         for v in arr.iter().take(k) {\n   |                      \
    \            ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an\
    \ `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n23\
    \ |         for v in arr.iter().take(k.try_into().unwrap()) {\n   |          \
    \                         ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpqd3z6aoq.rs:31:9\n   |\n16 | fn maximum(arr: Vec<isize>, k: isize)\
    \ -> Vec<isize> {\n   |                                          ---------- expected\
    \ `Vec<isize>` because of return type\n...\n31 |         sorted_arr\n   |    \
    \     ^^^^^^^^^^ expected `isize`, found `&isize`\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n              found struct `Vec<&isize>`\n\nerror: aborting due\
    \ to 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max = vec![T::default(); k];\n    for\
    \ i in 0..arr.len() {\n        if arr[i] > max[k] {\n            max[k] = arr[i];\n\
    \        }\n    }\n    max\n}\n\nfn main() {\n    let candidate = maximum;\n \
    \   assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `T`\n  --> /tmp/tmpp064lkmi.rs:17:24\n\
    \   |\n17 |     let mut max = vec![T::default(); k];\n   |                   \
    \     ^ use of undeclared type `T`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp064lkmi.rs:17:38\n\
    \   |\n17 |     let mut max = vec![T::default(); k];\n   |                   \
    \                   ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    17 |     let mut max = vec![T::default(); k.try_into().unwrap()];\n   |      \
    \                                 ++++++++++++++++++++\n\nerror[E0277]: the type\
    \ `[_]` cannot be indexed by `isize`\n  --> /tmp/tmpp064lkmi.rs:19:21\n   |\n\
    19 |         if arr[i] > max[k] {\n   |                     ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<_>`\n\nerror[E0277]: the type `[_]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpp064lkmi.rs:20:13\n   |\n20 |             max[k] =\
    \ arr[i];\n   |             ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<_>`\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308, E0433.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k > arr.len() {\n        vec![]\n    } else\
    \ {\n        let mut max = arr[0];\n        for i in 1..k {\n            if max\
    \ < arr[i] {\n                max = arr[i];\n            }\n        }\n      \
    \  vec![max]\n    }\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5oddgklb.rs:17:12\n   |\n\
    17 |     if k > arr.len() {\n   |            ^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if k > arr.len().try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp5oddgklb.rs:22:22\n   |\n22 |  \
    \           if max < arr[i] {\n   |                      ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp5oddgklb.rs:23:23\n   |\n23 |            \
    \     max = arr[i];\n   |                       ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_vec = Vec::with_capacity(arr.len());\n\
    \    let mut max_num = arr[0] as isize;\n    for &num in arr.iter() {\n      \
    \  if num > max_num {\n            max_num = num;\n        }\n    }\n    for num\
    \ in arr.iter() {\n        if num == max_num {\n            let index = max_vec.iter().position(|x|\
    \ x == num).unwrap();\n            if index >= k {\n                let mut max_vec\
    \ = Vec::with_capacity(arr.len() - index);\n                for &num in arr.iter()\
    \ {\n                    max_vec.push(num);\n                }\n             \
    \   max_vec\n            } else if index == k {\n                max_vec\n   \
    \         } else if index > k {\n                let mut max_vec = Vec::with_capacity(arr.len()\
    \ - k);\n                for &num in arr.iter() {\n                    max_vec.push(num);\n\
    \                }\n                max_vec\n            } else {\n          \
    \      max_vec\n            }\n        } else {\n            if num > max_num\
    \ {\n                max_vec.push(num);\n            }\n        }\n    }\n   \
    \ max_vec\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpqeobptac.rs:25:16\n\
    \   |\n25 |         if num == max_num {\n   |                ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpqeobptac.rs:27:25\n   |\n27 |             if index >= k {\n   |    \
    \                     ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    27 |             if index >= k.try_into().unwrap() {\n   |                   \
    \       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqeobptac.rs:32:17\n\
    \   |\n27 | /             if index >= k {\n28 | |                 let mut max_vec\
    \ = Vec::with_capacity(arr.len() - index);\n29 | |                 for &num in\
    \ arr.iter() {\n30 | |                     max_vec.push(num);\n31 | |        \
    \         }\n32 | |                 max_vec\n   | |                 ^^^^^^^ expected\
    \ `()`, found struct `Vec`\n...  |\n42 | |                 max_vec\n43 | |   \
    \          }\n   | |_____________- expected this to be `()`\n   |\n   = note:\
    \ expected unit type `()`\n                 found struct `Vec<isize>`\nhelp: you\
    \ might have meant to return this value\n   |\n32 |                 return max_vec;\n\
    \   |                 ++++++        +\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpqeobptac.rs:33:32\n   |\n33 |             } else if index == k {\n \
    \  |                                ^ expected `usize`, found `isize`\n   |\n\
    help: you can convert an `isize` to a `usize` and panic if the converted value\
    \ doesn't fit\n   |\n33 |             } else if index == k.try_into().unwrap()\
    \ {\n   |                                 ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpqeobptac.rs:34:17\n   |\n33 |"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    arr.sort().take_while(|&x| x <= arr.iter().skip(k).max().unwrap()).collect()\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: `()` is not an iterator\n  --> /tmp/tmp3pu_kr4t.rs:17:16\n\
    \   |\n17 |     arr.sort().take_while(|&x| x <= arr.iter().skip(k).max().unwrap()).collect()\n\
    \   |                ^^^^^^^^^^ `()` is not an iterator\n   |\n   = note: the\
    \ following trait bounds were not satisfied:\n           `(): Iterator`\n    \
    \       which is required by `&mut (): Iterator`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp3pu_kr4t.rs:17:53\n   |\n17 |     arr.sort().take_while(|&x| x\
    \ <= arr.iter().skip(k).max().unwrap()).collect()\n   |                      \
    \                               ^ expected `usize`, found `isize`\n   |\nhelp:\
    \ you can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n17 |     arr.sort().take_while(|&x| x <= arr.iter().skip(k.try_into().unwrap()).max().unwrap()).collect()\n\
    \   |                                                      ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if arr.len() <= k {\n        arr\n    } else\
    \ {\n        let mut max: isize = 0;\n        let mut max_idx: usize = -1;\n \
    \       for &element in &arr {\n            if max < element {\n             \
    \   max = element;\n                max_idx = arr.len() - 1;\n            }\n\
    \            assert!(max <= element && element <= arr[k], \"invalid element\"\
    );\n        }\n        let mut temp_vec: Vec<isize> = vec![max];\n        for\
    \ i in 0..k {\n            temp_vec[i] = arr[i + max_idx];\n        }\n      \
    \  temp_vec\n    }\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppil99com.rs:17:21\n   |\n\
    17 |     if arr.len() <= k {\n   |                     ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if arr.len() <= k.try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0600]: cannot apply\
    \ unary operator `-` to type `usize`\n  --> /tmp/tmppil99com.rs:21:34\n   |\n\
    21 |         let mut max_idx: usize = -1;\n   |                              \
    \    ^^\n   |                                  |\n   |                       \
    \           cannot apply unary operator `-`\n   |                            \
    \      help: you may have meant the maximum value of `usize`: `usize::MAX`\n \
    \  |\n   = note: unsigned values cannot be negated\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmppil99com.rs:27:50\n   |\n27 |  \
    \           assert!(max <= element && element <= arr[k], \"invalid element\");\n\
    \   |                                                  ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmppil99com.rs:31:13\n   |\n31 |            \
    \ temp_vec[i] = arr[i + max_idx];\n   |             ^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppil99com.rs:31:35\n\
    \   |\n31 |             temp_vec[i] = arr[i + max_idx];\n   |                \
    \                   ^^^^^^^ expected `isize`, found `usize`\n\nerror[E0277]: cannot\
    \ add `usize` to `"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max = arr[0];\n    let mut max_idx =\
    \ 1;\n    for i in 1..arr.len() {\n        if arr[i] > max {\n            max\
    \ = arr[i];\n            max_idx = i;\n        }\n    }\n    let mut result =\
    \ vec![max];\n    for i in 1..k {\n        result.push(arr[max_idx - i]);\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0qxbm_j8.rs:27:35\n   |\n\
    27 |         result.push(arr[max_idx - i]);\n   |                            \
    \       ^ expected `usize`, found `isize`\n\nerror[E0277]: cannot subtract `isize`\
    \ from `usize`\n  --> /tmp/tmp0qxbm_j8.rs:27:33\n   |\n27 |         result.push(arr[max_idx\
    \ - i]);\n   |                                 ^ no implementation for `usize\
    \ - isize`\n   |\n   = help: the trait `Sub<isize>` is not implemented for `usize`\n\
    \   = help: the following other types implement trait `Sub<Rhs>`:\n          \
    \   <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n             <&'a\
    \ i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n             <&'a i32\
    \ as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n\
    \             <&'a isize as Sub<isize>>\n           and 48 others\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let len = arr.len();\n    if k >= len {\n   \
    \     return vec![];\n    }\n\n    let mut max = arr[k..].iter().max();\n    let\
    \ mut arr = arr.iter().skip(k).collect();\n    arr.push((*max).unwrap());\n  \
    \  return arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_7e1qxye.rs:18:13\n   |\n\
    18 |     if k >= len {\n   |             ^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n18 |     if k >= len.try_into().unwrap() {\n   |  \
    \              ++++++++++++++++++++\n\nerror[E0277]: the type `[isize]` cannot\
    \ be indexed by `RangeFrom<isize>`\n  --> /tmp/tmp_7e1qxye.rs:22:19\n   |\n22\
    \ |     let mut max = arr[k..].iter().max();\n   |                   ^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `RangeFrom<isize>`\n   =\
    \ help: the following other types implement trait `SliceIndex<T>`:\n         \
    \    <RangeFrom<usize> as SliceIndex<[T]>>\n             <RangeFrom<usize> as\
    \ SliceIndex<str>>\n   = note: required because of the requirements on the impl\
    \ of `Index<RangeFrom<isize>>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp_7e1qxye.rs:23:35\n   |\n23 |     let mut arr = arr.iter().skip(k).collect();\n\
    \   |                                   ^ expected `usize`, found `isize`\n  \
    \ |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     let mut arr = arr.iter().skip(k.try_into().unwrap()).collect();\n\
    \   |                                    ++++++++++++++++++++\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max: isize = 0;\n    for i in arr.iter()\
    \ {\n        if max < i {\n            max = i;\n        }\n    }\n    arr.drain(max..=k+1).collect()\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4rpbloso.rs:19:18\n   |\n\
    19 |         if max < i {\n   |                  ^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n19 |         if max < *i\
    \ {\n   |                  +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4rpbloso.rs:20:19\n\
    \   |\n17 |     let mut max: isize = 0;\n   |                  ----- expected\
    \ due to this type\n...\n20 |             max = i;\n   |                   ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    20 |             max = *i;\n   |                   +\n\nerror[E0277]: the trait\
    \ bound `RangeInclusive<isize>: RangeBounds<usize>` is not satisfied\n    -->\
    \ /tmp/tmp4rpbloso.rs:23:15\n     |\n23   |     arr.drain(max..=k+1).collect()\n\
    \     |         ----- ^^^^^^^^^ the trait `RangeBounds<usize>` is not implemented\
    \ for `RangeInclusive<isize>`\n     |         |\n     |         required by a\
    \ bound introduced by this call\n     |\n     = help: the following other types\
    \ implement trait `RangeBounds<T>`:\n               RangeInclusive<&T>\n     \
    \          RangeInclusive<T>\nnote: required by a bound in `Vec::<T, A>::drain`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 101
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut result = vec![];\n    for elem in arr\
    \ {\n        if k <= elem {\n            result.push(elem);\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5]`,\n right: `[-4, -3, 5]`', /tmp/tmpkht6h1rl.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_val = vec![0; k + 1];\n    let mut\
    \ max_idx = k;\n    let mut cur = 0;\n    let len = arr.len();\n    let mut idx\
    \ = 0;\n    for (i, &v) in arr.iter().enumerate() {\n        if v > &max_val[max_idx]\
    \ {\n            max_val[max_idx] = v;\n            max_idx = max_idx;\n     \
    \   }\n        if i < len {\n            if v > &arr[cur] {\n                max_val[max_idx]\
    \ = v;\n                max_idx = max_idx;\n            }\n            idx +=\
    \ 1;\n        }\n        cur += 1;\n    }\n    max_val\n}\n\nfn main() {\n   \
    \ let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzp6iv6hj.rs:17:31\n   |\n\
    17 |     let mut max_val = vec![0; k + 1];\n   |                             \
    \  ^^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n17 |     let\
    \ mut max_val = vec![0; (k + 1).try_into().unwrap()];\n   |                  \
    \             +     +++++++++++++++++++++\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpzp6iv6hj.rs:23:17\n   |\n23 |  \
    \       if v > &max_val[max_idx] {\n   |                 ^^^^^^^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpzp6iv6hj.rs:23:16\n   |\n23 |         if v >\
    \ &max_val[max_idx] {\n   |                ^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found reference\n   |\n   = note:   expected type `isize`\n           found\
    \ reference `&_`\nhelp: consider removing the borrow\n   |\n23 -         if v\
    \ > &max_val[max_idx] {\n23 +         if v > max_val[max_idx] {\n   | \n\nerror[E0277]:\
    \ the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpzp6iv6hj.rs:24:13\n\
    \   |\n24 |             max_val[max_idx] = v;\n   |             ^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpzp6iv6hj.rs:28:20\n   |\n28 |             if\
    \ v > &arr[cur] {\n   |                    ^^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider removing the borrow\n   |\n28 -             if v > &arr[cur]\
    \ {\n28 +             if v > arr[cur] {\n   |"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    assert!(k <= arr.len(), \"k should be less or\
    \ equal to len(arr)\");\n    let mut max_element = *arr.iter().max_by_key(|&x|\
    \ x);\n    if k == 1 {\n        vec![max_element]\n    } else {\n        if k\
    \ > 1 {\n            max_element = maximum(&arr[..k - 1], k - 1);\n        }\n\
    \        vec![max_element] + maximum(&arr[k..], k)\n    }\n}\n\nfn main() {\n\
    \    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpaedp09h9.rs:17:18\n   |\n\
    17 |     assert!(k <= arr.len(), \"k should be less or equal to len(arr)\");\n\
    \   |                  ^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp:\
    \ you can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n17 |     assert!(k <= arr.len().try_into().unwrap(), \"k should be\
    \ less or equal to len(arr)\");\n   |                           ++++++++++++++++++++\n\
    \nerror[E0614]: type `Option<&isize>` cannot be dereferenced\n  --> /tmp/tmpaedp09h9.rs:18:27\n\
    \   |\n18 |     let mut max_element = *arr.iter().max_by_key(|&x| x);\n   |  \
    \                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the\
    \ type `[isize]` cannot be indexed by `RangeTo<isize>`\n  --> /tmp/tmpaedp09h9.rs:23:36\n\
    \   |\n23 |             max_element = maximum(&arr[..k - 1], k - 1);\n   |   \
    \                                 ^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `RangeTo<isize>`\n   = help: the following other types implement\
    \ trait `SliceIndex<T>`:\n             <RangeTo<usize> as SliceIndex<[T]>>\n \
    \            <RangeTo<usize> as SliceIndex<str>>\n   = note: required because\
    \ of the requirements on the impl of `Index<RangeTo<isize>>` for `Vec<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpaedp09h9.rs:23:35\n   |\n23 |\
    \             max_element = maximum(&arr[..k - 1], k - 1);\n   |             \
    \                      ^^^^^^^^^^^^^ expected struct `Vec`, found reference\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found reference `&_`\n\
    help: consider removing the borrow\n   |\n23 -             max_element = maximum(&arr[..k\
    \ - 1], k - 1);\n23 +             max_element = maximum(arr[..k - 1], k - 1);\n\
    \   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpaedp09h9.rs:23:27\n  \
    \ |\n18 |     let mut max_element = *arr.iter().max_by_key(|&x| x);\n   |    \
    \                       ------------------------------ expected due to this value\n\
    ...\n23 |             max_element = maximum"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 || arr.len() < k {\n        return\
    \ arr;\n    }\n    let mut result = vec![std::i32::MAX; k];\n    for i in 0..arr.len()\
    \ {\n        result[i] = if arr[i] > result[i] {\n            arr[i]\n       \
    \ } else {\n            result[i]\n        };\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsjv427c7.rs:17:30\n   |\n\
    17 |     if k == 0 || arr.len() < k {\n   |                              ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     if k == 0 || arr.len()\
    \ < k.try_into().unwrap() {\n   |                               ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsjv427c7.rs:20:42\n   |\n20 |\
    \     let mut result = vec![std::i32::MAX; k];\n   |                         \
    \                 ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    20 |     let mut result = vec![std::i32::MAX; k.try_into().unwrap()];\n   |  \
    \                                         ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpsjv427c7.rs:22:33\n   |\n22 |         result[i]\
    \ = if arr[i] > result[i] {\n   |                                 ^^^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n22 |         result[i] = if\
    \ arr[i] > result[i].try_into().unwrap() {\n   |                             \
    \             ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsjv427c7.rs:23:13\n\
    \   |\n23 |             arr[i]\n   |             ^^^^^^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsjv427c7.rs:28:5\n\
    \   |\n16 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |      \
    \                                    ---------- expected `Vec<isize>` because\
    \ of return type\n...\n28 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ `i32`\n   |\n   = note: expected struct `Vec<isize>`\n              found struct\
    \ `Vec<i32>`\n\nerror: aborting due to 5 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if arr.len() < k {\n        vec![]\n    }\n \
    \   else {\n        arr.iter().cloned().max_by_key(|&x| x).collect().unwrap()\n\
    \    }\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfeexkpa0.rs:17:20\n   |\n\
    17 |     if arr.len() < k {\n   |                    ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if arr.len() < k.try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0599]: `Option<isize>`\
    \ is not an iterator\n   --> /tmp/tmpfeexkpa0.rs:21:48\n    |\n21  |         \
    \  arr.iter().cloned().max_by_key(|&x| x).collect().unwrap()\n    |          \
    \                                        ^^^^^^^ `Option<isize>` is not an iterator\n\
    \    |\n    = note: the following trait bounds were not satisfied:\n         \
    \   `Option<isize>: Iterator`\n            which is required by `&mut Option<isize>:\
    \ Iterator`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 || k > arr.len() {\n        return\
    \ arr\n    }\n    if k == 1 {\n        arr.iter().skip(1).take(k).collect()\n\
    \    } else {\n        arr.iter().windows(k).map(|x| maximum(x, k - 1)).collect()\n\
    \    }\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdvl9d7io.rs:17:22\n   |\n\
    17 |     if k == 0 || k > arr.len() {\n   |                      ^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     if k == 0 || k\
    \ > arr.len().try_into().unwrap() {\n   |                               ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpdvl9d7io.rs:21:33\n   |\n21 |\
    \         arr.iter().skip(1).take(k).collect()\n   |                         \
    \        ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n21 |      \
    \   arr.iter().skip(1).take(k.try_into().unwrap()).collect()\n   |           \
    \                       ++++++++++++++++++++\n\nerror[E0277]: a value of type\
    \ `Vec<isize>` cannot be built from an iterator over elements of type `&isize`\n\
    \    --> /tmp/tmpdvl9d7io.rs:21:36\n     |\n21   |         arr.iter().skip(1).take(k).collect()\n\
    \     |                                    ^^^^^^^ value of type `Vec<isize>`\
    \ cannot be built from `std::iter::Iterator<Item=&isize>`\n     |\n     = help:\
    \ the trait `FromIterator<&isize>` is not implemented for `Vec<isize>`\n     =\
    \ help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0599]: no method named `windows` found for\
    \ struct `std::slice::Iter` in the current scope\n  --> /tmp/tmpdvl9d7io.rs:23:20\n\
    \   |\n23 |         arr.iter().windows(k).map(|x| maximum(x, k - 1)).collect()\n\
    \   |                    ^^^^^^^ method not found in `std::slice::Iter<'_, isize>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max = arr[0];\n    for &i in arr {\n\
    \        if i < max {\n            max = i;\n        }\n    }\n\n    vec.sort_by_key(|x|\
    \ x - max);\n    vec.take_while(|x| x < k).collect()\n}\n\nfn main() {\n    let\
    \ candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0423]: expected value, found macro `vec`\n  --> /tmp/tmpp8nc0kg9.rs:24:5\n\
    \   |\n24 |     vec.sort_by_key(|x| x - max);\n   |     ^^^ not a value\n\nerror[E0423]:\
    \ expected value, found macro `vec`\n  --> /tmp/tmpp8nc0kg9.rs:25:5\n   |\n25\
    \ |     vec.take_while(|x| x < k).collect()\n   |     ^^^ not a value\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpp8nc0kg9.rs:18:9\n   |\n18 |     for &i in arr\
    \ {\n   |         ^^    --- this expression has type `Option<isize>`\n   |   \
    \      |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0423.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k <= arr.len() {\n        arr.windows(k).max().collect()\n\
    \    } else {\n        vec![]\n    }\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8trxp95v.rs:17:13\n   |\n\
    17 |     if k <= arr.len() {\n   |             ^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if k <= arr.len().try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp8trxp95v.rs:18:21\n   |\n18 |         arr.windows(k).max().collect()\n\
    \   |                     ^ expected `usize`, found `isize`\n   |\nhelp: you can\
    \ convert an `isize` to a `usize` and panic if the converted value doesn't fit\n\
    \   |\n18 |         arr.windows(k.try_into().unwrap()).max().collect()\n   | \
    \                     ++++++++++++++++++++\n\nerror[E0599]: `Option<&[isize]>`\
    \ is not an iterator\n   --> /tmp/tmp8trxp95v.rs:18:30\n    |\n18  |         \
    \  arr.windows(k).max().collect()\n    |                                ^^^^^^^\
    \ `Option<&[isize]>` is not an iterator\n    |\n    = note: the following trait\
    \ bounds were not satisfied:\n            `Option<&[isize]>: Iterator`\n     \
    \       which is required by `&mut Option<&[isize]>: Iterator`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let n = arr.len();\n    if n == 0 {\n       \
    \ vec![]\n    } else if k == 0 || n == 1 {\n        vec![arr[0]]\n    } else {\n\
    \        let mut max_arr = vec![];\n        for i in 0..n {\n            let mut\
    \ cur_max = arr[i];\n            for j in i + 1..n {\n                if arr[j]\
    \ > cur_max {\n                    cur_max = arr[j];\n                }\n    \
    \        }\n            max_arr.push(cur_max);\n        }\n        max_arr.sort();\n\
    \        if k == max_arr.len() {\n            max_arr\n        } else {\n    \
    \        vec![max_arr[k-1]]\n        }\n    }\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7q4c2oi3.rs:34:17\n   |\n\
    34 |         if k == max_arr.len() {\n   |                 ^^^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n34 |         if k == max_arr.len().try_into().unwrap()\
    \ {\n   |                              ++++++++++++++++++++\n\nerror[E0277]: the\
    \ type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp7q4c2oi3.rs:37:18\n\
    \   |\n37 |             vec![max_arr[k-1]]\n   |                  ^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    assert!(arr.len() <= 1000);\n    assert!(k <=\
    \ arr.len());\n\n    let mut max_arr: Vec<isize> = vec![0; k];\n\n    for i in\
    \ 0..arr.len() {\n        if i > 0 && arr[i] > arr[i-1] {\n            max_arr[k\
    \ - 1] = arr[i-1];\n        }\n        max_arr[k - 1] = arr[i];\n    }\n\n   \
    \ max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsx4dlsws.rs:18:18\n   |\n\
    18 |     assert!(k <= arr.len());\n   |                  ^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n18 |     assert!(k <= arr.len().try_into().unwrap());\n\
    \   |                           ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpsx4dlsws.rs:20:43\n   |\n20 |     let mut max_arr: Vec<isize>\
    \ = vec![0; k];\n   |                                           ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n20 |     let mut max_arr: Vec<isize>\
    \ = vec![0; k.try_into().unwrap()];\n   |                                    \
    \        ++++++++++++++++++++\n\nerror[E0277]: the type `[isize]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpsx4dlsws.rs:24:13\n   |\n24 |             max_arr[k\
    \ - 1] = arr[i-1];\n   |             ^^^^^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpsx4dlsws.rs:26:9\n   |\n26 |         max_arr[k\
    \ - 1] = arr[i];\n   |         ^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 {\n        vec![]\n    } else {\n \
    \       let mut maximum = arr\n            .iter()\n            .take_while(|x|\
    \ x < k)\n            .fold(0, |max, _| max)\n            .collect::<Vec<_>>()\n\
    \            .unwrap_or(k);\n        for i in 0..k {\n            if maximum <\
    \ arr[i] {\n                maximum = arr[i];\n            }\n        }\n    \
    \    maximum\n    }\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpieb3pigh.rs:22:33\n   |\n\
    22 |             .take_while(|x| x < k)\n   |                                \
    \ ^ expected `&&isize`, found `isize`\n\nerror[E0689]: can't call method `collect`\
    \ on ambiguous numeric type `{integer}`\n  --> /tmp/tmpieb3pigh.rs:24:14\n   |\n\
    24 |             .collect::<Vec<_>>()\n   |              ^^^^^^^\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpieb3pigh.rs:27:26\n\
    \   |\n27 |             if maximum < arr[i] {\n   |                          ^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpieb3pigh.rs:28:27\n\
    \   |\n28 |                 maximum = arr[i];\n   |                          \
    \ ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help:\
    \ the trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0689.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr: Vec<isize> = vec![];\n    let\
    \ mut max_val: isize = 0;\n\n    for ele in arr.iter() {\n        if ele > max_val\
    \ {\n            max_arr.push(ele);\n            max_val = ele;\n        } else\
    \ if ele == max_val {\n            for i in 0..k {\n                max_arr.push(0);\n\
    \            }\n        }\n    }\n    max_arr\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0p6wl8ev.rs:21:18\n   |\n\
    21 |         if ele > max_val {\n   |                  ^^^^^^^\n   |         \
    \         |\n   |                  expected `&isize`, found `isize`\n   |    \
    \              help: consider borrowing here: `&max_val`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp0p6wl8ev.rs:22:26\n   |\n22 |             max_arr.push(ele);\n\
    \   |                          ^^^ expected `isize`, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n22 |             max_arr.push(*ele);\n\
    \   |                          +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0p6wl8ev.rs:23:23\n\
    \   |\n18 |     let mut max_val: isize = 0;\n   |                      ----- expected\
    \ due to this type\n...\n23 |             max_val = ele;\n   |               \
    \        ^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n23 |             max_val = *ele;\n   |                   \
    \    +\n\nerror[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmp0p6wl8ev.rs:24:23\n\
    \   |\n24 |         } else if ele == max_val {\n   |                       ^^\
    \ no implementation for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 101
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut arr = arr.clone();\n    arr.sort();\n\
    \    let mut ret = vec![];\n    for ele in arr {\n        if ele >= k {\n    \
    \        break;\n        }\n        ret.push(ele);\n    }\n    ret\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-4, -3]`,\n right: `[-4, -3, 5]`', /tmp/tmpab5k_3pg.rs:31:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k <= arr.len() {\n        arr.iter().take(k).collect()\n\
    \    } else {\n        let mut m = arr.iter().max().unwrap();\n        arr.iter().take(k\
    \ - 1).zip(arr.iter().skip(1)).for_each(|&(mut x, &y)| {\n            if x < m\
    \ {\n                *y = x;\n            } else {\n                m = *x;\n\
    \            }\n        });\n        vec![m]\n    }\n}\n\nfn main() {\n    let\
    \ candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2rt06zn0.rs:17:13\n   |\n\
    17 |     if k <= arr.len() {\n   |             ^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if k <= arr.len().try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2rt06zn0.rs:18:25\n   |\n18 |         arr.iter().take(k).collect()\n\
    \   |                         ^ expected `usize`, found `isize`\n   |\nhelp: you\
    \ can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n18 |         arr.iter().take(k.try_into().unwrap()).collect()\n \
    \  |                          ++++++++++++++++++++\n\nerror[E0277]: a value of\
    \ type `Vec<isize>` cannot be built from an iterator over elements of type `&isize`\n\
    \    --> /tmp/tmp2rt06zn0.rs:18:28\n     |\n18   |         arr.iter().take(k).collect()\n\
    \     |                            ^^^^^^^ value of type `Vec<isize>` cannot be\
    \ built from `std::iter::Iterator<Item=&isize>`\n     |\n     = help: the trait\
    \ `FromIterator<&isize>` is not implemented for `Vec<isize>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2rt06zn0.rs:21:25\n\
    \   |\n21 |         arr.iter().take(k - 1).zip(arr.iter().skip(1)).for_each(|&(mut\
    \ x, &y)| {\n   |                         ^^^^^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n21 |         arr.iter().take((k - 1).try_into().unwrap()).zip(arr.iter().skip(1)).for_each(|&(mut\
    \ x, &y)| {\n   |                         +     +++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2rt06zn0.rs:21:66\n   |\n21 |         arr.iter().take(k\
    \ - 1).zip(arr.iter().skip(1)).for_each(|&(mut x, &y)| {\n   |               \
    \                                                   ^^^^^^^^^^^-\n   |       \
    \                                                       "
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k > arr.len() {\n        arr\n    } else {\n\
    \        let mut max_elements = vec![vec![-1000, 1000]];\n        let mut max_element\
    \ = vec![-1000, 1000];\n        for i in 0..k {\n            let max_element =\
    \ max_elements[i];\n            if arr[i].max() > max_element[0] {\n         \
    \       max_element[0] = arr[i];\n                max_elements[1] = max_element[1];\n\
    \            }\n        }\n        max_elements\n    }\n}\n\nfn main() {\n   \
    \ let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprxdfixn4.rs:17:12\n   |\n\
    17 |     if k > arr.len() {\n   |            ^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if k > arr.len().try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmprxdfixn4.rs:23:31\n   |\n23 |  \
    \           let max_element = max_elements[i];\n   |                         \
    \      ^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmprxdfixn4.rs:24:16\n   |\n24 |             if arr[i].max()\
    \ > max_element[0] {\n   |                ^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmprxdfixn4.rs:25:34\n   |\n25 |            \
    \     max_element[0] = arr[i];\n   |                                  ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmprxdfixn4.rs:29:9\n   |\n16 | fn maximum(arr: Vec<isize>, k: isize)\
    \ -> Vec<isize> {\n   |                                          ---------- expected\
    \ `Vec<isize>` because "
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut new_vec = vec![];\n    let max_val =\
    \ arr[0];\n\n    for i in arr {\n        if i > max_val {\n            new_vec.push(max_val);\n\
    \        }\n\n        if i == max_val {\n            new_vec.push(i as isize);\n\
    \        }\n    }\n\n    match new_vec.len() {\n        0 => new_vec,\n      \
    \  _ => new_vec[k..].sort_unstable(),\n    }\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `RangeFrom<isize>`\n\
    \  --> /tmp/tmp54b7ceqo.rs:32:14\n   |\n32 |         _ => new_vec[k..].sort_unstable(),\n\
    \   |              ^^^^^^^^^^^^ slice indices are of type `usize` or ranges of\
    \ `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `RangeFrom<isize>`\n   = help: the following other types implement trait\
    \ `SliceIndex<T>`:\n             <RangeFrom<usize> as SliceIndex<[T]>>\n     \
    \        <RangeFrom<usize> as SliceIndex<str>>\n   = note: required because of\
    \ the requirements on the impl of `Index<RangeFrom<isize>>` for `Vec<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if arr.len() <= k {\n        return arr;\n  \
    \  }\n    let mut max_arr = vec![arr[0]];\n    let mut max_element = arr[0];\n\
    \    for i in 1..arr.len() {\n        if arr[i] > max_element {\n            max_element\
    \ = arr[i];\n        }\n    }\n    for j in 1..k {\n        if max_element < arr[j]\
    \ {\n            max_arr.push(max_element);\n            max_element = arr[j];\n\
    \        }\n        else {\n            max_arr.push(arr[j]);\n        }\n   \
    \ }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpchnof5dx.rs:17:21\n   |\n\
    17 |     if arr.len() <= k {\n   |                     ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if arr.len() <= k.try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0277]: the type\
    \ `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpchnof5dx.rs:28:26\n  \
    \ |\n28 |         if max_element < arr[j] {\n   |                          ^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpchnof5dx.rs:30:27\n\
    \   |\n30 |             max_element = arr[j];\n   |                          \
    \ ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help:\
    \ the trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpchnof5dx.rs:33:26\n\
    \   |\n33 |             max_arr.push(arr[j]);\n   |                          ^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max = arr[0];\n    let mut max_so_far\
    \ = arr[0];\n    for elem in arr.iter().skip(1) {\n        if elem > max {\n \
    \           max = elem;\n        }\n        if elem > max_so_far {\n         \
    \   max_so_far = elem;\n        }\n    }\n    if k <= 0 {\n        vec![max]\n\
    \    } else {\n        vec![max for _ in 0..k]\n    }\n}\n\nfn main() {\n    let\
    \ candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: no rules expected the token `for`\n  --> /tmp/tmpw_rv3c89.rs:30:18\n\
    \   |\n30 |         vec![max for _ in 0..k]\n   |                  ^^^ no rules\
    \ expected this token in macro call\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw_rv3c89.rs:20:19\n\
    \   |\n20 |         if elem > max {\n   |                   ^^^\n   |        \
    \           |\n   |                   expected `&isize`, found `isize`\n   | \
    \                  help: consider borrowing here: `&max`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpw_rv3c89.rs:21:19\n   |\n17 |     let mut max = arr[0];\n\
    \   |                   ------ expected due to this value\n...\n21 |         \
    \    max = elem;\n   |                   ^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n21 |             max = *elem;\n\
    \   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw_rv3c89.rs:23:19\n\
    \   |\n23 |         if elem > max_so_far {\n   |                   ^^^^^^^^^^\n\
    \   |                   |\n   |                   expected `&isize`, found `isize`\n\
    \   |                   help: consider borrowing here: `&max_so_far`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpw_rv3c89.rs:24:26\n   |\n18 |     let mut max_so_far\
    \ = arr[0];\n   |                          ------ expected due to this value\n\
    ...\n24 |             max_so_far = elem;\n   |                          ^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    24 |             max_so_far = *elem;\n   |                          +\n\nerror:\
    \ aborting due to 5 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    arr.windows(k).max()\n}\n\nfn main() {\n    let\
    \ candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4ut1dj3d.rs:17:17\n   |\n\
    17 |     arr.windows(k).max()\n   |                 ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     arr.windows(k.try_into().unwrap()).max()\n\
    \   |                  ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp4ut1dj3d.rs:17:5\n   |\n16 | fn maximum(arr: Vec<isize>, k: isize)\
    \ -> Vec<isize> {\n   |                                          ---------- expected\
    \ `Vec<isize>` because of return type\n17 |     arr.windows(k).max()\n   |   \
    \  ^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found enum `Option`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n                found enum `Option<&[isize]>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k <= 0 || arr.len() <= k {\n        return\
    \ arr;\n    }\n    let mut max = arr[0];\n    let mut max_pos = 0;\n    for &i\
    \ in arr {\n        if i > max {\n            max_pos = i;\n            max =\
    \ i;\n        } else if i == max {\n            max_pos = i;\n        }\n    }\n\
    \    let mut ans = vec![max];\n    for &i in arr[0..k] {\n        if i == max\
    \ {\n            ans.push(max_pos);\n        }\n    }\n    ans\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc_v7i7tj.rs:17:31\n   |\n\
    17 |     if k <= 0 || arr.len() <= k {\n   |                               ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     if k <= 0 || arr.len()\
    \ <= k.try_into().unwrap() {\n   |                                ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpc_v7i7tj.rs:22:9\n   |\n22 | \
    \    for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `std::ops::Range<isize>`\n  --> /tmp/tmpc_v7i7tj.rs:31:15\n\
    \   |\n31 |     for &i in arr[0..k] {\n   |               ^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `std::ops::Range<isize>`\n   = help: the following other\
    \ types implement trait `SliceIndex<T>`:\n             <std::ops::Range<usize>\
    \ as SliceIndex<[T]>>\n             <std::ops::Range<usize> as SliceIndex<str>>\n\
    \   = note: required because of the requirements on the impl of `Index<std::ops::Range<isize>>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let len = arr.len();\n    \n    if k > len {\n\
    \        return arr;\n    }\n    \n    if k == 0 {\n        return arr\n    }\n\
    \    \n    if k == 1 {\n        return arr\n            .windows(k)\n        \
    \    .flat_map(|window| window.iter().max())\n            .take(k)\n         \
    \   .collect();\n    }\n    \n    let mut min_v = arr.iter().min();\n    let mut\
    \ max_v = arr.iter().max();\n    for i in 0..k - 1 {\n        if max_v == min_v\
    \ {\n            max_v = arr.iter().max();\n        }\n        if arr[i] == min_v\
    \ {\n            min_v = arr.iter().min();\n        }\n    }\n    \n    vec![min_v,\
    \ max_v]\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppz1cxgf3.rs:19:12\n   |\n\
    19 |     if k > len {\n   |            ^^^ expected `isize`, found `usize`\n \
    \  |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n19 |     if k > len.try_into().unwrap() {\n   |   \
    \            ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppz1cxgf3.rs:29:22\n\
    \   |\n29 |             .windows(k)\n   |                      ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n29 |             .windows(k.try_into().unwrap())\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmppz1cxgf3.rs:31:19\n   |\n31 |             .take(k)\n   |      \
    \             ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an\
    \ `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n31\
    \ |             .take(k.try_into().unwrap())\n   |                    ++++++++++++++++++++\n\
    \nerror[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `&isize`\n    --> /tmp/tmppz1cxgf3.rs:32:14\n     |\n\
    32   |             .collect();\n     |              ^^^^^^^ value of type `Vec<isize>`\
    \ cannot be built from `std::iter::Iterator<Item=&isize>`\n     |\n     = help:\
    \ the trait `FromIterator<&isize>` is not implemented for `Vec<isize>`\n     =\
    \ help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0277]: the type `[isize]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmppz1cxgf3.rs:41:12\n   |\n41 |         if arr[i] ==\
    \ min_v {\n   |            ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppz1cxgf3.rs:46:10\n\
    \   |\n46 |     vec!["
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if arr.len() < k { return vec![]; }\n    let\
    \ mut maxs = vec![];\n    let mut current_max = arr[0];\n    for i in 1..k {\n\
    \        if arr[i] > current_max {\n            current_max = arr[i];\n      \
    \  }\n    }\n    maxs.push(current_max);\n    for i in 1..k {\n        if arr[i]\
    \ > current_max {\n            maxs.push(arr[i]);\n        }\n    }\n    maxs\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp052vil5q.rs:17:20\n   |\n\
    17 |     if arr.len() < k { return vec![]; }\n   |                    ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     if arr.len() <\
    \ k.try_into().unwrap() { return vec![]; }\n   |                     ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp052vil5q.rs:21:12\n\
    \   |\n21 |         if arr[i] > current_max {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp052vil5q.rs:22:27\n   |\n22 |            \
    \ current_max = arr[i];\n   |                           ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp052vil5q.rs:27:12\n   |\n27 |         if arr[i]\
    \ > current_max {\n   |            ^^^^^^ slice indices are of type `usize` or\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmp052vil5q.rs:28:23\n   |\n28 |             maxs.push(arr[i]);\n\
    \   |                       ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k > arr.len() {\n        return vec![];\n\
    \    }\n    let mut max_k = k;\n    let mut largest = vec![];\n    for i in arr.iter().rev()\
    \ {\n        if i > 0 && i < arr.len() - 1 && arr[i] < arr[i-1] {\n          \
    \  max_k = max_k - 1;\n            largest.push(arr[i]);\n        }\n    }\n \
    \   if max_k > 0 {\n        largest = largest.iter().take(max_k).collect();\n\
    \    }\n    largest\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8862wnek.rs:17:12\n   |\n\
    17 |     if k > arr.len() {\n   |            ^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if k > arr.len().try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp8862wnek.rs:23:16\n   |\n23 |         if i > 0 && i < arr.len()\
    \ - 1 && arr[i] < arr[i-1] {\n   |                ^\n   |                |\n \
    \  |                expected `&isize`, found integer\n   |                help:\
    \ consider borrowing here: `&0`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8862wnek.rs:23:25\n\
    \   |\n23 |         if i > 0 && i < arr.len() - 1 && arr[i] < arr[i-1] {\n   |\
    \                         ^^^^^^^^^^^^^ expected `&isize`, found `usize`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp8862wnek.rs:23:42\n\
    \   |\n23 |         if i > 0 && i < arr.len() - 1 && arr[i] < arr[i-1] {\n   |\
    \                                          ^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmp8862wnek.rs:23:51\n   |\n23 |         if\
    \ i > 0 && i < arr.len() - 1 && arr[i] < arr[i-1] {\n   |                    \
    \                               ^^^^^^^^ slice indices are of type `usize` or\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n\
    \  --> /tmp/tmp8862wnek.rs:25:26\n   |\n25 |             largest.push(arr[i]);\n\
    \   |              "
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    // Your code here\n    let mut cur_max = arr[0];\n\
    \    let mut new_vec: Vec<isize> = vec![];\n    for &x in arr {\n        if x\
    \ < cur_max {\n            new_vec.push(x);\n        } else {\n            cur_max\
    \ = x;\n        }\n    }\n    new_vec.push(cur_max);\n    \n    new_vec.sort_unstable_by(|a,\
    \ b| a.partial_cmp(&b).unwrap());\n    new_vec[..k].clone()\n}\n\nfn main() {\n\
    \    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptevdey2i.rs:20:9\n   |\n\
    20 |     for &x in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `RangeTo<isize>`\n  --> /tmp/tmptevdey2i.rs:30:5\n   |\n\
    30 |     new_vec[..k].clone()\n   |     ^^^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `RangeTo<isize>`\n   = help: the following other types\
    \ implement trait `SliceIndex<T>`:\n             <RangeTo<usize> as SliceIndex<[T]>>\n\
    \             <RangeTo<usize> as SliceIndex<str>>\n   = note: required because\
    \ of the requirements on the impl of `Index<RangeTo<isize>>` for `Vec<isize>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k > arr.len() {\n        return vec![];\n\
    \    }\n    let mut result = vec![arr[0]];\n    let mut max_val = arr[0];\n  \
    \  for val in &arr[k..] {\n        if val > max_val {\n            max_val = val;\n\
    \        }\n        result.push(val);\n    }\n    result\n}\n\nfn main() {\n \
    \   let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj0kr2q3k.rs:17:12\n   |\n\
    17 |     if k > arr.len() {\n   |            ^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if k > arr.len().try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `RangeFrom<isize>`\n  --> /tmp/tmpj0kr2q3k.rs:22:17\n \
    \  |\n22 |     for val in &arr[k..] {\n   |                 ^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `RangeFrom<isize>`\n   = help: the following other types\
    \ implement trait `SliceIndex<T>`:\n             <RangeFrom<usize> as SliceIndex<[T]>>\n\
    \             <RangeFrom<usize> as SliceIndex<str>>\n   = note: required because\
    \ of the requirements on the impl of `Index<RangeFrom<isize>>` for `Vec<isize>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    assert_eq!(arr.len(), k);\n\n    let mut max\
    \ = arr[k - 1 as usize];\n    for i in k..arr.len() {\n        if arr[i] > max\
    \ {\n            max = arr[i];\n        }\n    }\n    vec![max]\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfct6z9sh.rs:17:5\n   |\n\
    17 |     assert_eq!(arr.len(), k);\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `usize`, found `isize`\n   |\n   = note: this error originates in the macro\
    \ `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpfct6z9sh.rs:19:27\n   |\n19 |\
    \     let mut max = arr[k - 1 as usize];\n   |                           ^^^^^^^^^^\
    \ expected `isize`, found `usize`\n\nerror[E0277]: cannot subtract `usize` from\
    \ `isize`\n  --> /tmp/tmpfct6z9sh.rs:19:25\n   |\n19 |     let mut max = arr[k\
    \ - 1 as usize];\n   |                         ^ no implementation for `isize\
    \ - usize`\n   |\n   = help: the trait `Sub<usize>` is not implemented for `isize`\n\
    \   = help: the following other types implement trait `Sub<Rhs>`:\n          \
    \   <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n             <&'a\
    \ i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n             <&'a i32\
    \ as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n\
    \             <&'a isize as Sub<isize>>\n           and 48 others\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpfct6z9sh.rs:19:19\n\
    \   |\n19 |     let mut max = arr[k - 1 as usize];\n   |                   ^^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpfct6z9sh.rs:20:17\n   |\n20 |     for i in k..arr.len()\
    \ {\n   |                 ^^^^^^^^^ expected `isize`, found `usize`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpfct6z9sh.rs:21:12\n\
    \   |\n21 |         if arr[i] > max {\n   |            ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemente"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if arr.len() <= k {\n        arr\n    } else\
    \ {\n        if k > arr.len() {\n            arr\n        } else {\n         \
    \   let mut max_val = arr[0];\n            for x in arr {\n                if\
    \ x > max_val {\n                    max_val = x;\n                }\n       \
    \     }\n            arr.iter().skip(k).take(arr.len() - k + 1).collect::<Vec<isize>>()\n\
    \                .sort_unstable().collect()\n        }\n    }\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmps3qt5g7x.rs:17:21\n   |\n\
    17 |     if arr.len() <= k {\n   |                     ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if arr.len() <= k.try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmps3qt5g7x.rs:20:16\n   |\n20 |         if k > arr.len()\
    \ {\n   |                ^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp:\
    \ you can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n20 |         if k > arr.len().try_into().unwrap() {\n   |       \
    \                  ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmps3qt5g7x.rs:29:29\n   |\n29 |             arr.iter().skip(k).take(arr.len()\
    \ - k + 1).collect::<Vec<isize>>()\n   |                             ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n29 |             arr.iter().skip(k.try_into().unwrap()).take(arr.len()\
    \ - k + 1).collect::<Vec<isize>>()\n   |                              ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmps3qt5g7x.rs:29:49\n   |\n29 |\
    \             arr.iter().skip(k).take(arr.len() - k + 1).collect::<Vec<isize>>()\n\
    \   |                                                 ^ expected `usize`, found\
    \ `isize`\n\nerror[E0277]: cannot subtract `isize` from `usize`\n  --> /tmp/tmps3qt5g7x.rs:29:47\n\
    \   |\n29 |             arr.iter().skip(k).take(arr.len() - k + 1).collect::<Vec<isize>>()\n\
    \   |                                               ^ no implementation for `usize\
    \ - isize`\n   |\n   = help: the trait `Sub<isize>` is not implemented for `usize`\n\
    \   = help: the following other types implement trait `Sub<Rhs>`:\n          \
    \   <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n             <&'a\
    \ i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n             <&'a i32\
    \ as Sub<i32>>\n             <&'a i64 as Sub<i64>"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if arr.is_empty() {\n        return vec![];\n\
    \    }\n    if k == 1 {\n        return vec![arr[0]];\n    }\n    let mut l =\
    \ vec![];\n    let mut x = vec![];\n    for i in 0..k {\n        l.push(arr[i]);\n\
    \        x.push(arr[i]);\n    }\n    for i in arr.iter().take(k) {\n        if\
    \ *i > arr[k] {\n            l.push(*i);\n            x.push(arr[k]);\n      \
    \  }\n    }\n    for i in l.iter().rev() {\n        if i != 0 {\n            x.push(i);\n\
    \        }\n    }\n    x\n}\n\nfn main() {\n    let candidate = maximum;\n   \
    \ assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpkd7e5gau.rs:26:16\n\
    \   |\n26 |         l.push(arr[i]);\n   |                ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpkd7e5gau.rs:27:16\n   |\n27 |         x.push(arr[i]);\n\
    \   |                ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpkd7e5gau.rs:29:30\n   |\n29 |\
    \     for i in arr.iter().take(k) {\n   |                              ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n29 |     for i in arr.iter().take(k.try_into().unwrap())\
    \ {\n   |                               ++++++++++++++++++++\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpkd7e5gau.rs:30:17\n\
    \   |\n30 |         if *i > arr[k] {\n   |                 ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpkd7e5gau.rs:32:20\n   |\n32 |            \
    \ x.push(arr[k]);\n   |                    ^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   ="
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let n = arr.len();\n    if k > n {\n        vec![]\n\
    \    } else if k == 0 {\n        arr.into_iter().take(n).collect()\n    } else\
    \ if k == n {\n        arr\n    } else {\n        let mut max = arr.clone();\n\
    \        let mut max = vec![max[0]].clone();\n        for i in 1..k {\n      \
    \      if max[i] < arr[i] {\n                max[i] = arr[i];\n            }\n\
    \        }\n        max\n    }\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpu111i86k.rs:18:12\n   |\n\
    18 |     if k > n {\n   |            ^ expected `isize`, found `usize`\n   |\n\
    help: you can convert a `usize` to an `isize` and panic if the converted value\
    \ doesn't fit\n   |\n18 |     if k > n.try_into().unwrap() {\n   |           \
    \  ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpu111i86k.rs:22:20\n\
    \   |\n22 |     } else if k == n {\n   |                    ^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n22 |     } else if k == n.try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpu111i86k.rs:28:16\n   |\n28 |  \
    \           if max[i] < arr[i] {\n   |                ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpu111i86k.rs:28:25\n   |\n28 |            \
    \ if max[i] < arr[i] {\n   |                         ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpu111i86k.rs:29:17\n   |\n29 |            \
    \     max[i] = arr[i];\n   |                 ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if arr.len() <= k {\n        return arr;\n  \
    \  }\n    let mut max_arr = arr.iter().take(k).collect::<Vec<_>>();\n    for i\
    \ in 1..arr.len() {\n        max_arr.push(*arr.max_unwrap_or_else(|&x| if x ==\
    \ *i { *i } else { x }));\n    }\n    max_arr.sort_unstable();\n    max_arr\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw6fvu8au.rs:17:21\n   |\n\
    17 |     if arr.len() <= k {\n   |                     ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if arr.len() <= k.try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpw6fvu8au.rs:20:39\n   |\n20 |     let mut max_arr = arr.iter().take(k).collect::<Vec<_>>();\n\
    \   |                                       ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     let mut max_arr = arr.iter().take(k.try_into().unwrap()).collect::<Vec<_>>();\n\
    \   |                                        ++++++++++++++++++++\n\nerror[E0599]:\
    \ no method named `max_unwrap_or_else` found for struct `Vec<isize>` in the current\
    \ scope\n  --> /tmp/tmpw6fvu8au.rs:22:27\n   |\n22 |         max_arr.push(*arr.max_unwrap_or_else(|&x|\
    \ if x == *i { *i } else { x }));\n   |                           ^^^^^^^^^^^^^^^^^^\
    \ method not found in `Vec<isize>`\n\nerror[E0614]: type `usize` cannot be dereferenced\n\
    \  --> /tmp/tmpw6fvu8au.rs:22:59\n   |\n22 |         max_arr.push(*arr.max_unwrap_or_else(|&x|\
    \ if x == *i { *i } else { x }));\n   |                                      \
    \                     ^^\n\nerror[E0614]: type `usize` cannot be dereferenced\n\
    \  --> /tmp/tmpw6fvu8au.rs:22:64\n   |\n22 |         max_arr.push(*arr.max_unwrap_or_else(|&x|\
    \ if x == *i { *i } else { x }));\n   |                                      \
    \                          ^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw6fvu8au.rs:25:5\n\
    \   |\n16 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |      \
    \                                    ---------- expected `Vec<isize>` because\
    \ of return type\n...\n25 |     max_arr\n   |     ^^^^^^^ expected `isize`, found\
    \ `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n              found\
    \ struct `Vec<&isize>`\n\nerror: aborting due to 6 previous errors\n\nSom"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if arr.len() < k {\n        vec![]\n    } else\
    \ {\n        let mut min = arr[0];\n        let mut max = arr[0];\n        for\
    \ i in 1..arr.len() {\n            if arr[i] > max {\n                max = arr[i];\n\
    \            }\n            if arr[i] < min {\n                min = arr[i];\n\
    \            }\n            if arr.len() - i < k {\n                break;\n \
    \           }\n        }\n        vec![min, max]\n    }\n}\n\nfn main() {\n  \
    \  let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbil3r0t3.rs:17:20\n   |\n\
    17 |     if arr.len() < k {\n   |                    ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if arr.len() < k.try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpbil3r0t3.rs:29:32\n   |\n29 |             if arr.len()\
    \ - i < k {\n   |                                ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n29 |             if arr.len() - i < k.try_into().unwrap()\
    \ {\n   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k > arr.len() {\n        return vec![];\n\
    \    }\n    \n    if k == 1 {\n        return arr;\n    }\n    \n    let mut max_num\
    \ = arr[0];\n    let mut max_index = k;\n    for i in arr.iter().rev() {\n   \
    \     if i > max_num {\n            max_num = i;\n            max_index = k -\
    \ 1;\n        }\n        if i == max_num {\n            k -= 1;\n        }\n \
    \   }\n    \n    arr[0..max_index]\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsk4e_ms5.rs:17:12\n   |\n\
    17 |     if k > arr.len() {\n   |            ^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if k > arr.len().try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpsk4e_ms5.rs:28:16\n   |\n28 |         if i > max_num {\n\
    \   |                ^^^^^^^\n   |                |\n   |                expected\
    \ `&isize`, found `isize`\n   |                help: consider borrowing here:\
    \ `&max_num`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsk4e_ms5.rs:29:23\n\
    \   |\n25 |     let mut max_num = arr[0];\n   |                       ------ expected\
    \ due to this value\n...\n29 |             max_num = i;\n   |                \
    \       ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n29 |             max_num = *i;\n   |                     \
    \  +\n\nerror[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpsk4e_ms5.rs:32:14\n\
    \   |\n32 |         if i == max_num {\n   |              ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror[E0277]: the type `[isize]` cannot\
    \ be indexed by `std::ops::Range<isize>`\n  --> /tmp/tmpsk4e_ms5.rs:37:5\n   |\n\
    37 |     arr[0..max_index]\n   |     ^^^^^^^^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `std::ops::Range<isize>`\n   = help: the following other\
    \ types implement trait `SliceIndex<T>`:\n             <std::ops::Range<usize>\
    \ as SliceIndex<[T]>>\n             <std::ops::Range<usize> as SliceIndex<str>>\n\
    \   = note: required because of the requirements on the impl of `Index"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if arr.len() <= k {\n        return arr;\n  \
    \  }\n    let mut max_arr = vec![];\n    let mut max_idx = -1;\n    for i in 0..k\
    \ {\n        if arr[i] > max_arr[0] {\n            max_arr[0] = arr[i];\n    \
    \        max_idx = 0;\n        }\n        if arr[i] > max_arr[max_idx].as_isize()\
    \ {\n            max_arr[max_idx] = arr[i];\n            max_idx = i;\n      \
    \  }\n    }\n    max_arr[max_idx..].sort();\n    max_arr.shrink_to_fit();\n  \
    \  max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_5z1s0t1.rs:17:21\n   |\n\
    17 |     if arr.len() <= k {\n   |                     ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if arr.len() <= k.try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0277]: the type\
    \ `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp_5z1s0t1.rs:23:12\n  \
    \ |\n23 |         if arr[i] > max_arr[0] {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp_5z1s0t1.rs:24:26\n   |\n24 |            \
    \ max_arr[0] = arr[i];\n   |                          ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp_5z1s0t1.rs:27:12\n   |\n27 |         if arr[i]\
    \ > max_arr[max_idx].as_isize() {\n   |            ^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the trait bound `usize: Neg`\
    \ is not satisfied\n  --> /tmp/tmp_5z1s0t1.rs:21:23\n   |\n21 |     let mut max_idx\
    \ = -1;\n   |                       ^^ the trait `Neg` is not implemented for\
    \ `usize`\n   |\n   = help: the following other types implement trait `Neg`:\n\
    \             &f32\n       "
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![0; k];\n    max_arr.clone_from_slice(arr.to_owned());\n\
    \    let mut max_pos = vec![k; k];\n    for i in 1..k {\n        let mut max =\
    \ 0;\n        for j in 0..i {\n            let temp: isize = max_arr[i - 1];\n\
    \            if arr[i] > temp {\n                max = temp;\n            }\n\
    \            max_arr[j] += 1;\n            if max_pos[j] > max_pos[i] + 1 {\n\
    \                max_pos[j] += 1;\n            }\n        }\n        if max >\
    \ max_arr[i-1] {\n            max_arr[i-1] = max;\n            max_pos[i-1] +=\
    \ 1;\n        }\n    }\n    max_arr.clone_from_slice(&max_arr[i..k]);\n    max_pos.clone_from_slice(&max_pos[i..k]);\n\
    \    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmpn_54h09r.rs:37:39\n\
    \   |\n37 |     max_arr.clone_from_slice(&max_arr[i..k]);\n   |              \
    \                         ^ help: a local variable with a similar name exists:\
    \ `k`\n\nerror[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmpn_54h09r.rs:38:39\n\
    \   |\n38 |     max_pos.clone_from_slice(&max_pos[i..k]);\n   |              \
    \                         ^ help: a local variable with a similar name exists:\
    \ `k`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn_54h09r.rs:17:31\n   |\n\
    17 |     let mut max_arr = vec![0; k];\n   |                               ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     let mut max_arr\
    \ = vec![0; k.try_into().unwrap()];\n   |                                ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpn_54h09r.rs:18:30\n   |\n18 |\
    \     max_arr.clone_from_slice(arr.to_owned());\n   |                        \
    \      ^^^^^^^^^^^^^^\n   |                              |\n   |             \
    \                 expected `&[{integer}]`, found struct `Vec`\n   |          \
    \                    help: consider borrowing here: `&arr.to_owned()`\n   |\n\
    \   = note: expected reference `&[{integer}]`\n                 found struct `Vec<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpn_54h09r.rs:19:31\n   |\n19 |\
    \     let mut max_pos = vec![k; k];\n   |                               ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n19 |     let mut max_pos\
    \ = vec![k; k.try_into().unwrap()];\n   |                                ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpn_54h09r.rs:23:31\n\
    \   |\n23 |             let temp: isize = max_arr[i - 1];\n   |              \
    \                 ^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of\
    \ `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is not imple"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max = arr[0];\n    let mut idx = 1;\n\
    \n    while idx <= k {\n        if max < arr[idx] {\n            max = arr[idx];\n\
    \        }\n        idx += 1;\n    }\n\n    vec![max]\n}\n\nfn main() {\n    let\
    \ candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp17xdmrb9.rs:21:18\n\
    \   |\n21 |         if max < arr[idx] {\n   |                  ^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp17xdmrb9.rs:22:19\n   |\n22 |  \
    \           max = arr[idx];\n   |                   ^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    // 1. initialize max and maxIdx\n    let mut\
    \ max = arr[0];\n    let mut maxIdx = -1;\n\n    // 2. find max of arr and update\
    \ max & maxIdx if necessary\n    for i in 0..k {\n        if arr[i] > max {\n\
    \            max = arr[i];\n            maxIdx = i;\n        }\n    }\n\n    //\
    \ 3. find the remaining items in the arr\n    let mut rest = vec![];\n    for\
    \ i in 0..arr.len() {\n        if i != maxIdx {\n            rest.push(arr[i]);\n\
    \        }\n    }\n\n    // 4. return\n    rest\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpttyetkpw.rs:23:12\n\
    \   |\n23 |         if arr[i] > max {\n   |            ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpttyetkpw.rs:24:19\n   |\n24 |            \
    \ max = arr[i];\n   |                   ^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpttyetkpw.rs:32:17\n\
    \   |\n32 |         if i != maxIdx {\n   |                 ^^^^^^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n32 |         if i != maxIdx.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if arr.len() <= k { vec![arr.last()] }\n    else\
    \ if k <= 0 {\n        vec![]\n    }\n    else {\n        let mut max_arr = arr.clone();\n\
    \        for i in 0..k {\n            if arr[i] > max_arr[0] {\n             \
    \   max_arr.clear();\n                break;\n            }\n            max_arr.push(arr[i]);\n\
    \        }\n        vec![max_arr.last()..arr.last().unwrap() + k - 1]\n    }\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpliio_wcd.rs:17:21\n   |\n\
    17 |     if arr.len() <= k { vec![arr.last()] }\n   |                     ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     if arr.len() <=\
    \ k.try_into().unwrap() { vec![arr.last()] }\n   |                      ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpliio_wcd.rs:17:30\n   |\n17 |\
    \     if arr.len() <= k { vec![arr.last()] }\n   |                           \
    \   ^^^^^^^^^^ expected `isize`, found enum `Option`\n   |\n   = note: expected\
    \ type `isize`\n              found enum `Option<&isize>`\n\nerror[E0277]: the\
    \ type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpliio_wcd.rs:24:16\n\
    \   |\n24 |             if arr[i] > max_arr[0] {\n   |                ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpliio_wcd.rs:28:26\n   |\n28 |  \
    \           max_arr.push(arr[i]);\n   |                          ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpliio_wcd.rs:30:30\n   |\n30 |         vec![max_arr.last()..arr.last().unwrap()\
    \ + k - 1]\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ enum `Option`, found `isize`\n   |\n   = note: expected enum `Option<&isize>`\n\
    \              found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpliio_wcd.rs:30:14\n\
    \   |\n30 |         vec![max_arr.last()..arr.last().unwrap() + k - 1"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    assert!(k <= arr.len(), \"Invalid input\");\n\
    \    let mut max_nums = vec![vec![0, 0]; k];\n    for num in arr.iter() {\n  \
    \      if num > max_nums[k-1].0.unwrap() {\n            max_nums[k-1] = vec![num,\
    \ 0];\n        }\n    }\n    max_nums\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpahp0byby.rs:17:18\n   |\n\
    17 |     assert!(k <= arr.len(), \"Invalid input\");\n   |                  ^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n17 |     assert!(k\
    \ <= arr.len().try_into().unwrap(), \"Invalid input\");\n   |                \
    \           ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpahp0byby.rs:18:41\n\
    \   |\n18 |     let mut max_nums = vec![vec![0, 0]; k];\n   |                \
    \                         ^ expected `usize`, found `isize`\n   |\nhelp: you can\
    \ convert an `isize` to a `usize` and panic if the converted value doesn't fit\n\
    \   |\n18 |     let mut max_nums = vec![vec![0, 0]; k.try_into().unwrap()];\n\
    \   |                                          ++++++++++++++++++++\n\nerror[E0277]:\
    \ the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  --> /tmp/tmpahp0byby.rs:20:18\n\
    \   |\n20 |         if num > max_nums[k-1].0.unwrap() {\n   |                \
    \  ^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n\
    \   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmpahp0byby.rs:21:13\n   |\n21 |             max_nums[k-1] = vec![num,\
    \ 0];\n   |             ^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpahp0byby.rs:21:39\n   |\n21 |             max_nums[k-1] = vec![num,\
    \ 0];\n   |                                       ^ expected `&isize`, found integer\n\
    \nerror"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_idx = k;\n    let mut max_val = arr[k];\n\
    \    \n    for i in 0..k {\n        if arr[i] > max_val {\n            max_val\
    \ = arr[i];\n            max_idx = i;\n        }\n    }\n    \n    for i in 0..k\
    \ {\n        arr[i] = arr[k];\n    }\n    \n    for i in 0..k {\n        if max_idx\
    \ < i {\n            arr[i] = max_val;\n        }\n    }\n    \n    arr\n}\n\n\
    fn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4,\
    \ 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
    \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpkjss2vvu.rs:18:23\n\
    \   |\n18 |     let mut max_val = arr[k];\n   |                       ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpkjss2vvu.rs:21:12\n   |\n21 |  \
    \       if arr[i] > max_val {\n   |            ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpkjss2vvu.rs:22:23\n   |\n22 |            \
    \ max_val = arr[i];\n   |                       ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpkjss2vvu.rs:28:9\n   |\n28 |         arr[i]\
    \ = arr[k];\n   |         ^^^^^^ slice indices are of type `usize` or ranges of\
    \ `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpkjss2vvu.rs:28:18\n   |\n28 |         arr[i] = arr[k];\n   |  \
    \                ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = "
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 || arr.is_empty() {\n        return\
    \ arr;\n    }\n\n    let mut max: isize = 0;\n    let mut max_idx: usize = 0;\n\
    \n    for i in 0..(arr.len() - 1) {\n        if arr[i] > max {\n            max\
    \ = arr[i];\n            max_idx = i;\n        }\n    }\n\n    let mut new_arr\
    \ = vec![];\n\n    for i in 0..k {\n        new_arr.push(arr[i]);\n    }\n\n \
    \   new_arr.push(max);\n\n    for i in 0..k {\n        arr[i] = arr[i + k - 1];\n\
    \    }\n\n    for i in 0..k {\n        arr[max_idx] = arr[i];\n    }\n\n    new_arr\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp6lhgc_kh.rs:34:22\n\
    \   |\n34 |         new_arr.push(arr[i]);\n   |                      ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp6lhgc_kh.rs:40:9\n   |\n40 |   \
    \      arr[i] = arr[i + k - 1];\n   |         ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp6lhgc_kh.rs:40:18\n   |\n40 |         arr[i]\
    \ = arr[i + k - 1];\n   |                  ^^^^^^^^^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp6lhgc_kh.rs:44:24\n   |\n44 |         arr[max_idx]\
    \ = arr[i];\n   |                        ^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 4 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 {\n        return arr;\n    }\n   \
    \ \n    let mut max = arr[k - 1];\n    for i in 1..k {\n        if max < arr[i]\
    \ {\n            max = arr[i];\n        }\n    }\n    return vec![max];\n}\n\n\
    fn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4,\
    \ 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
    \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpgxt7jo41.rs:21:19\n\
    \   |\n21 |     let mut max = arr[k - 1];\n   |                   ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpgxt7jo41.rs:23:18\n   |\n23 |  \
    \       if max < arr[i] {\n   |                  ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpgxt7jo41.rs:24:19\n   |\n24 |            \
    \ max = arr[i];\n   |                   ^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max = arr[0];\n    let mut max_index\
    \ = -1;\n    for i in 0..arr.len() {\n        if arr[i] > max {\n            max\
    \ = arr[i];\n            max_index = i;\n        }\n    }\n    max_index..(k+1)\n\
    \        .enumerate()\n        .filter(|&(i, _)| arr[i] > max)\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpsv37j8fk.rs:18:25\n\
    \   |\n18 |     let mut max_index = -1;\n   |                         ^^ the trait\
    \ `Neg` is not implemented for `usize`\n   |\n   = help: the following other types\
    \ implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n\
    \             &i16\n             &i32\n             &i64\n             &i8\n \
    \            &isize\n           and 8 others\n\nerror[E0599]: `isize` is not an\
    \ iterator\n  --> /tmp/tmpsv37j8fk.rs:26:10\n   |\n26 |         .enumerate()\n\
    \   |          ^^^^^^^^^ `isize` is not an iterator\n   |\n   = note: the following\
    \ trait bounds were not satisfied:\n           `isize: Iterator`\n           which\
    \ is required by `&mut isize: Iterator`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpsv37j8fk.rs:25:5\n   |\n16 |   fn maximum(arr: Vec<isize>, k: isize)\
    \ -> Vec<isize> {\n   |                                            ----------\
    \ expected `Vec<isize>` because of return type\n...\n25 | /     max_index..(k+1)\n\
    26 | |         .enumerate()\n27 | |         .filter(|&(i, _)| arr[i] > max)\n\
    28 | |         .collect()\n   | |__________________^ expected struct `Vec`, found\
    \ struct `std::ops::Range`\n   |\n   = note: expected struct `Vec<isize>`\n  \
    \            found struct `std::ops::Range<usize>`\n\nerror: aborting due to 3\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    assert_eq!(k, arr.len(), \"invalid k\");\n  \
    \  \n    if k > arr.len() {\n        vec![arr[0]]\n    } else {\n        let mut\
    \ max_num = arr[0];\n        let mut max_pos = 0;\n        for &num in &arr {\n\
    \            if num > max_num {\n                max_num = num;\n            \
    \    max_pos = 0;\n            }\n            if num == max_num {\n          \
    \      max_pos++;\n            }\n        }\n        vec![max_num]\n         \
    \   .iter()\n            .take(k)\n            .chain(arr\n                .iter()\n\
    \                .skip(max_pos)\n                .take(k)\n                .cloned()\n\
    \                .collect())\n            .cloned()\n    }\n}\n\nfn main() {\n\
    \    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp5z77ckfk.rs:30:24\n\
    \   |\n30 |                 max_pos++;\n   |                        ^^ not a valid\
    \ postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n30 |               \
    \  { let tmp = max_pos; max_pos += 1; tmp };\n   |                 +++++++++++\
    \        ~~~~~~~~~~~~~~~~~~~~~\n30 -                 max_pos++;\n30 +        \
    \         max_pos += 1;\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5z77ckfk.rs:17:5\n\
    \   |\n17 |     assert_eq!(k, arr.len(), \"invalid k\");\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\n   = note: this error originates in the\
    \ macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp5z77ckfk.rs:19:12\n   |\n19 |\
    \     if k > arr.len() {\n   |            ^^^^^^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n19 |     if k > arr.len().try_into().unwrap() {\n \
    \  |                     ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp5z77ckfk.rs:35:19\n   |\n35 |             .take(k)\n   |      \
    \             ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an\
    \ `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n35\
    \ |             .take(k.try_into().unwrap())\n   |                    ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp5z77ckfk.rs:39:23\n   |\n39 |\
    \                 .take(k)\n   |                       ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n39 |                 .take(k.try_into().unwrap())\n\
    \   |                        ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp5z77ckfk.rs:33:9\n   |\n16 |   fn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n   |                                            ----------\
    \ expected `Vec<isize>` because of return type\n...\n33 | /         vec![max_num]"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let len = arr.len();\n    if k < 1 || k > len\
    \ {\n        panic!(\"k should be in range [1, len].\");\n    }\n\n    if k ==\
    \ 1 {\n        return arr.iter().cloned().collect();\n    }\n\n    let mut i =\
    \ 0;\n    let mut j = 0;\n    let mut max = Vec::<isize>::new();\n    while i\
    \ <= k {\n        max.push(arr[i]);\n        while j < len && arr[j] < max[i -\
    \ j] {\n            j += 1\n        }\n        if j == len {\n            j =\
    \ 0;\n        }\n        i += j;\n    }\n    return max;\n}\n\nfn main() {\n \
    \   let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9gmfbbbe.rs:18:21\n   |\n\
    18 |     if k < 1 || k > len {\n   |                     ^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n18 |     if k < 1 || k > len.try_into().unwrap()\
    \ {\n   |                        ++++++++++++++++++++\n\nerror[E0277]: the type\
    \ `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp9gmfbbbe.rs:30:18\n  \
    \ |\n30 |         max.push(arr[i]);\n   |                  ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9gmfbbbe.rs:31:43\n\
    \   |\n31 |         while j < len && arr[j] < max[i - j] {\n   |             \
    \                              ^ expected `isize`, found `usize`\n\nerror[E0277]:\
    \ cannot subtract `usize` from `isize`\n  --> /tmp/tmp9gmfbbbe.rs:31:41\n   |\n\
    31 |         while j < len && arr[j] < max[i - j] {\n   |                    \
    \                     ^ no implementation for `isize - usize`\n   |\n   = help:\
    \ the trait `Sub<usize>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n\
    \             <&'a f64 as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n  \
    \           <&'a i16 as Sub<i16>>\n             <&'a i32 as Sub<i32>>\n      \
    \       <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n            \
    \ <&'a isize as Sub<isize>>\n           and 48 others\n\nerror[E0277]: the type\
    \ `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp9gmfbbbe.rs:31:35\n  \
    \ |\n31 |         while j < len && arr[j] < max[i - j] {\n   |               \
    \                    ^^^^^^^^^^ slice indices are of type `usize` or ranges of\
    \ `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `Sl"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut m = arr.clone();\n    m.sort();\n   \
    \ let mut res = vec![0; k as usize];\n    for i in 0..k {\n        res[i] = m[i];\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmpn18hzbw7.rs:21:9\n   |\n21 |         res[i] = m[i];\n   |         ^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpn18hzbw7.rs:21:18\n\
    \   |\n21 |         res[i] = m[i];\n   |                  ^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k <= 0 {\n        vec![]\n    }\n    if k\
    \ > arr.len() {\n        vec![]\n    }\n\n    if k == 1 {\n        vec![arr[0]]\n\
    \    }\n\n    let mut biggest = arr[0];\n    let mut index = 0;\n\n    for i in\
    \ 0..k {\n        if arr[i] > biggest {\n            biggest = arr[i];\n     \
    \       index = i;\n        }\n    }\n\n    vec![biggest, arr[index]]\n}\n\nfn\
    \ main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4,\
    \ 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
    \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb0cvihqe.rs:18:9\n   |\n\
    17 | /     if k <= 0 {\n18 | |         vec![]\n   | |         ^^^^^^ expected\
    \ `()`, found struct `Vec`\n19 | |     }\n   | |_____- expected this to be `()`\n\
    \   |\n   = note: expected unit type `()`\n                 found struct `Vec<_>`\n\
    \   = note: this error originates in the macro `vec` (in Nightly builds, run with\
    \ -Z macro-backtrace for more info)\nhelp: consider using a semicolon here\n \
    \  |\n19 |     };\n   |      +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb0cvihqe.rs:20:12\n\
    \   |\n20 |     if k > arr.len() {\n   |            ^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n20 |     if k > arr.len().try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpb0cvihqe.rs:21:9\n   |\n20 | /     if k > arr.len() {\n\
    21 | |         vec![]\n   | |         ^^^^^^ expected `()`, found struct `Vec`\n\
    22 | |     }\n   | |_____- expected this to be `()`\n   |\n   = note: expected\
    \ unit type `()`\n                 found struct `Vec<_>`\n   = note: this error\
    \ originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace\
    \ for more info)\nhelp: consider using a semicolon here\n   |\n22 |     };\n \
    \  |      +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb0cvihqe.rs:25:9\n\
    \   |\n24 | /     if k == 1 {\n25 | |         vec![arr[0]]\n   | |         ^^^^^^^^^^^^\
    \ expected `()`, found struct `Vec`\n26 | |     }\n   | |_____- expected this\
    \ to be `()`\n   |\n   = note: expected unit type `()`\n                 found\
    \ struct `Vec<isize>`\n   = note: this error originates in the macro `vec` (in\
    \ Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider using\
    \ a semicolon here\n   |\n26 |     };\n   |      +\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpb0cvihqe.rs:32:12\n   |\n32 |  \
    \       if arr[i] > biggest {\n   |            ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the "
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k <= arr.len() {\n        arr.iter().take(k).copied().collect()\n\
    \    } else {\n        arr.iter().copied().max_by_key(|&x| x).collect()\n    }\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdkca6376.rs:17:13\n   |\n\
    17 |     if k <= arr.len() {\n   |             ^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if k <= arr.len().try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpdkca6376.rs:18:25\n   |\n18 |         arr.iter().take(k).copied().collect()\n\
    \   |                         ^ expected `usize`, found `isize`\n   |\nhelp: you\
    \ can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n18 |         arr.iter().take(k.try_into().unwrap()).copied().collect()\n\
    \   |                          ++++++++++++++++++++\n\nerror[E0599]: `Option<isize>`\
    \ is not an iterator\n   --> /tmp/tmpdkca6376.rs:20:48\n    |\n20  |         \
    \  arr.iter().copied().max_by_key(|&x| x).collect()\n    |                   \
    \                               ^^^^^^^ `Option<isize>` is not an iterator\n \
    \   |\n    = note: the following trait bounds were not satisfied:\n          \
    \  `Option<isize>: Iterator`\n            which is required by `&mut Option<isize>:\
    \ Iterator`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    assert!(\n        k <= arr.len(),\n        \"\
    The length of the vector must be in the range of [1, 1000].\".to_string()\n  \
    \  );\n    let mut result = vec![0; k];\n    let mut cur = vec![-1000, -1000];\n\
    \    for i in 0..k {\n        if arr[i] > cur[1] {\n            cur = vec![arr[i],\
    \ arr[i]];\n        } else if arr[i] < cur[0] {\n            cur = vec![arr[i],\
    \ arr[i]];\n        } else {\n            cur = vec![arr[i], cur[1]];\n      \
    \  }\n        result[i] = cur[0];\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpesikp9o7.rs:18:14\n   |\n\
    18 |         k <= arr.len(),\n   |              ^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n18 |         k <= arr.len().try_into().unwrap(),\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpesikp9o7.rs:21:30\n   |\n21 |     let mut result = vec![0; k];\n\
    \   |                              ^ expected `usize`, found `isize`\n   |\nhelp:\
    \ you can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n21 |     let mut result = vec![0; k.try_into().unwrap()];\n   | \
    \                              ++++++++++++++++++++\n\nerror[E0277]: the type\
    \ `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpesikp9o7.rs:24:12\n  \
    \ |\n24 |         if arr[i] > cur[1] {\n   |            ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpesikp9o7.rs:25:24\n   |\n25 |            \
    \ cur = vec![arr[i], arr[i]];\n   |                        ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpesikp9o7.rs:25:32\n   |\n25 |            \
    \ cur = vec![arr[i], arr[i]];\n   |                                ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented "
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    assert!(k <= arr.len());\n\n    let mut max =\
    \ isize::max_value();\n    let mut max = arr.iter().cloned().take(k).collect::<Vec<_>>();\n\
    \n    for i in 0..k {\n        if max < arr[i] {\n            max = arr[i];\n\
    \        }\n    }\n\n    max\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_5843ke_.rs:17:18\n   |\n\
    17 |     assert!(k <= arr.len());\n   |                  ^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n17 |     assert!(k <= arr.len().try_into().unwrap());\n\
    \   |                           ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_5843ke_.rs:20:44\n   |\n20 |     let mut max = arr.iter().cloned().take(k).collect::<Vec<_>>();\n\
    \   |                                            ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     let mut max = arr.iter().cloned().take(k.try_into().unwrap()).collect::<Vec<_>>();\n\
    \   |                                             ++++++++++++++++++++\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp_5843ke_.rs:23:18\n\
    \   |\n23 |         if max < arr[i] {\n   |                  ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp_5843ke_.rs:24:19\n   |\n24 |            \
    \ max = arr[i];\n   |                   ^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    arr.iter().cloned().windows(k).max().collect()\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `windows` found for struct `Cloned` in the\
    \ current scope\n  --> /tmp/tmpx3_v9_1_.rs:17:25\n   |\n17 |     arr.iter().cloned().windows(k).max().collect()\n\
    \   |                         ^^^^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == arr.len() {\n        arr\n    } else\
    \ {\n        let mut max_num = arr[k - 1];\n        for i in k..arr.len() {\n\
    \            if arr[i] > max_num {\n                max_num = arr[i];\n      \
    \      }\n        }\n        vec![max_num; k]\n    }\n}\n\nfn main() {\n    let\
    \ candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp45497jlr.rs:17:13\n   |\n\
    17 |     if k == arr.len() {\n   |             ^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if k == arr.len().try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0277]: the type\
    \ `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp45497jlr.rs:20:27\n  \
    \ |\n20 |         let mut max_num = arr[k - 1];\n   |                        \
    \   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n\
    \   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n \
    \  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp45497jlr.rs:21:21\n   |\n21 |\
    \         for i in k..arr.len() {\n   |                     ^^^^^^^^^ expected\
    \ `isize`, found `usize`\n\nerror[E0277]: the type `[isize]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmp45497jlr.rs:22:16\n   |\n22 |             if arr[i]\
    \ > max_num {\n   |                ^^^^^^ slice indices are of type `usize` or\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmp45497jlr.rs:23:27\n   |\n23 |                 max_num = arr[i];\n\
    \   |                           ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp45497jlr.rs:26:23\n\
    \   |\n26 |         vec![max_num; k]\n   |      "
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    // write your code here\n    debug_assert_msg(k\
    \ < arr.len(), \"The length of the vector should be less than or equal to the\
    \ length of array\");\n    arr.sort_by(|x, y| x.cmp(y).reverse());\n    let mut\
    \ new_arr = vec![];\n    for i in 0..k {\n        new_arr.push(arr[i]);\n    }\n\
    \    new_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `debug_assert_msg` in this scope\n \
    \ --> /tmp/tmpootfe_ii.rs:18:5\n   |\n18 |     debug_assert_msg(k < arr.len(),\
    \ \"The length of the vector should be less than or equal to the length of array\"\
    );\n   |     ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpootfe_ii.rs:18:26\n   |\n18 |     debug_assert_msg(k <\
    \ arr.len(), \"The length of the vector should be less than or equal to the length\
    \ of array\");\n   |                          ^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n18 |     debug_assert_msg(k < arr.len().try_into().unwrap(),\
    \ \"The length of the vector should be less than or equal to the length of array\"\
    );\n   |                                   ++++++++++++++++++++\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpootfe_ii.rs:22:22\n\
    \   |\n22 |         new_arr.push(arr[i]);\n   |                      ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308, E0425.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    assert!(1 <= arr.len() && arr.len() <= 1000 &&\n\
    \             -1000 <= arr.first() && arr.first() <= 1000,\n             \"Vector\
    \ length must be in the range of [1, 1000].\");\n    assert!(1 <= k && k <= arr.len(),\n\
    \             \"Invalid k: {} for given arr: {}, k: {}\",\n             k,\n \
    \            &arr[..k],\n             arr.len());\n    \n    let mut maximum =\
    \ vec![arr.first()]\n    for i in 1..k {\n        let ele = arr.iter().max().unwrap_or(arr.first());\n\
    \        maximum.push(ele)\n    }\n    \n    maximum\n}\n\nfn main() {\n    let\
    \ candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found keyword `for`\n  --> /tmp/tmptc2i1g55.rs:26:40\n\
    \   |\n26 |     let mut maximum = vec![arr.first()]\n   |                    \
    \                    ^ help: add `;` here\n27 |     for i in 1..k {\n   |    \
    \ --- unexpected token\n\nerror[E0277]: can't compare `{integer}` with `Option<&isize>`\n\
    \  --> /tmp/tmptc2i1g55.rs:18:20\n   |\n18 |              -1000 <= arr.first()\
    \ && arr.first() <= 1000,\n   |                    ^^ no implementation for `{integer}\
    \ < Option<&isize>` and `{integer} > Option<&isize>`\n   |\n   = help: the trait\
    \ `PartialOrd<Option<&isize>>` is not implemented for `{integer}`\n   = help:\
    \ the following other types implement trait `PartialOrd<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmptc2i1g55.rs:18:53\n   |\n18 |\
    \              -1000 <= arr.first() && arr.first() <= 1000,\n   |            \
    \                                         ^^^^ expected enum `Option`, found integer\n\
    \   |\n   = note: expected enum `Option<&isize>`\n              found type `{integer}`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmptc2i1g55.rs:20:28\n   |\n20 |\
    \     assert!(1 <= k && k <= arr.len(),\n   |                            ^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n20 |     assert!(1\
    \ <= k && k <= arr.len().try_into().unwrap(),\n   |                          \
    \           ++++++++++++++++++++\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `RangeTo<isize>`\n  --> /tmp/tmptc2i1g55.rs:23:15\n   |\n23 |   \
    \           &arr[..k],\n   |               ^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `RangeTo<isize>`\n   = help: the following other types\
    \ implement trait `SliceIndex<T>`:\n             <RangeTo<usize> as SliceIndex<[T]>>\n\
    \             <RangeTo<usize> as SliceIndex<str>>\n  "
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 {\n        vec![]\n    } else if arr.len()\
    \ < k {\n        vec![arr.iter().max().unwrap()]\n    } else {\n        arr\n\
    \            .iter()\n            .windows(k)\n            .map(|x| x.iter().max().unwrap())\n\
    \            .collect()\n    }\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5_b95n6f.rs:19:27\n   |\n\
    19 |     } else if arr.len() < k {\n   |                           ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n19 |     } else if arr.len()\
    \ < k.try_into().unwrap() {\n   |                            ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp5_b95n6f.rs:20:14\n   |\n20 |\
    \         vec![arr.iter().max().unwrap()]\n   |              ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n20 |         vec![*arr.iter().max().unwrap()]\n   |              +\n\n\
    error[E0599]: no method named `windows` found for struct `std::slice::Iter` in\
    \ the current scope\n  --> /tmp/tmp5_b95n6f.rs:24:14\n   |\n24 |             .windows(k)\n\
    \   |              ^^^^^^^ method not found in `std::slice::Iter<'_, isize>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 101
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    // Write your code here\n    let mut maximum\
    \ = arr[0];\n    for i in 1..arr.len() {\n        if maximum < arr[i] {\n    \
    \        maximum = arr[i];\n        }\n    }\n    let mut result = Vec::new();\n\
    \    for i in 1..k {\n        result.push(maximum);\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4,\
    \ 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
    \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 5]`,\n right: `[-4, -3, 5]`', /tmp/tmpyixnhfg7.rs:33:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max: isize = 0;\n    let len = arr.len();\n\
    \    if k > len {\n        max = arr[len - 1];\n    } else {\n        for i in\
    \ 0..k {\n            if arr[i] > max {\n                max = arr[i];\n     \
    \       }\n        }\n    }\n    max\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpiunq_12x.rs:19:12\n   |\n\
    19 |     if k > len {\n   |            ^^^ expected `isize`, found `usize`\n \
    \  |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n19 |     if k > len.try_into().unwrap() {\n   |   \
    \            ++++++++++++++++++++\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpiunq_12x.rs:23:16\n   |\n23 |            \
    \ if arr[i] > max {\n   |                ^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpiunq_12x.rs:24:23\n   |\n24 |            \
    \     max = arr[i];\n   |                       ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpiunq_12x.rs:28:5\n\
    \   |\n16 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |      \
    \                                    ---------- expected `Vec<isize>` because\
    \ of return type\n...\n28 |     max\n   |     ^^^ expected struct `Vec`, found\
    \ `isize`\n   |\n   = note: expected struct `Vec<isize>`\n                found\
    \ type `isize`\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    // write your code in here\n    \n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9s3oc9cv.rs:16:42\n   |\n\
    16 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |    -------  \
    \                             ^^^^^^^^^^ expected struct `Vec`, found `()`\n \
    \  |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n   |\n   = note: expected struct `Vec<isize>`\n           found\
    \ unit type `()`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut new_arr = vec![];\n    for i in (0..k).rev()\
    \ {\n        let m = arr.iter().max_by_key(|x| x);\n        new_arr.push(m.unwrap());\n\
    \    }\n    new_arr.sort_unstable();\n    new_arr\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpprm4f31v.rs:23:5\n   |\n\
    16 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |             \
    \                             ---------- expected `Vec<isize>` because of return\
    \ type\n...\n23 |     new_arr\n   |     ^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<&isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k <= 0 || arr.len() <= k {\n        return\
    \ arr;\n    }\n\n    arr.sort().reverse();\n    arr[0..k]\n}\n\nfn main() {\n\
    \    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzc7_xwij.rs:17:31\n   |\n\
    17 |     if k <= 0 || arr.len() <= k {\n   |                               ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     if k <= 0 || arr.len()\
    \ <= k.try_into().unwrap() {\n   |                                ++++++++++++++++++++\n\
    \nerror[E0599]: no method named `reverse` found for unit type `()` in the current\
    \ scope\n  --> /tmp/tmpzc7_xwij.rs:21:16\n   |\n21 |     arr.sort().reverse();\n\
    \   |                ^^^^^^^ method not found in `()`\n\nerror[E0277]: the type\
    \ `[isize]` cannot be indexed by `std::ops::Range<isize>`\n  --> /tmp/tmpzc7_xwij.rs:22:5\n\
    \   |\n22 |     arr[0..k]\n   |     ^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `std::ops::Range<isize>`\n   = help: the following other types\
    \ implement trait `SliceIndex<T>`:\n             <std::ops::Range<usize> as SliceIndex<[T]>>\n\
    \             <std::ops::Range<usize> as SliceIndex<str>>\n   = note: required\
    \ because of the requirements on the impl of `Index<std::ops::Range<isize>>` for\
    \ `Vec<isize>`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    assert_eq!(arr.len(), k);\n    let mut arr =\
    \ arr.to_owned();\n    let mut max = arr.iter().max().unwrap();\n    let mut rev\
    \ = vec![];\n    for i in arr.iter() {\n        if i == max {\n            \n\
    \            rev.push(i);\n            \n        } else {\n            \n    \
    \        rev.push(max);\n            \n        }\n    }\n    rev.iter().cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5zvjbhfj.rs:17:5\n   |\n\
    17 |     assert_eq!(arr.len(), k);\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `usize`, found `isize`\n   |\n   = note: this error originates in the macro\
    \ `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n\
    \nerror[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `&isize`\n    --> /tmp/tmp5zvjbhfj.rs:32:25\n     |\n\
    32   |     rev.iter().cloned().collect()\n     |                         ^^^^^^^\
    \ value of type `Vec<isize>` cannot be built from `std::iter::Iterator<Item=&isize>`\n\
    \     |\n     = help: the trait `FromIterator<&isize>` is not implemented for\
    \ `Vec<isize>`\n     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\n\
    note: required by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut maximums = vec![0; k];\n    for element\
    \ in arr {\n        if element > maximums[0] {\n            maximums[0] = element;\n\
    \        } else {\n            for i in 1..k {\n                if element > maximums[i]\
    \ {\n                    maximums[i] = element;\n                }\n         \
    \   }\n        }\n    }\n    maximums\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmph25_ujh6.rs:17:32\n   |\n\
    17 |     let mut maximums = vec![0; k];\n   |                                ^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n17 |     let mut\
    \ maximums = vec![0; k.try_into().unwrap()];\n   |                           \
    \      ++++++++++++++++++++\n\nerror[E0277]: the type `[isize]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmph25_ujh6.rs:23:30\n   |\n23 |                 if element\
    \ > maximums[i] {\n   |                              ^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmph25_ujh6.rs:24:21\n   |\n24 |            \
    \         maximums[i] = element;\n   |                     ^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k < 1 || k > arr.len() {\n        vec![]\n\
    \    } else {\n        let mut max_arr = vec![arr[0]];\n        for i in 2..k\
    \ {\n            if max_arr[0] > max_arr[i] {\n                max_arr[i] = max_arr[0];\n\
    \            }\n        }\n        max_arr\n    }\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqttpclc4.rs:17:21\n   |\n\
    17 |     if k < 1 || k > arr.len() {\n   |                     ^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     if k < 1 || k >\
    \ arr.len().try_into().unwrap() {\n   |                              ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpqttpclc4.rs:22:29\n\
    \   |\n22 |             if max_arr[0] > max_arr[i] {\n   |                   \
    \          ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpqttpclc4.rs:23:17\n\
    \   |\n23 |                 max_arr[i] = max_arr[0];\n   |                 ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k > arr.len() {\n        arr\n    } else {\n\
    \        let mut max_ele = arr[k - 1];\n        let mut max = vec![max_ele; k];\n\
    \        for i in 1..k {\n            if arr[i] > max_ele {\n                max_ele\
    \ = arr[i];\n            }\n            if arr[i] > max_ele {\n              \
    \  max[0] = max_ele;\n            }\n        }\n        max\n    }\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp89amx20o.rs:17:12\n   |\n\
    17 |     if k > arr.len() {\n   |            ^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if k > arr.len().try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp89amx20o.rs:20:27\n   |\n20 |  \
    \       let mut max_ele = arr[k - 1];\n   |                           ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp89amx20o.rs:21:37\n   |\n21 |         let mut\
    \ max = vec![max_ele; k];\n   |                                     ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n21 |         let mut max\
    \ = vec![max_ele; k.try_into().unwrap()];\n   |                              \
    \        ++++++++++++++++++++\n\nerror[E0277]: the type `[isize]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmp89amx20o.rs:23:16\n   |\n23 |             if arr[i]\
    \ > max_ele {\n   |                ^^^^^^ slice indices are of type `usize` or\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmp89amx20o.rs:24:27\n   |\n24 |                 max_ele = arr[i];\n\
    \   |                           ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIn"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    debug_assert!(0 <= k && k <= arr.len());\n  \
    \  let mut max: Option<isize> = None;\n    let mut max_index: usize = 0;\n   \
    \ for index in range(arr.len()) {\n        if max_index < k {\n            let\
    \ element = arr[index];\n            if max != None && element > max.unwrap()\
    \ {\n                max_index = index;\n            }\n            max = Some(element);\n\
    \        } else {\n            break;\n        }\n    }\n    if let Some(element)\
    \ = (max.clone()) {\n        return vec![element];\n    }\n    let mut max = arr.clone();\n\
    \    for element in max {\n        max_index = max_index - 1;\n        if element\
    \ > max[max_index] {\n            max[max_index] = element;\n        }\n    }\n\
    \    return vec![max[0], *max[..k]];\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `range` in this scope\n  --> /tmp/tmpp744jmru.rs:20:18\n\
    \   |\n20 |     for index in range(arr.len()) {\n   |                  ^^^^^ not\
    \ found in this scope\n   |\nhelp: consider importing this function\n   |\n1 \
    \ | use std::slice::range;\n   |\n\nwarning: unnecessary parentheses around `let`\
    \ scrutinee expression\n  --> /tmp/tmpp744jmru.rs:31:28\n   |\n31 |     if let\
    \ Some(element) = (max.clone()) {\n   |                            ^         \
    \  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these\
    \ parentheses\n   |\n31 -     if let Some(element) = (max.clone()) {\n31 +   \
    \  if let Some(element) = max.clone() {\n   | \n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpp744jmru.rs:17:34\n   |\n17 |     debug_assert!(0 <= k && k <=\
    \ arr.len());\n   |                                  ^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n17 |     debug_assert!(0 <= k && k\
    \ <= arr.len().try_into().unwrap());\n   |                                   \
    \        ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp744jmru.rs:21:24\n\
    \   |\n21 |         if max_index < k {\n   |                        ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n21 |         if max_index\
    \ < k.try_into().unwrap() {\n   |                         ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `RangeTo<isize>`\n  -->\
    \ /tmp/tmpp744jmru.rs:41:26\n   |\n41 |     return vec![max[0], *max[..k]];\n\
    \   |                          ^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `RangeTo<isize>`\n   = help: the following other types implement trait `SliceIndex<T>`:\n\
    \             <RangeTo<usize> as SliceIndex<[T]>>\n             <RangeTo<usize>\
    \ as SliceIndex<str>>\n   = note: required because of the requirements on the\
    \ impl of `Index<RangeTo<isize>>"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let len = arr.len();\n    if k == 1 {\n     \
    \   arr\n    } else if k == len {\n        arr.max_by_index(|i| arr[i])\n    }\
    \ else {\n        let mid = (len - 1) / 2;\n        maximum(arr.split_at_mut(mid),\
    \ k - 1).into_iter().flatten().sort_by(|a, b| {\n            let a1 = a as isize;\n\
    \            let b1 = b as isize;\n            a1.cmp(&b1)\n        }).take(k).collect()\n\
    \    }\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmwe6qv1q.rs:20:20\n   |\n\
    20 |     } else if k == len {\n   |                    ^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n20 |     } else if k == len.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0599]: no method\
    \ named `max_by_index` found for struct `Vec<isize>` in the current scope\n  -->\
    \ /tmp/tmpmwe6qv1q.rs:21:13\n   |\n21 |         arr.max_by_index(|i| arr[i])\n\
    \   |             ^^^^^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpmwe6qv1q.rs:24:17\n   |\n24 |         maximum(arr.split_at_mut(mid),\
    \ k - 1).into_iter().flatten().sort_by(|a, b| {\n   |                 ^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found tuple\n   |\n   = note: expected struct `Vec<isize>`\n\
    \               found tuple `(&mut [isize], &mut [isize])`\n\nerror[E0277]: `isize`\
    \ is not an iterator\n    --> /tmp/tmpmwe6qv1q.rs:24:59\n     |\n24   |      \
    \   maximum(arr.split_at_mut(mid), k - 1).into_iter().flatten().sort_by(|a, b|\
    \ {\n     |                                                           ^^^^^^^\
    \ `isize` is not an iterator\n     |\n     = help: the trait `Iterator` is not\
    \ implemented for `isize`\n     = note: if you want to iterate between `start`\
    \ until a value `end`, use the exclusive range syntax `start..end` or the inclusive\
    \ range syntax `start..=end`\n     = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `isize`\nnote: required by a bound in `flatten`\n\
    \nerror[E0599]: no method named `sort_by` found for struct `Flatten` in the current\
    \ scope\n  --> /tmp/tmpmwe6qv1q.rs:24:69\n   |\n24 |         maximum(arr.split_at_mut(mid),\
    \ k - 1).into_iter().flatten().sort_by(|a, b| {\n   |                        \
    \                                             ^^^^^^^ method not found in `Flatten<std::vec::IntoIter<isize>>`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0599.\nFor more inform"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    assert_eq!(k < arr.len(), ())\n    if arr.len()\
    \ == 0 {\n        return vec![];\n    }\n\n    let mut max = arr[0];\n    for\
    \ ele in arr.iter().skip(1) {\n        if ele > max {\n            max = ele;\n\
    \        }\n    }\n\n    let mut max_indices = vec![];\n    let mut max_indices_size\
    \ = vec![0];\n    for ele in arr {\n        if ele == max {\n            let mut\
    \ i = 1;\n            while i < k {\n                let old_size = max_indices_size;\n\
    \                max_indices_size = max_indices_size.iter().cloned().map(|i| i\
    \ * (i + 1)) / 2;\n                max_indices_size.extend(old_size.cloned().iter().cloned().take(k\
    \ - i - 1).cloned());\n                i += 1;\n            }\n            max_indices.extend_from_slice(max_indices_size.clone());\n\
    \        }\n    }\n\n    max_indices.extend_from_slice(max_indices_size.clone());\n\
    \    max_indices.clone()\n}\n\nfn main() {\n    let candidate = maximum;\n   \
    \ assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmp_kyw1cca.rs:17:34\n\
    \   |\n17 |     assert_eq!(k < arr.len(), ())\n   |                          \
    \        ^ help: add `;` here\n18 |     if arr.len() == 0 {\n   |     -- unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_kyw1cca.rs:17:20\n \
    \  |\n17 |     assert_eq!(k < arr.len(), ())\n   |                    ^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n17 |     assert_eq!(k\
    \ < arr.len().try_into().unwrap(), ())\n   |                             ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp_kyw1cca.rs:17:5\n   |\n17 | \
    \    assert_eq!(k < arr.len(), ())\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `bool`, found `()`\n   |\n   = note: this error originates in the macro `assert_eq`\
    \ (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_kyw1cca.rs:24:18\n   |\n24 |         if ele\
    \ > max {\n   |                  ^^^\n   |                  |\n   |          \
    \        expected `&isize`, found `isize`\n   |                  help: consider\
    \ borrowing here: `&max`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_kyw1cca.rs:25:19\n\
    \   |\n22 |     let mut max = arr[0];\n   |                   ------ expected\
    \ due to this value\n...\n25 |             max = ele;\n   |                  \
    \ ^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n25 |             max = *ele;\n   |                   +\n\nerror[E0369]:\
    \ cannot divide `Map<Cloned<std::slice::Iter<'_, {integer}>>, [closure@/tmp/tmp_kyw1cca.rs:36:73:\
    \ 36:88]>` by `{integer}`\n  --> /tmp/tmp_kyw1cca.rs:36:90\n   |\n36 |       \
    \          max_indices_size = max_indices_size.iter().cloned().map(|i| i * (i\
    \ + 1)) / 2;\n   |                                    -----------------------------------------------------\
    \ ^ - {integer}\n   |                                    |\n   |             \
    \                       Map<Cloned<std::slice::Iter<'_, {integer}>>, [closu"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k > arr.len() {\n        return vec![];\n\
    \    }\n    let mut arr = arr.to_vec();\n    let mut max: isize = arr[0];\n  \
    \  let mut max_idx: isize = 1;\n    for (i, elt) in arr.iter().enumerate() {\n\
    \        if elt > max {\n            max = elt;\n            max_idx = i;\n  \
    \      }\n    }\n    let mut ret = vec![max];\n    ret.truncate(max_idx);\n  \
    \  return ret;\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpscmd1iq5.rs:17:12\n   |\n\
    17 |     if k > arr.len() {\n   |            ^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if k > arr.len().try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpscmd1iq5.rs:24:18\n   |\n24 |         if elt > max {\n\
    \   |                  ^^^\n   |                  |\n   |                  expected\
    \ `&isize`, found `isize`\n   |                  help: consider borrowing here:\
    \ `&max`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpscmd1iq5.rs:25:19\n\
    \   |\n21 |     let mut max: isize = arr[0];\n   |                  ----- expected\
    \ due to this type\n...\n25 |             max = elt;\n   |                   ^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n25 |             max = *elt;\n   |                   +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpscmd1iq5.rs:26:23\n   |\n22 |     let mut max_idx:\
    \ isize = 1;\n   |                      ----- expected due to this type\n...\n\
    26 |             max_idx = i;\n   |                       ^ expected `isize`,\
    \ found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpscmd1iq5.rs:30:18\n\
    \   |\n30 |     ret.truncate(max_idx);\n   |                  ^^^^^^^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n30 |     ret.truncate(max_idx.try_into().unwrap());\n\
    \   |                         ++++++++++++++++++++\n\nerror: aborting due to 5\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_element = arr.iter().max();\n   \
    \ let mut result = vec![];\n    while k < arr.len() {\n        result += vec![max_element];\n\
    \        max_element = arr.iter().max();\n        k += 1;\n    }\n    result +=\
    \ vec![max_element];\n    result\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw7bg5mmh.rs:19:15\n   |\n\
    19 |     while k < arr.len() {\n   |               ^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n19 |     while k < arr.len().try_into().unwrap()\
    \ {\n   |                        ++++++++++++++++++++\n\nerror[E0368]: binary\
    \ assignment operation `+=` cannot be applied to type `Vec<_>`\n  --> /tmp/tmpw7bg5mmh.rs:20:9\n\
    \   |\n20 |         result += vec![max_element];\n   |         ------^^^^^^^^^^^^^^^^^^^^^\n\
    \   |         |\n   |         cannot use `+=` on type `Vec<_>`\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `Vec<_>`\n  --> /tmp/tmpw7bg5mmh.rs:24:5\n\
    \   |\n24 |     result += vec![max_element];\n   |     ------^^^^^^^^^^^^^^^^^^^^^\n\
    \   |     |\n   |     cannot use `+=` on type `Vec<_>`\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0368.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut res = vec![];\n    \n    for i in arr.iter()\
    \ {\n        if res.len() < k {\n            res.push(i);\n        } else {\n\
    \            if *i > *res.iter().max() {\n                res.clear();\n     \
    \       }\n        }\n    }\n\n    res\n}\n\nfn main() {\n    let candidate =\
    \ maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0s02ip9a.rs:20:24\n   |\n\
    20 |         if res.len() < k {\n   |                        ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n20 |         if res.len() < k.try_into().unwrap()\
    \ {\n   |                         ++++++++++++++++++++\n\nerror[E0614]: type `Option<&&isize>`\
    \ cannot be dereferenced\n  --> /tmp/tmp0s02ip9a.rs:23:21\n   |\n23 |        \
    \     if *i > *res.iter().max() {\n   |                     ^^^^^^^^^^^^^^^^^\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp0s02ip9a.rs:29:5\n   |\n16 | fn\
    \ maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |                   \
    \                       ---------- expected `Vec<isize>` because of return type\n\
    ...\n29 |     res\n   |     ^^^ expected `isize`, found `&isize`\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n              found struct `Vec<&isize>`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0614.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max = vec![];\n    for i in arr {\n \
    \       if i > k.into() {\n            max.push(i - k.into());\n        } else\
    \ {\n            max.push(i);\n        }\n    }\n    max\n}\n\nfn main() {\n \
    \   let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0284]: type annotations needed: cannot satisfy `<isize as Sub<_>>::Output\
    \ == isize`\n  --> /tmp/tmp5y418cr6.rs:20:24\n   |\n20 |             max.push(i\
    \ - k.into());\n   |                        ^ cannot satisfy `<isize as Sub<_>>::Output\
    \ == isize`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0284`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 {\n        return arr\n    }\n    if\
    \ k == arr.len() {\n        let mut res = vec![arr[0]];\n        for e in arr.iter().rev()\
    \ {\n            if e > res[0] {\n                res.insert(0, e);\n        \
    \    }\n        }\n        return res.drain(..);\n    }\n    let mut m = vec![arr[0]];\n\
    \    for i in 1..k {\n        let mut max = m[0]\n        for i in 0..k {\n  \
    \          if m[i] > max {\n                max = m[i];\n            }\n     \
    \   }\n        m.insert(0, max);\n    }\n    return m.drain(..);\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found keyword `for`\n  --> /tmp/tmpp6u46x88.rs:31:27\n\
    \   |\n31 |         let mut max = m[0]\n   |                           ^ help:\
    \ add `;` here\n32 |         for i in 0..k {\n   |         --- unexpected token\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpp6u46x88.rs:20:13\n   |\n20 |\
    \     if k == arr.len() {\n   |             ^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n20 |     if k == arr.len().try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpp6u46x88.rs:23:20\n   |\n23 |             if e > res[0]\
    \ {\n   |                    ^^^^^^\n   |                    |\n   |         \
    \           expected `&isize`, found `isize`\n   |                    help: consider\
    \ borrowing here: `&res[0]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp6u46x88.rs:24:31\n\
    \   |\n24 |                 res.insert(0, e);\n   |                          \
    \     ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n24 |                 res.insert(0, *e);\n   |                \
    \               +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp6u46x88.rs:27:16\n\
    \   |\n16 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |      \
    \                                    ---------- expected `Vec<isize>` because\
    \ of return type\n...\n27 |         return res.drain(..);\n   |              \
    \  ^^^^^^^^^^^^^ expected struct `Vec`, found struct `std::vec::Drain`\n   |\n\
    \   = note: expected struct `Vec<isize>`\n              found struct `std::vec::Drain<'_,\
    \ isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n \
    \ --> /tmp/tmpp6u46x88.rs:33:16\n   |\n33 |             if m[i] > max {\n   |\
    \                ^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Ind"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k < 0 || arr.len() < k {\n        return vec![];\n\
    \    }\n    let mut maximum: Vec<isize> = vec![];\n    for i in 0..k {\n     \
    \   if arr[i] > maximum[0] {\n            maximum = vec![maximum[0], arr[i]];\n\
    \        }\n    }\n    for i in 0..k {\n        maximum = vec![maximum[0], maximum[1]];\n\
    \    }\n    for i in 0..k {\n        if arr[i] > maximum[1] {\n            maximum\
    \ = vec![maximum[1], arr[i]];\n        }\n    }\n    for i in 0..k {\n       \
    \ if arr[i] > maximum[1] {\n            maximum = vec![maximum[1], maximum[2]];\n\
    \        }\n    }\n    for i in 0..k {\n        if arr[i] > maximum[2] {\n   \
    \         maximum = vec![maximum[2], arr[i]];\n        }\n    }\n    for i in\
    \ 0..k {\n        if arr[i] > maximum[2] {\n            maximum = vec![maximum[2],\
    \ maximum[3]];\n        }\n    }\n    for i in 0..k {\n        if arr[i] > maximum[3]\
    \ {\n            maximum = vec![maximum[3], arr[i]];\n        }\n    }\n    for\
    \ i in 0..k {\n        if arr[i] > maximum[3] {\n            maximum = vec![maximum[3],\
    \ maximum[4]];\n        }\n    }\n    for i in 0..k {\n        if arr[i] > maximum[4]\
    \ {\n            maximum = vec![maximum[4], arr[i]];\n        }\n    }\n    for\
    \ i in 0..k {\n        if arr[i] > maximum[4] {\n            maximum = vec![maximum[4],\
    \ maximum[5]];\n        }\n    }\n    for i in 0..k {\n        if arr[i] > maximum[5]\
    \ {\n            maximum = vec![maximum[5], arr[i]];\n        }\n    }\n    for\
    \ i in 0..k {\n        if arr[i] > maximum[5] {\n            maximum = vec![maximum[5],\
    \ maximum[6]];\n        }\n    }\n    for i in 0..k {\n        if arr[i] > maximum[6]\
    \ {\n            maximum = vec![maximum[6], arr[i]];\n        }\n    }\n    for\
    \ i in 0..k {\n        if arr[i] > maximum[6] {\n            maximum = vec![maximum[6],\
    \ maximum[7]];\n        }\n    }\n    for i in 0..k {\n        if arr[i] > maximum[7]\
    \ {\n            maximum = vec![maximum[7], arr[i]];\n        }\n    }\n    for\
    \ i in 0..k {\n        if arr[i] > maximum[7] {\n            maximum = vec![maximum[7],\
    \ maximum[8]];\n        }\n    }\n    for i in 0..k {\n        if arr[i] > maximum[8]\
    \ {\n            maximum\n}\n\nfn main() {\n    let candidate = maximum;\n   \
    \ assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp5_99hsmg.rs:117:3\n\
    \    |\n16  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    99  |     for i in 0..k {\n    |                   - unclosed delimiter\n100 |\
    \         if arr[i] > maximum[8] {\n    |                                - this\
    \ delimiter might not be properly closed...\n101 |             maximum\n102 |\
    \ }\n    | - ...as it matches this but it has different indentation\n...\n117\
    \ | }\n    |   ^\n\nerror[E0434]: can't capture dynamic environment in a fn item\n\
    \   --> /tmp/tmp5_99hsmg.rs:105:21\n    |\n105 |     let candidate = maximum;\n\
    \    |                     ^^^^^^^\n    |\n    = help: use the `|| { ... }` closure\
    \ form instead\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5_99hsmg.rs:17:29\n\
    \   |\n17 |     if k < 0 || arr.len() < k {\n   |                            \
    \ ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to\
    \ a `usize` and panic if the converted value doesn't fit\n   |\n17 |     if k\
    \ < 0 || arr.len() < k.try_into().unwrap() {\n   |                           \
    \   ++++++++++++++++++++\n\nerror[E0277]: the type `[isize]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmp5_99hsmg.rs:22:12\n   |\n22 |         if arr[i] >\
    \ maximum[0] {\n   |            ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmp5_99hsmg.rs:23:40\n   |\n23 |             maximum = vec![maximum[0],\
    \ arr[i]];\n   |                                        ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required becaus"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k >= arr.len() {\n        arr\n    } else\
    \ {\n        arr.iter().windows(k).max_by_key(|&w| w.max()).collect()\n    }\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqvcdine6.rs:17:13\n   |\n\
    17 |     if k >= arr.len() {\n   |             ^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if k >= arr.len().try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0599]: no method\
    \ named `windows` found for struct `std::slice::Iter` in the current scope\n \
    \ --> /tmp/tmpqvcdine6.rs:20:20\n   |\n20 |         arr.iter().windows(k).max_by_key(|&w|\
    \ w.max()).collect()\n   |                    ^^^^^^^ method not found in `std::slice::Iter<'_,\
    \ isize>`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_so_far = arr;\n    let mut max_element\
    \ = arr[0];\n    for x in arr {\n        if x > max_element {\n            max_element\
    \ = x;\n        }\n    }\n    let mut res = vec![];\n    for x in max_so_far {\n\
    \        if max_element <= x {\n            res.push(x);\n            max_element\
    \ = x;\n        }\n    }\n    res.push((max_element + k - 1) as isize);\n    res\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpht430384.rs:17:9\n\
    \   |\n17 |     let mut max_so_far = arr;\n   |         ----^^^^^^^^^^\n   | \
    \        |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: borrow of moved value: `arr`\n  --> /tmp/tmpht430384.rs:18:27\n\
    \   |\n16 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |      \
    \      --- move occurs because `arr` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n17 |     let mut max_so_far = arr;\n   |                 \
    \         --- value moved here\n18 |     let mut max_element = arr[0];\n   | \
    \                          ^^^ value borrowed here after move\n\nerror: aborting\
    \ due to previous error; 1 warning emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut maxs = arr;\n    for i in 0..k {\n  \
    \      match maxs.iter().cmp::max(*i, *maxs.iter().min()) {\n            Ordering::Greater\
    \ => {\n                maxs.push(*maxs.iter().min().unwrap());\n            }\n\
    \            Ordering::Less => {\n                maxs.push(*maxs.iter().max().unwrap());\n\
    \            }\n        }\n    }\n    maxs\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected mut or const in raw pointer type\n  --> /tmp/tmpib2bm66v.rs:19:36\n\
    \   |\n19 |         match maxs.iter().cmp::max(*i, *maxs.iter().min()) {\n   |\
    \                                    ^ expected mut or const in raw pointer type\n\
    \   |\n   = help: use `*mut T` or `*const T` as appropriate\n\nerror: expected\
    \ mut or const in raw pointer type\n  --> /tmp/tmpib2bm66v.rs:19:40\n   |\n19\
    \ |         match maxs.iter().cmp::max(*i, *maxs.iter().min()) {\n   |       \
    \                                 ^ expected mut or const in raw pointer type\n\
    \   |\n   = help: use `*mut T` or `*const T` as appropriate\n\nerror: expected\
    \ one of `!`, `(`, `)`, `,`, `::`, or `<`, found `.`\n  --> /tmp/tmpib2bm66v.rs:19:45\n\
    \   |\n19 |         match maxs.iter().cmp::max(*i, *maxs.iter().min()) {\n   |\
    \                                             ^\n   |                        \
    \                     |\n   |                                             expected\
    \ one of `!`, `(`, `)`, `,`, `::`, or `<`\n   |                              \
    \               help: missing `,`\n\nerror: expected one of `!`, `)`, `+`, `,`,\
    \ `->`, or `::`, found `.`\n  --> /tmp/tmpib2bm66v.rs:19:52\n   |\n19 |      \
    \   match maxs.iter().cmp::max(*i, *maxs.iter().min()) {\n   |               \
    \                                     ^\n   |                                \
    \                    |\n   |                                                 \
    \   expected one of `!`, `)`, `+`, `,`, `->`, or `::`\n   |                  \
    \                                  help: missing `,`\n\nerror: expected one of\
    \ `(`, `.`, `?`, `{`, or an operator, found `::`\n  --> /tmp/tmpib2bm66v.rs:19:30\n\
    \   |\n19 |         match maxs.iter().cmp::max(*i, *maxs.iter().min()) {\n   |\
    \         -----                ^^ expected one of `(`, `.`, `?`, `{`, or an operator\n\
    \   |         |\n   |         while parsing this `match` expression\n\nerror:\
    \ aborting due to 5 previous errors\n\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr: Vec<isize> = arr.to_vec();\n\
    \    for i in 0..k {\n        max_arr.iter().max_by_key(|x| *x).unwrap()\n   \
    \ }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpol2x9c9i.rs:19:9\n   |\n\
    19 |         max_arr.iter().max_by_key(|x| *x).unwrap()\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: consider using a semicolon here: `;`\n   |         |\n   |         expected\
    \ `()`, found `&isize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut largest = arr[0];\n    for i in 1..k\
    \ {\n        if largest.partial_cmp(&arr[i]) < 0 {\n            largest = arr[i];\n\
    \        }\n    }\n    largest\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp85huizpd.rs:19:33\n\
    \   |\n19 |         if largest.partial_cmp(&arr[i]) < 0 {\n   |              \
    \                   ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp85huizpd.rs:19:43\n   |\n19 |\
    \         if largest.partial_cmp(&arr[i]) < 0 {\n   |                        \
    \                   ^ expected enum `Option`, found integer\n   |\n   = note:\
    \ expected enum `Option<std::cmp::Ordering>`\n              found type `{integer}`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp85huizpd.rs:20:23\n\
    \   |\n20 |             largest = arr[i];\n   |                       ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp85huizpd.rs:23:5\n   |\n16 | fn maximum(arr: Vec<isize>, k: isize)\
    \ -> Vec<isize> {\n   |                                          ---------- expected\
    \ `Vec<isize>` because of return type\n...\n23 |     largest\n   |     ^^^^^^^\
    \ expected struct `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \                found type `isize`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut sorted_arr = arr.clone();\n    sorted_arr.sort_unstable();\n\
    \    if k <= 0 || k > arr.len() {\n        sorted_arr.clone_from_slice(arr.to_vec())\n\
    \    } else {\n        let mut max_k = k;\n        let mut max_element = sorted_arr[0];\n\
    \        sorted_arr.sort_unstable();\n        for i in 0..k {\n            if\
    \ sorted_arr[i] > max_element {\n                max_k = k;\n                max_element\
    \ = sorted_arr[i];\n            }\n            else\n            {\n         \
    \       max_k--;\n            }\n        }\n        sorted_arr.push(max_element);\n\
    \        sorted_arr.clone_from_slice(sorted_arr.to_vec())\n    }\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmp2ardnoem.rs:32:24\n\
    \   |\n32 |                 max_k--;\n   |                        ^ expected expression\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp2ardnoem.rs:19:22\n   |\n19 |\
    \     if k <= 0 || k > arr.len() {\n   |                      ^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n19 |     if k <= 0 || k\
    \ > arr.len().try_into().unwrap() {\n   |                               ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp2ardnoem.rs:20:37\n   |\n20 |\
    \         sorted_arr.clone_from_slice(arr.to_vec())\n   |                    \
    \                 ^^^^^^^^^^^^\n   |                                     |\n \
    \  |                                     expected `&[isize]`, found struct `Vec`\n\
    \   |                                     help: consider borrowing here: `&arr.to_vec()`\n\
    \   |\n   = note: expected reference `&[isize]`\n                 found struct\
    \ `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2ardnoem.rs:20:9\n\
    \   |\n16 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |      \
    \                                    ---------- expected `Vec<isize>` because\
    \ of return type\n...\n20 |         sorted_arr.clone_from_slice(arr.to_vec())\n\
    \   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n   |\n   = note: expected struct `Vec<isize>`\n           found\
    \ unit type `()`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmp2ardnoem.rs:26:16\n   |\n26 |             if sorted_arr[i] > max_element\
    \ {\n   |                ^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmp2ardnoem.rs:28"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_val = vec![];\n    for val in arr\
    \ {\n        if val > max_val.len() {\n            max_val.resize(val as usize,\
    \ 0);\n        }\n        max_val[val as usize] += 1;\n    }\n\n    // sort the\
    \ vector to get the maximum number of elements.\n    max_val.sort();\n\n    //\
    \ remove the elements of the vector that correspond to the maximum number of elements\n\
    \    for mut i in 0..k {\n        let index = max_val.iter().find(|&n| n > i).unwrap();\n\
    \        max_val[index as usize] -= 1;\n    }\n\n    // return the vector with\
    \ the maximum number of elements\n    max_val\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphinettkp.rs:19:18\n   |\n\
    19 |         if val > max_val.len() {\n   |                  ^^^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n19 |         if val > max_val.len().try_into().unwrap()\
    \ {\n   |                               ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmphinettkp.rs:30:50\n   |\n30 |         let index\
    \ = max_val.iter().find(|&n| n > i).unwrap();\n   |                          \
    \                        ^\n   |                                             \
    \     |\n   |                                                  expected reference,\
    \ found `isize`\n   |                                                  help: consider\
    \ borrowing here: `&i`\n   |\n   = note: expected reference `&_`\n           \
    \        found type `isize`\n\nerror[E0606]: casting `&isize` as `usize` is invalid\n\
    \  --> /tmp/tmphinettkp.rs:31:17\n   |\n31 |         max_val[index as usize] -=\
    \ 1;\n   |                 -----^^^^^^^^^\n   |                 |\n   |      \
    \           cannot cast `&isize` as `usize`\n   |                 help: dereference\
    \ the expression: `*index`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0606.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k <= arr.len() {\n        let mut result =\
    \ vec![];\n        let mut max = 0;\n        for i in 0..k {\n            if max\
    \ < arr[i] {\n                max = arr[i];\n            }\n            result[i]\
    \ = max;\n        }\n        result\n    } else {\n        arr\n    }\n}\n\nfn\
    \ main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4,\
    \ 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
    \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8gqmo2fi.rs:17:13\n   |\n\
    17 |     if k <= arr.len() {\n   |             ^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if k <= arr.len().try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0277]: the type\
    \ `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp8gqmo2fi.rs:21:22\n  \
    \ |\n21 |             if max < arr[i] {\n   |                      ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp8gqmo2fi.rs:22:23\n   |\n22 |  \
    \               max = arr[i];\n   |                       ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[_]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmp8gqmo2fi.rs:24:13\n   |\n24 |             result[i]\
    \ = max;\n   |             ^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<_>`\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 {\n        arr\n    } else if arr.len()\
    \ < k {\n        arr\n    } else {\n        let mut max_index = arr.len();\n \
    \       let mut max_element = arr.clone();\n        \n        for i in 0..arr.len()\
    \ {\n            if arr[i] > max_element[i] {\n                max_index = i;\n\
    \                max_element = max_element.clone();\n            }\n        }\n\
    \        \n        if max_index == k {\n            max_element\n        } else\
    \ {\n            max_element.swap(0, k);\n            max_element\n        }\n\
    \    }\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2i5gmc8m.rs:19:27\n   |\n\
    19 |     } else if arr.len() < k {\n   |                           ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n19 |     } else if arr.len()\
    \ < k.try_into().unwrap() {\n   |                            ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp2i5gmc8m.rs:32:25\n   |\n32 |\
    \         if max_index == k {\n   |                         ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n32 |         if max_index == k.try_into().unwrap()\
    \ {\n   |                          ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2i5gmc8m.rs:35:33\n   |\n35 |             max_element.swap(0,\
    \ k);\n   |                                 ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n35 |             max_element.swap(0, k.try_into().unwrap());\n\
    \   |                                  ++++++++++++++++++++\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let len = arr.len();\n    let mut max = isize::max_value();\n\
    \    for i in 0..k {\n        max = if max > arr[i] { max } else { arr[i] };\n\
    \    }\n    vec.from_iter((0..k).map(|i| max).take(len)).collect()\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0423]: expected value, found macro `vec`\n  --> /tmp/tmpgt90mase.rs:22:5\n\
    \   |\n22 |     vec.from_iter((0..k).map(|i| max).take(len)).collect()\n   | \
    \    ^^^ not a value\n\nerror[E0277]: the type `[isize]` cannot be indexed by\
    \ `isize`\n  --> /tmp/tmpgt90mase.rs:20:24\n   |\n20 |         max = if max >\
    \ arr[i] { max } else { arr[i] };\n   |                        ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpgt90mase.rs:20:46\n   |\n20 |         max\
    \ = if max > arr[i] { max } else { arr[i] };\n   |                           \
    \                   ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0423.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut result = vec![vec![0]; k];\n    for i\
    \ in 0..k {\n        vec![i] = max!(arr[i], vec![0]);\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4,\
    \ 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
    \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error: cannot find macro `max` in this scope\n  --> /tmp/tmpf05el2cf.rs:19:19\n\
    \   |\n19 |         vec![i] = max!(arr[i], vec![0]);\n   |                   ^^^\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpf05el2cf.rs:17:36\n   |\n17 |\
    \     let mut result = vec![vec![0]; k];\n   |                               \
    \     ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n17 |     let\
    \ mut result = vec![vec![0]; k.try_into().unwrap()];\n   |                   \
    \                  ++++++++++++++++++++\n\nerror[E0164]: expected tuple struct\
    \ or tuple variant, found associated function\n  --> /tmp/tmpf05el2cf.rs:19:9\n\
    \   |\n19 |         vec![i] = max!(arr[i], vec![0]);\n   |         ^^^^^^^ `fn`\
    \ calls are not allowed in patterns\n   |\n   = help: for more information, visit\
    \ https://doc.rust-lang.org/book/ch18-00-patterns.html\n   = note: this error\
    \ originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace\
    \ for more info)\n\nerror[E0070]: invalid left-hand side of assignment\n  -->\
    \ /tmp/tmpf05el2cf.rs:19:17\n   |\n19 |         vec![i] = max!(arr[i], vec![0]);\n\
    \   |         ------- ^\n   |         |\n   |         cannot assign to this expression\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpf05el2cf.rs:21:5\n   |\n16 | fn\
    \ maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |                   \
    \                       ---------- expected `Vec<isize>` because of return type\n\
    ...\n21 |     result\n   |     ^^^^^^ expected `isize`, found struct `Vec`\n \
    \  |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<Vec<{integer}>>`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0070, E0164, E0308.\nFor more information about an error, try `rustc --explain\
    \ E0070`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k <= 0 || k > arr.len() {\n        return\
    \ vec![];\n    }\n    let mut result = vec![];\n    for i in 0..k {\n        let\
    \ mut max_element = arr[0];\n        for element in arr {\n            if element\
    \ > max_element {\n                max_element = element;\n            }\n   \
    \     }\n        result.append(max_element);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc61ltrk1.rs:17:22\n   |\n\
    17 |     if k <= 0 || k > arr.len() {\n   |                      ^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     if k <= 0 || k\
    \ > arr.len().try_into().unwrap() {\n   |                               ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpc61ltrk1.rs:28:23\n   |\n28 |\
    \         result.append(max_element);\n   |                       ^^^^^^^^^^^\
    \ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference\
    \ `&mut Vec<_>`\n                           found type `isize`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if arr.is_empty() { return vec![]; }\n    if\
    \ arr.len() < k {\n        return vec![];\n    }\n    if k == 1 {\n        return\
    \ vec![arr.iter().max().unwrap()];\n    }\n    let mut max_val: isize = 0;\n \
    \   let mut max_idx: usize = 0;\n    for i in arr.iter() {\n        if i > max_val\
    \ {\n            max_idx = i;\n            max_val = i;\n        }\n    }\n  \
    \  if max_idx == arr.len() - 1 {\n        return vec![max_val];\n    }\n    let\
    \ mut tail: Vec<isize> = arr[k..];\n    for i in tail.iter() {\n        if i >\
    \ max_val {\n            max_idx = k;\n            max_val = i;\n        }\n \
    \   }\n    vec![max_val] + tail.iter().map(|x| x).collect()\n}\n\nfn main() {\n\
    \    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0ih066kr.rs:18:20\n   |\n\
    18 |     if arr.len() < k {\n   |                    ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n18 |     if arr.len() < k.try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp0ih066kr.rs:22:21\n   |\n22 |         return vec![arr.iter().max().unwrap()];\n\
    \   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n22 |         return vec![*arr.iter().max().unwrap()];\n\
    \   |                     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0ih066kr.rs:27:16\n\
    \   |\n27 |         if i > max_val {\n   |                ^^^^^^^\n   |      \
    \          |\n   |                expected `&isize`, found `isize`\n   |     \
    \           help: consider borrowing here: `&max_val`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp0ih066kr.rs:28:23\n   |\n25 |     let mut max_idx: usize\
    \ = 0;\n   |                      ----- expected due to this type\n...\n28 | \
    \            max_idx = i;\n   |                       ^ expected `usize`, found\
    \ `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0ih066kr.rs:29:23\n\
    \   |\n24 |     let mut max_val: isize = 0;\n   |                      ----- expected\
    \ due to this type\n...\n29 |             max_val = i;\n   |                 \
    \      ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n29 |             max_val = *i;\n   |                     \
    \  +\n\nerror[E0277]: the type `[isize]` cannot be indexed by `RangeFrom<isize>`\n\
    \  --> /tmp/tmp0ih066kr.rs:35:32\n   |\n35 |     let mut tail: Vec<isize> = arr[k..];\n\
    \   |                                ^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `RangeFrom<isize>`\n   = help: the following other types implement\
    \ trait `SliceIndex<T>`:\n             <RangeFrom<usize> as SliceIndex<[T]>>\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut maxs = vec![];\n    for i in 0..k {\n\
    \        let mut max = vec![];\n        for j in 0..arr.len() {\n            if\
    \ arr[j] > arr[j + 1] {\n                max.push(arr[j + 1]);\n            }\
    \ else {\n                max.push(arr[j]);\n            }\n        }\n      \
    \  maxs.push(max);\n    }\n    maxs\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9j1f6qzk.rs:29:5\n   |\n\
    16 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |             \
    \                             ---------- expected `Vec<isize>` because of return\
    \ type\n...\n29 |     maxs\n   |     ^^^^ expected `isize`, found struct `Vec`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<Vec<isize>>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    debug_assert!(arr.len() <= k);\n    arr.sort_unstable();\n\
    \    arr[..k].cloned()\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_fr5uz3z.rs:17:32\n   |\n\
    17 |     debug_assert!(arr.len() <= k);\n   |                                ^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n17 |     debug_assert!(arr.len()\
    \ <= k.try_into().unwrap());\n   |                                 ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `RangeTo<isize>`\n  -->\
    \ /tmp/tmp_fr5uz3z.rs:19:5\n   |\n19 |     arr[..k].cloned()\n   |     ^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `RangeTo<isize>`\n   = help:\
    \ the following other types implement trait `SliceIndex<T>`:\n             <RangeTo<usize>\
    \ as SliceIndex<[T]>>\n             <RangeTo<usize> as SliceIndex<str>>\n   =\
    \ note: required because of the requirements on the impl of `Index<RangeTo<isize>>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_val = arr[0];\n    for i in 0..k\
    \ {\n        if arr[i] > max_val {\n            max_val = arr[i];\n        }\n\
    \    }\n    let mut arr = arr.clone();\n    arr.sort();\n    arr\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpc1anjliz.rs:19:12\n\
    \   |\n19 |         if arr[i] > max_val {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpc1anjliz.rs:20:23\n   |\n20 |            \
    \ max_val = arr[i];\n   |                       ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut result = vec![];\n    let mut max_element\
    \ = arr[0];\n    for i in 1 .. arr.len() {\n        if arr[i] > max_element {\n\
    \            max_element = arr[i];\n        }\n    }\n    let mut count = 1;\n\
    \    for i in 0 .. k {\n        while count < k {\n            if arr[count -\
    \ 1] > arr[i] {\n                result.push(arr[count - 1]);\n            }\n\
    \            count += 1;\n        }\n        result.push(arr[i]);\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpexuh3tvq.rs:27:16\n\
    \   |\n27 |             if arr[count - 1] > arr[i] {\n   |                ^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpexuh3tvq.rs:27:33\n\
    \   |\n27 |             if arr[count - 1] > arr[i] {\n   |                   \
    \              ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpexuh3tvq.rs:28:29\n\
    \   |\n28 |                 result.push(arr[count - 1]);\n   |               \
    \              ^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpexuh3tvq.rs:32:21\n\
    \   |\n32 |         result.push(arr[i]);\n   |                     ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 4 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    assert!(k <= arr.len());\n\n    // Get the maximum\
    \ number in the array\n    let mut max_num = arr[0];\n    for i in 1..k {\n  \
    \      if arr[i] > max_num {\n            max_num = arr[i];\n        }\n    }\n\
    \    max_num\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6wsd86hn.rs:17:18\n   |\n\
    17 |     assert!(k <= arr.len());\n   |                  ^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n17 |     assert!(k <= arr.len().try_into().unwrap());\n\
    \   |                           ++++++++++++++++++++\n\nerror[E0277]: the type\
    \ `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp6wsd86hn.rs:22:12\n  \
    \ |\n22 |         if arr[i] > max_num {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp6wsd86hn.rs:23:23\n   |\n23 |            \
    \ max_num = arr[i];\n   |                       ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6wsd86hn.rs:26:5\n\
    \   |\n16 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |      \
    \                                    ---------- expected `Vec<isize>` because\
    \ of return type\n...\n26 |     max_num\n   |     ^^^^^^^ expected struct `Vec`,\
    \ found `isize`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \   found type `isize`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if arr.len() <= k {\n        return arr;\n  \
    \  }\n    let mut maximum = arr[0];\n    let mut maxIndex = Vec::new();\n    for\
    \ i in 0..k {\n        if maximum > arr[i] {\n            maximum = arr[i];\n\
    \            maxIndex = i;\n        }\n    }\n    arr.remove(maxIndex);\n    return\
    \ arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppbczdjsb.rs:17:21\n   |\n\
    17 |     if arr.len() <= k {\n   |                     ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if arr.len() <= k.try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0277]: the type\
    \ `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmppbczdjsb.rs:23:22\n  \
    \ |\n23 |         if maximum > arr[i] {\n   |                      ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmppbczdjsb.rs:24:23\n   |\n24 |  \
    \           maximum = arr[i];\n   |                       ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppbczdjsb.rs:25:24\n\
    \   |\n21 |     let mut maxIndex = Vec::new();\n   |                        ----------\
    \ expected due to this value\n...\n25 |             maxIndex = i;\n   |      \
    \                  ^ expected struct `Vec`, found `isize`\n   |\n   = note: expected\
    \ struct `Vec<_>`\n                found type `isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmppbczdjsb.rs:28:16\n   |\n28 |     arr.remove(maxIndex);\n\
    \   |                ^^^^^^^^ expected `usize`, found struct `Vec`\n   |\n   =\
    \ note: expected type `usize`\n            found struct `Vec<_>`\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k > arr.len() {\n        return vec![]\n \
    \   }\n    if k == 1 {\n        return arr\n    }\n    let mut max_so_far = arr.clone();\n\
    \    max_so_far.sort_by_key(|i| *i);\n    max_so_far.iter().take(k).collect()\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpiishvnog.rs:17:12\n   |\n\
    17 |     if k > arr.len() {\n   |            ^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if k > arr.len().try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpiishvnog.rs:25:28\n   |\n25 |     max_so_far.iter().take(k).collect()\n\
    \   |                            ^ expected `usize`, found `isize`\n   |\nhelp:\
    \ you can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n25 |     max_so_far.iter().take(k.try_into().unwrap()).collect()\n\
    \   |                             ++++++++++++++++++++\n\nerror[E0277]: a value\
    \ of type `Vec<isize>` cannot be built from an iterator over elements of type\
    \ `&isize`\n    --> /tmp/tmpiishvnog.rs:25:31\n     |\n25   |     max_so_far.iter().take(k).collect()\n\
    \     |                               ^^^^^^^ value of type `Vec<isize>` cannot\
    \ be built from `std::iter::Iterator<Item=&isize>`\n     |\n     = help: the trait\
    \ `FromIterator<&isize>` is not implemented for `Vec<isize>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009287
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max = arr[0];\n    let mut max_index\
    \ = arr.iter().enumerate().filter(|(idx, el)| el > &max).count();\n    while max_index\
    \ > k {\n        max_index -= 1;\n        max = arr[max_index];\n    }\n    arr.iter().enumerate().filter(|(idx,\
    \ el)| el > &max).collect()\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpy6qo1_yk.rs:18:72\n   |\n\
    18 |     let mut max_index = arr.iter().enumerate().filter(|(idx, el)| el > &max).count();\n\
    \   |                                                                        ^^^^\
    \ expected `&isize`, found `isize`\n   |\n   = note: expected reference `&&isize`\n\
    \              found reference `&isize`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpy6qo1_yk.rs:19:23\n   |\n19 |     while max_index > k {\n   |      \
    \                 ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    19 |     while max_index > k.try_into().unwrap() {\n   |                     \
    \   ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpy6qo1_yk.rs:23:52\n\
    \   |\n23 |     arr.iter().enumerate().filter(|(idx, el)| el > &max).collect()\n\
    \   |                                                    ^^^^ expected `&isize`,\
    \ found `isize`\n   |\n   = note: expected reference `&&isize`\n             \
    \ found reference `&isize`\n\nerror[E0277]: a value of type `Vec<isize>` cannot\
    \ be built from an iterator over elements of type `(usize, &isize)`\n    --> /tmp/tmpy6qo1_yk.rs:23:58\n\
    \     |\n23   |     arr.iter().enumerate().filter(|(idx, el)| el > &max).collect()\n\
    \     |                                                          ^^^^^^^ value\
    \ of type `Vec<isize>` cannot be built from `std::iter::Iterator<Item=(usize,\
    \ &isize)>`\n     |\n     = help: the trait `FromIterator<(usize, &isize)>` is\
    \ not implemented for `Vec<isize>`\n     = help: the trait `FromIterator<T>` is\
    \ implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009288
- exit_code: 1
  program: "/// Given a vector arr of integers and a positive integer k, return a\
    \ sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n\
    /// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the vector will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if arr.len() < k || k <= 0 {\n        return\
    \ arr;\n    }\n    let mut max = arr[0];\n    for i in 1..k {\n        if arr[i]\
    \ > max {\n            max = arr[i];\n        }\n    }\n    vec![k..arr.len()].iter().skip(1).take(k).cloned().collect().unwrap_or_else(||\
    \ max)\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_p6y9q9j.rs:17:20\n   |\n\
    17 |     if arr.len() < k || k <= 0 {\n   |                    ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n17 |     if arr.len() < k.try_into().unwrap()\
    \ || k <= 0 {\n   |                     ++++++++++++++++++++\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp_p6y9q9j.rs:22:12\n\
    \   |\n22 |         if arr[i] > max {\n   |            ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp_p6y9q9j.rs:23:19\n   |\n23 |            \
    \ max = arr[i];\n   |                   ^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_p6y9q9j.rs:26:13\n\
    \   |\n26 |     vec![k..arr.len()].iter().skip(1).take(k).cloned().collect().unwrap_or_else(||\
    \ max)\n   |             ^^^^^^^^^ expected `isize`, found `usize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_p6y9q9j.rs:26:44\n   |\n26 |     vec![k..arr.len()].iter().skip(1).take(k).cloned().collect().unwrap_or_else(||\
    \ max)\n   |                                            ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n26 |     vec![k..arr.len()].iter().skip(1).take(k.try_into().unwrap()).cloned().collect().unwrap_or_else(||\
    \ max)\n   |                                             ++++++++++++++++++++\n\
    \nerror: aborting due to 5"
  stdout: ''
  timestamp: 1660009287
