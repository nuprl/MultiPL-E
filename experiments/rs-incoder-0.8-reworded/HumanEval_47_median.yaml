name: HumanEval_47_median
language: rs
prompt: "/// Return median of elements in the vector l.\n/// >>> median(vec![3, 1,\
  \ 2, 4, 5])\n/// 3\n/// >>> median(vec![-10, 4, 6, 1000, 10, 20])\n/// 15.0\nfn\
  \ median(l: Vec<isize>) -> f64 {\n"
tests: "}\n\nfn main() {\n    let candidate = median;\n    assert_eq!(candidate(vec![3,\
  \ 1, 2, 4, 5]), 3.0);\n    assert_eq!(candidate(vec![-10, 4, 6, 1000, 10, 20]),\
  \ 8.0);\n    assert_eq!(candidate(vec![5]), 5.0);\n    assert_eq!(candidate(vec![6,\
  \ 5]), 5.5);\n    assert_eq!(candidate(vec![8, 1, 3, 9, 9, 2, 7]), 7.0);\n}\n"
completions: ["    // Check if vector is sorted.\n    let is_sorted = l.iter().all(|&x|\
    \ x >= 0);\n    if is_sorted {\n        l.iter().fold(0, |x, y| if x < y { x }\
    \ else { y })\n    } else {\n        let mid = l.iter().size_hint().unwrap() /\
    \ 2;\n        let mx_value = l.iter().nth(mid).unwrap();\n        l.iter().fold(mx_value,\
    \ |x, y| if x < y { x } else { y })\n    }", '    l.iter().enumerate().fold(l.len()
    / 2.0, |a, (idx, item)| a + item) / 2.0', '    l.iter().fold(0.0, |x, y| if y
    > x { y } else { x })', "    let l = l.to_owned();\n    l.iter().fold(if l.len()\
    \ % 2 == 0 { l.len() / 2.0 } else { l.len() / 2.0 }, |x, y| if x < y { x } else\
    \ { y })", "    let mut med = 0.;\n    for elt in l.iter() {\n        if elt >\
    \ med {\n            med = elt;\n        }\n    }\n    med", "    let mut l =\
    \ l.to_vec();\n    l.sort();\n    let mid = l.len() / 2;\n    l[mid]", '    l.iter().filter(|&x|
    x > 0).nth(l.len() / 2).unwrap().unwrap_or(0)', "    if l.len() == 0 {\n     \
    \   return 0.0;\n    }\n\n    let len = l.len();\n    let mut l = l.iter().map(|&i|\
    \ i).collect::<Vec<_>>();\n    l.sort();\n\n    match len % 2 {\n        0 =>\
    \ l.iter().next().unwrap(),\n        _ => {\n            let center = l.len()\
    \ / 2;\n            let left = (l.len() / 2) - 1;\n            if left+1 == center\
    \ {\n                // odd: median is element at mid point\n                l.swap(center,\
    \ left);\n            } else {\n                // even: median is mid point -\
    \ median/2\n                l.swap(center, left);\n                l.swap(left,\
    \ (l.len() / 2));\n            }\n        }\n    }", "    let len = l.len();\n\
    \    if len < 2 {\n        0.0\n    }\n    else {\n        let sorted = l.sorted();\n\
    \        sorted[len / 2].expect(\"median of empty list\")\n    }", "    l.iter().fold(f64::nan(),\
    \ |median, item| {\n        if median < item {\n            median\n        }\
    \ else {\n            item\n        }\n    })", "    // Find the midpoint between\
    \ the first and last elements.\n    let mid = l.len() / 2.0;\n\n    // Return\
    \ middle element if odd.\n    if l.len() % 2 == 1 {\n        l[mid]\n    } else\
    \ {\n        // Return median of middle two elements if even.\n        l.len()\
    \ / 2\n    }", "    // Sort the vector in ascending order.\n    l.iter().cloned().sort();\n\
    \    let len = l.len();\n    if len % 2 == 0 {\n        return l[(len - 1) / 2]\
    \ as f64;\n    } else {\n        return l[(len - 1) / 2] - l[(len - 1) / 2].floor()\
    \ as f64;\n    }", "    let mut v = l.iter().cloned().collect::<Vec<_>>();\n \
    \   v.sort_unstable();\n    v.into_iter().next().unwrap() as f64", "    let mut\
    \ v: Vec<isize> = l.iter().cloned().collect();\n    v.sort();\n    v.len().checked_div(2)\n\
    \        .expect(\"median length must be even\")\n        .floor()\n        .expect(\"\
    median length must be even\")", "    l.iter().fold(l.len() / 2.0, |a, b| {\n \
    \       (a + (b / 2.0))\n    })", "    l.iter().enumerate().fold(\n        f64::min(l.iter().map(|(_,\
    \ x)| x)),\n        |m, (i, x)| {\n            if m == i {\n                x\n\
    \            } else {\n                i as f64 / 2.\n            }\n        },\n\
    \    )", "    l.iter()\n        .windows(l.len() / 2)\n        .map(|v| v.iter().cloned().map(|i|\
    \ i.clone()).collect::<Vec<_>>())\n        .flatten()\n        .iter()\n     \
    \   .fold(0.0, |m, v| m + f64(v as f64))\n        .sqrt()\n        .to_f64()",
  '    l.iter().fold(f64::nan, |x, y| if x < y { x } else { y })', '    l.iter().sorted(|a,
    b| a.partial_cmp(b).unwrap()).last().unwrap()', '    l.iter().cloned().fold(0,
    |m, n| if n < m { n } else { m })', "    let n = l.len();\n\n    l.iter().enumerate().skip(n\
    \ - 1).fold(\n        l.iter().max(),\n        |max, (i, elem)| if i == 0 { max\
    \ } else { max.min(elem) },\n    ) as f64", '    l.iter().fold(l.len() / 2., |a,
    x| a + (x.len() / 2.))', '    l.len() / 2', "    l.iter().fold(\n        l.len()\
    \ / 2,\n        |mut min, e| {\n            if *e < min {\n                min\
    \ = *e;\n            }\n            min\n        },\n    )", '    l.iter().take(l.len()
    / 2).fold(0.0, |a, b| a + b) / 2.0', '    l.len() / 2.0', "    l.iter().fold(f64::min_value(),\
    \ |e, &e| {\n        match e {\n            None => e,\n            Some(x) =>\
    \ {\n                let mut low = x;\n                let mut high = x;\n   \
    \             for &e in l {\n                    if e < low {\n              \
    \          low = e;\n                    }\n                    if e > high {\n\
    \                        high = e;\n                    }\n                }\n\
    \                Some((low + high) / 2)\n            }\n        }\n    })", " \
    \   l.iter()\n        .partition(|x| x < l.len() / 2)\n        .map(|(l, r)| l\
    \ + r) / 2\n        .max()", "    l.iter()\n        .enumerate()\n        .fold(0.0,\
    \ |mut sum, (_, i) => sum + i)\n        / l.len()", "    let n = l.len();\n  \
    \  let mut count = vec![0isize; n];\n    for el in l {\n        count [el] +=\
    \ 1;\n    }\n    count [n/2] / (n.into() * 2.0 - 1.0)", '    l.iter().fold(f64::nan(),
    |m, n| m + (n / 2).floor() as f64)', "    // First pass: find the midpoint of\
    \ the sorted list\n    let midpoint = (l.len() / 2) as f64;\n    let left_idx\
    \ = l.iter().enumerate().filter(|(&i, x)| i < midpoint).map(|(i, x)| i).min().unwrap();\n\
    \    let right_idx = l.iter().enumerate().filter(|(&i, x)| i > midpoint).map(|(i,\
    \ x)| i).max().unwrap();\n\n    // Second pass: calculate the median\n    let\
    \ mut v = l.iter().enumerate();\n    v.sort_by_key(|&(i, x)| x);\n    if v.len()\
    \ % 2 == 0 {\n        let median = (v.next().unwrap().0 + v.next().unwrap().1)\
    \ / 2.0;\n    } else {\n        let median = (v.next().unwrap().0 + v.next().unwrap().1)\
    \ / 2.0;\n    }\n\n    // Third pass: find the position of the median in the sorted\
    \ list\n    l.iter().enumerate().filter(|&(i, x)| if x == median { Some(i) } else\
    \ { None }).min().unwrap()", "    l.iter().fold(0, |a, b| if a.is_odd() {\n  \
    \      a.checked_add((b + 1) / (b + 2))\n    } else {\n        b\n    })", '    l.iter().fold(l.len()
    / 2., |acc, x| acc + x)', "    // Find middle index of array and return the middle\
    \ element.\n    let mid = l.len() / 2;\n    l[mid]", "    let mut count = l.len();\n\
    \    let mut m = l.len();\n\n    let mut m2 = l.len();\n    while m2 > m {\n \
    \       count /= 2;\n        m2 = count * 2;\n    }\n\n    if m2 > m {\n     \
    \   m = m2;\n    }\n\n    l.iter().fold(l, |mut x, &n| {\n        if n > x {\n\
    \            x = n;\n        }\n        x\n    })", '    l.iter().fold(f64::NEG_INFINITY,
    |sum, e| sum + e / l.len())', "    l.iter().fold_left(0.0, |sum, val| {\n    \
    \    if sum < val {\n            sum\n        } else {\n            val\n    \
    \    }\n    }) / l.len()", "    let mut lt = l.iter().enumerate();\n    let mut\
    \ lv = lt.rev();\n    let (min, max) = lv.min().unwrap();\n\n    lt.sort_by(|&(_,\
    \ v)| v);\n    let min = lt.next().unwrap().1;\n    let max = lt.next().unwrap().1;\n\
    \    let mid = min + (max - min) / 2;\n\n    if min < mid {\n        lt.sort_by(|&(_,\
    \ v)| -v);\n    }\n\n    if max > mid {\n        lt.reverse();\n    }\n\n    let\
    \ mut median: f64 = 0.0;\n\n    for (i, _) in lt {\n        if i == 0 {\n    \
    \        continue;\n        }\n        if i == 1 {\n            median += *l /\
    \ 2;\n        }\n        median += *l / 2;\n    }\n\n    median", "    if l.len()\
    \ % 2 == 0 {\n        l[(l.len() / 2) - 1].min(l.iter().rev().skip(l.len() / 2)).unwrap()\n\
    \    } else {\n        l[(l.len() / 2)]\n    }", "    let mut sorted = l.iter().cloned().sorted();\n\
    \    sorted.midpoint()", '    l.iter().fold(0, |acc, x| acc + (x / 2))', "   \
    \ l.iter().fold(\n        l.len() % 2 == 0\n            ? l.len() / 2\n      \
    \      : l.len() / 2,\n        |sum, e| sum + (e.fma(l.len() / 2.0, 0.5)),\n \
    \   )", "    l.iter().enumerate().fold(\n        l.len() / 2.0,\n        |m, (i,\
    \ _)| *i as f64 + m / 2.0,\n    )", "    l.iter().fold(f64::NEG_INFINITY,\n  \
    \      |acc, x| if x > acc + f64::from(x / 2) && x < acc + f64::from(x / 2) {\
    \ acc } else { x })", "    l.iter().fold(f64::INFINITY, |res, e| {\n        if\
    \ res < e {\n            res\n        } else {\n            res\n        }\n \
    \   })", "    if l.len() == 0 {\n        f64::MAX\n    } else {\n        let mut\
    \ mid = l.len() / 2;\n        let a = l[mid..].iter().cloned().collect::<Vec<_>>();\n\
    \        mid = a.iter().position(|e| *e < l.iter().last().unwrap()).unwrap_or(mid);\n\
    \        mid\n            .iter()\n            .zip(l.iter().cloned().collect::<Vec<_>>())\n\
    \            .map(|&(aa, bb)| *bb + (*aa < *bb))\n            .max()\n    }",
  "    l.iter()\n        .fold(0.0, |sum, num| sum + num / l.len())", '    l.iter().fold(0f64,
    |acc, x| acc + x / 2)', "    l.iter().cloned().enumerate().map(|(i, _)| (l.len()\
    \ - i).sqrt()).filter(|x| *x != 0.0)\n        .nth(l.len() / 2).unwrap_or(0.0)",
  "    let mut l = l.sort_unstable();\n    let mid = l.len() / 2;\n    l.iter_mut().enumerate().for_each(|(i,\
    \ v)| {\n        if i < mid {\n            *i += 1;\n        } else {\n      \
    \      *i = *i / 2;\n        }\n    });\n    l.iter().fold(0.0, |sum, v| sum +\
    \ v)", '    l.len() / 2.0', "    l.iter().fold1(|a, e| {\n        (a + e) / 2.0\n\
    \    })", "    l.iter().fold(\n        l.iter().fold(0.0f64, |a, b| {\n      \
    \      a > b ? a : b\n        }),\n        |a, b| {\n            a > b ? a : b\n\
    \        })", "    l.iter()\n        .enumerate()\n        .fold(0, |a, (i, v)|\
    \ {\n            a.min(|a, b| if a > b { a } else { b })\n        })", "    l\
    \ is vec::IntoIter<isize> || panic!(\"median requires a vector of isizes\");\n\
    \    let len = l.len();\n    if len == 0 {\n        return panic!(\"median requires\
    \ non-empty vector\");\n    }\n    if len == 1 {\n        return l[0];\n    }\n\
    \n    let mut middle = len / 2;\n    let mut a = l[middle - 1];\n    let mut b\
    \ = l[middle];\n    while a < b {\n        middle = middle / 2;\n        a = l[middle\
    \ - 1];\n        b = l[middle];\n    }\n    let mut c = a;\n    while a <= b {\n\
    \        c = c + 1;\n        a = a + 1;\n    }\n    c / 2", "    if l.len() <=\
    \ 1 {\n        0\n    } else {\n        let l = l.iter().cloned().collect::<Vec<_>>();\n\
    \        let len = l.len();\n        let mid = len / 2;\n        l.sort_unstable();\n\
    \        let l0 = l[mid..].iter().cloned().collect::<Vec<_>>();\n        let l1\
    \ = l[0..mid].iter().cloned().collect::<Vec<_>>();\n        let l2 = l[mid..len].iter().cloned().collect::<Vec<_>>();\n\
    \        let mut l = l0.iter_mut().zip(l1.iter_mut()).zip(l2.iter_mut()).map(|(a,b,c)|\
    \ *a + std::cmp::max(*b,*c)).collect::<Vec<_>>();\n        l.iter().cloned().reduce(std::cmp::max);\n\
    \    }", "    // Find the median.\n    let mut s = l.len() / 2;\n    if l.len()\
    \ % 2 == 1 {\n        s = s + 1;\n    }\n    l.iter().cloned().sorted().first().unwrap()\
    \ + l.iter().cloned().sorted().last().unwrap() / (s.into() + 1)", "    l.iter().fold_left(\n\
    \        l.len() / 2,\n        |acc, x| if x > acc {\n            x\n        }\
    \ else {\n            acc\n        }\n    )", '    l.into_iter().fold(l.len()
    / 2, |a, b| if *b < a { a } else { b })', '    l.iter().fold(0.0, |sum, x| sum
    + f64::from(x.unwrap()))', '    (l.len() / 2) as f64', "    let mut v = l.iter().cloned().collect::<Vec<_>>();\n\
    \    v.sort();\n    v.len() / 2.0", "    let mut a = l.iter().cloned().sorted();\n\
    \    let mut s = a.next().unwrap();\n    let mut m = 0;\n    for x in a {\n  \
    \      if x < s {\n            m = x;\n        } else {\n            s = x;\n\
    \        }\n    }\n    m", "    l.iter().fold(l.len() / 2., |a, b| {\n       \
    \ if a < b {\n            a as f64\n        } else {\n            b as f64\n \
    \       }\n    })", "    let mut lower = l.iter().min().unwrap();\n    let mut\
    \ upper = l.iter().max().unwrap();\n\n    if l.len() == 0 {\n        std::panic!(\"\
    median with empty input\");\n    }\n    if lower == upper {\n        0.0\n   \
    \ }\n    else if lower == std::i32::MIN as f64 {\n        l.len() / 2\n    }\n\
    \    else if upper == std::i32::MAX as f64 {\n        l.len() / 2\n    }\n   \
    \ else {\n        let mid = l.len() / 2;\n        l.len() > mid ? mid\n      \
    \      : l.len() < mid ? l.len() / 2 : mid\n    }", "    let mut i = l.len() /\
    \ 2;\n    match l.len() % 2 {\n        0 => l[i],\n        1 => l.iter().skip(i).fold(l[i],\
    \ |a, b| a + b),\n        _ => l.iter().skip(i).take(i).fold(l[i], |a, b| a +\
    \ b),\n    }", '    (l.len() + 1) as f64 / 2', "    if l.len() % 2 == 1 {\n  \
    \      // If odd number of elements\n        l.len() / 2.0\n    } else {\n   \
    \     let mut mid = l.len() / 2;\n        let mut l_sorted = l.iter().cloned().sorted();\n\
    \        let l_median = l_sorted.mid(mid);\n        l_median.len() / 2\n    }",
  "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n    l.len()\
    \ / 2", "    let mut vec: Vec<_> = l.iter().cloned().collect();\n    vec.sort_unstable_by_key(|x|\
    \ *x);\n    vec.len() / 2.0", "    if l.len() <= 1 {\n        l.first().unwrap()\n\
    \    } else {\n        l.iter().cloned().sorted().last().unwrap()\n    }", " \
    \   let l = l.iter().copied().collect::<Vec<_>>();\n    let n = l.len();\n   \
    \ if n < 2 {\n        return l[0];\n    }\n    let mut middle = n / 2;\n    if\
    \ n % 2 == 0 {\n        middle += 1;\n    }\n    let first_pivot = l.split_at_mut(middle).iter().copied().collect::<Vec<_>>();\n\
    \    let mut second_pivot = l.split_at_mut(middle + 1).iter().copied().collect::<Vec<_>>();\n\
    \    let mut res = 0.0f64;\n    for i in first_pivot {\n        res += i;\n  \
    \  }\n    for i in second_pivot {\n        res += i;\n    }\n    res", "    //\
    \ Compute median of middle two elements.\n    // If l is odd or has only one element,\
    \ just return it.\n    let (left, right) = l.split_last_mut(2);\n    if left.len()\
    \ == 1 {\n        return left[0];\n    }\n    if right.len() == 1 {\n        return\
    \ right[0];\n    }\n    let mid = (left.len() / 2.) + (right.len() / 2.);\n  \
    \  if left.len() <= right.len() {\n        return left[mid];\n    } else {\n \
    \       return right[mid];\n    }", '    l.iter().fold(0.0, |x, y| f64::from(x.partial_cmp(y).unwrap().median()))',
  "    let l = l.iter().cloned().collect::<Vec<_>>();\n    let len = l.iter().cloned().count();\n\
    \    let mut min_value = std::i32::MAX;\n    let mut max_value = std::i32::MIN;\n\
    \    let mut max_pos = 0;\n    let mut min_pos = 0;\n    for i in 0..len {\n \
    \       if l[i] < min_value {\n            min_value = l[i];\n            min_pos\
    \ = i;\n        }\n        if l[i] > max_value {\n            max_value = l[i];\n\
    \            max_pos = i;\n        }\n    }\n\n    if len % 2 == 1 {\n       \
    \ // even\n        let mid = len / 2;\n        let a = l[mid];\n        let b\
    \ = l[len - mid - 1];\n        if a < b {\n            min_pos = mid;\n      \
    \  } else {\n            max_pos = mid;\n        }\n    } else {\n        // odd\n\
    \        let mid = len / 2;\n        let a = l[mid];\n        let b = l[len -\
    \ mid - 1];\n        if a > b {\n            max_pos = mid;\n        } else {\n\
    \            min_pos = mid;\n        }\n    }\n\n    // linear search to find\
    \ the median\n    let mut middle = len / 2;\n    while len > 1 {\n        let\
    \ middle = middle/2;\n        if min_value == l[middle] {\n            min_pos\
    \ = middle;\n        } else if max_value == l[middle] {\n            max_pos =\
    \ middle;\n        } else {\n            break;\n        }\n        len -= middle;\n\
    \    }\n\n    len\n        .checked_sub(min_pos)\n        .checked_add(max_pos\
    \ - min_pos)\n        .checked_div(2)\n        .unwrap_or(std::i32::MAX)", " \
    \   // Calculate the median using the median of medians algorithm.\n    // See\
    \ https://en.wikipedia.org/wiki/Median#Medians_of_medians.\n    let mut l = l.to_vec();\n\
    \    let mut len = l.len();\n    if len == 0 {\n        return 0.0;\n    }\n \
    \   let mut mid = len / 2;\n    let mut res = 0.0f64;\n    while let Some(elem)\
    \ = l.get_mut(mid) {\n        if elem < res {\n            res = elem;\n     \
    \   }\n        mid -= 1;\n    }\n    res", "    if l.len() <= 1 {\n        return\
    \ l.iter().max().unwrap_or(0.0);\n    }\n    let mut n = l.len();\n    let mut\
    \ center = l.iter().fold(0.0, |center, x| {\n        if x < center { x } else\
    \ { center }\n    });\n    if n < 2 {\n        return center;\n    }\n    let\
    \ mut q = n/2;\n    let mut i = 0;\n    let mut min_j = n - 1;\n    while i <\
    \ min_j {\n        if l[i] < center { i += 1; }\n        else { min_j -= 1; }\n\
    \    }\n    if center == l[i] {\n        return l[i];\n    }\n    if l[min_j]\
    \ == center {\n        return l[min_j];\n    }\n    let mut j = min_j;\n    while\
    \ j > i {\n        let min_i = i + 1;\n        let min_p = center;\n        if\
    \ min_i < n {\n            if l[min_i] < center {\n                min_p = l[min_i];\n\
    \                min_i = i;\n            }\n        }\n        if l[j] < min_p\
    \ {\n            return l[j];\n        }\n        i += 1;\n        j -= 1;\n \
    \   }\n    return center;", "    l.iter().fold(f64::INFINITY, (|a, x| {\n    \
    \    if a > x {\n            a\n        } else {\n            x\n        }\n \
    \   }) + f64::INFINITY) / 2", "    let mut m = l.len() / 2;\n    let mut l = l[..m];\n\
    \    l.sort();\n    l[m..].iter().fold(0.0, |a, b| f64::max(b, a) / f64::max(a,\
    \ b))", '    l.iter().fold(f64::NEG_INFINITY, |a, &x| a + (x / 2))', "    l.iter().enumerate().map(|(_,\
    \ e)| {\n        assert!(e % 2 == 0);\n        e / 2\n    }).max().unwrap()",
  "    let mut r = vec![l.len() as f64].into_iter().map(|&v| v as f64).sum();\n  \
    \  for v in l {\n        if r < v {\n            r = v;\n        }\n    }\n  \
    \  r", "    l.iter().cloned().enumerate().filter_map(|(i, e)|\n        if i <\
    \ l.len() / 2 {\n            Some(e * 2.0 / l.len())\n        } else {\n     \
    \       None\n        }\n    ).collect()", "    // Sort and find the middle\n\
    \    let mut s = l.iter().sorted();\n    match s.len() {\n        0 => 0.0,\n\
    \        _ => s[s.len() / 2].0 + s[s.len() / 2].1\n    }", "    l.iter().fold_left(\n\
    \        vec![1],\n        |mut v, e| {\n            if v[0] == e {\n        \
    \        v\n            } else {\n                vec![v.iter().next().unwrap(),\
    \ e].into_iter()\n            }\n        },\n    )\n    .iter()\n    .fold(\n\
    \        vec![],\n        |mut v, e| {\n            if v[0] == e {\n         \
    \       v.push(*e);\n            } else {\n                let x = v.pop();\n\
    \                v.push(*e + x / 2);\n            }\n        },\n    )\n    .into_iter()\n\
    \    .collect()", '    l.len() / 2.0', "    let mut s = l.len() as f64;\n    s.check();\n\
    \    let mut mid = s.floor();\n    if l.len() % 2 == 0 {\n        while l [mid..mid+2]\
    \ > s.iter().map(|x| x as f64).max().unwrap() {\n            mid = (mid + s.iter().map(|x|\
    \ x as f64).max().unwrap() + 1) / 2;\n        }\n    } else {\n        while l\
    \ [mid..mid+2] < s.iter().map(|x| x as f64).min().unwrap() {\n            mid\
    \ = (mid + s.iter().map(|x| x as f64).min().unwrap() - 1) / 2;\n        }\n  \
    \  }\n    l.iter().map(|x| x as f64).filter(|x| x % 2 == 0).max().unwrap()", " \
    \   let mut l = l;\n    l.sort();\n    l.len() / 2.0", '    (l.len() / 2) as f64',
  "    let mut l = l.to_vec();\n    l.sort_unstable();\n    if l.len() == 1 {\n  \
    \      l.iter().next().unwrap()\n    } else {\n        l.iter()\n            .windows(2)\n\
    \            .map(|x| x.iter().next().unwrap())\n            .filter(|x| x.is_some())\n\
    \            .median()\n            .unwrap()\n            .unwrap()\n    }",
  "    l.iter()\n        .enumerate()\n        .filter((i, v) => i % 2 == 0)\n   \
    \     .fold(\n            (0..l.len() / 2).fold(f64::NAN, f64::NAN),\n       \
    \     |prev, index| {\n                let mut v = prev;\n                if index\
    \ < 2 * index {\n                    v += v[index];\n                }\n     \
    \           v\n            },\n        )", "    l.iter().fold(l.len() / 2.0, |acc,\
    \ val| {\n        // round the result to nearest even number\n        acc.floor()\
    \ as f64 + acc.fract() * (l.len() - acc.floor() as f64) / l.len() as f64\n   \
    \ })", "    let n = l.len();\n    let mut l = l.into_iter().collect::<Vec<_>>();\n\
    \    l.sort();\n\n    if n % 2 == 0 {\n        l.iter().fold(\n            Some(l.len()\
    \ / 2),\n            |x, y| if x <= y { Some(x) } else { Some(y) },\n        )\n\
    \    } else {\n        l.iter().fold(\n            Some(l.len() / 2),\n      \
    \      |x, y| if x >= y { Some(x) } else { Some(y) },\n        )\n    }\n    .unwrap()",
  "    let mut l = l.iter().cloned().collect::<Vec<isize>>();\n    l.sort_unstable();\n\
    \    let mut middle = l.len() / 2;\n    let lower = if l.len() % 2 == 0 {\n  \
    \      middle\n    } else {\n        middle - 1\n    };\n    let upper = middle\
    \ + 1;\n    l.swap(lower, upper);\n    let mut mid = 0;\n    for i in 0..l.len()\
    \ {\n        if i == lower || i == upper {\n            continue;\n        }\n\
    \        if mid == 0 || l[i] < l[mid - 1] {\n            l[i] = l[mid];\n    \
    \        mid += 1;\n        } else {\n            l[i] = l[mid - 1];\n       \
    \     mid -= 1;\n        }\n    }\n    l[middle - 1]", '    l.iter().fold(0, |a,
    &x| a.checked_add((*x).abs().floor() as f64) / 2)', "    if l.len() <= 1 {\n \
    \       return l[0];\n    }\n    let mut s = l.iter().fold(0.0, |mut s, e| s +\
    \ e);\n    l.sort_unstable();\n    s / l.len()", '    l.iter().fold(0, |sum, e|
    sum + e) as f64', "    if l.len() > 1 {\n        let mut q: f64 = l.len() / 2.0;\n\
    \        let mut l0: Vec<isize> = l.clone();\n        l0.sort();\n        let\
    \ mut l1: Vec<isize> = l.clone();\n        l1.sort();\n        while l0.len()\
    \ > 0 && l1.len() > 0 {\n            let mut l0i = l0.len() - 1;\n           \
    \ let mut l1i = l1.len() - 1;\n            if l0i < l1i {\n                if\
    \ l0i < q {\n                    l0.pop();\n                    q -= l0i;\n  \
    \              } else {\n                    l1.pop();\n                    q\
    \ -= l1i;\n                }\n            } else {\n                if l1i < q\
    \ {\n                    l1.pop();\n                    q -= l1i;\n          \
    \      } else {\n                    l0.pop();\n                    q -= l0i;\n\
    \                }\n            }\n        }\n        q\n    } else {\n      \
    \  l.len() / 2\n    }", "    l.iter().fold(\n        l.len() / 2.0,\n        |median,\
    \ item| {\n            median - f64::from(item) / f64::from(l.len() - 1.0)\n \
    \       },\n    )", "    if l.len() == 0 {\n        return -1.0;\n    }\n\n  \
    \  if l.len() <= 1 {\n        return l[0] as f64;\n    }\n\n    let mut count\
    \ = 0;\n    let mut min_val = l[0];\n    for v in l.iter().skip(1) {\n       \
    \ min_val = std::cmp::min(min_val, v);\n        count += 1;\n    }\n\n    if count\
    \ / 2 <= 1 {\n        min_val\n    } else {\n        let mut m = (min_val + l[l.len()\
    \ - 1]) / 2.0;\n        let i = 1;\n        for v in l.iter().skip(1) {\n    \
    \        if std::cmp::min(v, (m + v) / 2.0) < m {\n                m = v as f64;\n\
    \                i += 1;\n            }\n        }\n        i / 2.0\n    }", " \
    \   let mut q = (l.len() + 1) >> 1;\n    loop {\n        if l.len() < 2 {\n  \
    \          break;\n        }\n        q = q / 2.0;\n        let mut med = l[q\
    \ as usize / 2];\n        for (i, &v) in l.iter().enumerate() {\n            if\
    \ v < med {\n                med = v;\n            }\n        }\n        q = q\
    \ * 2;\n    }\n    med", "    l.iter().fold(0.0, |a, b| {\n        b.is_odd()\
    \ ? a : ((a + b) / 2.0 - a)\n    })", "    let mut len = l.len();\n    if len\
    \ < 2 {\n        return l[0];\n    }\n    let half = len / 2;\n    l.sort_unstable();\n\
    \    l.partition(|&i| i < half);\n    l.iter().filter(|&i| i >= half).fold(l[0],\
    \ |a, b| {\n        if a < b {\n            a\n        } else {\n            b\n\
    \        }\n    })", "    l.iter()\n        .enumerate()\n        .fold(l.len()\
    \ / 2.0 - l[0] / 2.0, |acc, (n, _)| {\n            acc.checked_add(n * n as f64).unwrap();\n\
    \            acc\n        })", "    let mut m = l.iter().fold(f64::max, |a, b|\
    \ a.max(b));\n    m / f64::from(l.len())", "    let mut m = (l.len() + 1) >> 1;\n\
    \    m += std::cmp::min(l.len() / 2, 1);\n    (l.len() - m).min(m).median()",
  "    l.iter().fold(\n        l.iter().min(),\n        |mut min, elem| {\n      \
    \      if elem < min {\n                min = elem;\n            }\n         \
    \   min\n        },\n    )", "    l.iter().enumerate().map(|(i, x)| {\n      \
    \  if x.len() > i {\n            x.len() as f64 / f64::from(x.len())\n       \
    \ } else {\n            x.len() as f64 / f64::from(1.0).sqrt()\n        }\n  \
    \  }).sum() / f64::from(l.len())", "    let len = l.len();\n    if len < 2 {\n\
    \        return l.len() as f64;\n    }\n    let pivot = len / 2;\n    let mut\
    \ left = l.iter().take(pivot).collect::<Vec<isize>>();\n    let right = l.iter().skip(pivot).collect::<Vec<isize>>();\n\
    \    left + median(right)", '    l.iter().take(l.len() / 2).fold(f64::nan, |sum,
    e| sum + e / 2)', "    l.iter().windowed(l.len() / 2).fold(0.0, |a, b| {\n   \
    \     b.iter().enumerate().fold(a, |mut c, (_, e)| {\n            *c = math.max(0.0,\
    \ *c + e / b.len());\n            a\n        })\n    })", '    l.iter().sorted().fold(0.0,
    |m, x| if *x.floor() < m { *x.floor() } else { m })', '    l.iter().fold(0.0,
    |a, &x| a.min(|b| b if x < b else x))', "    let mut l = l.to_vec();\n    l.sort_unstable();\n\
    \    l.len() / 2", "    let n = l.len();\n    l.iter()\n        .enumerate()\n\
    \        .filter(|(_, x)| x % 2 == 0)\n        .filter(|(_, x)| x < n)\n     \
    \   .map(|(_, x)| x.to_f64() / n as f64)\n        .max()", "    l.iter().fold(math.f64::NEG,\
    \ |a, b| {\n        if *a > *b {\n            a\n        } else {\n          \
    \  b\n        }\n    })", "    l.iter()\n        .enumerate()\n        .filter(|&(i,\
    \ _)| i < l.len() / 2)\n        .fold(\n            l.len() as f64,\n        \
    \    |x, y| {\n                f64::from(x.0) / f64::from(y.0) + f64::from(x.1)\
    \ / f64::from(y.1)\n            },\n        )", '    l.iter().fold((l.len() /
    2).min(l.iter().sum() / 2), (l.len() / 2))', '    (l as f64).median()', "    l.iter().fold(f64::nan(),\
    \ |x, y| {\n        x.checked_add(y).unwrap().into()\n    }).unwrap()", '    l.iter().fold(0.0,
    |acc, e| acc + e) / l.len() as f64', "    l.iter()\n        .enumerate()\n   \
    \     .take(l.len() / 2)\n        .map(|(i, v)| (v as f64 - l[i as usize]) / l[i\
    \ as usize])\n        .sum() as f64", "    let len = l.len();\n    match len {\n\
    \        0 => panic!(\"no elements\"),\n        _ => if len % 2 == 0 { l.len()\
    \ / 2.0 } else { l.len() / 2.0 },\n    }", "    // median of 0 elements is the\
    \ same as 0\n    if l.len() == 0 {\n        return 0.0;\n    }\n\n    let mut\
    \ v = l.iter().cloned().collect::<Vec<isize>>();\n    v.sort();\n    v.dedup();\n\
    \    match v.len() {\n        0 => 0.0,\n        1 => l[0] as f64,\n        _\
    \ => {\n            let mid = v.len() / 2;\n            match v.len() {\n    \
    \            0 => l[0] as f64,\n                1 => {\n                    if\
    \ v[0] == l[0] {\n                        return l[0] as f64\n               \
    \     } else {\n                        return (v[mid] + (l[mid] - v[mid]) / 2.0)\
    \ as f64\n                    }\n                }\n                n => {\n \
    \                   // find the median of the left and right half\n          \
    \          let mid = n / 2;\n                    if v[mid] < l[mid] {\n      \
    \                  if v[mid] < (l[mid] - v[mid]) / 2 {\n                     \
    \       return v[mid]\n                        } else {\n                    \
    \        return l[mid]\n                        }\n                    } else\
    \ {\n                        if v[mid] < (l[mid] - v[mid]) / 2 {\n           \
    \                 return l[mid]\n                        } else {\n          \
    \                  return v[mid]\n                        }\n                \
    \    }\n                }\n            }\n        }\n    }", '    l.iter().fold(0,
    |a, &x| a + x / 2)', "    if l.len() == 0 {\n        return 0.0\n    }\n    l.iter().fold(0.0,\
    \ |sum, el| {\n        let mut value = *el;\n        if value == *sum {\n    \
    \        return *el;\n        } else {\n            *sum += value;\n         \
    \   return value;\n        }\n    })", "    let mut s = l.iter().fold(0.0, |a,\
    \ b| a + b) / l.len();\n    l.iter().skip(l.len() / 2).fold(s | s, |s, &x| s +\
    \ (*x).abs() / 2);", "    let len = l.len();\n\n    if len == 0 {\n        0.0\n\
    \    }\n    if len == 1 {\n        l[0]\n    }\n    let mut middle: f64 = l.iter()\n\
    \        .enumerate()\n        .next()\n        .unwrap()\n        .1;\n\n   \
    \ for x in l {\n        if x < middle {\n            middle = x;\n        }\n\
    \    }\n    middle", "    let mut count = l.len();\n    if count == 0 {\n    \
    \    return 0;\n    }\n    let mut mid = count / 2;\n    let mut l: Vec<_> = l.to_vec();\n\
    \    let mut max = l.iter().max();\n    let mut min = l.iter().min();\n    if\
    \ count % 2 == 1 {\n        mid = mid.saturating_add((count - 1) / 2);\n    }\n\
    \    match count {\n        1 => l[mid],\n        2 => l[mid] + l[mid].clone(),\n\
    \        3 => l[mid] + l[mid].clone() * 2,\n        _ => {\n            count\
    \ = ((count - 1) / 2);\n            mid = mid.saturating_add(count / 2);\n   \
    \         let mut new_count = count - 1;\n            let mut new_mid = mid.saturating_add(new_count\
    \ / 2);\n            while new_count > 0 {\n                if l[new_mid] >= max\
    \ {\n                    new_count -= 1;\n                    let temp = new_mid;\n\
    \                    new_mid = temp.saturating_add(new_count / 2);\n         \
    \       } else {\n                    max = max(max, l[new_mid]);\n          \
    \          new_mid = new_mid.saturating_add(new_count / 2);\n                }\n\
    \            }\n            while new_count < count {\n                if l[new_mid]\
    \ <= min {\n                    new_count += 1;\n                    let temp\
    \ = new_mid;\n                    new_mid = temp.saturating_add(new_count / 2);\n\
    \                } else {\n                    min = min(min, l[new_mid]);\n \
    \                   new_mid = new_mid.saturating_add(new_count / 2);\n       \
    \         }\n            }\n        }\n    }\n    l[mid].clone() * 0.5", '    l.len()
    / 2.0', "    l.iter()\n        .enumerate()\n        .fold(\n            (0.5,\
    \ 0),\n            |(mut sum, mut idx), x| {\n                if *idx < x.0 {\
    \ sum += *idx; }\n                *idx += 1;\n                (sum, idx)\n   \
    \         },\n        )\n        .1", '    l.iter().fold(f64::nan(), |acc, x|
    if x.is_nan() || acc.is_nan() { f64::nan() } else { acc })', "    l.iter().fold(l.len()\
    \ / 2.0, |a, b| if b == 0 || a == b.floor() {\n        a\n    } else {\n     \
    \   b.floor()\n    })", "    let mut r = l.len() / 2;\n    if l.len() % 2 != 0\
    \ {\n        r = r + 1;\n    }\n    l.iter_mut().skip(r).fold(l.iter().median(),\
    \ |a, b| {\n        a.partial_sort_reverse();\n        a.last().unwrap().partial_sort_reverse();\n\
    \        a.last().unwrap() + b.last().unwrap()\n    })", "    let mut vec: Vec<isize>\
    \ = l.to_owned();\n    vec.sort_unstable();\n    vec[vec.len() / 2].to_owned()",
  '    l.iter().windows(2).map(|x| x.iter().min()).unwrap_or_else(|| l.iter().min())',
  "    // O(n log n) algorithm\n    l.iter().rev().windowed(2).fold(\n        0.0,\n\
    \        |a, b| {\n            match (a.last() + b.last()).unwrap_or(a.len() +\
    \ b.len()) {\n                // median between two equal values\n           \
    \     0 => {\n                    let mid: isize = (a.len() + b.len()) / 2;\n\
    \                    a.last().unwrap_or(mid) as f64 / 2\n                }\n \
    \               a.len() => {\n                    a.last().unwrap_or(a.len() as\
    \ f64) / 2 as f64\n                }\n                b.len() => {\n         \
    \           b.last().unwrap_or(b.len() as f64) / 2 as f64\n                }\n\
    \                // median between two non-equal values\n                1 =>\
    \ {\n                    let mid: isize = (b.len() + a.len()) / 2;\n         \
    \           b.last().unwrap_or(mid) as f64 / 2\n                }\n          \
    \      a.len() > b.len() => {\n                    b.last().unwrap_or(b.len()\
    \ as f64) / 2 as f64\n                }\n                a.len() < b.len() =>\
    \ {\n                    a.last().unwrap_or(a.len() as f64) / 2 as f64\n     \
    \           }\n            }\n        },\n    )", "    if l.len() == 0 {\n   \
    \     f64::MAX\n    } else if l.len() == 1 {\n        l[0]\n    } else {\n   \
    \     let mut mid = l.len() / 2;\n        std::cmp::min(mid, l.len() - 1).map(|i|\
    \ l[i])\n    }", "    let mut m = l.iter().min().unwrap();\n    for e in l.iter().skip(1)\
    \ {\n        if e < m {\n            m = e;\n        }\n    }\n    m", "    let\
    \ mut l = l.iter().cloned().collect::<Vec<f64>>();\n    l.sort_unstable();\n \
    \   l.into_iter().next().unwrap()", "    let mut v = l.iter().cloned().collect::<Vec<_>>();\n\
    \    v.sort();\n    let mid = v.len() / 2;\n    v.insert(mid, mid);\n    if v.len()\
    \ % 2 == 0 {\n        v.push((v[0] + v[v.len() - 1]) * 0.5);\n    }\n    v.iter().fold(0.0,\
    \ |sum, val| sum + val / 2.0)", "    l.iter().fold(f64::min_value(), |mut m, &x|\
    \ {\n        if m > x {\n            m\n        } else {\n            x\n    \
    \    }\n    })", '    l.iter().fold(f64::NINF, |sum, e| sum + e)', '    l.len()
    / 2', "    let mut n: isize = 0;\n    let mut mid: isize = 0;\n    for i in l\
    \ {\n        if n < i {\n            n = i;\n        }\n        mid += 1;\n  \
    \      if mid > l.len() / 2 {\n            return mid;\n        }\n    }\n   \
    \ l.len() / 2", '    l.iter().rev().sum().unwrap() / 2.0', "    l.iter().fold(\n\
    \        l.len() as f64 / 2.0,\n        |prev, cur| prev + (cur as f64 / 2),\n\
    \    )", '    l .sorted() . f64::div(l.len() as f64 + 1) .ceil()', "    let mut\
    \ l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n    l.len() / 2.",
  "    let mut count = l.len();\n    if count < 2 {\n        return std::mem::transmute::<f64,\
    \ usize>(*l.iter().next().unwrap());\n    }\n    let mut sum = 0;\n    let mut\
    \ mid = 0;\n    let mut low_idx = 0;\n    let mut high_idx = count - 1;\n    while\
    \ low_idx < high_idx {\n        let (low, high) = if low_idx < high_idx {\n  \
    \          (&mut sum, &mut mid)\n        } else {\n            (&mut mid, &mut\
    \ sum)\n        };\n        let mut lower = &mut l;\n        let mut higher =\
    \ &mut l;\n        if low_idx < high_idx {\n            lower = &mut l[low_idx..high_idx\
    \ + 1];\n            higher = &mut l[..low_idx + high_idx - 1];\n        }\n \
    \       let (l_mid, l_sum) = low.iter().cloned().rev().fold(0, |sum, el| {\n \
    \           sum + el\n        });\n        let (h_mid, h_sum) = higher.iter().cloned().rev().fold(0,\
    \ |sum, el| {\n            sum + el\n        });\n        let mut sum = (l_mid\
    \ + h_mid + l_sum + h_sum) / 4.0;\n        let mut mid = l_mid + h_mid;\n    \
    \    if l_mid < h_mid {\n            low_idx += 1;\n            high_idx -= 1;\n\
    \        } else {\n            low_idx -= 1;\n            high_idx += 1;\n   \
    \     }\n    }\n    return std::mem::transmute::<f64, usize>(*l.iter().next().unwrap());",
  "    l.iter().enumerate().fold(0.0, |mut sum, (_, num)| {\n        *sum += num;\n\
    \        sum\n    }) / l.len()", "    l.iter().fold(f64::NEG_INFINITY, |median,\
    \ el| {\n        if el >= median {\n            el\n        } else {\n       \
    \     median\n        }\n    })", "    // Sort the vector\n    l.iter().sort().take(l.len()\
    \ / 2).fold(0.0, |s, &x| s + f64::from(x / 2))", "    if l.len() < 2 {\n     \
    \   return l.iter().min().unwrap();\n    }\n    let mut midpoint = l.len() / 2;\n\
    \    let mut median_element = 0;\n    for i in 0..midpoint.min(midpoint) {\n \
    \       median_element = if i < midpoint {\n            l[i]\n        } else {\n\
    \            l.get_mut(midpoint + i).unwrap()\n        };\n    }\n    median_element",
  "    l as f64\n        .iter()\n        .fold(0.0f64, |a, b| {\n            a +\
    \ (b as f64) / 2.0\n        })", '    l.iter().enumerate().filter(|&(x, _)| x
    < l.len() / 2).map(|(_, x)| x).median().unwrap_or(0.0)', "    let mut n = l.len();\n\
    \    if n % 2 == 0 {\n        return l.iter().skip(n / 2).reduce(f64::median).unwrap();\n\
    \    }\n\n    let mut median = f64::MAX;\n    let mut index = 0;\n    for i in\
    \ l.iter().skip(n / 2) {\n        median =\n            l.iter().skip(index).take(n\
    \ - index).reduce(f64::median).unwrap()\n            + median;\n        index\
    \ += 1;\n    }\n    median", "    let len = l.len();\n    if len == 0 {\n    \
    \    0.0\n    } else {\n        let middle = len / 2;\n        l.iter().enumerate().for_each(|(idx,\
    \ val)|{\n            if idx - middle < 0 {\n                panic!(\"median index\
    \ should be >= 0\");\n            }\n            if idx + 1 > middle {\n     \
    \           panic!(\"median index should be < len\");\n            }\n       \
    \     assert!(val == l[idx - middle] || val == l[idx + 1]);\n        });\n   \
    \     l.iter().enumerate().for_each(|(idx, val)|{\n            if idx == middle\
    \ {\n                val\n            } else {\n                (val + l[middle\
    \ - idx] - l[middle + idx]) / 2\n            }\n        })\n    }", "    l.iter().fold(\n\
    \        l.iter().skip(l.len() / 2).fold(l[2..].iter().max().unwrap_or(l[l.len()\
    \ / 2]),\n            |a, b| {\n                // if either one is negative,\
    \ we choose the negative\n                // one as the median\n             \
    \   if a < b {\n                    -b\n                } else {\n           \
    \         a\n                }\n            },\n    )", "    let mut min_value\
    \ = l[0];\n    let mut min_idx = l.iter().enumerate().find(|(e, _)| e < min_value);\n\
    \    let mut max_value = l[0];\n    let mut max_idx = l.iter().enumerate().find(|(e,\
    \ _)| e > max_value);\n\n    for idx in l.iter().enumerate().rev() {\n       \
    \ match min_idx {\n            Some(m) if m.0 + m.1 < idx => min_value = l[m.0\
    \ + m.1],\n            _ => (),\n        }\n\n        match max_idx {\n      \
    \      Some(m) if m.0 + m.1 > idx => max_value = l[m.0 + m.1],\n            _\
    \ => (),\n        }\n    }\n\n    (max_value.0, (min_value.0, (max_idx.0 + max_idx.1,\
    \ (min_idx.0 + min_idx.1, l.len() ))))", "    let mut l = l.to_vec();\n    l.sort();\n\
    \    l.len().checked_div(2).unwrap();\n    l[(l.len() - 1)/2].checked_div(2).unwrap()",
  '    l.into_iter().fold(0.0, |acc, x| acc + x)', "    let n = l.len();\n    if n\
    \ == 0 {\n        return 0;\n    }\n    let mut m = l[n / 2];\n    for (i, el)\
    \ in l.iter_mut().enumerate() {\n        if *el < *m {\n            m = el;\n\
    \        }\n    }\n    m", "    let mut l = l.iter().cloned().collect::<Vec<isize>>();\n\
    \    l.sort();\n    l.len()/2", "    let mut lower = l.iter().skip(l.len() / 2).take(l.len()\
    \ / 2).collect::<Vec<_>>();\n    let mut upper = l.iter().skip(l.len() / 2).take(l.len()\
    \ / 2).collect::<Vec<_>>();\n    lower = lower.iter().filter(|x| *x < *lower[0]).collect::<Vec<_>>();\n\
    \    upper = upper.iter().filter(|x| *x < *upper[0]).collect::<Vec<_>>();\n  \
    \  lower.iter().filter(|x| *x > *lower[0]).collect::<Vec<_>>().min(|a, b| a.partial_cmp(&b).unwrap_or(1))",
  '    l.iter().windowed(2).min().next().unwrap_or(l.iter().min())', "    // use rand\
    \ to avoid some problems with unstable algorithms\n    let mut rng = rand::thread_rng();\n\
    \    let mut arr = l.to_vec();\n    arr.sort_unstable();\n    let sz = arr.len()\
    \ as isize;\n    if sz <= 1 { 0.0 }\n    else {\n        let mid = sz / 2.0;\n\
    \        arr[(sz + mid) / 2] as f64\n    }", '    l.iter().cloned().enumerate().map(|(i,
    _)| l.len() - i / 2).unwrap().sum::<f64>() / l.len() as f64', "    l.iter().fold((l.len()\
    \ / 2).floor() as isize, |a, b| {\n        if a > b {\n            (b, a)\n  \
    \      } else {\n            (a, b)\n        }\n    }).0", "    let mut v = l.iter().cloned().collect::<Vec<_>>();\n\
    \    v.sort();\n    v.len()\n        .checked_div(2)\n        .expect(\"len {}\
    \ should be even\", v)", "    let l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    (l.len() % 2).fold(l.iter().next().unwrap(), l.iter().next().unwrap())",
  "    let mut v = l.iter().cloned().collect::<Vec<_>>();\n    v.sort_unstable_by_key(|x|\
    \ x);\n    v.len() / 2", "    if l.len() == 0 {\n        return 0.0\n    }\n \
    \   let mut sorted_l = l;\n    sorted_l.sort();\n\n    if l.len() % 2 == 1 {\n\
    \        let mid = l.len() / 2;\n        sorted_l[mid]\n    } else {\n       \
    \ l.len() / 2\n    }", "    let len = l.len();\n    if len < 1 {\n        return\
    \ std::f64::NAN;\n    }\n\n    let sorted_list = l.iter().sorted();\n    sorted_list[len\
    \ / 2 - 1].unwrap()", "    l.iter().enumerate().fold(l.len() / 2.0, |a, b| {\n\
    \        if b == 0 {\n            a\n        } else {\n            (b.0 as f64).floor()\
    \ + a.0\n        }\n    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    if l.len() < 2 {\n        return l.len().reciprocal();\n \
    \   }\n    let mid = l.len() / 2;\n    let mut lower = l[0];\n    let mut upper\
    \ = l[mid];\n    loop {\n        loop {\n            let mut iter_mid_lower =\
    \ l.iter_mut().skip(mid).take(mid).cloned().collect::<Vec<_>>();\n           \
    \ let mut iter_mid_upper = iter_mid_lower.clone();\n            if iter_mid_lower.len()\
    \ > iter_mid_upper.len() {\n                iter_mid_lower.sort();\n         \
    \       iter_mid_upper.sort();\n            }\n            if iter_mid_lower.len()\
    \ > iter_mid_upper.len() {\n                if iter_mid_lower[0] == iter_mid_upper[0]\
    \ {\n                    return iter_mid_lower[0];\n                } else {\n\
    \                    lower = iter_mid_lower[0];\n                    upper = iter_mid_upper[0];\n\
    \                    mid = l.len() / 2;\n                }\n            } else\
    \ {\n                if iter_mid_lower[mid] == iter_mid_upper[mid] {\n       \
    \             return iter_mid_lower[mid];\n                } else {\n        \
    \            lower = iter_mid_lower[mid];\n                    upper = iter_mid_upper[mid];\n\
    \                    mid = l.len() / 2;\n                }\n            }\n  \
    \      }\n    }", "    let mut n = l.len();\n    n /= 2;\n    let mut m = l.len()\
    \ / 2;\n    if n == 0 {\n        return 0.;\n    }\n    loop {\n        if l[m]\
    \ < l[m + 1] {\n            let tmp = l[m];\n            l[m] = l[m + 1];\n  \
    \          l[m + 1] = tmp;\n        } else {\n            let tmp = l[m + 1];\n\
    \            l[m + 1] = l[m];\n            l[m] = tmp;\n        }\n        m +=\
    \ 1;\n        if m >= n {\n            break;\n        }\n    }\n    l[m]", '    l.iter().fold(0.0,
    |t, el| t + el / l.len())', '    l.iter().rev().skip(l.len() / 2).fold(l.iter().cloned().max(),
    |a, b| a.max() < (b as f64).max())', '    l.iter().cloned().fold(f64::median(),
    |sum, el| sum + el) / l.len()', "    l.iter().enumerate().fold(\n        || l.len()\
    \ / 2,\n        |acc, &(i, val)| {\n            if i > acc.0 {\n             \
    \   acc\n            } else {\n                let mut mid = (acc + i) / 2;\n\
    \                if val < mid.0 {\n                    mid\n                }\
    \ else {\n                    val\n                }\n            }\n        },\n\
    \    )", "    let mut n = l.len();\n    if n % 2 == 1 {\n        l[l.len() / 2]\
    \ = l[l.len() / 2] / 2.0 + l[l.len() / 2] / 2.0;\n    }\n    else {\n        l[l.len()\
    \ / 2]\n    }", "    l.iter().fold(\n        l.len() / 2.0,\n        |median,\
    \ x| if median == l.len() / 2.0 { return x } else { median + x },\n    )", " \
    \   if l.len() > 1 {\n        let middle = l.len() / 2;\n        let median1 =\
    \ l[middle];\n        let median2 = l[middle + 1];\n        (median1 + median2)\
    \ / 2.0\n    } else {\n        l[0]\n    }", "    let mut m = l[0];\n    for i\
    \ in 1..l.len() {\n        if l[i] < m {\n            m = l[i];\n        }\n \
    \   }\n    m", '    l.iter().fold(0.0, |sum, e| sum + e / 2)', "    let len =\
    \ l.iter().filter(|&x| x > 0).count();\n    len / 2.0", "    let mut v = l.iter().cloned().collect();\n\
    \    v.sort();\n    let mid = v.len() / 2;\n    if v.len() % 2 == 1 {\n      \
    \  v.swap(0, mid);\n    }\n    v.into_iter().fold(0, |acc, x| acc + x)", '    l.iter().enumerate().fold(0.0,
    |sum, (i, item)| sum + f64(item) / (i + 1))', "    let n = l.len();\n\n    if\
    \ n < 2 {\n        return l[n/2];\n    }\n\n    // median of medians\n    // https://en.wikipedia.org/wiki/Median-of-medians\n\
    \n    let mid = l.len() / 2;\n    let mut l1 = l.subslice(0..mid);\n    let mut\
    \ l2 = l.subslice(mid..);\n\n    // sort left half\n    l1.sort_unstable();\n\n\
    \    // sort right half\n    l2.sort_unstable();\n\n    let mut m1 = median(l1);\n\
    \    let mut m2 = median(l2);\n\n    while m2 < m1 {\n        l2.swap(0, mid);\n\
    \        l2.swap(mid, mid-1);\n        l2.swap(mid-1, mid);\n        l2.swap(mid,\
    \ mid+1);\n\n        l1.swap(0, mid);\n        l1.swap(mid, mid-1);\n        l1.swap(mid-1,\
    \ mid);\n        l1.swap(mid, mid+1);\n\n        m1 = m1;\n        m2 = m2;\n\
    \    }\n\n    return m1;", "    l.iter().fold(\n        // Note: median is defined\
    \ only for sorted data.\n        l.len() % 2 == 0 ? l.len() / 2.0 : (l.len() -\
    \ l.len() / 2.0),\n        |a, b| a.checked_add(b).ok() / 2.0,\n    )", "    let\
    \ len = l.len();\n    if len == 0 {\n        return 0.0; // special case\n   \
    \ }\n    // sort, get middle element\n    let mut mid = l.len() / 2;\n    l.sort_unstable();\n\
    \    let i = mid;\n    let mut a = l[i];\n    for j in 1..mid {\n        if l[j]\
    \ < a {\n            a = l[j];\n        }\n    }\n    return a;", '    l.iter().fold(0f64,
    |a, b| std::cmp::Ordering::Less(a, b)).mid', '    l.iter().cloned().sorted().median()',
  "    let len = l.len();\n    l.iter().fold(\n        l.iter().skip(len/2).take(len/2).count()\
    \ as f64 * 1.0 / len as f64,\n        (l, r) => {\n            l + (r - l) as\
    \ f64\n        }\n    )", "    let mut s = l.iter().fold(0f64, 0.);\n    let mut\
    \ m = 0;\n    let len = l.len();\n    for i in 0..len {\n        if s <= l[i/2]\
    \ {\n            m = i;\n        }\n        s += l[i];\n    }\n    m + 1.", '    l.iter().map(|&x|
    x.abs()).fold(f64::MIN, f64::MAX).unwrap() / 2.0', "    l.iter().cloned().enumerate().fold(\n\
    \        l.iter().sorted().nth(l.len() / 2).unwrap().unwrap() as f64,\n      \
    \  |acc, elt| acc + elt,\n    )", "    let mut n = l.len();\n    loop {\n    \
    \    if n % 2 == 0 {\n            n /= 2;\n        } else {\n            n = n\
    \ / 2 + 1;\n        }\n        let mid = l.len() - n;\n        if l.len() % 2\
    \ == 0 {\n            if l[mid] <= l[mid + 1] {\n                return l[mid];\n\
    \            } else {\n                return l[mid - 1] + 1.0_f64 / 2.0_f64;\n\
    \            }\n        } else {\n            if l[mid] >= l[mid + 1] {\n    \
    \            return l[mid];\n            } else {\n                return l[mid\
    \ - 1] + 1.0_f64 / 2.0_f64;\n            }\n        }\n    }"]
stop_tokens:
- "\n}"
