language: rs
name: HumanEval_118_get_closest_vowel
results:
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    //\
    \ convert word into vector\n    let mut word_vec = word.chars().collect::<Vec<_>>();\n\
    \    word_vec.reverse();\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\"\
    , \"u\"];\n    // find first vowel from the right side of the word\n    let vowels_idx\
    \ = word_vec.iter().position(|c|\n                                    vowels.iter().position(|v|\n\
    \                                                    c == v\n                \
    \                                    )\n                                    );\n\
    \    if vowels_idx < 0 {\n        return String::from(\"\");\n    }\n    // find\
    \ the closest consonant pair\n    let mut closest_pairs = Vec::new();\n    closest_pairs.push(vowels_idx);\n\
    \    let vowels_idx = word_vec.iter().position(|c|\n                         \
    \           vowels.iter().position(|v|\n                                     \
    \               c == v\n                                                    )\n\
    \                                    );\n    while vowels_idx != -1 {\n      \
    \  let mut next_idx = vowels_idx + 1;\n        let mut pairs = Vec::new();\n \
    \       while next_idx != word_vec.len() {\n            pairs.push(next_idx);\n\
    \            next_idx = word_vec.iter().position(|c|\n                       \
    \                     vowels.iter().position(|v|\n                           \
    \                                 c == v\n                                   \
    \                         )\n                                            );\n\
    \        }\n        if pairs.len() > closest_pairs.len() {\n            closest_pairs\
    \ = pairs;\n        }\n        vowels_idx = word_vec.iter().position(|c|\n   \
    \                                     vowels.iter().position(|v|\n           \
    \                                             c == v\n                       \
    \                                 )\n                                        );\n\
    \    }\n    if closest_pairs.len() == 0 {\n        return String::from(\"\");\n\
    \    }\n    // convert closest_pairs into String\n    let mut pairs = String::from(\"\
    \");\n    for &idx in closest_pairs {\n        pairs.push_str(&vowels[idx].to_ascii_lowercase());\n\
    \    }\n    pairs\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `char` with `&str`\n  --> /tmp/tmpap0kb9de.rs:23:55\n\
    \   |\n23 | ...                   c == v\n   |                         ^^ no implementation\
    \ for `char == &str`\n   |\n   = help: the trait `PartialEq<&str>` is not implemented\
    \ for `char`\n   = help: the trait `PartialEq` is implemented for `char`\n   =\
    \ note: required because of the requirements on the impl of `PartialEq<&&str>`\
    \ for `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpap0kb9de.rs:22:37\n\
    \   |\n22 | / ...                   vowels.iter().position(|v|\n23 | | ...   \
    \                                c == v\n24 | | ...                          \
    \         )\n   | |_______________________________________^ expected `bool`, found\
    \ enum `Option`\n   |\n   = note: expected type `bool`\n              found enum\
    \ `Option<usize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpap0kb9de.rs:26:21\n\
    \   |\n26 |     if vowels_idx < 0 {\n   |                     ^ expected enum\
    \ `Option`, found integer\n   |\n   = note: expected enum `Option<usize>`\n  \
    \            found type `{integer}`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n26 |     if vowels_idx < Some(0) {\n   |                     +++++ +\n\n\
    error[E0277]: can't compare `char` with `&str`\n  --> /tmp/tmpap0kb9de.rs:34:55\n\
    \   |\n34 | ...                   c == v\n   |                         ^^ no implementation\
    \ for `char == &str`\n   |\n   = help: the trait `PartialEq<&str>` is not implemented\
    \ for `char`\n   = help: the trait `PartialEq` is implemented for `char`\n   =\
    \ note: required because of the requirements on the impl of `PartialEq<&&str>`\
    \ for `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpap0kb9de.rs:33:37\n\
    \   |\n33 | / ...                   vowels.iter().position(|v|\n34 | | ...   \
    \                                c == v\n35 | | ...                          \
    \         )\n   | |_______________________________________^ expected `bool`, found\
    \ enum `Option`\n   |\n   = note: expected type `bool`\n              found enum\
    \ `Option<usize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpap0kb9de.rs:37:25\n\
    \   |\n37 |     while "
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut result = String::from(\"\");\n    let mut vowels = vec![\"a\",\"e\",\"i\"\
    ,\"o\",\"u\"];\n    for vowel in vowels.rev() {\n        let mut vowel_len = word.len();\n\
    \        let mut vowel_start = word.rfind(vowel, &vowel_len);\n        let mut\
    \ vowel_end = word.rfind(vowel.clone(), &vowel_len);\n        let mut consonant_start\
    \ = vowel_start + 1;\n        let mut consonant_end = vowel_end + 1;\n       \
    \ // find next consonant\n        while consonant_end < word.len() {\n       \
    \     if word[consonant_end].is_uppercase() {\n                consonant_end +=\
    \ 1;\n            } else {\n                break;\n            }\n        }\n\
    \        // find previous consonant\n        while consonant_start > 0 {\n   \
    \         if word[consonant_start - 1].is_uppercase() {\n                consonant_start\
    \ -= 1;\n            } else {\n                break;\n            }\n       \
    \ }\n        // return closest vowel\n        if consonant_start < consonant_end\
    \ {\n            let mut vowel_len = word.len() - vowel_end + consonant_start;\n\
    \            let mut vowel_start = vowel_end + 1;\n            let mut vowel_end\
    \ = vowel_start + 1;\n            while vowel_start < vowel_end {\n          \
    \      if word[vowel_start].is_uppercase() {\n                    vowel_start\
    \ += 1;\n                } else {\n                    break;\n              \
    \  }\n            }\n            while vowel_end < word.len() {\n            \
    \    if word[vowel_end].is_uppercase() {\n                    vowel_end += 1;\n\
    \                } else {\n                    break;\n                }\n   \
    \         }\n            result = if vowel_start < vowel_end {\n             \
    \   String::from(word[vowel_start..vowel_end].to_lowercase())\n            } else\
    \ if consonant_start < consonant_end {\n                String::from(word[consonant_start..consonant_end].to_lowercase())\n\
    \            } else {\n                String::from(\"\")\n            };\n  \
    \          break;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `Vec<&str>` is not an iterator\n   --> /tmp/tmpqet3kv1l.rs:18:25\n\
    \    |\n18  |       for vowel in vowels.rev() {\n    |                       \
    \    ^^^ `Vec<&str>` is not an iterator\n    |\n    = note: the following trait\
    \ bounds were not satisfied:\n            `Vec<&str>: Iterator`\n            which\
    \ is required by `&mut Vec<&str>: Iterator`\n            `[&str]: Iterator`\n\
    \            which is required by `&mut [&str]: Iterator`\n\nerror[E0061]: this\
    \ function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpqet3kv1l.rs:20:36\n\
    \     |\n20   |         let mut vowel_start = word.rfind(vowel, &vowel_len);\n\
    \     |                                    ^^^^^ -----  ---------- supplied 2\
    \ arguments\n     |                                    |\n     |             \
    \                       expected 1 argument\n     |\nnote: associated function\
    \ defined here\n\nerror[E0061]: this function takes 1 argument but 2 arguments\
    \ were supplied\n    --> /tmp/tmpqet3kv1l.rs:21:34\n     |\n21   |         let\
    \ mut vowel_end = word.rfind(vowel.clone(), &vowel_len);\n     |             \
    \                     ^^^^^ -------------  ---------- supplied 2 arguments\n \
    \    |                                  |\n     |                            \
    \      expected 1 argument\n     |\nnote: associated function defined here\n\n\
    error[E0369]: cannot add `{integer}` to `Option<usize>`\n  --> /tmp/tmpqet3kv1l.rs:22:47\n\
    \   |\n22 |         let mut consonant_start = vowel_start + 1;\n   |         \
    \                          ----------- ^ - {integer}\n   |                   \
    \                |\n   |                                   Option<usize>\n\nerror[E0369]:\
    \ cannot add `{integer}` to `Option<usize>`\n  --> /tmp/tmpqet3kv1l.rs:23:43\n\
    \   |\n23 |         let mut consonant_end = vowel_end + 1;\n   |             \
    \                    --------- ^ - {integer}\n   |                           \
    \      |\n   |                                 Option<usize>\n\nerror[E0277]:\
    \ cannot subtract `Option<usize>` from `usize`\n  --> /tmp/tmpqet3kv1l.rs:42:44\n\
    \   |\n42 |             let mut vowel_len = word.len() - v"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ word = word.to_lowercase();\n    let mut index = word.len() - 1;\n    let mut\
    \ index = word\n        .chars()\n        .skip_while(|c| {\n            c ==\
    \ 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'\n        })\n        .position(|c|\
    \ {\n            c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'\n  \
    \      })\n        .unwrap() - 1;\n\n    if index < 0 {\n        index = 0;\n\
    \    }\n\n    if word[..index].contains(|&c| {\n        c != 'a' && c != 'e' &&\
    \ c != 'i' && c != 'o' && c != 'u'\n    }) {\n        index = word.len() - 1;\n\
    \    }\n\n    let mut vowel = String::new();\n    let mut vowel_index = -1;\n\
    \    let mut vowel_start = -1;\n    let mut vowel_end = -1;\n    let mut vowel_len\
    \ = word.len() - index;\n    while index < word.len() {\n        if word[..index].contains(|&c|\
    \ {\n            c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u'\n  \
    \      }) {\n            break;\n        }\n\n        if index < word.len() -\
    \ 1 {\n            if word[index] == word[index + 1] {\n                index\
    \ += 1;\n                vowel_len = index - vowel_start;\n                vowel_start\
    \ = index;\n            } else {\n                break;\n            }\n    \
    \    } else {\n            vowel_len = index - vowel_start;\n            vowel_start\
    \ = index;\n            vowel_end = index - 1;\n        }\n\n        if vowel_len\
    \ < 0 {\n            break;\n        }\n\n        index = vowel_end + 1;\n   \
    \     if index > word.len() - 2 {\n            break;\n        }\n\n        if\
    \ word[..index].contains(|&c| {\n            c != 'a' && c != 'e' && c != 'i'\
    \ && c != 'o' && c != 'u'\n        }) {\n            break;\n        }\n\n   \
    \     vowel = word[index..];\n        vowel_index = index - 1;\n        break;\n\
    \    }\n\n    vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpqamnbet_.rs:21:15\n\
    \   |\n21 |             c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'\n\
    \   |               ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmpqamnbet_.rs:21:27\n   |\n21 |             c == 'a'\
    \ || c == 'e' || c == 'i' || c == 'o' || c == 'u'\n   |                      \
    \     ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpqamnbet_.rs:21:39\n\
    \   |\n21 |             c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'\n\
    \   |                                       ^^ no implementation for `&char ==\
    \ char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpqamnbet_.rs:21:51\n   |\n21 |   \
    \          c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'\n   |    \
    \                                               ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmpqamnbet_.rs:21:63\n   |\n21\
    \ |             c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'\n   |\
    \                                                               ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0631]: type mismatch in closure arguments\n    --> /tmp/tmpqamnbet_.rs:32:22\n\
    \     |\n32   |     if word[..index].contains(|&c| {\n     |                  "
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut i = 0;\n\
    \    vowels.sort_by_key(|&x| word.chars().position(|&y| x == y).unwrap());\n \
    \   let mut found = 0;\n    while i < word.len() && found < 4 {\n        if vowels[found\
    \ + 1] == word[i] {\n            found += 1;\n        }\n        i += 1;\n   \
    \ }\n    found == 4 ? String::from(\"\") : String::from(vowels[found - 1] + vowels[found\
    \ + 1])\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `String`\n\
    \  --> /tmp/tmpiw9nc1to.rs:26:18\n   |\n26 |     found == 4 ? String::from(\"\"\
    ) : String::from(vowels[found - 1] + vowels[found + 1])\n   |                \
    \  ^^^^^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpiw9nc1to.rs:18:52\n   |\n18 |     vowels.sort_by_key(|&x|\
    \ word.chars().position(|&y| x == y).unwrap());\n   |                        \
    \                            ^--\n   |                                       \
    \             ||\n   |                                                    |expected\
    \ due to this\n   |                                                    expected\
    \ `char`, found reference\n   |                                              \
    \      help: did you mean `y`: `&char`\n   |\n   = note:   expected type `char`\n\
    \           found reference `&_`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n  --> /tmp/tmpiw9nc1to.rs:21:33\n   |\n21 |         if vowels[found\
    \ + 1] == word[i] {\n   |                                 ^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut index = 0;\n    let mut vowel_found = false;\n    let mut vowel_to_be_found\
    \ = \"\".to_string();\n    let mut first_consonant_found = false;\n    let mut\
    \ second_consonant_found = false;\n    \n    // Iterate over the string and find\
    \ all vowels\n    while index < word.len() {\n        if word.chars().any(|c|\
    \ c == b'a' || c == b'e' || c == b'i' || c == b'o' || c == b'u') {\n         \
    \   vowel_found = true;\n            vowel_to_be_found = word.chars().nth(index).unwrap();\n\
    \        }\n        if word.chars().any(|c| c == b'b' || c == b'c' || c == b'd'\
    \ || c == b'f' || c == b'g' || c == b'h' || c == b'j' || c == b'k' || c == b'l'\
    \ || c == b'm' || c == b'n' || c == b'p' || c == b'q' || c == b'r' || c == b's'\
    \ || c == b't' || c == b'v' || c == b'w' || c == b'x' || c == b'y' || c == b'z')\
    \ {\n            vowel_found = true;\n            vowel_to_be_found = word.chars().nth(index).unwrap();\n\
    \        }\n        // If the first letter is consonant and vowel not already\
    \ found, add the first vowel\n        if word.chars().any(|c| c == b'a' || c ==\
    \ b'e' || c == b'i' || c == b'o' || c == b'u') && !first_consonant_found && vowel_found\
    \ {\n            first_consonant_found = true;\n            vowel_to_be_found\
    \ = word.chars().nth(index).unwrap();\n        }\n        // If the second letter\
    \ is consonant and vowel not already found, add the first vowel\n        if word.chars().any(|c|\
    \ c == b'b' || c == b'c' || c == b'd' || c == b'f' || c == b'g' || c == b'h' ||\
    \ c == b'j' || c == b'k' || c == b'l' || c == b'm' || c == b'n' || c == b'p' ||\
    \ c == b'q' || c == b'r' || c == b's' || c == b't' || c == b'v' || c == b'w' ||\
    \ c == b'x' || c == b'y' || c == b'z') && !second_consonant_found && vowel_found\
    \ {\n            second_consonant_found = true;\n            vowel_to_be_found\
    \ = word.chars().nth(index).unwrap();\n        }\n        \n        // Break if\
    \ there are no more vowels\n        if !vowel_found {\n            break;\n  \
    \      }\n        \n        // If the first consonant found is vowel, skip the\
    \ vowel and \n        // increment the index\n        if first_consonant_found\
    \ && vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpozw7d2vg.rs:68:3\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n23 |     while index\
    \ < word.len() {\n   |                              - this delimiter might not\
    \ be properly closed...\n...\n51 | }\n   | - ...as it matches this but it has\
    \ different indentation\n...\n68 | }\n   |   ^\n\nerror: expected `{`, found `}`\n\
    \  --> /tmp/tmpozw7d2vg.rs:51:1\n   |\n50 |         if first_consonant_found &&\
    \ vowel\n   |         -- this `if` expression has a condition, but no block\n\
    51 | }\n   | ^ expected `{`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpozw7d2vg.rs:24:38\n\
    \   |\n24 |         if word.chars().any(|c| c == b'a' || c == b'e' || c == b'i'\
    \ || c == b'o' || c == b'u') {\n   |                                      ^^^^\
    \ expected `char`, found `u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpozw7d2vg.rs:24:51\n\
    \   |\n24 |         if word.chars().any(|c| c == b'a' || c == b'e' || c == b'i'\
    \ || c == b'o' || c == b'u') {\n   |                                         \
    \          ^^^^ expected `char`, found `u8`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpozw7d2vg.rs:24:64\n   |\n24 |         if word.chars().any(|c| c\
    \ == b'a' || c == b'e' || c == b'i' || c == b'o' || c == b'u') {\n   |       \
    \                                                         ^^^^ expected `char`,\
    \ found `u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpozw7d2vg.rs:24:77\n\
    \   |\n24 |         if word.chars().any(|c| c == b'a' || c == b'e' || c == b'i'\
    \ || c == b'o' || c == b'u') {\n   |                                         \
    \                                    ^^^^ expected `char`, found `u8`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpozw7d2vg.rs:24:90\n   |\n24 |         if word.chars().any(|c|\
    \ c == b'a' || c == b'e' || c == b'i' || c == b'o' || c == b'u') {\n   |     \
    \                                                                            \
    \         ^^^^ expected `char`, found `u8`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpozw7d2vg.r"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    \n\
    \    let vowels_set = Set::new();\n    \n    for c in word.chars() {\n       \
    \ if c >= 'a' && c <= 'z' {\n            continue;\n        }\n        if c >=\
    \ 'A' && c <= 'Z' {\n            continue;\n        }\n        vowels_set.insert(c);\n\
    \    }\n    \n    let mut first_vowel = vowels_set.iter().next().unwrap();\n \
    \   let mut second_vowel = vowels_set.iter().next().unwrap();\n    \n    if word.len()\
    \ >= 2 {\n        if first_vowel < second_vowel {\n            first_vowel = second_vowel;\n\
    \            second_vowel = vowels_set.iter().next().unwrap();\n        }\n  \
    \  }\n    \n    String::from(&first_vowel)\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Set`\n  --> /tmp/tmpi06o5xr0.rs:17:22\n\
    \   |\n17 |     let vowels_set = Set::new();\n   |                      ^^^ use\
    \ of undeclared type `Set`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut i = word.len();\n\
    \    loop {\n        let mut j = i;\n        loop {\n            let mut vowel_pos\
    \ = 0;\n            if j == 0 {\n                vowel_pos = 0;\n            }\n\
    \            let char = word.chars().nth(j).unwrap();\n            if char ==\
    \ 'a' || char == 'e' || char == 'i' || char == 'o' || char == 'u' {\n        \
    \        return word.chars().nth(vowel_pos + 1).unwrap();\n            }\n   \
    \         vowel_pos += 1;\n            j -= 1;\n            if j == 0 {\n    \
    \            return String::new();\n            }\n        }\n        i = j;\n\
    \    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpasdpajf3.rs:27:24\n   |\n\
    27 |                 return word.chars().nth(vowel_pos + 1).unwrap();\n   |  \
    \                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |                        |\n   |   \
    \                     expected struct `String`, found `char`\n\nwarning: unreachable\
    \ statement\n  --> /tmp/tmpasdpajf3.rs:35:9\n   |\n20 | /         loop {\n21 |\
    \ |             let mut vowel_pos = 0;\n22 | |             if j == 0 {\n23 | |\
    \                 vowel_pos = 0;\n...  |\n33 | |             }\n34 | |       \
    \  }\n   | |_________- any code following this expression is unreachable\n35 |\
    \           i = j;\n   |           ^^^^^^ unreachable statement\n   |\n   = note:\
    \ `#[warn(unreachable_code)]` on by default\n\nerror: aborting due to previous\
    \ error; 1 warning emitted\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"A\", \"E\", \"I\", \"O\", \"U\"];\n    let vowel_count =\
    \ word.chars().filter(|c| vowels.contains(&c.to_string())).count();\n    let vowel_idx\
    \ = vowels.iter().position(|c| word.chars().contains(&c)).unwrap_or_else(|| 0);\n\
    \    let vowel_start = vowel_idx + 1;\n    if vowel_start > vowel_count {\n  \
    \      vowel_start = 0;\n    }\n    let vowel_end = vowel_idx + 1;\n    if vowel_end\
    \ > vowel_count {\n        vowel_end = vowel_count;\n    }\n    if word.chars().any(|c|\
    \ vowels[c].is_uppercase()) {\n        vowel_end += 1;\n    }\n    let vowel =\
    \ &vowels[vowel_end - vowel_start];\n    String::from(vowel)\n}\n\nfn main() {\n\
    \    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpii344fcc.rs:17:63\n   |\n\
    17 |     let vowel_count = word.chars().filter(|c| vowels.contains(&c.to_string())).count();\n\
    \   |                                                               ^^^^^^^^^^^^^^\
    \ expected `&str`, found struct `String`\n   |\n   = note: expected reference\
    \ `&&str`\n              found reference `&String`\n\nerror[E0599]: no method\
    \ named `contains` found for struct `Chars` in the current scope\n  --> /tmp/tmpii344fcc.rs:18:61\n\
    \   |\n18 |     let vowel_idx = vowels.iter().position(|c| word.chars().contains(&c)).unwrap_or_else(||\
    \ 0);\n   |                                                             ^^^^^^^^\
    \ method not found in `Chars<'_>`\n\nerror[E0277]: the type `[&str]` cannot be\
    \ indexed by `char`\n  --> /tmp/tmpii344fcc.rs:27:29\n   |\n27 |     if word.chars().any(|c|\
    \ vowels[c].is_uppercase()) {\n   |                             ^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[&str]>` is not implemented for `char`\n   = note: required because\
    \ of the requirements on the impl of `Index<char>` for `Vec<&str>`\n\nerror[E0277]:\
    \ the trait bound `String: From<&&str>` is not satisfied\n  --> /tmp/tmpii344fcc.rs:31:5\n\
    \   |\n31 |     String::from(vowel)\n   |     ^^^^^^^^^^^^ the trait `From<&&str>`\
    \ is not implemented for `String`\n   |\n   = help: the following other types\
    \ implement trait `From<T>`:\n             <String as From<&String>>\n       \
    \      <String as From<&mut str>>\n             <String as From<&str>>\n     \
    \        <String as From<Box<str>>>\n             <String as From<Cow<'a, str>>>\n\
    \             <String as From<char>>\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowel_index = String::new();\n\n    let mut vowels: Vec<String> = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n\n    for vowel in vowels.iter_mut() {\n  \
    \      if word.ends_with(vowel.to_string()) {\n            return vowel.to_string();\n\
    \        }\n    }\n\n    vowels.sort();\n\n    if word.ends_with('u') {\n    \
    \    vowel_index.push(\"u\");\n    }\n    if word.ends_with('e') {\n        vowel_index.push(\"\
    e\");\n    }\n    if word.ends_with('i') {\n        vowel_index.push(\"i\");\n\
    \    }\n    if word.ends_with('o') {\n        vowel_index.push(\"o\");\n    }\n\
    \    if word.ends_with('u') {\n        vowel_index.push(\"u\");\n    }\n\n   \
    \ for vowel in vowel_index.iter() {\n        if word.ends_with(vowel.to_string())\
    \ {\n            return vowel.to_string();\n        }\n    }\n\n    \"\".to_string()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplns1glk0.rs:18:40\n   |\n\
    18 |     let mut vowels: Vec<String> = vec![\"a\", \"e\", \"i\", \"o\", \"u\"\
    ];\n   |                                        ^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                                        |\n   |\
    \                                        expected struct `String`, found `&str`\n\
    \nerror[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n  --> /tmp/tmplns1glk0.rs:21:27\n\
    \   |\n21 |         if word.ends_with(vowel.to_string()) {\n   |             \
    \    --------- ^^^^^^^^^^^^^^^^^ expected an implementor of trait `Pattern<'_>`\n\
    \   |                 |\n   |                 required by a bound introduced by\
    \ this call\n   |\n   = note: the trait bound `String: Pattern<'_>` is not satisfied\n\
    \   = note: required because of the requirements on the impl of `Pattern<'_>`\
    \ for `String`\nhelp: consider borrowing here\n   |\n21 |         if word.ends_with(&vowel.to_string())\
    \ {\n   |                           +\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmplns1glk0.rs:29:26\n   |\n29 |         vowel_index.push(\"u\");\n   |\
    \                          ^^^ expected `char`, found `&str`\n   |\nhelp: if you\
    \ meant to write a `char` literal, use single quotes\n   |\n29 |         vowel_index.push('u');\n\
    \   |                          ~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplns1glk0.rs:32:26\n\
    \   |\n32 |         vowel_index.push(\"e\");\n   |                          ^^^\
    \ expected `char`, found `&str`\n   |\nhelp: if you meant to write a `char` literal,\
    \ use single quotes\n   |\n32 |         vowel_index.push('e');\n   |         \
    \                 ~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplns1glk0.rs:35:26\n\
    \   |\n35 |         vowel_index.push(\"i\");\n   |                          ^^^\
    \ expected `char`, found `&str`\n   |\nhelp: if you meant to write a `char` literal,\
    \ use single quotes\n   |\n35 |         vowel_index.push('i');\n   |         \
    \                 ~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplns1glk0.rs:38:26\n\
    \   |\n38 |         vowel_index.push(\"o\");\n   |          "
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    fn\
    \ get_closest_vowel(word: String) -> String {\n        let mut vowels = Vec::new();\n\
    \        for ch in word.chars().rrev() {\n            if ch.is_ascii_uppercase()\
    \ {\n                vowels.push(ch);\n            }\n        }\n        let mut\
    \ left = word.len() - 2;\n        let mut right = word.len() - 1;\n        let\
    \ mut index = vowels.len();\n        while index > 0 {\n            if left ==\
    \ -1 {\n                index--;\n                break;\n            }\n    \
    \        if right == word.len() - 1 {\n                index--;\n            \
    \    break;\n            }\n            if word.chars().nth(left).unwrap().is_ascii_uppercase()\
    \ &&\n                word.chars().nth(right).unwrap().is_ascii_uppercase() {\n\
    \                vowels.pop();\n                left -= 1;\n                right\
    \ -= 1;\n            } else {\n                index--;\n                left\
    \ -= 1;\n                right -= 1;\n            }\n        }\n        vowels.iter().next().unwrap()\n\
    \    }\n    get_closest_vowel(word)\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmp0_tw2ydj.rs:28:24\n\
    \   |\n28 |                 index--;\n   |                        ^ expected expression\n\
    \nerror: expected expression, found `;`\n  --> /tmp/tmp0_tw2ydj.rs:32:24\n   |\n\
    32 |                 index--;\n   |                        ^ expected expression\n\
    \nerror: expected expression, found `;`\n  --> /tmp/tmp0_tw2ydj.rs:41:24\n   |\n\
    41 |                 index--;\n   |                        ^ expected expression\n\
    \nerror[E0599]: no method named `rrev` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmp0_tw2ydj.rs:18:32\n   |\n18 |         for ch in word.chars().rrev()\
    \ {\n   |                                ^^^^ method not found in `Chars<'_>`\n\
    \nerror[E0600]: cannot apply unary operator `-` to type `usize`\n  --> /tmp/tmp0_tw2ydj.rs:27:24\n\
    \   |\n27 |             if left == -1 {\n   |                        ^^\n   |\
    \                        |\n   |                        cannot apply unary operator\
    \ `-`\n   |                        help: you may have meant the maximum value\
    \ of `usize`: `usize::MAX`\n   |\n   = note: unsigned values cannot be negated\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp0_tw2ydj.rs:46:9\n   |\n16 | \
    \    fn get_closest_vowel(word: String) -> String {\n   |                    \
    \                       ------ expected `String` because of return type\n...\n\
    46 |         vowels.iter().next().unwrap()\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |         |\n   |  \
    \       expected struct `String`, found reference\n   |\n   = note: expected struct\
    \ `String`\n           found reference `&_`\n\nerror: aborting due to 6 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599, E0600.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    //\
    \ Write your code here\n    let mut vowel_str = \"\";\n    let vowel_end = word.chars().rposition(|&c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u');\n    if vowel_end\
    \ == word.len() - 1 {\n        for ii in 0..word.len() {\n            if ii <\
    \ vowel_end {\n                if word.chars()[ii].is_uppercase() {\n        \
    \            vowel_str += &word.chars()[ii];\n                }\n            }\n\
    \        }\n    }\n    return vowel_str;\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \    --> /tmp/tmpbd6cze0k.rs:18:34\n     |\n18   |     let vowel_end = word.chars().rposition(|&c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u');\n     |         \
    \                         ^^^^^^^^^ the trait `ExactSizeIterator` is not implemented\
    \ for `Chars<'_>`\n     |\n     = help: the following other types implement trait\
    \ `ExactSizeIterator`:\n               &mut I\n               Args\n         \
    \      ArgsOs\n               ArrayChunks<'_, T, N>\n               ArrayChunksMut<'_,\
    \ T, N>\n               ArrayWindows<'_, T, N>\n               Box<I, A>\n   \
    \            Chunks<'_, T>\n             and 109 others\nnote: required by a bound\
    \ in `rposition`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbd6cze0k.rs:18:45\n\
    \   |\n18 |     let vowel_end = word.chars().rposition(|&c| c == 'a' || c == 'e'\
    \ || c == 'i' || c == 'o' || c == 'u');\n   |                                \
    \             ^--\n   |                                             ||\n   | \
    \                                            |expected due to this\n   |     \
    \                                        expected `char`, found reference\n  \
    \ |                                             help: did you mean `c`: `&char`\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpbd6cze0k.rs:19:21\n   |\n19 |  \
    \   if vowel_end == word.len() - 1 {\n   |                     ^^^^^^^^^^^^^^\
    \ expected enum `Option`, found `usize`\n   |\n   = note: expected enum `Option<usize>`\n\
    \              found type `usize`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n19 |     if vowel_end == Some(word.len() - 1) {\n   |                 \
    \    +++++              +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbd6cze0k.rs:21:21\n\
    \   |\n21 |             if ii < vowel_end {\n   |                     ^^^^^^^^^\
    \ expected `usize`, found enum `Option`\n   |\n   = note: expected type `usize`\n\
    \              found enum `Option<usize>`\n\nerror[E0608]: cannot index into a\
    \ value of type `Chars"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    fn\
    \ is_vowel(c: char) -> bool {\n        (c >= 'A' && c <= 'Z') || (c >= 'a' &&\
    \ c <= 'z')\n    }\n    let vowels = vec!['A', 'a', 'E', 'e', 'I', 'i', 'O', 'o',\
    \ 'U', 'u', 'a', 'e', 'i', 'o', 'u'];\n    let mut vowel = String::from(\"\");\n\
    \    let mut consonants = word.chars();\n    let mut consonants = consonants.filter(|&c|\
    \ !is_vowel(c));\n    while vowels.len() < consonants.len() {\n        let left\
    \ = consonants.len() - vowels.len();\n        let right = consonants.len() - vowels.len()\
    \ - 1;\n        if left >= 0 {\n            if vowels[left] == consonants[left]\
    \ {\n                vowel = vowels[left];\n                consonants = consonants[left..right];\n\
    \            } else {\n                break;\n            }\n        } else {\n\
    \            if vowels[right] == consonants[right] {\n                vowel =\
    \ vowels[right];\n                consonants = consonants[0..left..right];\n \
    \           } else {\n                break;\n            }\n        }\n    }\n\
    \    consonants.collect::<String>()\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `.`, `::`, `?`, `]`, `{`, or an operator, found\
    \ `..`\n  --> /tmp/tmp0wv2bx8z.rs:36:48\n   |\n36 |                 consonants\
    \ = consonants[0..left..right];\n   |                                        \
    \        ^^ expected one of 7 possible tokens\n\nerror[E0599]: no method named\
    \ `len` found for struct `Filter` in the current scope\n  --> /tmp/tmp0wv2bx8z.rs:23:37\n\
    \   |\n23 |     while vowels.len() < consonants.len() {\n   |                \
    \                     ^^^ method not found in `Filter<Chars<'_>, [closure@/tmp/tmp0wv2bx8z.rs:22:44:\
    \ 22:61]>`\n\nerror[E0599]: no method named `len` found for struct `Filter` in\
    \ the current scope\n  --> /tmp/tmp0wv2bx8z.rs:24:31\n   |\n24 |         let left\
    \ = consonants.len() - vowels.len();\n   |                               ^^^ method\
    \ not found in `Filter<Chars<'_>, [closure@/tmp/tmp0wv2bx8z.rs:22:44: 22:61]>`\n\
    \nerror[E0599]: no method named `len` found for struct `Filter` in the current\
    \ scope\n  --> /tmp/tmp0wv2bx8z.rs:25:32\n   |\n25 |         let right = consonants.len()\
    \ - vowels.len() - 1;\n   |                                ^^^ method not found\
    \ in `Filter<Chars<'_>, [closure@/tmp/tmp0wv2bx8z.rs:22:44: 22:61]>`\n\nerror[E0608]:\
    \ cannot index into a value of type `Filter<Chars<'_>, [closure@/tmp/tmp0wv2bx8z.rs:22:44:\
    \ 22:61]>`\n  --> /tmp/tmp0wv2bx8z.rs:27:32\n   |\n27 |             if vowels[left]\
    \ == consonants[left] {\n   |                                ^^^^^^^^^^^^^^^^\n\
    \nerror[E0608]: cannot index into a value of type `Filter<Chars<'_>, [closure@/tmp/tmp0wv2bx8z.rs:22:44:\
    \ 22:61]>`\n  --> /tmp/tmp0wv2bx8z.rs:29:30\n   |\n29 |                 consonants\
    \ = consonants[left..right];\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0608]: cannot index into a value of type `Filter<Chars<'_>, [closure@/tmp/tmp0wv2bx8z.rs:22:44:\
    \ 22:61]>`\n  --> /tmp/tmp0wv2bx8z.rs:34:33\n   |\n34 |             if vowels[right]\
    \ == consonants[right] {\n   |                                 ^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations:\
    \ E0"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels: Vec<&str> = vec![\"\", \"a\", \"e\", \"i\", \"o\", \"u\"];\n   \
    \ for i in word.rchars().rrev() {\n        if let Some(&vowel) = vowels.iter().position(|&a|\
    \ &a == i {\n            return vowel;\n        }) {\n            vowels.remove(vowel);\n\
    \        }\n    }\n    \"\"\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found keyword `return`\n  --> /tmp/tmp0qegzz2t.rs:19:13\n\
    \   |\n18 |         if let Some(&vowel) = vowels.iter().position(|&a| &a == i\
    \ {\n   |                                                                 - while\
    \ parsing this struct\n19 |             return vowel;\n   |             ^^^^^^\
    \ expected identifier, found keyword\n\nerror[E0574]: expected struct, variant\
    \ or union type, found local variable `i`\n  --> /tmp/tmp0qegzz2t.rs:18:65\n \
    \  |\n18 |         if let Some(&vowel) = vowels.iter().position(|&a| &a == i {\n\
    \   |                                                                 ^ not a\
    \ struct, variant or union type\n\nerror[E0599]: no method named `rchars` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmp0qegzz2t.rs:17:19\n\
    \   |\n17 |     for i in word.rchars().rrev() {\n   |                   ^^^^^^\
    \ help: there is an associated function with a similar name: `chars`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp0qegzz2t.rs:18:21\n   |\n18 |           if let\
    \ Some(&vowel) = vowels.iter().position(|&a| &a == i {\n   |  _____________________^^^^^^____-\n\
    \   | |                     |\n   | |                     expected `usize`, found\
    \ reference\n   | |                     help: you can probably remove the explicit\
    \ borrow: `vowel`\n19 | |             return vowel;\n20 | |         }) {\n   |\
    \ |__________- this expression has type `Option<usize>`\n   |\n   = note:   expected\
    \ type `usize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp0qegzz2t.rs:24:5\n   |\n15 | fn get_closest_vowel(word: String)\
    \ -> String {\n   |                                       ------ expected `String`\
    \ because of return type\n...\n24 |     \"\"\n   |     ^^- help: try using a conversion\
    \ method: `.to_string()`\n   |     |\n   |     expected struct `String`, found\
    \ `&str`\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0574, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowel_indexes\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowel_index = -1;\n\n    for (index, char)\
    \ in word.chars().enumerate() {\n        if let Some(&vowel) = vowels.iter().find(|&i|\
    \ i == char) {\n            vowel_indexes.push(index);\n            vowel_index\
    \ = vowel;\n        }\n    }\n    let mut previous_vowel_found = vowel_indexes.iter().find(|&i|\
    \ i != vowel_index);\n\n    while vowel_indexes.len() > vowel_index {\n      \
    \  if vowel_indexes.len() < vowel_index {\n            let index = vowel_indexes.iter().position(|&i|\
    \ i == vowel_index).unwrap();\n            vowel_indexes.push(index);\n      \
    \  }\n\n        let index = vowel_indexes.iter().position(|&i| i == vowel_index).unwrap();\n\
    \        let current_vowel_index = vowel_indexes.iter().position(|&i| i == index).unwrap();\n\
    \        vowel_indexes.remove(current_vowel_index);\n\n        if vowel_indexes.len()\
    \ < vowel_index {\n            vowel_index = vowel_indexes.iter().position(|&i|\
    \ i == vowel_index).unwrap();\n        }\n\n        if vowel_indexes.len() ==\
    \ 0 {\n            break;\n        }\n\n        let previous_vowel_index = vowel_indexes.iter().position(|&i|\
    \ i == vowel_index).unwrap();\n        let previous_vowel_found = vowel_indexes.iter().position(|&i|\
    \ i == previous_vowel_index).unwrap();\n\n        if previous_vowel_found != previous_vowel_index\
    \ {\n            vowel_index = vowel_indexes.iter().position(|&i| i == vowel_index).unwrap();\n\
    \        }\n\n        let current_vowel_index = vowel_indexes.iter().position(|&i|\
    \ i == index).unwrap();\n        vowel_indexes.remove(current_vowel_index);\n\
    \    }\n\n    if vowel_indexes.len() > vowel_index {\n        String::from(\"\"\
    )\n    } else {\n        String::from(vowels[vowel_index])\n    }\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&&str` with `char`\n  --> /tmp/tmp7iltoizn.rs:21:57\n\
    \   |\n21 |         if let Some(&vowel) = vowels.iter().find(|&i| i == char) {\n\
    \   |                                                         ^^ no implementation\
    \ for `&&str == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&&str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp7iltoizn.rs:23:27\n   |\n18 |     let mut vowel_index =\
    \ -1;\n   |                           -- expected due to this value\n...\n23 |\
    \             vowel_index = vowel;\n   |                           ^^^^^ expected\
    \ integer, found `&str`\n\nerror[E0277]: can't compare `&usize` with `{integer}`\n\
    \  --> /tmp/tmp7iltoizn.rs:26:69\n   |\n26 |     let mut previous_vowel_found\
    \ = vowel_indexes.iter().find(|&i| i != vowel_index);\n   |                  \
    \                                                   ^^ no implementation for `&usize\
    \ == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&usize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n\
    \  --> /tmp/tmp7iltoizn.rs:18:27\n   |\n18 |     let mut vowel_index = -1;\n \
    \  |                           ^^ the trait `Neg` is not implemented for `usize`\n\
    \   |\n   = help: the following other types implement trait `Neg`:\n         \
    \    &f32\n             &f64\n             &i128\n             &i16\n        \
    \     &i32\n    "
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    if\
    \ word.len() == 0 {\n        return String::from(\"\");\n    }\n    let mut last_consonant\
    \ = false;\n    let mut current_consonant = false;\n    let mut first_vowel =\
    \ false;\n    let mut vowel_index = 0;\n    let mut vowel_char = String::from(\"\
    u\");\n    let mut current_char = String::from(\"u\");\n    for c in word.chars()\
    \ {\n        current_char = c.to_string();\n        if current_consonant {\n \
    \           if c == String::from(\"z\") {\n                last_consonant = true;\n\
    \            }\n            else if c == String::from(\"Z\") {\n             \
    \   first_vowel = true;\n            }\n            else if c != String::from(\"\
    y\") && (c != String::from(\"Y\")) {\n                if last_consonant {\n  \
    \                  if current_consonant && first_vowel && vowel_index < word.len()\
    \ - 1 {\n                        current_char = String::from(\"\");\n        \
    \                vowel_index += 1;\n                        last_consonant = false;\n\
    \                        vowel_char = String::from(\"\");\n                  \
    \      current_consonant = false;\n                        first_vowel = false;\n\
    \                    }\n                    else {\n                        if\
    \ c != String::from(\"y\") && (c != String::from(\"Y\")) {\n                 \
    \           vowel_char = String::from(\"\");\n                        }\n    \
    \                }\n                }\n            }\n        }\n        current_consonant\
    \ = !current_consonant;\n        if current_char == \"y\" || current_char == \"\
    Y\" {\n            first_vowel = true;\n        }\n        if current_char ==\
    \ \"a\" || current_char == \"A\" {\n            first_vowel = false;\n       \
    \ }\n    }\n    return vowel_char;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpodvrgmzs.rs:28:21\n   |\n\
    28 |             if c == String::from(\"z\") {\n   |                     ^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpodvrgmzs.rs:31:26\n   |\n31 |             else if c == String::from(\"\
    Z\") {\n   |                          ^^^^^^^^^^^^^^^^^ expected `char`, found\
    \ struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpodvrgmzs.rs:34:26\n\
    \   |\n34 |             else if c != String::from(\"y\") && (c != String::from(\"\
    Y\")) {\n   |                          ^^^^^^^^^^^^^^^^^ expected `char`, found\
    \ struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpodvrgmzs.rs:34:53\n\
    \   |\n34 |             else if c != String::from(\"y\") && (c != String::from(\"\
    Y\")) {\n   |                                                     ^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpodvrgmzs.rs:45:33\n   |\n45 |                         if c != String::from(\"\
    y\") && (c != String::from(\"Y\")) {\n   |                                 ^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpodvrgmzs.rs:45:60\n   |\n45 |                         if c != String::from(\"\
    y\") && (c != String::from(\"Y\")) {\n   |                                   \
    \                         ^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \nerror: aborting due to 6 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    if\
    \ word.len() < 3 || word.len() > word.chars().count() + 3 {\n        return String::from(\"\
    \");\n    }\n    let mut vowels = vec![String::from(\"a\"), String::from(\"e\"\
    ), String::from(\"i\"), String::from(\"o\"), String::from(\"u\")];\n    for letter\
    \ in word.chars() {\n        if let Some(vowel) = vowels.iter().position(|&vowel|\
    \ vowel == letter) {\n            if vowels.iter().position(|&vowel| vowel ==\
    \ letter + &letter && vowel != vowels.last())\n                .unwrap_or(0) >\
    \ 0\n            {\n                return vowel;\n            }\n        }\n\
    \    }\n    String::from(\"\")\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `String` with `char`\n  --> /tmp/tmpxcnj9rme.rs:21:68\n\
    \   |\n21 |         if let Some(vowel) = vowels.iter().position(|&vowel| vowel\
    \ == letter) {\n   |                                                         \
    \           ^^ no implementation for `String == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n\
    \             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0369]: cannot add `&char` to `char`\n  --> /tmp/tmpxcnj9rme.rs:22:64\n\
    \   |\n22 |             if vowels.iter().position(|&vowel| vowel == letter + &letter\
    \ && vowel != vowels.last())\n   |                                           \
    \              ------ ^ ------- &char\n   |                                  \
    \                       |\n   |                                              \
    \           char\n\nerror[E0277]: can't compare `String` with `Option<&String>`\n\
    \  --> /tmp/tmpxcnj9rme.rs:22:83\n   |\n22 |             if vowels.iter().position(|&vowel|\
    \ vowel == letter + &letter && vowel != vowels.last())\n   |                 \
    \                                                                  ^^ no implementation\
    \ for `String == Option<&String>`\n   |\n   = help: the trait `PartialEq<Option<&String>>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\", \"y\"];\n    let mut consonants\
    \ = vec![\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\"\
    , \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"z\"];\n   \
    \ let mut index = 0;\n    let mut len = word.len();\n    while index < len {\n\
    \        if word[len - index - 1] == consonants.last() {\n            vowels.push(consonants.last());\n\
    \            index = len - 1;\n        }\n        else {\n            index +=\
    \ 1;\n        }\n    }\n    vowels.last().to_string()\n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpp8xhccyn.rs:21:12\n\
    \   |\n21 |         if word[len - index - 1] == consonants.last() {\n   |    \
    \        ^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpp8xhccyn.rs:22:25\n   |\n22 |             vowels.push(consonants.last());\n\
    \   |                         ^^^^^^^^^^^^^^^^^ expected `&str`, found enum `Option`\n\
    \   |\n   = note: expected reference `&str`\n                   found enum `Option<&&str>`\n\
    \nerror[E0599]: the method `to_string` exists for enum `Option<&&str>`, but its\
    \ trait bounds were not satisfied\n   --> /tmp/tmpp8xhccyn.rs:29:19\n    |\n29\
    \  |       vowels.last().to_string()\n    |                     ^^^^^^^^^ method\
    \ cannot be called on `Option<&&str>` due to unsatisfied trait bounds\n    |\n\
    \    = note: the following trait bounds were not satisfied:\n            `Option<&&str>:\
    \ std::fmt::Display`\n            which is required by `Option<&&str>: ToString`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut min_dist = 0;\n    let mut min_index = -1;\n    let mut max_dist = std::cmp::min::<i32>(word.len(),\
    \ 5);\n    let mut max_index = -1;\n    for i in 1..word.len() {\n        if !is_vowel(word[i\
    \ - 2]) && word[i - 2] != word[i] {\n            min_dist = std::cmp::max::<i32>(min_dist,i);\n\
    \            min_index = i - 1;\n        }\n        if !is_vowel(word[i - 1])\
    \ && word[i - 1] != word[i] {\n            max_dist = std::cmp::max::<i32>(max_dist,i);\n\
    \            max_index = i;\n        }\n    }\n    let mut min_index = max_index;\n\
    \    if min_dist > max_dist {\n        min_index = min_index;\n    }\n    if min_index\
    \ >= 0 {\n        return String::from(word[min_index]);\n    }\n    \"\"\n}\n\n\
    fn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp_8moc2wx.rs:21:13\n\
    \   |\n21 |         if !is_vowel(word[i - 2]) && word[i - 2] != word[i] {\n  \
    \ |             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ function `is_vowel` in this scope\n  --> /tmp/tmp_8moc2wx.rs:25:13\n   |\n25\
    \ |         if !is_vowel(word[i - 1]) && word[i - 1] != word[i] {\n   |      \
    \       ^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmp_8moc2wx.rs:18:45\n   |\n18 |     let mut max_dist = std::cmp::min::<i32>(word.len(),\
    \ 5);\n   |                                             ^^^^^^^^^^ expected `i32`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `i32` and panic if\
    \ the converted value doesn't fit\n   |\n18 |     let mut max_dist = std::cmp::min::<i32>(word.len().try_into().unwrap(),\
    \ 5);\n   |                                                       ++++++++++++++++++++\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp_8moc2wx.rs:21:22\n\
    \   |\n21 |         if !is_vowel(word[i - 2]) && word[i - 2] != word[i] {\n  \
    \ |                      ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n \
    \  |\n   = help: the trait `Index<usize>` is not implemented for `String`\n  \
    \ = help: the following other types implement trait `Index<Idx>`:\n          \
    \   <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp_8moc2wx.rs:21:38\n   |\n21 |         if !is_vowel(word[i - 2])\
    \ && word[i - 2] != word[i] {\n   |                                      ^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <Str"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    word.chars().enumerate().filter_map(|(&i,\
    \ c)| {\n        if c.to_ascii_lowercase().contains(\"a\"..\"e\") && (i >= word.len()\
    \ - 2 || c != word.chars()[i + 1]) {\n            Some(c.to_ascii_lowercase())\n\
    \        } else {\n            None\n        }\n    }).min()\n    .unwrap_or_else(||\
    \ \"\")\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpks0pca9r.rs:16:43\n   |\n\
    16 |     word.chars().enumerate().filter_map(|(&i, c)| {\n   |               \
    \                            ^^   - expected due to this\n   |               \
    \                            |\n   |                                         \
    \  expected `usize`, found reference\n   |                                   \
    \        help: you can probably remove the explicit borrow: `i`\n   |\n   = note:\
    \   expected type `usize`\n           found reference `&_`\n\nerror[E0599]: no\
    \ method named `contains` found for type `char` in the current scope\n  --> /tmp/tmpks0pca9r.rs:17:35\n\
    \   |\n17 |         if c.to_ascii_lowercase().contains(\"a\"..\"e\") && (i >=\
    \ word.len() - 2 || c != word.chars()[i + 1]) {\n   |                        \
    \           ^^^^^^^^ method not found in `char`\n\nerror[E0608]: cannot index\
    \ into a value of type `Chars<'_>`\n  --> /tmp/tmpks0pca9r.rs:17:86\n   |\n17\
    \ |         if c.to_ascii_lowercase().contains(\"a\"..\"e\") && (i >= word.len()\
    \ - 2 || c != word.chars()[i + 1]) {\n   |                                   \
    \                                                   ^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpks0pca9r.rs:23:24\n   |\n23 |     .unwrap_or_else(||\
    \ \"\")\n   |                        ^^ expected `char`, found `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpks0pca9r.rs:16:5\n   |\n15 |   fn get_closest_vowel(word:\
    \ String) -> String {\n   |                                         ------ expected\
    \ `String` because of return type\n16 | /     word.chars().enumerate().filter_map(|(&i,\
    \ c)| {\n17 | |         if c.to_ascii_lowercase().contains(\"a\"..\"e\") && (i\
    \ >= word.len() - 2 || c != word.chars()[i + 1]) {\n18 | |             Some(c.to_ascii_lowercase())\n\
    19 | |         } else {\n...  |\n22 | |     }).min()\n23 | |     .unwrap_or_else(||\
    \ \"\")\n   | |                          ^- help: try using a conversion method:\
    \ `.to_string()`\n   | |__________________________|\n   |                    \
    \        expected struct `String`, found `char`\n\nerror: aborting due to 5 previous\
    \ er"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = \"AEIOUaeiou\".to_string();\n    vowels.splice(vowels.len() - vowels.chars().count(),\
    \ vowels.len());\n\n    let mut index = 0;\n    let mut prev = 0;\n    while index\
    \ < word.len() {\n        if word.chars().nth(index).unwrap() == vowels.chars().nth(prev).unwrap()\
    \ {\n            prev += 1;\n        }\n        index += 1;\n    }\n\n    if prev\
    \ >= vowels.len() {\n        return String::from(\"\");\n    }\n    word.chars().nth(prev).unwrap()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `splice` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp1wosb8gl.rs:17:12\n   |\n17 |     vowels.splice(vowels.len()\
    \ - vowels.chars().count(), vowels.len());\n   |            ^^^^^^ help: there\
    \ is an associated function with a similar name: `rsplit_once`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp1wosb8gl.rs:31:5\n   |\n15 | fn get_closest_vowel(word:\
    \ String) -> String {\n   |                                       ------ expected\
    \ `String` because of return type\n...\n31 |     word.chars().nth(prev).unwrap()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method:\
    \ `.to_string()`\n   |     |\n   |     expected struct `String`, found `char`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels: Vec<&str> = vec![];\n    let mut word_chars: Vec<&str> = word.chars().collect();\n\
    \    let mut cur_char: usize = 0;\n    while cur_char < word_chars.len() {\n \
    \       let mut has_vowel = false;\n        let mut has_consonant = false;\n \
    \       for n in 1..=26 {\n            if word_chars[cur_char + n - 1] == 'a'\
    \ || word_chars[cur_char + n - 1] == 'e' || word_chars[cur_char + n - 1] == 'i'\
    \ || word_chars[cur_char + n - 1] == 'o' || word_chars[cur_char + n - 1] == 'u'\
    \ {\n                has_vowel = true;\n                break;\n            }\n\
    \        }\n        for n in 1..=26 {\n            if word_chars[cur_char + n]\
    \ == 'a' || word_chars[cur_char + n] == 'e' || word_chars[cur_char + n] == 'i'\
    \ || word_chars[cur_char + n] == 'o' || word_chars[cur_char + n] == 'u' {\n  \
    \              has_consonant = true;\n                break;\n            }\n\
    \        }\n        if has_consonant && has_vowel {\n            vowels.push(&word_chars[cur_char]);\n\
    \        }\n        cur_char += 1;\n    }\n    if vowels.len() == 0 {\n      \
    \  return String::from(\"\");\n    }\n    let mut vowel = String::from(\"\");\n\
    \    for &vowel_str in vowels {\n        if vowel_str.len() < word.len() {\n \
    \           if !vowel.empty() {\n                return vowel;\n            }\n\
    \            vowel = vowel_str;\n        }\n    }\n    vowel\n}\n\nfn main() {\n\
    \    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<&str>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmpvd_c5p2m.rs:17:50\n     |\n17\
    \   |     let mut word_chars: Vec<&str> = word.chars().collect();\n     |    \
    \                                              ^^^^^^^ value of type `Vec<&str>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n     |\n     = help:\
    \ the trait `FromIterator<char>` is not implemented for `Vec<&str>`\n     = help:\
    \ the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a\
    \ bound in `collect`\n\nerror[E0277]: can't compare `&str` with `char`\n  -->\
    \ /tmp/tmpvd_c5p2m.rs:23:45\n   |\n23 | ...   if word_chars[cur_char + n - 1]\
    \ == 'a' || word_chars[cur_char + n - 1] == 'e' || word_chars[cur_char + n - 1]\
    \ == 'i' || word_chars[cur...\n   |                                       ^^ no\
    \ implementation for `&str == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&str`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0277]: can't compare `&str` with `char`\n  -->\
    \ /tmp/tmpvd_c5p2m.rs:23:84\n   |\n23 | ...   if word_chars[cur_char + n - 1]\
    \ == 'a' || word_chars[cur_char + n - 1] == 'e' || word_chars[cur_char + n - 1]\
    \ == 'i' || word_chars[cur...\n   |                                          \
    \                                    ^^ no implementation for `&str == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&str`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <Str"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    word.chars()\n\
    \        .chain(word.chars().skip_while(|&c| *c != 'a' && *c != 'A'))\n      \
    \  .chain(word.chars().skip_while(|&c| *c != 'e' && *c != 'E'))\n        .chain(word.chars().skip_while(|&c|\
    \ *c != 'i' && *c != 'I'))\n        .chain(word.chars().skip_while(|&c| *c !=\
    \ 'o' && *c != 'O'))\n        .chain(word.chars().skip_while(|&c| *c != 'u' &&\
    \ *c != 'U'))\n        .chain(word.chars().skip_while(|&c| *c != 'y' && *c !=\
    \ 'Y'))\n        .chain(word.chars().skip_while(|&c| *c != 'i'))\n        .collect::<Vec<char>>()\n\
    \        .iter()\n        .cloned()\n        .enumerate()\n        .filter_map(|(_,\
    \ i)| {\n            if i.0 == 0 || *i.0 != 'a' || *i.0 != 'A' {\n           \
    \     None\n            } else {\n                Some(\n                    i.0\
    \ as usize\n                )\n            }\n        })\n        .filter(|&_|\
    \ *_ != 0)\n        .map(|i|\n            if *i.0 > i.1 || *i.0 < i.1 {\n    \
    \            i.0 as usize\n            } else {\n                i.1 as usize\n\
    \            })\n        .min().unwrap_or(0)\n        .to_string()\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: in expressions, `_` can only be used on the left-hand side of an\
    \ assignment\n  --> /tmp/tmp17pvvkh_.rs:37:23\n   |\n37 |         .filter(|&_|\
    \ *_ != 0)\n   |                       ^ `_` not allowed here\n\nerror[E0614]:\
    \ type `char` cannot be dereferenced\n  --> /tmp/tmp17pvvkh_.rs:17:45\n   |\n\
    17 |         .chain(word.chars().skip_while(|&c| *c != 'a' && *c != 'A'))\n  \
    \ |                                             ^^\n\nerror[E0614]: type `char`\
    \ cannot be dereferenced\n  --> /tmp/tmp17pvvkh_.rs:17:58\n   |\n17 |        \
    \ .chain(word.chars().skip_while(|&c| *c != 'a' && *c != 'A'))\n   |         \
    \                                                 ^^\n\nerror[E0614]: type `char`\
    \ cannot be dereferenced\n  --> /tmp/tmp17pvvkh_.rs:18:45\n   |\n18 |        \
    \ .chain(word.chars().skip_while(|&c| *c != 'e' && *c != 'E'))\n   |         \
    \                                    ^^\n\nerror[E0614]: type `char` cannot be\
    \ dereferenced\n  --> /tmp/tmp17pvvkh_.rs:18:58\n   |\n18 |         .chain(word.chars().skip_while(|&c|\
    \ *c != 'e' && *c != 'E'))\n   |                                             \
    \             ^^\n\nerror[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmp17pvvkh_.rs:19:45\n\
    \   |\n19 |         .chain(word.chars().skip_while(|&c| *c != 'i' && *c != 'I'))\n\
    \   |                                             ^^\n\nerror[E0614]: type `char`\
    \ cannot be dereferenced\n  --> /tmp/tmp17pvvkh_.rs:19:58\n   |\n19 |        \
    \ .chain(word.chars().skip_while(|&c| *c != 'i' && *c != 'I'))\n   |         \
    \                                                 ^^\n\nerror[E0614]: type `char`\
    \ cannot be dereferenced\n  --> /tmp/tmp17pvvkh_.rs:20:45\n   |\n20 |        \
    \ .chain(word.chars().skip_while(|&c| *c != 'o' && *c != 'O'))\n   |         \
    \                                    ^^\n\nerror[E0614]: type `char` cannot be\
    \ dereferenced\n  --> /tmp/tmp17pvvkh_.rs:20:58\n   |\n20 |         .chain(word.chars().skip_while(|&c|\
    \ *c != 'o' && *c != 'O'))\n   |                                             \
    \             ^^\n\nerror[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmp17pvvkh_.rs:21:45\n\
    \   |\n"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    word.split_ascii_lowercase().fold(\"\
    \", |memo, letter| {\n        memo\n            .iter()\n            .fold(String::from(\"\
    \"), |memo, next| {\n                if let Some(next) = letter.get_next_letter()\
    \ {\n                    if memo.len() < next.len() {\n                      \
    \  let mut vowels = \"aeiou\".chars().skip(1).collect::<String>();\n         \
    \               if memo.contains(vowels.next()) {\n                          \
    \  memo = memo.clone() + next.to_uppercase();\n                        }\n   \
    \                 }\n                }\n                memo\n            })\n\
    \    })\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `split_ascii_lowercase` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmp1soxa301.rs:16:10\n   |\n16 | \
    \    word.split_ascii_lowercase().fold(\"\", |memo, letter| {\n   |          ^^^^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_lowercase`\n\
    \nerror[E0599]: no method named `next` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp1soxa301.rs:23:49\n   |\n23 |                         if\
    \ memo.contains(vowels.next()) {\n   |                                       \
    \          ^^^^ method not found in `String`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    //\
    \ write your code here\n    let mut consonants: Vec<&str> = word.chars().filter_map(|c|\
    \ c.is_alphabetic()).collect();\n    consonants.push(\"\");\n    consonants.sort_by(|a,\
    \ b| a.cmp(b));\n    consonants.last_mut().unwrap().to_string()\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp77mps724.rs:17:65\n   |\n\
    17 |     let mut consonants: Vec<&str> = word.chars().filter_map(|c| c.is_alphabetic()).collect();\n\
    \   |                                                                 ^^^^^^^^^^^^^^^^^\
    \ expected enum `Option`, found `bool`\n   |\n   = note: expected enum `Option<_>`\n\
    \              found type `bool`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n17 |     let mut consonants: Vec<&str> = word.chars().filter_map(|c| Some(c.is_alphabetic())).collect();\n\
    \   |                                                                 +++++  \
    \               +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    for &vowel in vowels.iter()\
    \ {\n        let pos = word.rfind(vowel);\n        if pos == word.len() - 1 ||\
    \ pos < 0 {\n            continue;\n        }\n        let vowel_start = word.rfind(\"\
    a\", pos);\n        let vowel_end = word.rfind(\"e\", pos);\n        if vowel_start\
    \ == -1 || vowel_end == -1 {\n            continue;\n        }\n        if word[vowel_end]\
    \ == vowel {\n            return word.into_string_lossy();\n        }\n      \
    \  if word[vowel_start] != vowel {\n            return word.into_string_lossy();\n\
    \        }\n    }\n    word.to_owned()\n}\n\nfn main() {\n    let candidate =\
    \ get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpn4s83do5.rs:19:19\n   |\n\
    19 |         if pos == word.len() - 1 || pos < 0 {\n   |                   ^^^^^^^^^^^^^^\
    \ expected enum `Option`, found `usize`\n   |\n   = note: expected enum `Option<usize>`\n\
    \              found type `usize`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n19 |         if pos == Some(word.len() - 1) || pos < 0 {\n   |        \
    \           +++++              +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn4s83do5.rs:19:43\n\
    \   |\n19 |         if pos == word.len() - 1 || pos < 0 {\n   |              \
    \                             ^ expected enum `Option`, found integer\n   |\n\
    \   = note: expected enum `Option<usize>`\n              found type `{integer}`\n\
    help: try wrapping the expression in `Some`\n   |\n19 |         if pos == word.len()\
    \ - 1 || pos < Some(0) {\n   |                                           +++++\
    \ +\n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpn4s83do5.rs:22:32\n     |\n22   |         let vowel_start = word.rfind(\"\
    a\", pos);\n     |                                ^^^^^ ---  --- supplied 2 arguments\n\
    \     |                                |\n     |                             \
    \   expected 1 argument\n     |\nnote: associated function defined here\n\nerror[E0061]:\
    \ this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpn4s83do5.rs:23:30\n\
    \     |\n23   |         let vowel_end = word.rfind(\"e\", pos);\n     |      \
    \                        ^^^^^ ---  --- supplied 2 arguments\n     |         \
    \                     |\n     |                              expected 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpn4s83do5.rs:24:27\n   |\n24 |         if vowel_start == -1 || vowel_end\
    \ == -1 {\n   |                           ^^ expected enum `Option`, found integer\n\
    \   |\n   = note: expected enum `Option<usize>`\n              found type `{integer}`\n\
    help: try wrapping the expression in `Some`\n   |\n24 |         if vowel_start\
    \ == Some(-1) || vowel_end == -1 {\n   |        "
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels: Vec<&str> = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n\n    word.chars().fold(\"\
    \", (|s| {\n        let idx = vowels.iter().position(|&x| x.to_lowercase() ==\
    \ s);\n        idx if idx >= 0\n    }))\n}\n\nfn main() {\n    let candidate =\
    \ get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator,\
    \ found keyword `if`\n  --> /tmp/tmp_o2aju9a.rs:20:13\n   |\n20 |         idx\
    \ if idx >= 0\n   |             ^^ expected one of 8 possible tokens\n\nwarning:\
    \ unnecessary parentheses around method argument\n  --> /tmp/tmp_o2aju9a.rs:18:27\n\
    \   |\n18 |     word.chars().fold(\"\", (|s| {\n   |                         \
    \  ^\n...\n21 |     }))\n   |      ^\n   |\n   = note: `#[warn(unused_parens)]`\
    \ on by default\nhelp: remove these parentheses\n   |\n18 ~     word.chars().fold(\"\
    \", |s| {\n19 |         let idx = vowels.iter().position(|&x| x.to_lowercase()\
    \ == s);\n20 |         idx if idx >= 0\n21 ~     })\n   |\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_o2aju9a.rs:18:23\n   |\n18 |     word.chars().fold(\"\"\
    , (|s| {\n   |                       ^^- help: try using a conversion method:\
    \ `.to_string()`\n   |                       |\n   |                       expected\
    \ struct `String`, found `&str`\n\nerror[E0593]: closure is expected to take 2\
    \ arguments, but it takes 1 argument\n  --> /tmp/tmp_o2aju9a.rs:18:18\n   |\n\
    18 |     word.chars().fold(\"\", (|s| {\n   |                  ^^^^      --- takes\
    \ 1 argument\n   |                  |\n   |                  expected closure\
    \ that takes 2 arguments\n\nerror: aborting due to 3 previous errors; 1 warning\
    \ emitted\n\nSome errors have detailed explanations: E0308, E0593.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    use\
    \ std::cmp::Ordering;\n\n    let mut result: String = String::new();\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    if word.len() ==\
    \ 0 {\n        return result;\n    }\n    let mut consonants: Vec<&str> = word\n\
    \        .chars()\n        .filter(|c| c != 'a' && c != 'e' && c != 'i' && c !=\
    \ 'o' && c != 'u')\n        .collect();\n    consonants.sort();\n    for consonant\
    \ in consonants {\n        let mut current_consonant_index: usize = 0;\n     \
    \   let mut current_consonant_vowel: Vec<&str> = vowels.clone();\n        let\
    \ mut current_vowel_index: usize = 0;\n        for vowel in &vowels {\n      \
    \      if vowel.len() > current_consonant_vowel.len() {\n                continue;\n\
    \            }\n            if !current_consonant_vowel.contains(&vowel) {\n \
    \               break;\n            }\n            current_vowel_index += 1;\n\
    \        }\n        if current_vowel_index < current_consonant_index {\n     \
    \       continue;\n        }\n        while current_vowel_index < current_consonant_index\
    \ {\n            current_consonant_index += 1;\n            if current_consonant_index\
    \ > consonants.len() - 1 {\n                break;\n            }\n          \
    \  current_consonant_vowel = consonants[current_consonant_index..].iter().cloned().collect();\n\
    \            for vowel in &vowels {\n                if vowel.len() > current_consonant_vowel.len()\
    \ {\n                    continue;\n                }\n                if !current_consonant_vowel.contains(&vowel)\
    \ {\n                    break;\n                }\n            }\n          \
    \  current_vowel_index += 1;\n        }\n        if current_vowel_index > result.len()\
    \ {\n            result = consonants[current_consonant_index..];\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "warning: unused import: `std::cmp::Ordering`\n  --> /tmp/tmps1kbgwud.rs:16:9\n\
    \   |\n16 |     use std::cmp::Ordering;\n   |         ^^^^^^^^^^^^^^^^^^\n   |\n\
    \   = note: `#[warn(unused_imports)]` on by default\n\nerror[E0277]: can't compare\
    \ `&char` with `char`\n  --> /tmp/tmps1kbgwud.rs:25:23\n   |\n25 |         .filter(|c|\
    \ c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u')\n   |            \
    \           ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmps1kbgwud.rs:25:35\n   |\n25 |         .filter(|c| c != 'a' && c\
    \ != 'e' && c != 'i' && c != 'o' && c != 'u')\n   |                          \
    \         ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmps1kbgwud.rs:25:47\n   |\n25 |         .filter(|c| c != 'a' && c\
    \ != 'e' && c != 'i' && c != 'o' && c != 'u')\n   |                          \
    \                     ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmps1kbgwud.rs:25:59\n   |\n25 |         .filter(|c|\
    \ c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u')\n   |            \
    \                                               ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmps1kbgwud.rs:25:71\n   |\n25\
    \ |         .filter(|c| c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u')\n\
    \   |                                                                       ^^\
    \ no implementation for `&char == char`\n   |\n"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    for vowel in vowels.iter()\
    \ {\n        let mut index = word.len();\n        let mut c = vowel;\n       \
    \ let mut found = false;\n        while !found && index > 0 {\n            if\
    \ word[index - 1] == c {\n                found = true;\n                index\
    \ -= 1;\n            } else {\n                index -= 1;\n            }\n  \
    \      }\n        if found {\n            return word.chars().skip(index).take(1).collect();\n\
    \        }\n    }\n    \"\".to_string()\n}\n\nfn main() {\n    let candidate =\
    \ get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmptujr2m5x.rs:22:16\n\
    \   |\n22 |             if word[index - 1] == c {\n   |                ^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowel_index = word.len() - 1;\n\n    while vowel_index >= 0 && vowel_index\
    \ > 0 && word.chars().skip(vowel_index).find(|c| c == char::from(char::from('a'))))\
    \ {\n        vowel_index -= 1;\n    }\n    while vowel_index < 0 && vowel_index\
    \ + 1 < word.len() && word.chars().skip(vowel_index + 1).find(|c| c == char::from(char::from('a'))))\
    \ {\n        vowel_index += 1;\n    }\n\n    if vowel_index < 0 {\n        return\
    \ String::from(\"\");\n    }\n    let mut vowel_pos = word.chars().skip(vowel_index).find(|c|\
    \ c == char::from(char::from('a')));\n    let mut vowel_length = vowel_pos - vowel_index;\n\
    \n    if vowel_length <= 1 {\n        return String::from(\"\");\n    }\n    let\
    \ mut vowel = String::from(\"\");\n    if word.chars().skip(vowel_index + vowel_length).find(|c|\
    \ c == char::from(char::from('u'))) != None {\n        vowel.clear();\n      \
    \  vowel.push(char::from(char::from('u')));\n    }\n    if word.chars().skip(vowel_index\
    \ - vowel_length).find(|c| c == char::from(char::from('i'))) != None {\n     \
    \   vowel.clear();\n        vowel.push(char::from(char::from('i')));\n    }\n\
    \    if vowel.len() != 0 {\n        return vowel;\n    }\n    let mut consonant_index\
    \ = vowel_index + vowel_length - 1;\n    while consonant_index >= 0 && consonant_index\
    \ < word.len() && word.chars().skip(consonant_index + 1).find(|c| c == char::from(char::from('n')))\
    \ != None {\n        consonant_index += 1;\n    }\n    if consonant_index >= word.len()\
    \ || consonant_index < 0 {\n        return String::from(\"\");\n    }\n    let\
    \ mut consonant_pos = word.chars().skip(consonant_index).find(|c| c == char::from(char::from('n')));\n\
    \    let mut consonant_length = consonant_pos - consonant_index;\n    if consonant_length\
    \ <= 1 {\n        return String::from(\"\");\n    }\n    if word.chars().skip(consonant_index\
    \ + consonant_length).find(|c| c == char::from(char::from('e'))) != None {\n \
    \       vowel.clear();\n        vowel.push(char::from(char::from('e')));\n   \
    \ }\n    if word.chars().skip(consonant_index\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: unexpected closing delimiter: `)`\n  --> /tmp/tmpc8lwa03b.rs:21:139\n\
    \   |\n18 |     while vowel_index >= 0 && vowel_index > 0 && word.chars().skip(vowel_index).find(|c|\
    \ c == char::from(char::from('a')))) {\n   |                                 \
    \                                                                            \
    \                - this opening brace...\n19 |         vowel_index -= 1;\n20 |\
    \     }\n   |     - ...matches this closing brace\n21 |     while vowel_index\
    \ < 0 && vowel_index + 1 < word.len() && word.chars().skip(vowel_index + 1).find(|c|\
    \ c == char::from(char::from('a')))) {\n   |                                 \
    \                                                                            \
    \                              ^ unexpected closing delimiter\n\nerror: mismatched\
    \ closing delimiter: `)`\n  --> /tmp/tmpc8lwa03b.rs:15:46\n   |\n15 | fn get_closest_vowel(word:\
    \ String) -> String {\n   |                                              ^ unclosed\
    \ delimiter\n...\n18 |     while vowel_index >= 0 && vowel_index > 0 && word.chars().skip(vowel_index).find(|c|\
    \ c == char::from(char::from('a')))) {\n   |                                 \
    \                                                                            \
    \              ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous\
    \ errors\n\n"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut result = String::new();\n    let mut counter = 0;\n\n    for i in word.chars()\
    \ {\n        result += '\\0';\n        counter += 1;\n\n        if i.is_vowel()\
    \ {\n            result += i.to_lowercase();\n            continue;\n        }\n\
    \n        let mut left_index = 0;\n        let mut right_index = word.len() -\
    \ 1;\n\n        loop {\n            let mut index = left_index;\n\n          \
    \  while index < right_index {\n                if word.chars().skip_while(|c|\
    \ c.is_vowel()).next().unwrap().is_vowel() {\n                    break;\n   \
    \             }\n\n                index += 1;\n            }\n\n            left_index\
    \ = index;\n\n            index = right_index;\n\n            while index > left_index\
    \ {\n                if word.chars().skip_while(|c| c.is_vowel()).next().unwrap().is_vowel()\
    \ {\n                    break;\n                }\n\n                index -=\
    \ 1;\n            }\n\n            right_index = index;\n        }\n\n       \
    \ let left_vowel = if counter > 0 {\n            let mut index = left_index -\
    \ 1;\n\n            while index >= 0 {\n                if word.chars().skip_while(|c|\
    \ c.is_vowel()).next().unwrap().is_vowel() {\n                    break;\n   \
    \             }\n\n                index -= 1;\n            }\n\n            word.chars().skip_while(|c|\
    \ c.is_vowel()).next().unwrap().to_lowercase()\n        } else {\n           \
    \ String::from(\"\")\n        };\n\n        let right_vowel = if counter > 0 {\n\
    \            let mut index = right_index + 1;\n\n            while index < word.len()\
    \ {\n                if word.chars().skip_while(|c| c.is_vowel()).next().unwrap().is_vowel()\
    \ {\n                    break;\n                }\n\n                index +=\
    \ 1;\n            }\n\n            word.chars().skip_while(|c| c.is_vowel()).next().unwrap().to_lowercase()\n\
    \        } else {\n            String::from(\"\")\n        };\n\n        if left_vowel\
    \ == right_vowel {\n            if left_vowel != String::from(\"\") {\n      \
    \          result += '\\0';\n            }\n\n            result += '\\0';\n \
    \       } else {\n            if left_vowel != String::from(\"\") {\n        \
    \        result += '\\0';\n            }\n\n            if right_vowel != String::from(\"\
    \") {\n                result += '\\0';\n            }\n\n            result +=\
    \ left_vowel.chars().next().unwrap();\n            result += right_vowel.chars().next().unwrap();\n\
    \        }\n    }\n\n    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2hmzj7ub.rs:20:19\n   |\n\
    20 |         result += '\\0';\n   |                   ^^^^ expected `&str`, found\
    \ `char`\n   |\nhelp: if you meant to write a `str` literal, use double quotes\n\
    \   |\n20 |         result += \"\\0\";\n   |                   ~~~~\n\nerror[E0599]:\
    \ no method named `is_vowel` found for type `char` in the current scope\n  -->\
    \ /tmp/tmp2hmzj7ub.rs:23:14\n   |\n23 |         if i.is_vowel() {\n   |      \
    \        ^^^^^^^^ method not found in `char`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2hmzj7ub.rs:24:23\n   |\n24 |             result += i.to_lowercase();\n\
    \   |                       ^^^^^^^^^^^^^^^^ expected `&str`, found struct `ToLowercase`\n\
    \nerror[E0599]: no method named `is_vowel` found for reference `&char` in the\
    \ current scope\n  --> /tmp/tmp2hmzj7ub.rs:35:50\n   |\n35 |                 if\
    \ word.chars().skip_while(|c| c.is_vowel()).next().unwrap().is_vowel() {\n   |\
    \                                                  ^^^^^^^^ method not found in\
    \ `&char`\n\nerror[E0599]: no method named `is_vowel` found for type `char` in\
    \ the current scope\n  --> /tmp/tmp2hmzj7ub.rs:35:78\n   |\n35 |             \
    \    if word.chars().skip_while(|c| c.is_vowel()).next().unwrap().is_vowel() {\n\
    \   |                                                                        \
    \      ^^^^^^^^ method not found in `char`\n\nerror[E0599]: no method named `is_vowel`\
    \ found for reference `&char` in the current scope\n  --> /tmp/tmp2hmzj7ub.rs:47:50\n\
    \   |\n47 |                 if word.chars().skip_while(|c| c.is_vowel()).next().unwrap().is_vowel()\
    \ {\n   |                                                  ^^^^^^^^ method not\
    \ found in `&char`\n\nerror[E0599]: no method named `is_vowel` found for type\
    \ `char` in the current scope\n  --> /tmp/tmp2hmzj7ub.rs:47:78\n   |\n47 |   \
    \              if word.chars().skip_while(|c| c.is_vowel()).next().unwrap().is_vowel()\
    \ {\n   |                                                                    \
    \          ^^^^^^^^ method not found in `char`\n\nwarning: unreachable statement\n\
    \  --> /tmp/tmp2hmzj7ub.r"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    if\
    \ word.is_empty() {\n        String::from(\"\")\n    } else {\n        let mut\
    \ vowel = String::from(\"\");\n        let mut index = word.len() - 1;\n     \
    \   while index > 0 && vowel.contains(\"a\") {\n            index -= 1;\n    \
    \    }\n        while index < word.len() && vowel.contains(\"e\") {\n        \
    \    index += 1;\n        }\n        while index > 0 && vowel.contains(\"o\")\
    \ {\n            index -= 1;\n        }\n        while index < word.len() && vowel.contains(\"\
    u\") {\n            index += 1;\n        }\n        vowel = word.chars().nth(index).unwrap().to_string();\n\
    \    }\n    vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `vowel` in this scope\n  --> /tmp/tmpfhi6pn5v.rs:35:5\n\
    \   |\n35 |     vowel\n   |     ^^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpfhi6pn5v.rs:17:9\n   |\n16 | /     if word.is_empty()\
    \ {\n17 | |         String::from(\"\")\n   | |         ^^^^^^^^^^^^^^^^ expected\
    \ `()`, found struct `String`\n18 | |     } else {\n19 | |         let mut vowel\
    \ = String::from(\"\");\n...  |\n33 | |         vowel = word.chars().nth(index).unwrap().to_string();\n\
    34 | |     }\n   | |_____- expected this to be `()`\n   |\nhelp: consider using\
    \ a semicolon here\n   |\n17 |         String::from(\"\");\n   |             \
    \            +\nhelp: consider using a semicolon here\n   |\n34 |     };\n   |\
    \      +\nhelp: you might have meant to return this value\n   |\n17 |        \
    \ return String::from(\"\");\n   |         ++++++                 +\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    vowels.remove(&vowels.iter().position(|&x|\
    \ word.chars().next().unwrap().is_uppercase()).unwrap());\n    vowels.remove(&vowels.iter().position(|&x|\
    \ word.chars().next().unwrap().is_lowercase()).unwrap());\n    word.chars().take_while(|&c|\
    \ vowels.iter().any(|&x|\n        c == x.to_lowercase() || c == x.to_uppercase()\n\
    \    )).last().unwrap()\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdr3mutzs.rs:17:19\n   |\n\
    17 |     vowels.remove(&vowels.iter().position(|&x| word.chars().next().unwrap().is_uppercase()).unwrap());\n\
    \   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `usize`, found `&usize`\n   |\nhelp: consider removing the borrow\n\
    \   |\n17 -     vowels.remove(&vowels.iter().position(|&x| word.chars().next().unwrap().is_uppercase()).unwrap());\n\
    17 +     vowels.remove(vowels.iter().position(|&x| word.chars().next().unwrap().is_uppercase()).unwrap());\n\
    \   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdr3mutzs.rs:18:19\n  \
    \ |\n18 |     vowels.remove(&vowels.iter().position(|&x| word.chars().next().unwrap().is_lowercase()).unwrap());\n\
    \   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `usize`, found `&usize`\n   |\nhelp: consider removing the borrow\n\
    \   |\n18 -     vowels.remove(&vowels.iter().position(|&x| word.chars().next().unwrap().is_lowercase()).unwrap());\n\
    18 +     vowels.remove(vowels.iter().position(|&x| word.chars().next().unwrap().is_lowercase()).unwrap());\n\
    \   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdr3mutzs.rs:20:14\n  \
    \ |\n20 |         c == x.to_lowercase() || c == x.to_uppercase()\n   |       \
    \       ^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpdr3mutzs.rs:20:39\n   |\n20 |         c == x.to_lowercase()\
    \ || c == x.to_uppercase()\n   |                                       ^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpdr3mutzs.rs:19:5\n   |\n15 |   fn get_closest_vowel(word: String)\
    \ -> String {\n   |                                         ------ expected `String`\
    \ because of return type\n...\n19 | /     word.chars().take_while(|&c| vowels.iter().any(|&x|\n\
    20 | |         c == x.to_lowercase() || c == x.to_uppercase()\n21 | |     )).last().unwrap()\n\
    \   | |                      ^- help: try using a conversion method: `.to_string("
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    debugln!(\"\
    word is: {}\", word);\n    let mut res = String::new();\n    let mut current =\
    \ word;\n\n    while current.len() > 0 {\n        if current.starts_with(vowels)\
    \ {\n            res.clear();\n            break;\n        }\n        let current_slice\
    \ = current.as_slice();\n        let mut current_len = current_slice.len();\n\
    \        let mut found = false;\n        for i in 0..current_len - 1 {\n     \
    \       if current_slice[i] == vowels[0] {\n                // found the first\
    \ vowel\n                if current_slice[i + 1] == vowels[2] {\n            \
    \        found = true;\n                }\n            }\n        }\n        if\
    \ found {\n            break;\n        }\n        res.push_str(&current);\n  \
    \      current = String::from(\"\");\n    }\n    debugln!(\"res: {}\", res);\n\
    \    res\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: cannot find macro `debugln` in this scope\n  --> /tmp/tmp9ozyxjlm.rs:16:5\n\
    \   |\n16 |     debugln!(\"word is: {}\", word);\n   |     ^^^^^^^\n\nerror: cannot\
    \ find macro `debugln` in this scope\n  --> /tmp/tmp9ozyxjlm.rs:42:5\n   |\n42\
    \ |     debugln!(\"res: {}\", res);\n   |     ^^^^^^^\n\nerror[E0425]: cannot\
    \ find value `vowels` in this scope\n  --> /tmp/tmp9ozyxjlm.rs:21:32\n   |\n21\
    \ |         if current.starts_with(vowels) {\n   |                           \
    \     ^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `vowels`\
    \ in this scope\n  --> /tmp/tmp9ozyxjlm.rs:29:36\n   |\n29 |             if current_slice[i]\
    \ == vowels[0] {\n   |                                    ^^^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find value `vowels` in this scope\n  -->\
    \ /tmp/tmp9ozyxjlm.rs:31:44\n   |\n31 |                 if current_slice[i + 1]\
    \ == vowels[2] {\n   |                                            ^^^^^^ not found\
    \ in this scope\n\nerror[E0599]: no method named `as_slice` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp9ozyxjlm.rs:25:37\n   |\n25 |         let\
    \ current_slice = current.as_slice();\n   |                                  \
    \   ^^^^^^^^ method not found in `String`\n\nerror: aborting due to 6 previous\
    \ errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut res = String::from(\"\
    \");\n    let len = word.len();\n    if word.chars().any(|c| !vowels.contains(c))\
    \ {\n        return res;\n    }\n    let (first, last) = word.chars().windows(2).next();\n\
    \    if let Some(firstc) = first {\n        if let Some(lastc) = last {\n    \
    \        if let Some(firstv) = firstc {\n                if let Some(lastv) =\
    \ lastc {\n                    if firstv > lastv {\n                        let\
    \ mut i = len;\n                        while i > 0u && vowels.contains(word.chars()[i..i].to_string()\
    \ + &lastv) {\n                            i -= 1;\n                        }\n\
    \                        res.push_str(&word.chars()[0..i].to_string() + &firstv);\n\
    \                    } else {\n                        let mut i = len;\n    \
    \                    while i > 0u && vowels.contains(word.chars()[i..i].to_string()\
    \ + &firstv) {\n                            i -= 1;\n                        }\n\
    \                        res.push_str(&word.chars()[0..i].to_string() + &lastv);\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   res\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: invalid suffix `u` for number literal\n  --> /tmp/tmpe1kpz7fs.rs:29:35\n\
    \   |\n29 |                         while i > 0u && vowels.contains(word.chars()[i..i].to_string()\
    \ + &lastv) {\n   |                                   ^^ invalid suffix `u`\n\
    \   |\n   = help: the suffix must be one of the numeric types (`u32`, `isize`,\
    \ `f32`, etc.)\n\nerror: invalid suffix `u` for number literal\n  --> /tmp/tmpe1kpz7fs.rs:35:35\n\
    \   |\n35 |                         while i > 0u && vowels.contains(word.chars()[i..i].to_string()\
    \ + &firstv) {\n   |                                   ^^ invalid suffix `u`\n\
    \   |\n   = help: the suffix must be one of the numeric types (`u32`, `isize`,\
    \ `f32`, etc.)\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpe1kpz7fs.rs:19:46\n\
    \   |\n19 |     if word.chars().any(|c| !vowels.contains(c)) {\n   |         \
    \                                     ^ expected `&&str`, found `char`\n\nerror[E0599]:\
    \ no method named `windows` found for struct `Chars` in the current scope\n  -->\
    \ /tmp/tmpe1kpz7fs.rs:22:38\n   |\n22 |     let (first, last) = word.chars().windows(2).next();\n\
    \   |                                      ^^^^^^^ method not found in `Chars<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `Chars<'_>`\n  --> /tmp/tmpe1kpz7fs.rs:29:57\n\
    \   |\n29 |                         while i > 0u && vowels.contains(word.chars()[i..i].to_string()\
    \ + &lastv) {\n   |                                                         ^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0608]: cannot index into a value of type `Chars<'_>`\n  --> /tmp/tmpe1kpz7fs.rs:32:39\n\
    \   |\n32 |                         res.push_str(&word.chars()[0..i].to_string()\
    \ + &firstv);\n   |                                       ^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0608]: cannot index into a value of type `Chars<'_>`\n  --> /tmp/tmpe1kpz7fs.rs:35:57\n\
    \   |\n35 |                         while i > 0u && vowels.contains(word.chars()[i..i].to_string()\
    \ + &firstv) {\n   |                                                         ^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0608]: cannot index into a value of type `Chars<'_>`\n  --> /tmp/tmpe1kpz7fs.rs"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowel = String::from(\"\");\n    let mut consonant = String::from(\"\");\n\
    \    let mut s = String::from(\"\");\n    word.chars().for_each(|c| {\n      \
    \  if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n           \
    \ vowel = String::from(*c.to_string() + \"o\");\n        } else if c == 'b' ||\
    \ c == 'c' || c == 'd' || c == 'f' || c == 'g' || c == 'h' || c == 'j' || c ==\
    \ 'k' || c == 'l' || c == 'm' || c == 'n' || c == 'p' || c == 'q' || c == 'r'\
    \ || c == 's' || c == 't' || c == 'v' || c == 'w' || c == 'x' || c == 'y' || c\
    \ == 'z' {\n            consonant = String::from(*c.to_string() + \"c\");\n  \
    \      } else {\n            s = String::from(*c.to_string());\n        }\n  \
    \  });\n    vowel.chars().for_each(|c| {\n        if c == 'o' {\n            return\
    \ String::from(\"\");\n        } else if c == 'c' {\n            return String::from(\"\
    \");\n        }\n    });\n    consonant.chars().for_each(|c| {\n        if c ==\
    \ 'c' {\n            return String::from(\"\");\n        }\n    });\n    s + vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot add `&str` to `str`\n  --> /tmp/tmpkf1lpa90.rs:21:49\n\
    \   |\n21 |             vowel = String::from(*c.to_string() + \"o\");\n   |  \
    \                                -------------- ^ --- &str\n   |             \
    \                     |\n   |                                  str\n\nerror[E0369]:\
    \ cannot add `&str` to `str`\n  --> /tmp/tmpkf1lpa90.rs:23:53\n   |\n23 |    \
    \         consonant = String::from(*c.to_string() + \"c\");\n   |            \
    \                          -------------- ^ --- &str\n   |                   \
    \                   |\n   |                                      str\n\nerror[E0277]:\
    \ the size for values of type `str` cannot be known at compilation time\n   -->\
    \ /tmp/tmpkf1lpa90.rs:25:30\n    |\n25  |             s = String::from(*c.to_string());\n\
    \    |                 ------------ ^^^^^^^^^^^^^^ doesn't have a size known at\
    \ compile-time\n    |                 |\n    |                 required by a bound\
    \ introduced by this call\n    |\n    = help: the trait `Sized` is not implemented\
    \ for `str`\nnote: required by a bound in `from`\n\nerror[E0277]: the trait bound\
    \ `String: From<str>` is not satisfied\n  --> /tmp/tmpkf1lpa90.rs:25:17\n   |\n\
    25 |             s = String::from(*c.to_string());\n   |                 ^^^^^^^^^^^^\
    \ the trait `From<str>` is not implemented for `String`\n   |\n   = help: the\
    \ following other types implement trait `From<T>`:\n             <String as From<&String>>\n\
    \             <String as From<&mut str>>\n             <String as From<&str>>\n\
    \             <String as From<Box<str>>>\n             <String as From<Cow<'a,\
    \ str>>>\n             <String as From<char>>\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpkf1lpa90.rs:30:20\n   |\n30 |             return String::from(\"\
    \");\n   |                    ^^^^^^^^^^^^^^^^ expected `()`, found struct `String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpkf1lpa90.rs:37:20\n   |\n37 |\
    \             return String::from(\"\");\n   |                    ^^^^^^^^^^^^^^^^\
    \ expected `()`, found struct `String`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpkf1lpa90.rs:40:9\n   |\n40 |    "
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    if\
    \ word.len() == 0 {\n        return String::from(\"\");\n    }\n    let mut vowels\
    \ = vec![\"A\",\"E\",\"I\",\"O\",\"U\"];\n    let mut pos = word.len();\n    let\
    \ mut vowels_start = word.clone();\n    let mut vowels_end = word.clone();\n \
    \   while pos > 0 {\n        if vowels_start.chars().all(|c| c == vowels[pos..].first())\
    \ {\n            pos = pos - 1;\n            vowels_start = word.clone();\n  \
    \      } else {\n            pos = pos - 1;\n            vowels_end = word.clone();\n\
    \        }\n    }\n    let mut vowels_len = vowels_end.len() - vowels_start.len();\n\
    \    while vowels_len > 0 {\n        let mut index = vowels.len();\n        let\
    \ mut found = false;\n        while !found && index < vowels.len() {\n       \
    \     if vowels[index] == vowels_end.chars().last() {\n                found =\
    \ true;\n            } else {\n                index = index + 1;\n          \
    \  }\n        }\n        if index != vowels.len() {\n            vowels = vowels.remove(index);\n\
    \        }\n        vowels_len = vowels_len - 1;\n    }\n    if vowels_len < 2\
    \ {\n        return String::from(\"\");\n    }\n    let mut vowels_start = vowels.clone();\n\
    \    let mut vowels_end = vowels.clone();\n    while vowels_start.len() > 1 {\n\
    \        let mut index = vowels.len();\n        let mut found = false;\n     \
    \   while !found && index < vowels.len() {\n            if vowels_start.contains(&vowels[index])\
    \ {\n                found = true;\n            } else {\n                index\
    \ = index + 1;\n            }\n        }\n        if index != vowels.len() {\n\
    \            vowels_start = vowels.remove(index);\n        }\n    }\n    return\
    \ String::from(vowels_start.to_owned());\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9etu24io.rs:24:46\n   |\n\
    24 |         if vowels_start.chars().all(|c| c == vowels[pos..].first()) {\n \
    \  |                                              ^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `char`, found enum `Option`\n   |\n   = note: expected type `char`\n       \
    \       found enum `Option<&&str>`\n\nerror[E0277]: can't compare `&str` with\
    \ `Option<char>`\n  --> /tmp/tmp9etu24io.rs:37:30\n   |\n37 |             if vowels[index]\
    \ == vowels_end.chars().last() {\n   |                              ^^ no implementation\
    \ for `&str == Option<char>`\n   |\n   = help: the trait `PartialEq<Option<char>>`\
    \ is not implemented for `&str`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9etu24io.rs:44:22\n\
    \   |\n19 |     let mut vowels = vec![\"A\",\"E\",\"I\",\"O\",\"U\"];\n   |  \
    \                    ------------------------- expected due to this value\n...\n\
    44 |             vowels = vowels.remove(index);\n   |                      ^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found `&str`\n   |\n   = note: expected struct `Vec<&str>`\n\
    \           found reference `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9etu24io.rs:64:28\n\
    \   |\n51 |     let mut vowels_start = vowels.clone();\n   |                 \
    \           -------------- expected due to this value\n...\n64 |             vowels_start\
    \ = vowels.remove(index);\n   |                            ^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found `&str`\n   |\n   = note: expected struct `Vec<&str>`\n\
    \           found reference `&str`\n\nerror[E0277]: the trait bound `String: From<Vec<&str>>`\
    \ is not satisfied\n  --> /tmp/tmp9etu24io.rs:67:12\n   |\n67 |  "
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = \"aeiouAEIOU\".chars().skip(1).collect::<Vec<_>>();\n    if word.chars().last().unwrap()\
    \ == 'Z' {\n        vowels.reverse();\n    }\n    let mut idx = 0;\n    let mut\
    \ found = false;\n    for vowel in vowels.iter().rev() {\n        if let Some(idx)\
    \ = get_index(word, idx, vowel) {\n            found = true;\n            break;\n\
    \        }\n        idx += 1;\n    }\n    if found {\n        return word;\n \
    \   }\n    return String::from(\"\");\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `get_index` in this scope\n  --> /tmp/tmp2dtbhqz3.rs:23:28\n\
    \   |\n23 |         if let Some(idx) = get_index(word, idx, vowel) {\n   |   \
    \                         ^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec!['u', 'a', 'o', 'i', 'e'];\n    let mut prev_vowel = String::from(\"\
    \");\n    let mut consonants = String::from(\"\");\n    for (i, &c) in word.chars().enumerate().rev()\
    \ {\n        if !vowels.contains(&c) {\n            consonants = c;\n        \
    \    if i == word.chars().count() - 1 {\n                vowels = vec![];\n  \
    \          } else {\n                prev_vowel = consonants.clone();\n      \
    \      }\n        }\n    }\n    vowels\n        .iter()\n        .next()\n   \
    \     .expect(\"Should have found at least one vowel, got nothing\")\n       \
    \ .to_string()\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n   \
    \ assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"\
    most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n  \
    \  assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \    --> /tmp/tmp8vg7klug.rs:19:45\n     |\n19   |     for (i, &c) in word.chars().enumerate().rev()\
    \ {\n     |                                             ^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n     |\n     = help: the following other\
    \ types implement trait `ExactSizeIterator`:\n               &mut I\n        \
    \       Args\n               ArgsOs\n               ArrayChunks<'_, T, N>\n  \
    \             ArrayChunksMut<'_, T, N>\n               ArrayWindows<'_, T, N>\n\
    \               Box<I, A>\n               Chunks<'_, T>\n             and 109\
    \ others\n     = note: required because of the requirements on the impl of `DoubleEndedIterator`\
    \ for `Enumerate<Chars<'_>>`\nnote: required by a bound in `rev`\n\nerror[E0277]:\
    \ the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n  --> /tmp/tmp8vg7klug.rs:19:20\n\
    \   |\n19 |     for (i, &c) in word.chars().enumerate().rev() {\n   |        \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `ExactSizeIterator` is not\
    \ implemented for `Chars<'_>`\n   |\n   = help: the following other types implement\
    \ trait `ExactSizeIterator`:\n             &mut I\n             Args\n       \
    \      ArgsOs\n             ArrayChunks<'_, T, N>\n             ArrayChunksMut<'_,\
    \ T, N>\n             ArrayWindows<'_, T, N>\n             Box<I, A>\n       \
    \      Chunks<'_, T>\n           and 109 others\n   = note: required because of\
    \ the requirements on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\n\
    \   = note: required because of the requirements on the impl of `Iterator` for\
    \ `Rev<Enumerate<Chars<'_>>>`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `Rev<Enumerate<Chars<'_>>>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8vg7klug.rs:19:13\n   |\n19 |     for (i, &c)\
    \ in word.chars().enumerate().rev() {\n   |             ^^     ------------------------------\
    \ this expression has type `Option<(usize, char)>`\n   |             |\n   | \
    \            expected `char`, found reference\n   |           "
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowel = String::from(\"\");\n\n    let mut vowel_iterator = word.chars();\n\
    \    let mut consonant_iterator = vowel_iterator.skip_while(|c| !c.is_ascii_letter());\n\
    \    let mut consonant_iterator = consonant_iterator.skip_while(|c| !c.is_ascii_letter());\n\
    \    let mut consonant_iterator = consonant_iterator.skip_while(|c| !c.is_ascii_letter());\n\
    \n    while let Some(c1) = consonant_iterator.next() {\n        if let Some(c2)\
    \ = consonant_iterator.next() {\n            if let Some(c3) = consonant_iterator.next()\
    \ {\n                if let Some(c4) = consonant_iterator.next() {\n         \
    \           if let Some(c5) = consonant_iterator.next() {\n                  \
    \      if let Some(c6) = consonant_iterator.next() {\n                       \
    \     vowel = word.chars().skip_while( |c| c.is_ascii_letter()).take(1).unwrap();\n\
    \                        }\n                    }\n                }\n       \
    \     }\n        }\n    }\n    vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmp3ec0w1gb.rs:19:67\n   |\n19 |     let mut\
    \ consonant_iterator = vowel_iterator.skip_while(|c| !c.is_ascii_letter());\n\
    \   |                                                                   ^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `is_ascii`\n\nerror[E0599]:\
    \ no method named `is_ascii_letter` found for reference `&char` in the current\
    \ scope\n  --> /tmp/tmp3ec0w1gb.rs:20:71\n   |\n20 |     let mut consonant_iterator\
    \ = consonant_iterator.skip_while(|c| !c.is_ascii_letter());\n   |           \
    \                                                            ^^^^^^^^^^^^^^^ help:\
    \ there is an associated function with a similar name: `is_ascii`\n\nerror[E0599]:\
    \ no method named `is_ascii_letter` found for reference `&char` in the current\
    \ scope\n  --> /tmp/tmp3ec0w1gb.rs:21:71\n   |\n21 |     let mut consonant_iterator\
    \ = consonant_iterator.skip_while(|c| !c.is_ascii_letter());\n   |           \
    \                                                            ^^^^^^^^^^^^^^^ help:\
    \ there is an associated function with a similar name: `is_ascii`\n\nerror[E0599]:\
    \ no method named `is_ascii_letter` found for reference `&char` in the current\
    \ scope\n  --> /tmp/tmp3ec0w1gb.rs:29:68\n   |\n29 | ...                   vowel\
    \ = word.chars().skip_while( |c| c.is_ascii_letter()).take(1).unwrap();\n   |\
    \                                                              ^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `is_ascii`\n\nerror[E0599]:\
    \ no method named `unwrap` found for struct `std::iter::Take` in the current scope\n\
    \  --> /tmp/tmp3ec0w1gb.rs:29:95\n   |\n29 | ...                   vowel = word.chars().skip_while(\
    \ |c| c.is_ascii_letter()).take(1).unwrap();\n   |                           \
    \                                                              ^^^^^^ method not\
    \ found in `std::iter::Take<SkipWhile<Chars<'_>, [closure@/tmp/tmp3ec0w1gb.rs:29:62:\
    \ 29:85]>>`\n\nerror: aborting due to 5 previous errors\n\nFor more in"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = \"aeiouAEIOU\".chars();\n    let mut vowels_set = HashSet::new();\n\
    \    for (i, ch) in word.chars().enumerate() {\n        if vowels.contains(&ch)\
    \ {\n            vowels_set.insert(ch);\n        } else {\n            if i <\
    \ word.len() - 1 {\n                let ch1 = word[i - 1];\n                let\
    \ ch2 = word[i + 1];\n                if ch1 != ch2 {\n                    if\
    \ vowels_set.contains(&ch1) && vowels_set.contains(&ch2) {\n                 \
    \       let mut min_distance = std::i32::MAX;\n                        let mut\
    \ min_distance = std::i32::MAX;\n                        for vowel in vowels.iter()\
    \ {\n                            let distance = ch1.distance(vowel).unwrap();\n\
    \                            if distance < min_distance {\n                  \
    \              min_distance = distance;\n                                min_vowel\
    \ = vowel;\n                            }\n                        }\n       \
    \                 if min_distance == 0 {\n                            min_vowel\
    \ = ch1;\n                        } else {\n                            min_vowel\
    \ = min_vowel.clone();\n                        }\n                        vowels_set.insert(min_vowel);\n\
    \                    } else {\n                        return String::new();\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   let mut min_vowel = String::new();\n    for vowel in vowels.iter() {\n   \
    \     let distance = word.distance(vowel).unwrap();\n        if distance < min_vowel.len()\
    \ {\n            min_vowel = String::new();\n        }\n        if distance ==\
    \ 0 {\n            min_vowel = vowel.clone();\n        }\n    }\n    min_vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpcjd4y42s.rs:17:26\n   |\n17 |     let mut vowels_set = HashSet::new();\n\
    \   |                          ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0425]:\
    \ cannot find value `min_vowel` in this scope\n  --> /tmp/tmpcjd4y42s.rs:33:33\n\
    \   |\n33 | ...                   min_vowel = vowel;\n   |                   \
    \    ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `min_vowel`\
    \ in this scope\n  --> /tmp/tmpcjd4y42s.rs:37:29\n   |\n37 | ...             \
    \      min_vowel = ch1;\n   |                       ^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `min_vowel` in this scope\n  --> /tmp/tmpcjd4y42s.rs:39:29\n\
    \   |\n39 | ...                   min_vowel = min_vowel.clone();\n   |       \
    \                ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `min_vowel` in this scope\n  --> /tmp/tmpcjd4y42s.rs:39:41\n   |\n39 |\
    \ ...                   min_vowel = min_vowel.clone();\n   |                 \
    \                  ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `min_vowel` in this scope\n  --> /tmp/tmpcjd4y42s.rs:41:43\n   |\n41 |\
    \                         vowels_set.insert(min_vowel);\n   |                \
    \                           ^^^^^^^^^ not found in this scope\n\nerror[E0599]:\
    \ no method named `contains` found for struct `Chars` in the current scope\n \
    \ --> /tmp/tmpcjd4y42s.rs:19:19\n   |\n19 |         if vowels.contains(&ch) {\n\
    \   |                   ^^^^^^^^ method not found in `Chars<'_>`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpcjd4y42s.rs:23:27\n\
    \   |\n23 |                 let ch1 = word[i - 1];\n   |                     \
    \      ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as In"
  stdout: ''
  timestamp: 1660053308
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    if\
    \ let Some(pos) = word.rfind('a') {\n        word[..pos].to_string()\n    } else\
    \ if let Some(pos) = word.rfind('e') {\n        word[..pos].to_string()\n    }\
    \ else if let Some(pos) = word.rfind('i') {\n        word[..pos].to_string()\n\
    \    } else if let Some(pos) = word.rfind('o') {\n        word[..pos].to_string()\n\
    \    } else if let Some(pos) = word.rfind('u') {\n        word[..pos].to_string()\n\
    \    } else {\n        String::from(\"\")\n    }\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"y\"`,\n right: `\"u\"`', /tmp/tmppcqo_sn3.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660053309
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    vowels.sort_by_key(|&x|\
    \ word.chars().position(|&y| y == x).unwrap());\n    let vowel = vowels.iter().next().unwrap();\n\
    \    String::from(vowel)\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk2is5ez2.rs:17:52\n   |\n\
    17 |     vowels.sort_by_key(|&x| word.chars().position(|&y| y == x).unwrap());\n\
    \   |                                                    ^--\n   |           \
    \                                         ||\n   |                           \
    \                         |expected due to this\n   |                        \
    \                            expected `char`, found reference\n   |          \
    \                                          help: did you mean `y`: `&char`\n \
    \  |\n   = note:   expected type `char`\n           found reference `&_`\n\nerror[E0277]:\
    \ the trait bound `String: From<&&str>` is not satisfied\n  --> /tmp/tmpk2is5ez2.rs:19:5\n\
    \   |\n19 |     String::from(vowel)\n   |     ^^^^^^^^^^^^ the trait `From<&&str>`\
    \ is not implemented for `String`\n   |\n   = help: the following other types\
    \ implement trait `From<T>`:\n             <String as From<&String>>\n       \
    \      <String as From<&mut str>>\n             <String as From<&str>>\n     \
    \        <String as From<Box<str>>>\n             <String as From<Cow<'a, str>>>\n\
    \             <String as From<char>>\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    for vowel in vowels.iter()\
    \ {\n        let mut word_len = word.len();\n        let mut last_consonant_pos\
    \ = word_len-1;\n        let mut last_consonant = word[0];\n        let mut vowel_pos\
    \ = 0;\n        \n        while vowel_pos < word_len && vowels[vowel_pos] == last_consonant\
    \ {\n            last_consonant_pos--;\n            vowel_pos++;\n        }\n\
    \        \n        let mut last_vowel_pos = word_len-1;\n        let mut last_vowel\
    \ = word[word_len-1];\n        \n        while vowel_pos < word_len && vowels[vowel_pos]\
    \ == last_vowel {\n            last_vowel_pos--;\n            vowel_pos++;\n \
    \       }\n        \n        let mut distance = last_consonant_pos + 1;\n    \
    \    if last_vowel_pos < vowel_pos {\n            distance = last_vowel_pos +\
    \ 1;\n        }\n        \n        if distance < word_len {\n            return\
    \ word.clone();\n        }\n    }\n    return word.clone();\n}\n\nfn main() {\n\
    \    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpdb47dcql.rs:24:33\n\
    \   |\n24 |             last_consonant_pos--;\n   |                          \
    \       ^ expected expression\n\nerror: expected expression, found `;`\n  -->\
    \ /tmp/tmpdb47dcql.rs:32:29\n   |\n32 |             last_vowel_pos--;\n   |  \
    \                           ^ expected expression\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `{integer}`\n  --> /tmp/tmpdb47dcql.rs:20:34\n   |\n20\
    \ |         let mut last_consonant = word[0];\n   |                          \
    \        ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the\
    \ trait `Index<{integer}>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpdb47dcql.rs:29:30\n   |\n29 |         let mut last_vowel = word[word_len-1];\n\
    \   |                              ^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = \"aeiou\";\n    let consonants = \"bcdfghjklmnpqrstvwxyz\";\n    let\
    \ mut cur_pos = word.len();\n    let mut vowel_index = String::new();\n    let\
    \ mut consonant_index = String::new();\n    loop {\n        let mut cons_pos =\
    \ 0;\n        let mut vowel_pos = 0;\n        \n        while cons_pos < word.len()\
    \ {\n            let mut cur_ch = word[cons_pos];\n            \n            if\
    \ cons_pos == 0 {\n                if cur_ch in consonants {\n               \
    \     cons_pos++;\n                }\n            } else {\n                if\
    \ cur_ch in vowels {\n                    vowel_index.push_str(cur_ch);\n    \
    \                vowel_pos++;\n                }\n            }\n            \n\
    \            cons_pos++;\n        }\n        \n        if vowel_pos == 0 || cons_pos\
    \ == 0 {\n            break;\n        }\n        \n        let mut cons_len =\
    \ word.len();\n        let mut cons_index = String::new();\n        let mut cons_str_len\
    \ = 0;\n        \n        while vowel_index.len() > 0 && cons_pos < word.len()\
    \ {\n            let mut cur_ch = word[cons_pos];\n            \n            if\
    \ vowel_index.len() > 0 && cur_ch == vowel_index[0] {\n                cons_str_len\
    \ += 1;\n                cons_index.push_str(vowel_index.clone());\n         \
    \       cons_pos += 1;\n            } else if cons_pos == 0 {\n              \
    \  if cur_ch in consonants {\n                    cons_pos++;\n              \
    \  }\n            } else {\n                if cur_ch in vowels {\n          \
    \          vowel_index.push_str(cur_ch);\n                    vowel_pos++;\n \
    \               }\n            }\n            \n            cons_pos++;\n    \
    \    }\n        \n        if cons_str_len < word.len() {\n            cur_pos\
    \ += cons_str_len;\n        } else {\n            break;\n        }\n        \n\
    \        cons_index = cons_index.to_lowercase();\n        consonant_index = consonant_index.to_lowercase();\n\
    \    }\n    \n    if cur_pos == word.len() {\n        String::from(\"\")\n   \
    \ } else {\n        consonant_index\n    }\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found keyword `in`\n  --> /tmp/tmpch9g9hhr.rs:29:27\n\
    \   |\n29 |                 if cur_ch in consonants {\n   |                 --\
    \        ^^ expected `{`\n   |                 |\n   |                 this `if`\
    \ expression has a condition, but no block\n\nerror: expected `{`, found keyword\
    \ `in`\n  --> /tmp/tmpch9g9hhr.rs:33:27\n   |\n33 |                 if cur_ch\
    \ in vowels {\n   |                 --        ^^ expected `{`\n   |          \
    \       |\n   |                 this `if` expression has a condition, but no block\n\
    \nerror: Rust has no postfix increment operator\n  --> /tmp/tmpch9g9hhr.rs:39:21\n\
    \   |\n39 |             cons_pos++;\n   |                     ^^ not a valid postfix\
    \ operator\n   |\nhelp: use `+= 1` instead\n   |\n39 |             { let tmp =\
    \ cons_pos; cons_pos += 1; tmp };\n   |             +++++++++++         ~~~~~~~~~~~~~~~~~~~~~~\n\
    39 -             cons_pos++;\n39 +             cons_pos += 1;\n   | \n\nerror:\
    \ expected `{`, found keyword `in`\n  --> /tmp/tmpch9g9hhr.rs:58:27\n   |\n58\
    \ |                 if cur_ch in consonants {\n   |                 --       \
    \ ^^ expected `{`\n   |                 |\n   |                 this `if` expression\
    \ has a condition, but no block\n\nerror: expected `{`, found keyword `in`\n \
    \ --> /tmp/tmpch9g9hhr.rs:62:27\n   |\n62 |                 if cur_ch in vowels\
    \ {\n   |                 --        ^^ expected `{`\n   |                 |\n\
    \   |                 this `if` expression has a condition, but no block\n\nerror:\
    \ Rust has no postfix increment operator\n  --> /tmp/tmpch9g9hhr.rs:68:21\n  \
    \ |\n68 |             cons_pos++;\n   |                     ^^ not a valid postfix\
    \ operator\n   |\nhelp: use `+= 1` instead\n   |\n68 |             { let tmp =\
    \ cons_pos; cons_pos += 1; tmp };\n   |             +++++++++++         ~~~~~~~~~~~~~~~~~~~~~~\n\
    68 -             cons_pos++;\n68 +             cons_pos += 1;\n   | \n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpch9g9hhr.rs:26:30\n\
    \   |\n26 |             let mut cur_ch = word[cons_pos];\n   |               \
    \               ^^^^^^^^^^^^^^ `Stri"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"A\",\"E\",\"I\",\"O\",\"U\"];\n    let mut vowel_counter\
    \ = 1;\n    let mut vowel_start = word.len() - 1;\n    while vowel_start > 0 &&\
    \ vowel_start < word.len() - 1 {\n        if word.chars().nth(vowel_start).unwrap().unwrap()\
    \ == vowels[0] {\n            vowel_start = vowel_start - 1;\n        } else {\n\
    \            vowel_start = vowel_start + vowel_counter;\n            vowel_counter\
    \ += 1;\n        }\n        if word.chars().nth(vowel_start).unwrap().unwrap()\
    \ == vowels[4] {\n            vowel_start = vowel_start - 1;\n        } else {\n\
    \            vowel_start = vowel_start + vowel_counter;\n            vowel_counter\
    \ += 1;\n        }\n    }\n    if word.chars().nth(vowel_start).unwrap().unwrap()\
    \ == vowels[0] {\n        String::from(\"\")\n    } else {\n        String::from(vowels[vowel_start\
    \ + vowel_counter - 1])\n    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpb95junri.rs:20:51\n   |\n20 |         if word.chars().nth(vowel_start).unwrap().unwrap()\
    \ == vowels[0] {\n   |                                                   ^^^^^^\
    \ method not found in `char`\n\nerror[E0599]: no method named `unwrap` found for\
    \ type `char` in the current scope\n  --> /tmp/tmpb95junri.rs:26:51\n   |\n26\
    \ |         if word.chars().nth(vowel_start).unwrap().unwrap() == vowels[4] {\n\
    \   |                                                   ^^^^^^ method not found\
    \ in `char`\n\nerror[E0599]: no method named `unwrap` found for type `char` in\
    \ the current scope\n  --> /tmp/tmpb95junri.rs:33:47\n   |\n33 |     if word.chars().nth(vowel_start).unwrap().unwrap()\
    \ == vowels[0] {\n   |                                               ^^^^^^ method\
    \ not found in `char`\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    word.chars().enumerate().filter_map(|(i,\
    \ c)| {\n        if c.is_uppercase() {\n            if c.chars().next().unwrap()\
    \ == 'U'\n                || c.chars().next().unwrap() == 'I'\n              \
    \  || c.chars().next().unwrap() == 'O'\n                || c.chars().next().unwrap()\
    \ == 'A'\n            {\n                Some(i)\n            } else {\n     \
    \           None\n            }\n        } else {\n            None\n        }\n\
    \    }).next()\n        .expect(\"No vowel found!\")\n        .to_string()\n}\n\
    \nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `chars` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpuv8q5m1z.rs:18:18\n   |\n18 |             if c.chars().next().unwrap()\
    \ == 'U'\n   |                  ^^^^^ method not found in `char`\n\nerror[E0599]:\
    \ no method named `chars` found for type `char` in the current scope\n  --> /tmp/tmpuv8q5m1z.rs:19:22\n\
    \   |\n19 |                 || c.chars().next().unwrap() == 'I'\n   |        \
    \              ^^^^^ method not found in `char`\n\nerror[E0599]: no method named\
    \ `chars` found for type `char` in the current scope\n  --> /tmp/tmpuv8q5m1z.rs:20:22\n\
    \   |\n20 |                 || c.chars().next().unwrap() == 'O'\n   |        \
    \              ^^^^^ method not found in `char`\n\nerror[E0599]: no method named\
    \ `chars` found for type `char` in the current scope\n  --> /tmp/tmpuv8q5m1z.rs:21:22\n\
    \   |\n21 |                 || c.chars().next().unwrap() == 'A'\n   |        \
    \              ^^^^^ method not found in `char`\n\nerror: aborting due to 4 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    //\
    \ your solution here\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkqp90t0y.rs:15:39\n   |\n\
    15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut consonants = vec![\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\"\
    , \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\"\
    , \"y\", \"z\"];\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"\
    , \"A\", \"E\", \"I\", \"O\", \"U\"];\n\n    for i in consonants.iter() {\n  \
    \      if word.ends_with(i) {\n            consonants.remove(&i);\n        }\n\
    \    }\n\n    for i in vowels.iter() {\n        if word.ends_with(i) {\n     \
    \       vowels.remove(&i);\n        }\n    }\n\n    if consonants.len() > vowels.len()\
    \ {\n        let i = vowels.iter().cloned().next().unwrap();\n        return word.clone().replace((word.len()\
    \ - i).to_string(), i.to_string());\n    } else {\n        let i = consonants.iter().cloned().next().unwrap();\n\
    \        return word.clone().replace((word.len() - i).to_string(), i.to_string());\n\
    \    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6allwton.rs:21:31\n   |\n\
    21 |             consonants.remove(&i);\n   |                               ^^\
    \ expected `usize`, found `&&&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6allwton.rs:27:27\n\
    \   |\n27 |             vowels.remove(&i);\n   |                           ^^\
    \ expected `usize`, found `&&&str`\n\nerror[E0277]: cannot subtract `&str` from\
    \ `usize`\n  --> /tmp/tmp6allwton.rs:33:49\n   |\n33 |         return word.clone().replace((word.len()\
    \ - i).to_string(), i.to_string());\n   |                                    \
    \             ^ no implementation for `usize - &str`\n   |\n   = help: the trait\
    \ `Sub<&str>` is not implemented for `usize`\n   = help: the following other types\
    \ implement trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n          \
    \   <&'a f64 as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n            \
    \ <&'a i16 as Sub<i16>>\n             <&'a i32 as Sub<i32>>\n             <&'a\
    \ i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n             <&'a isize\
    \ as Sub<isize>>\n           and 48 others\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp6allwton.rs:33:67\n   |\n33 |         return word.clone().replace((word.len()\
    \ - i).to_string(), i.to_string());\n   |                                    \
    \                               ^^^^^^^^^^^^^\n   |                          \
    \                                         |\n   |                            \
    \                                       expected `&str`, found struct `String`\n\
    \   |                                                                   help:\
    \ consider borrowing here: `&i.to_string()`\n\nerror[E0277]: cannot subtract `&str`\
    \ from `usize`\n  --> /tmp/tmp6allwton.rs:36:49\n   |\n36 |         return word.clone().replace((word.len()\
    \ - i).to_string(), i.to_string());\n   |                                    \
    \             ^ no implementation for `usize - &str`\n   |\n   = help: the trait\
    \ `Sub<&str>` is not implemented for `usize`\n   = help: the following other types\
    \ implement trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n        "
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    word.chars().enumerate().filter(|&(i,_)|\
    \ word.chars().skip(i + 1).any(|&(_, w)| w == 'a' || w == 'e' || w == 'i' || w\
    \ == 'o' || w == 'u'))\n        .next()\n        .expect(\"no vowel found\")\n\
    \        .to_string()\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk4j855pf.rs:16:76\n   |\n\
    16 |     word.chars().enumerate().filter(|&(i,_)| word.chars().skip(i + 1).any(|&(_,\
    \ w)| w == 'a' || w == 'e' || w == 'i' || w == 'o' || w == 'u'))\n   |       \
    \                                                                     ^^^^^^-\n\
    \   |                                                                        \
    \    |     |\n   |                                                           \
    \                 |     expected due to this\n   |                           \
    \                                                 expected `char`, found reference\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\n\n\
    error[E0599]: `(usize, char)` doesn't implement `std::fmt::Display`\n  --> /tmp/tmpk4j855pf.rs:19:10\n\
    \   |\n19 |         .to_string()\n   |          ^^^^^^^^^ `(usize, char)` cannot\
    \ be formatted with the default formatter\n   |\n   = note: the following trait\
    \ bounds were not satisfied:\n           `(usize, char): std::fmt::Display`\n\
    \           which is required by `(usize, char): ToString`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut index = word.len() - 1;\n    let mut min: usize = (word[0] as usize + word[1]\
    \ as usize) / 2;\n    loop {\n        if word.len() > 2 && (word[0] as usize +\
    \ word[1] as usize) % 2 == 0 {\n            if word[min] as usize + word[min+1]\
    \ as usize > 0 {\n                min = min + 1;\n            } else {\n     \
    \           index = min;\n            }\n        } else {\n            if word[min]\
    \ as usize > 0 {\n                min = min + 1;\n            } else {\n     \
    \           index = min;\n            }\n        }\n        if index == word.len()\
    \ - 1 {\n            return String::new();\n        }\n    }\n}\n\nfn main() {\n\
    \    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmp3jbpee6i.rs:17:27\n   |\n17 |     let mut min: usize = (word[0] as usize\
    \ + word[1] as usize) / 2;\n   |                           ^^^^^^^ `String` cannot\
    \ be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is\
    \ not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmp3jbpee6i.rs:17:46\n   |\n17 |     let mut min: usize = (word[0]\
    \ as usize + word[1] as usize) / 2;\n   |                                    \
    \          ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help:\
    \ the trait `Index<{integer}>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp3jbpee6i.rs:19:31\n\
    \   |\n19 |         if word.len() > 2 && (word[0] as usize + word[1] as usize)\
    \ % 2 == 0 {\n   |                               ^^^^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    use\
    \ std::collections::HashMap;\n    use std::cmp::Ordering::{Equal, Greater};\n\
    \    let mut vowels: HashMap<u8, usize> = HashMap::new();\n    vowels.insert(0x55u,\
    \ 0);\n    vowels.insert(0x5Au, 1);\n    vowels.insert(0xA0u, 2);\n    vowels.insert(0xA1u,\
    \ 3);\n    vowels.insert(0xA2u, 4);\n    vowels.insert(0xA3u, 5);\n    vowels.insert(0xA4u,\
    \ 6);\n    vowels.insert(0xA5u, 7);\n    vowels.insert(0xA6u, 8);\n    vowels.insert(0xA7u,\
    \ 9);\n    vowels.insert(0xA8u, 10);\n    vowels.insert(0xA9u, 11);\n    vowels.insert(0xAAu,\
    \ 12);\n    vowels.insert(0xABu, 13);\n    vowels.insert(0xACu, 14);\n    vowels.insert(0xADu,\
    \ 15);\n    vowels.insert(0xAEu, 16);\n    vowels.insert(0xAFu, 17);\n    vowels.insert(0xBAu,\
    \ 18);\n    vowels.insert(0xBAu, 19);\n    vowels.insert(0xBBu, 20);\n    vowels.insert(0xBCu,\
    \ 21);\n    vowels.insert(0xBDu, 22);\n    vowels.insert(0xBEu, 23);\n    vowels.insert(0xBFu,\
    \ 24);\n    vowels.insert(0xC0u, 25);\n    vowels.insert(0xC1u, 26);\n    vowels.insert(0xC2u,\
    \ 27);\n    vowels.insert(0xC3u, 28);\n    vowels.insert(0xC4u, 29);\n    vowels.insert(0xC5u,\
    \ 30);\n    vowels.insert(0xC6u, 31);\n    vowels.insert(0xC7u, 32);\n    vowels.insert(0xC8u,\
    \ 33);\n    vowels.insert(0xC9u, 34);\n    vowels.insert(0xCAu, 35);\n    vowels.insert(0xCBu,\
    \ 36);\n    vowels.insert(0xCCu, 37);\n    vowels.insert(0xCDu, 38);\n    vowels.insert(0xCEu,\
    \ 39);\n    vowels.insert(0xCFu, 40);\n    vowels.insert(0xD0u, 41);\n    vowels.insert(0xD1u,\
    \ 42);\n    vowels.insert(0xD2u, 43);\n    vowels.insert(0xD3u, 44);\n    vowels.insert(0xD4u,\
    \ 45);\n    vowels.insert(0xD5u, 46);\n    vowels.insert(0x\n}\n\nfn main() {\n\
    \    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0768]: no valid digits found for number\n  --> /tmp/tmprjvs1vme.rs:66:19\n\
    \   |\n66 |     vowels.insert(0x\n   |                   ^^\n\nerror: mismatched\
    \ closing delimiter: `}`\n  --> /tmp/tmprjvs1vme.rs:66:18\n   |\n15 | fn get_closest_vowel(word:\
    \ String) -> String {\n   |                                              - closing\
    \ delimiter possibly meant for this\n...\n66 |     vowels.insert(0x\n   |    \
    \              ^ unclosed delimiter\n67 | }\n   | ^ mismatched closing delimiter\n\
    \nerror: invalid suffix `u` for number literal\n  --> /tmp/tmprjvs1vme.rs:19:19\n\
    \   |\n19 |     vowels.insert(0x55u, 0);\n   |                   ^^^^^ invalid\
    \ suffix `u`\n   |\n   = help: the suffix must be one of the numeric types (`u32`,\
    \ `isize`, `f32`, etc.)\n\nerror: invalid suffix `u` for number literal\n  -->\
    \ /tmp/tmprjvs1vme.rs:20:19\n   |\n20 |     vowels.insert(0x5Au, 1);\n   |   \
    \                ^^^^^ invalid suffix `u`\n   |\n   = help: the suffix must be\
    \ one of the numeric types (`u32`, `isize`, `f32`, etc.)\n\nerror: invalid suffix\
    \ `u` for number literal\n  --> /tmp/tmprjvs1vme.rs:21:19\n   |\n21 |     vowels.insert(0xA0u,\
    \ 2);\n   |                   ^^^^^ invalid suffix `u`\n   |\n   = help: the suffix\
    \ must be one of the numeric types (`u32`, `isize`, `f32`, etc.)\n\nerror: invalid\
    \ suffix `u` for number literal\n  --> /tmp/tmprjvs1vme.rs:22:19\n   |\n22 | \
    \    vowels.insert(0xA1u, 3);\n   |                   ^^^^^ invalid suffix `u`\n\
    \   |\n   = help: the suffix must be one of the numeric types (`u32`, `isize`,\
    \ `f32`, etc.)\n\nerror: invalid suffix `u` for number literal\n  --> /tmp/tmprjvs1vme.rs:23:19\n\
    \   |\n23 |     vowels.insert(0xA2u, 4);\n   |                   ^^^^^ invalid\
    \ suffix `u`\n   |\n   = help: the suffix must be one of the numeric types (`u32`,\
    \ `isize`, `f32`, etc.)\n\nerror: invalid suffix `u` for number literal\n  -->\
    \ /tmp/tmprjvs1vme.rs:24:19\n   |\n24 |     vowels.insert(0xA3u, 5);\n   |   \
    \                ^^^^^ invalid suffix `u`\n   |\n   = help: the suffix must be\
    \ one of the numeric types (`u32`, `isize`, `f32`, etc.)\n\nerror: invalid suffix\
    \ `u` for number lit"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels: Vec<&str> = vec![\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\"\
    , \"I\", \"O\", \"U\"];\n    let mut consonants: Vec<&str> = vec![\"b\", \"c\"\
    , \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\"\
    , \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n\n    let mut closest_vowel:\
    \ Option<&str> = None;\n    for vowel in &vowels {\n        if word.contains(&vowel)\
    \ {\n            closest_vowel = Some(vowel);\n            break;\n        }\n\
    \    }\n\n    let mut closest_consonant: Option<&str> = None;\n    for consonant\
    \ in &consonants {\n        if word.contains(&consonant) {\n            closest_consonant\
    \ = Some(consonant);\n            break;\n        }\n    }\n\n    closest_vowel.as_mut().map(String::from).unwrap_or(\"\
    \") + closest_consonant.as_mut().map(String::from).unwrap_or(\"\")\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `str`\n    --> /tmp/tmpwc02mu00.rs:21:26\n\
    \     |\n21   |         if word.contains(&vowel) {\n     |                 --------\
    \ ^^^^^^\n     |                 |        |\n     |                 |        expected\
    \ an `Fn<(char,)>` closure, found `str`\n     |                 |        help:\
    \ consider dereferencing here: `&*vowel`\n     |                 required by a\
    \ bound introduced by this call\n     |\n     = help: the trait `Fn<(char,)>`\
    \ is not implemented for `str`\n     = note: required because of the requirements\
    \ on the impl of `FnOnce<(char,)>` for `&str`\n     = note: required because of\
    \ the requirements on the impl of `Pattern<'_>` for `&&&str`\nnote: required by\
    \ a bound in `core::str::<impl str>::contains`\n\nerror[E0277]: expected a `Fn<(char,)>`\
    \ closure, found `str`\n    --> /tmp/tmpwc02mu00.rs:29:26\n     |\n29   |    \
    \     if word.contains(&consonant) {\n     |                 -------- ^^^^^^^^^^\n\
    \     |                 |        |\n     |                 |        expected an\
    \ `Fn<(char,)>` closure, found `str`\n     |                 |        help: consider\
    \ dereferencing here: `&*consonant`\n     |                 required by a bound\
    \ introduced by this call\n     |\n     = help: the trait `Fn<(char,)>` is not\
    \ implemented for `str`\n     = note: required because of the requirements on\
    \ the impl of `FnOnce<(char,)>` for `&str`\n     = note: required because of the\
    \ requirements on the impl of `Pattern<'_>` for `&&&str`\nnote: required by a\
    \ bound in `core::str::<impl str>::contains`\n\nerror[E0277]: the trait bound\
    \ `String: From<&mut &str>` is not satisfied\n  --> /tmp/tmpwc02mu00.rs:35:5\n\
    \   |\n35 |     closest_vowel.as_mut().map(String::from).unwrap_or(\"\") + closest_consonant.as_mut().map(String::from).unwrap_or(\"\
    \")\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `From<&mut &str>`\
    \ is not implemented for `String`\n   |\n   = help: the following other types\
    \ implement trait `From<T>`:\n             <String as From<&String>>\n       \
    \      <String as From<&mut str>>\n             <String"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    if\
    \ word.len() <= 1 {\n        return String::from(\"\");\n    }\n    let mut vowels_end\
    \ = word.chars().filter(|c| c.is_uppercase());\n    let mut vowels_start = vowels_end.rev().take(word.len()\
    \ - 2);\n    let mut vowels_middle = word.chars().filter(|c| !c.is_uppercase());\n\
    \    vowels_end.extend(vowels_middle.cloned());\n    vowels_start.extend(vowels_middle.cloned());\n\
    \    vowels_middle.extend(vowels_end.cloned());\n    if vowels_start.contains(&'a'..=&'z')\
    \ {\n        vowels_start = vowels_start.iter().filter(|c| !c.is_uppercase());\n\
    \    }\n    if vowels_end.contains(&'a'..=&'z') {\n        vowels_end = vowels_end.iter().filter(|c|\
    \ !c.is_uppercase());\n    }\n    if vowels_start.contains(&'a'..=&'z') {\n  \
    \      vowels_middle = vowels_middle.iter().filter(|c| !c.is_uppercase());\n \
    \   }\n    if vowels_end.contains(&'a'..=&'z') {\n        vowels_middle = vowels_middle.iter().filter(|c|\
    \ !c.is_uppercase());\n    }\n    let mut vowels_vec: [&'static; 5] = [&'a'.to_string(),\
    \ &'e'.to_string(), &'i'.to_string(), &'o'.to_string(), &'u'.to_string()];\n \
    \   vowels_vec.extend(vowels_start.clone());\n    vowels_vec.extend(vowels_middle.clone());\n\
    \    vowels_vec.extend(vowels_end.clone());\n    vowels_vec\n        .iter()\n\
    \        .cloned()\n        .filter(|&c| vowels_vec.iter().all(|&v| v == c))\n\
    \        .cloned()\n        .collect()\n}\n\nfn main() {\n    let candidate =\
    \ get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected type, found `;`\n  --> /tmp/tmp_9u9ji18.rs:37:34\n   |\n\
    37 |     let mut vowels_vec: [&'static; 5] = [&'a'.to_string(), &'e'.to_string(),\
    \ &'i'.to_string(), &'o'.to_string(), &'u'.to_string()];\n   |         --------------\
    \           ^ expected type\n   |         |\n   |         while parsing the type\
    \ for `mut vowels_vec`\n\nerror[E0599]: no method named `extend` found for struct\
    \ `Filter` in the current scope\n  --> /tmp/tmp_9u9ji18.rs:22:16\n   |\n22 | \
    \    vowels_end.extend(vowels_middle.cloned());\n   |                ^^^^^^ method\
    \ not found in `Filter<Chars<'_>, [closure@/tmp/tmp_9u9ji18.rs:19:46: 19:66]>`\n\
    \nerror[E0271]: type mismatch resolving `<Filter<Chars<'_>, [closure@/tmp/tmp_9u9ji18.rs:21:49:\
    \ 21:70]> as Iterator>::Item == &_`\n    --> /tmp/tmp_9u9ji18.rs:22:37\n     |\n\
    22   |     vowels_end.extend(vowels_middle.cloned());\n     |                \
    \                     ^^^^^^ expected reference, found `char`\n     |\n     =\
    \ note: expected reference `&_`\n                     found type `char`\nnote:\
    \ required by a bound in `cloned`\n\nerror[E0599]: no method named `extend` found\
    \ for struct `std::iter::Take` in the current scope\n  --> /tmp/tmp_9u9ji18.rs:23:18\n\
    \   |\n23 |     vowels_start.extend(vowels_middle.cloned());\n   |           \
    \       ^^^^^^ method not found in `std::iter::Take<Rev<Filter<Chars<'_>, [closure@/tmp/tmp_9u9ji18.rs:19:46:\
    \ 19:66]>>>`\n\nerror[E0271]: type mismatch resolving `<Filter<Chars<'_>, [closure@/tmp/tmp_9u9ji18.rs:21:49:\
    \ 21:70]> as Iterator>::Item == &_`\n    --> /tmp/tmp_9u9ji18.rs:23:39\n     |\n\
    23   |     vowels_start.extend(vowels_middle.cloned());\n     |              \
    \                         ^^^^^^ expected reference, found `char`\n     |\n  \
    \   = note: expected reference `&_`\n                     found type `char`\n\
    note: required by a bound in `cloned`\n\nerror[E0599]: no method named `extend`\
    \ found for struct `Filter` in the current scope\n  --> /tmp/tmp_9u9ji18.rs:24:19\n\
    \   |\n24 |     vowels_middle.extend(vowels_end.cloned());\n   |             \
    \      ^^^^^^ method not found in `Filter<Chars<'_>, [c"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    match\
    \ word.len() {\n        0 => String::from(\"\"),\n        _ => find_vowel_in_word(word),\n\
    \    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `find_vowel_in_word` in this scope\n\
    \  --> /tmp/tmpbfgo3zsr.rs:18:14\n   |\n18 |         _ => find_vowel_in_word(word),\n\
    \   |              ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowel_count = word.chars().map(|c| {\n        if c.is_uppercase() {\n  \
    \          vowel_count += 1;\n        }\n        vowel_count += 0;\n        vowel_count\n\
    \    }).collect();\n    vowel_count.sort();\n    let mut consonant_index = word.length();\n\
    \    let mut consonant_count = word.chars().filter(|c| !c.is_uppercase()).count();\n\
    \    consonant_count.sort_unstable();\n    if consonant_count.len() > vowel_count.len()\
    \ {\n        consonant_index -= consonant_count.len() - vowel_count.len();\n \
    \   }\n    let mut closest_index = consonant_index;\n    while closest_index >\
    \ 0 {\n        if vowel_count.len() < consonant_count {\n            closest_index\
    \ -= consonant_count.len();\n        } else {\n            let mut min_dist =\
    \ std::cmp::max::<u16>(consonant_count, vowel_count.len());\n            let mut\
    \ min_vowel = String::from(\"\");\n            for (vowel, index) in vowel_count.iter().zip(consonant_index.iter())\
    \ {\n                if index > vowel {\n                    break;\n        \
    \        }\n                let distance = std::cmp::max::<u16>(index, vowel -\
    \ min_dist as u16);\n                if distance < min_dist {\n              \
    \      min_dist = distance;\n                    min_vowel = vowel;\n        \
    \        }\n            }\n            return min_vowel;\n        }\n    }\n \
    \   String::from(\"\")\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `vowel_count` in this scope\n  --> /tmp/tmp82zl8o3s.rs:18:13\n\
    \   |\n18 |             vowel_count += 1;\n   |             ^^^^^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `vowel_count` in this scope\n\
    \  --> /tmp/tmp82zl8o3s.rs:20:9\n   |\n20 |         vowel_count += 0;\n   |  \
    \       ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `vowel_count` in this scope\n  --> /tmp/tmp82zl8o3s.rs:21:9\n   |\n21 |    \
    \     vowel_count\n   |         ^^^^^^^^^^^ not found in this scope\n\nerror[E0599]:\
    \ no method named `length` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmp82zl8o3s.rs:24:36\n   |\n24 |     let mut consonant_index = word.length();\n\
    \   |                                    ^^^^^^ help: there is an associated function\
    \ with a similar name: `len`\n\nerror[E0599]: no method named `sort_unstable`\
    \ found for type `usize` in the current scope\n  --> /tmp/tmp82zl8o3s.rs:26:21\n\
    \   |\n26 |     consonant_count.sort_unstable();\n   |                     ^^^^^^^^^^^^^\
    \ method not found in `usize`\n\nerror[E0599]: no method named `len` found for\
    \ type `usize` in the current scope\n  --> /tmp/tmp82zl8o3s.rs:27:24\n   |\n27\
    \ |     if consonant_count.len() > vowel_count.len() {\n   |                 \
    \       ^^^ method not found in `usize`\n\nerror[E0599]: no method named `len`\
    \ found for type `usize` in the current scope\n  --> /tmp/tmp82zl8o3s.rs:28:44\n\
    \   |\n28 |         consonant_index -= consonant_count.len() - vowel_count.len();\n\
    \   |                                            ^^^ method not found in `usize`\n\
    \nerror[E0599]: no method named `len` found for type `usize` in the current scope\n\
    \  --> /tmp/tmp82zl8o3s.rs:33:46\n   |\n33 |             closest_index -= consonant_count.len();\n\
    \   |                                              ^^^ method not found in `usize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp82zl8o3s.rs:35:53\n   |\n35 |\
    \             let mut min_dist = std::cmp::max::<u16>(consonant_count, vowel_count.len());\n\
    \   |                                                     ^^^^^^^^"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    if\
    \ word.is_empty() {\n        return String::from(\"\");\n    }\n\n    let mut\
    \ vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut consonants =\
    \ vec![\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"\
    n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n\
    \    let mut index = word.len() - 1;\n    let mut res = String::from(\"\");\n\n\
    \    while index >= 0 {\n        if vowels.contains(&word[index]) {\n        \
    \    res.push_str(&vowels[vowels.iter().position(|&x| x == word[index]).unwrap()]);\n\
    \            vowels.remove(&word[index]);\n        }\n\n        if word[index]\
    \ == consonants[0] {\n            consonants.remove(&word[index]);\n         \
    \   vowels.remove(&vowels[0]);\n            index -= 1;\n        }\n\n       \
    \ if word[index] == consonants[1] {\n            consonants.remove(&word[index]);\n\
    \            vowels.remove(&vowels[1]);\n            index -= 1;\n        }\n\n\
    \        if word[index] == consonants[2] {\n            consonants.remove(&word[index]);\n\
    \            vowels.remove(&vowels[2]);\n            index -= 1;\n        }\n\n\
    \        if word[index] == consonants[3] {\n            consonants.remove(&word[index]);\n\
    \            vowels.remove(&vowels[3]);\n            index -= 1;\n        }\n\n\
    \        if word[index] == consonants[4] {\n            consonants.remove(&word[index]);\n\
    \            vowels.remove(&vowels[4]);\n            index -= 1;\n        }\n\n\
    \        if word[index] == consonants[5] {\n            consonants.remove(&word[index]);\n\
    \            vowels.remove(&vowels[5]);\n            index -= 1;\n        }\n\n\
    \        if word[index] == consonants[6] {\n            consonants.remove(&word[index]);\n\
    \            vowels.remove(&vowels[6]);\n            index -= 1;\n        }\n\n\
    \        if word[index] == consonants[7] {\n            consonants.remove(&word[index]);\n\
    \            vowels.remove(&vowels[7]);\n            index -= 1;\n        }\n\n\
    \        if word[index] == consonants[8] {\n            consonants.remove(&word[index]);\n\
    \            vowels.remove(&vowels[8]);\n            index -= 1;\n        }\n\n\
    \        if word[index] == consonants[9] {\n            consonants.remove(&word[index]);\n\
    \            vowels.remove(&vowels[9]);\n            index -= 1;\n        }\n\n\
    \        if word[index] == consonants[10] {\n            consonants.remove(\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpmdjols4u.rs:110:3\n\
    \    |\n15  | fn get_closest_vowel(word: String) -> String {\n    |          \
    \                                    - unclosed delimiter\n...\n25  |     while\
    \ index >= 0 {\n    |                      - unclosed delimiter\n...\n91  |  \
    \       if word[index] == consonants[10] {\n    |                            \
    \              - this delimiter might not be properly closed...\n92  |       \
    \      consonants.remove(\n93  | }\n    | - ...as it matches this but it has different\
    \ indentation\n...\n110 | }\n    |   ^\n\nerror: mismatched closing delimiter:\
    \ `}`\n  --> /tmp/tmpmdjols4u.rs:92:30\n   |\n15 | fn get_closest_vowel(word:\
    \ String) -> String {\n   |                                              - closing\
    \ delimiter possibly meant for this\n...\n92 |             consonants.remove(\n\
    \   |                              ^ unclosed delimiter\n93 | }\n   | ^ mismatched\
    \ closing delimiter\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpmdjols4u.rs:26:29\n   |\n26 |         if vowels.contains(&word[index])\
    \ {\n   |                             ^^^^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpmdjols4u.rs:27:67\n   |\n27 |             res.push_str(&vowels[vowels.iter().position(|&x|\
    \ x == word[index]).unwrap()]);\n   |                                        \
    \                           ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the follo"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels_found = Vec::new();\n\n    for i in 0..word.len() {\n        let\
    \ start_index = word.len() - i;\n        let end_index = start_index + 1;\n  \
    \      let letter = word[end_index];\n\n        if let Some(found_index) = vowels_found.iter().position(|x|\
    \ x == letter) {\n            let last_vowel_index = vowels_found[found_index];\n\
    \            let last_vowel_length = word.len() - last_vowel_index - 1;\n    \
    \        if start_index >= last_vowel_index && end_index <= last_vowel_index +\
    \ last_vowel_length {\n                vowels_found.pop();\n            }\n  \
    \      }\n    }\n\n    if !vowels_found.is_empty() {\n        let last_vowel_index\
    \ = vowels_found.iter().position(|x| x == word.last()).unwrap();\n        let\
    \ last_vowel_length = word.len() - last_vowel_index - 1;\n        let start =\
    \ word[last_vowel_index];\n        let end = word[last_vowel_index + last_vowel_length];\n\
    \n        String::from(format!(\"{}{}\", start, end))\n    } else {\n        String::from(\"\
    \")\n    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpvpwnbbgb.rs:21:22\n\
    \   |\n21 |         let letter = word[end_index];\n   |                      ^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: `String` is not an iterator\n   --> /tmp/tmpvpwnbbgb.rs:33:75\n\
    \    |\n33  |           let last_vowel_index = vowels_found.iter().position(|x|\
    \ x == word.last()).unwrap();\n    |                                         \
    \                                    ^^^^ `String` is not an iterator; try calling\
    \ `.chars()` or `.bytes()`\n    |\n    = note: the following trait bounds were\
    \ not satisfied:\n            `String: Iterator`\n            which is required\
    \ by `&mut String: Iterator`\n            `str: Iterator`\n            which is\
    \ required by `&mut str: Iterator`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n  --> /tmp/tmpvpwnbbgb.rs:35:21\n   |\n35 |         let\
    \ start = word[last_vowel_index];\n   |                     ^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tm"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowel_index = word.rfind(&Vowels)?;\n    if vowel_index == 0 {\n       \
    \ String::from(\"\")\n    } else {\n        let vowel = word.as_str()[vowel_index..];\n\
    \        if vowel.contains(&consonants) {\n            vowel_index -= 1;\n   \
    \     }\n        let vowel = word.as_str()[vowel_index..];\n        if vowel.contains(&consonants)\
    \ {\n            vowel_index -= 1;\n        }\n        let vowel = word.as_str()[vowel_index..];\n\
    \        if vowel.contains(&consonants) {\n            vowel_index -= 1;\n   \
    \     }\n        word.as_str()[vowel_index..]\n    }\n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `Vowels` in this scope\n  --> /tmp/tmpdrn0m_mm.rs:16:39\n\
    \   |\n16 |     let mut vowel_index = word.rfind(&Vowels)?;\n   |            \
    \                           ^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `consonants` in this scope\n  --> /tmp/tmpdrn0m_mm.rs:21:28\n   |\n\
    21 |         if vowel.contains(&consonants) {\n   |                          \
    \  ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `consonants`\
    \ in this scope\n  --> /tmp/tmpdrn0m_mm.rs:25:28\n   |\n25 |         if vowel.contains(&consonants)\
    \ {\n   |                            ^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `consonants` in this scope\n  --> /tmp/tmpdrn0m_mm.rs:29:28\n\
    \   |\n29 |         if vowel.contains(&consonants) {\n   |                   \
    \         ^^^^^^^^^^ not found in this scope\n\nerror[E0277]: the `?` operator\
    \ can only be used in a function that returns `Result` or `Option` (or another\
    \ type that implements `FromResidual`)\n  --> /tmp/tmpdrn0m_mm.rs:16:46\n   |\n\
    15 | / fn get_closest_vowel(word: String) -> String {\n16 | |     let mut vowel_index\
    \ = word.rfind(&Vowels)?;\n   | |                                            \
    \  ^ cannot use the `?` operator in a function that returns `String`\n17 | | \
    \    if vowel_index == 0 {\n18 | |         String::from(\"\")\n...  |\n33 | |\
    \     }\n34 | | }\n   | |_- this function should return `Result` or `Option` to\
    \ accept `?`\n   |\n   = help: the trait `FromResidual<Option<Infallible>>` is\
    \ not implemented for `String`\n\nerror[E0277]: the size for values of type `str`\
    \ cannot be known at compilation time\n  --> /tmp/tmpdrn0m_mm.rs:20:13\n   |\n\
    20 |         let vowel = word.as_str()[vowel_index..];\n   |             ^^^^^\
    \ doesn't have a size known at compile-time\n   |\n   = help: the trait `Sized`\
    \ is not implemented for `str`\n   = note: all local variables must have a statically\
    \ known size\n   = help: unsized locals are gated as an unstable feature\nhelp:\
    \ consider borrowing here\n   |\n20 |         let vowel = &word.as_str()[vowel_index..];\n\
    \   |      "
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    word.chars()\n\
    \        .position(|&c| c.is_ascii_lowercase())\n        .unwrap_or_else(|| {\n\
    \            word.chars()\n                .position(|&c| !c.is_ascii_lowercase())\n\
    \                .unwrap_or(0)\n        })\n        .map(|i| {\n            if\
    \ i == 0 {\n                String::from(\"a\")\n            } else {\n      \
    \          word.chars().nth(i - 1).unwrap()\n            }\n        })\n     \
    \   .iter()\n        .cloned()\n        .find(|&c| c.is_ascii_uppercase())\n \
    \       .cloned()\n        .cloned()\n        .unwrap_or(\"\")\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmps4hv37uu.rs:17:20\n   |\n\
    17 |         .position(|&c| c.is_ascii_lowercase())\n   |                    ^--\n\
    \   |                    ||\n   |                    |expected due to this\n \
    \  |                    expected `char`, found reference\n   |               \
    \     help: did you mean `c`: `&char`\n   |\n   = note:   expected type `char`\n\
    \           found reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmps4hv37uu.rs:20:28\n\
    \   |\n20 |                 .position(|&c| !c.is_ascii_lowercase())\n   |    \
    \                        ^--\n   |                            ||\n   |       \
    \                     |expected due to this\n   |                            expected\
    \ `char`, found reference\n   |                            help: did you mean\
    \ `c`: `&char`\n   |\n   = note:   expected type `char`\n           found reference\
    \ `&_`\n\nerror[E0599]: `usize` is not an iterator\n  --> /tmp/tmps4hv37uu.rs:23:10\n\
    \   |\n23 |         .map(|i| {\n   |          ^^^ `usize` is not an iterator\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `usize:\
    \ Iterator`\n           which is required by `&mut usize: Iterator`\n\nerror[E0308]:\
    \ `if` and `else` have incompatible types\n  --> /tmp/tmps4hv37uu.rs:27:17\n \
    \  |\n24 | /             if i == 0 {\n25 | |                 String::from(\"a\"\
    )\n   | |                 ----------------- expected because of this\n26 | | \
    \            } else {\n27 | |                 word.chars().nth(i - 1).unwrap()\n\
    \   | |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   | |                 |\n   | |                 expected\
    \ struct `String`, found `char`\n28 | |             }\n   | |_____________- `if`\
    \ and `else` have incompatible types\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowel = String::new();\n    let mut prev_vowel = String::new();\n    let\
    \ mut start_idx = 0;\n    let mut end_idx = word.len() - 1;\n\n    // If the word\
    \ contains only one consonant, we simply return an empty string.\n    // Otherwise,\
    \ get the index of the first consonant in the word, and get the vowel\n    //\
    \ that stands between them.\n    while start_idx < word.len() {\n        if word[start_idx]\
    \ == String::from(\"c\") {\n            vowel.push(String::from(\"c\"));\n   \
    \         start_idx += 1;\n        } else {\n            if start_idx == end_idx\
    \ {\n                // If it's the last consonant, simply return an empty string.\n\
    \                vowel.push(String::from(\"\"));\n            } else {\n     \
    \           // If it's not a consonant, get the index of the next consonant,\n\
    \                // get the vowel that stands between them and return the vowel.\n\
    \                let mut idx = start_idx;\n                while idx < end_idx\
    \ {\n                    if word[idx] == String::from(\"c\") {\n             \
    \           // If it's the last consonant, simply return an empty string.\n  \
    \                      vowel.push(String::from(\"\"));\n                     \
    \   break;\n                    }\n                    idx += 1;\n           \
    \     }\n                if idx == end_idx {\n                    // If it's the\
    \ last consonant, simply return an empty string.\n                    vowel.push(String::from(\"\
    \"));\n                } else {\n                    // If it's not the last consonant,\
    \ get the vowel that stands between them\n                    // and return the\
    \ vowel.\n                    prev_vowel = vowel;\n                    let mut\
    \ idx = start_idx;\n                    while idx < end_idx {\n              \
    \          if word[idx] == String::from(\"c\") {\n                           \
    \ // If it's the last consonant, simply return an empty string.\n            \
    \                vowel.push(String::from(\"\"));\n                           \
    \ break;\n                        }\n                        if idx == end_idx\
    \ {\n                            // If it's the last consonant, simply return\
    \ an empty string.\n                            vowel.push(String::from(\"\"));\n\
    \                            break;\n                        }\n             \
    \           if word[idx] == String::from(\"u\") {\n                          \
    \  // If it's the last consonant, simply return an empty string.\n           \
    \                 vowel.push(String::from(\"\"));\n                          \
    \  break;\n                        }\n                        idx += 1;\n    \
    \                }\n                }\n            }\n        }\n    }\n    prev_vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpbswphyib.rs:25:12\n\
    \   |\n25 |         if word[start_idx] == String::from(\"c\") {\n   |        \
    \    ^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbswphyib.rs:26:24\n\
    \   |\n26 |             vowel.push(String::from(\"c\"));\n   |               \
    \         ^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpbswphyib.rs:31:28\n   |\n31 |              \
    \   vowel.push(String::from(\"\"));\n   |                            ^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0277]: the type `String` cannot\
    \ be indexed by `usize`\n  --> /tmp/tmpbswphyib.rs:37:24\n   |\n37 |         \
    \            if word[idx] == String::from(\"c\") {\n   |                     \
    \   ^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbswphyib.rs:39:36\n\
    \   |\n39 |                         vowel.push(String::from(\"\"));\n   |    \
    \                                ^^^^^^^^^^^^^^^^ expected `char`, found struct\
    \ `String`\n\nerror["
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = HashMap::new();\n    let mut index = 0;\n    vowels.insert(\"a\"\
    , 1);\n    vowels.insert(\"e\", 1);\n    vowels.insert(\"i\", 1);\n    vowels.insert(\"\
    o\", 1);\n    vowels.insert(\"u\", 1);\n    vowels.insert(\"y\", 1);\n    let\
    \ mut consonants = word.chars().skip_while(|c| !vowels.contains_key(c.to_ascii_lowercase()));\n\
    \    vowels.insert(\"a\", 1);\n    vowels.insert(\"e\", 1);\n    vowels.insert(\"\
    i\", 1);\n    vowels.insert(\"o\", 1);\n    vowels.insert(\"u\", 1);\n    vowels.insert(\"\
    y\", 1);\n    consonants.next().unwrap();\n    loop {\n        let mut min_distance\
    \ = std::cmp::min(consonants.next().unwrap(), word.len());\n        let mut min_distance\
    \ = std::cmp::min(min_distance, index + 1);\n        if min_distance > index {\n\
    \            min_distance = index;\n        }\n        \n        if min_distance\
    \ > word.len() - 1 {\n            break;\n        }\n        \n        let mut\
    \ curr_char = consonants.next().unwrap();\n        while vowels.contains_key(curr_char.to_ascii_lowercase())\
    \ &&\n              vowels.get(curr_char.to_ascii_lowercase()).unwrap() > min_distance\
    \ {\n            min_distance = vowels.get(curr_char.to_ascii_lowercase()).unwrap();\n\
    \            curr_char = consonants.next().unwrap();\n        }\n        \n  \
    \      index += min_distance + 1;\n        if index >= word.len() {\n        \
    \    break;\n        }\n    }\n    \n    format!(\"{}\", word.chars().skip_while(|c|\
    \ !vowels.contains_key(c.to_ascii_lowercase())).next().unwrap().to_ascii_lowercase())\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpuu_i1wdw.rs:16:22\n   |\n16 |     let mut vowels = HashMap::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpuu_i1wdw.rs:33:74\n   |\n33 |         let mut\
    \ min_distance = std::cmp::min(consonants.next().unwrap(), word.len());\n   |\
    \                                                                          ^^^^^^^^^^\
    \ expected `char`, found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpuu_i1wdw.rs:34:60\n\
    \   |\n34 |         let mut min_distance = std::cmp::min(min_distance, index +\
    \ 1);\n   |                                                            ^^^^^^^^^\
    \ expected `char`, found integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpuu_i1wdw.rs:35:27\n\
    \   |\n35 |         if min_distance > index {\n   |                          \
    \ ^^^^^ expected `char`, found integer\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpuu_i1wdw.rs:36:28\n   |\n34 |         let mut min_distance = std::cmp::min(min_distance,\
    \ index + 1);\n   |                                --------------------------------------\
    \ expected due to this value\n35 |         if min_distance > index {\n36 |   \
    \          min_distance = index;\n   |                            ^^^^^ expected\
    \ `char`, found integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpuu_i1wdw.rs:39:27\n\
    \   |\n39 |         if min_distance > word.len() - 1 {\n   |                 \
    \          ^^^^^^^^^^^^^^ expected `char`, found `usize`\n\nerror[E0369]: cannot\
    \ add `{integer}` to `char`\n  --> /tmp/tmpuu_i1wdw.rs:50:31\n   |\n50 |     \
    \    index += min_distance + 1;\n   |                  ------------ ^ - {integer}\n\
    \   |                  |\n   |                  char\n\nerror: aborting due to\
    \ 7 previous errors\n\nSome errors have detailed explanations: E0308, E0369, E0433.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut s = String::from(\"\");\n    let mut vowels = \"aeiouAEIOU\";\n    let mut\
    \ vowels_index = -1;\n    \n    for &c in word.chars() {\n        if vowels.contains(&c.to_lowercase())\
    \ {\n            vowels_index = vowels.find(&c.to_lowercase());\n            \n\
    \            if vowels_index == 0 {\n                s = String::from(\"\");\n\
    \                break;\n            } else if vowels_index == vowels.len() -\
    \ 1 {\n                s = String::from(\"\");\n                break;\n     \
    \       } else {\n                s = s.chars().enumerate().find(|&(i, &x)| x\
    \ == c).unwrap().0;\n                break;\n            }\n        }\n    }\n\
    \    \n    s\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc3qyggkb.rs:20:9\n   |\n\
    20 |     for &c in word.chars() {\n   |         ^^    ------------ this expression\
    \ has type `Option<char>`\n   |         |\n   |         expected `char`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `c`\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpc3qyggkb.rs:22:28\n   |\n18 |  \
    \   let mut vowels_index = -1;\n   |                            -- expected due\
    \ to this value\n...\n22 |             vowels_index = vowels.find(&c.to_lowercase());\n\
    \   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected integer,\
    \ found enum `Option`\n   |\n   = note: expected type `{integer}`\n          \
    \    found enum `Option<usize>`\n\nerror[E0277]: the trait bound `usize: Neg`\
    \ is not satisfied\n  --> /tmp/tmpc3qyggkb.rs:18:28\n   |\n18 |     let mut vowels_index\
    \ = -1;\n   |                            ^^ the trait `Neg` is not implemented\
    \ for `usize`\n   |\n   = help: the following other types implement trait `Neg`:\n\
    \             &f32\n             &f64\n             &i128\n             &i16\n\
    \             &i32\n             &i64\n             &i8\n             &isize\n\
    \           and 8 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc3qyggkb.rs:31:54\n\
    \   |\n31 |                 s = s.chars().enumerate().find(|&(i, &x)| x == c).unwrap().0;\n\
    \   |                                                      ^^- expected due to\
    \ this\n   |                                                      |\n   |    \
    \                                                  expected `char`, found reference\n\
    \   |                                                      help: you can probably\
    \ remove the explicit borrow: `x`\n   |\n   = note:   expected type `char`\n \
    \          found reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc3qyggkb.rs:31:21\n\
    \   |\n16 |     let mut s = String::from(\"\");\n   |                 ----------------\
    \ expected due to this value\n...\n31 |                 s = s.chars().enumerate().find(|&(i, "
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    if\
    \ word.len() < 2 {\n        return String::from(\"\");\n    }\n    let mut first\
    \ = word[0];\n    let mut last = word[word.len() - 1];\n    \n    for &c in word.chars().rref().rev()\
    \ {\n        if c == first {\n            first = c;\n            continue;\n\
    \        }\n        if c == last {\n            last = c;\n            continue;\n\
    \        }\n        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'\n\
    \            || (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n\
    \            return String::from(c);\n        }\n    }\n    \n    return String::from(\"\
    \");\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpsqlvnyi8.rs:19:21\n   |\n19 |     let mut first = word[0];\n   |   \
    \                  ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n \
    \  = help: the trait `Index<{integer}>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpsqlvnyi8.rs:20:20\n   |\n20 |     let mut last = word[word.len()\
    \ - 1];\n   |                    ^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `rref` found for struct `Chars` in\
    \ the current scope\n  --> /tmp/tmpsqlvnyi8.rs:22:28\n   |\n22 |     for &c in\
    \ word.chars().rref().rev() {\n   |                            ^^^^ method not\
    \ found in `Chars<'_>`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = [String::from(\"\")];\n    vowels.push(String::from(\"u\"));\n\
    \    vowels.push(String::from(\"i\"));\n    vowels.push(String::from(\"e\"));\n\
    \    vowels.push(String::from(\"a\"));\n    vowels.push(String::from(\"o\"));\n\
    \    vowels.push(String::from(\"U\"));\n    vowels.push(String::from(\"I\"));\n\
    \    vowels.push(String::from(\"E\"));\n    vowels.push(String::from(\"A\"));\n\
    \    vowels.push(String::from(\"O\"));\n    for vowel in vowels.iter() {\n   \
    \     if word.contains(\"U\") {\n            word.truncate(word.len() - vowel.len());\n\
    \        }\n        if word.contains(\"I\") {\n            word.truncate(word.len()\
    \ - vowel.len());\n        }\n        if word.contains(\"E\") {\n            word.truncate(word.len()\
    \ - vowel.len());\n        }\n        if word.contains(\"A\") {\n            word.truncate(word.len()\
    \ - vowel.len());\n        }\n        if word.contains(\"O\") {\n            word.truncate(word.len()\
    \ - vowel.len());\n        }\n        if word.contains(\"u\") {\n            word.truncate(word.len()\
    \ - vowel.len());\n        }\n        if word.contains(\"i\") {\n            word.truncate(word.len()\
    \ - vowel.len());\n        }\n        if word.contains(\"e\") {\n            word.truncate(word.len()\
    \ - vowel.len());\n        }\n        if word.contains(\"a\") {\n            word.truncate(word.len()\
    \ - vowel.len());\n        }\n        if word.contains(\"o\") {\n            word.truncate(word.len()\
    \ - vowel.len());\n        }\n    }\n    word.truncate(word.len() - 1);\n    word\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `push` found for array `[String; 1]` in the\
    \ current scope\n  --> /tmp/tmp5djhluap.rs:17:12\n   |\n17 |     vowels.push(String::from(\"\
    u\"));\n   |            ^^^^ method not found in `[String; 1]`\n\nerror[E0599]:\
    \ no method named `push` found for array `[String; 1]` in the current scope\n\
    \  --> /tmp/tmp5djhluap.rs:18:12\n   |\n18 |     vowels.push(String::from(\"i\"\
    ));\n   |            ^^^^ method not found in `[String; 1]`\n\nerror[E0599]: no\
    \ method named `push` found for array `[String; 1]` in the current scope\n  -->\
    \ /tmp/tmp5djhluap.rs:19:12\n   |\n19 |     vowels.push(String::from(\"e\"));\n\
    \   |            ^^^^ method not found in `[String; 1]`\n\nerror[E0599]: no method\
    \ named `push` found for array `[String; 1]` in the current scope\n  --> /tmp/tmp5djhluap.rs:20:12\n\
    \   |\n20 |     vowels.push(String::from(\"a\"));\n   |            ^^^^ method\
    \ not found in `[String; 1]`\n\nerror[E0599]: no method named `push` found for\
    \ array `[String; 1]` in the current scope\n  --> /tmp/tmp5djhluap.rs:21:12\n\
    \   |\n21 |     vowels.push(String::from(\"o\"));\n   |            ^^^^ method\
    \ not found in `[String; 1]`\n\nerror[E0599]: no method named `push` found for\
    \ array `[String; 1]` in the current scope\n  --> /tmp/tmp5djhluap.rs:22:12\n\
    \   |\n22 |     vowels.push(String::from(\"U\"));\n   |            ^^^^ method\
    \ not found in `[String; 1]`\n\nerror[E0599]: no method named `push` found for\
    \ array `[String; 1]` in the current scope\n  --> /tmp/tmp5djhluap.rs:23:12\n\
    \   |\n23 |     vowels.push(String::from(\"I\"));\n   |            ^^^^ method\
    \ not found in `[String; 1]`\n\nerror[E0599]: no method named `push` found for\
    \ array `[String; 1]` in the current scope\n  --> /tmp/tmp5djhluap.rs:24:12\n\
    \   |\n24 |     vowels.push(String::from(\"E\"));\n   |            ^^^^ method\
    \ not found in `[String; 1]`\n\nerror[E0599]: no method named `push` found for\
    \ array `[String; 1]` in the current scope\n  --> /tmp/tmp5djhluap.rs:25:12\n\
    \   |\n25 |     vowels.push(String::from(\"A\"));\n   |            ^^^^ method\
    \ not found in `[String; 1]`\n\nerror[E0599]: no method named `push` found for\
    \ arr"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    if\
    \ word.is_empty() {\n        return String::from(\"\");\n    }\n    let mut vowels\
    \ = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_right = vec![\"\
    u\", \"e\", \"i\", \"o\", \"a\"];\n    let mut vowels_left = vec![\"u\", \"e\"\
    , \"i\", \"o\", \"a\"];\n    if word.len() == 0 {\n        return String::from(\"\
    \");\n    }\n    for c in word.chars() {\n        for v in &vowels {\n       \
    \     if c >= v as u8 {\n                if vowels_right.contains(&v) || vowels_left.contains(&v)\
    \ {\n                    vowels_right = vowels_right.filter(|x| !vowels.contains(x));\n\
    \                    vowels_left = vowels_left.filter(|x| !vowels.contains(x));\n\
    \                    if vowels_right.contains(&v) {\n                        return\
    \ String::from(&v);\n                    } else if vowels_left.contains(&v) {\n\
    \                        return String::from(&v);\n                    }\n   \
    \             }\n                vowels_right = vowels_right.push(v);\n      \
    \          if vowels_right.len() == 4 {\n                    break;\n        \
    \        }\n            }\n        }\n        for v in &vowels_right {\n     \
    \       if c <= v as u8 {\n                if vowels_left.contains(&v) || vowels.contains(&v)\
    \ {\n                    vowels_left = vowels_left.filter(|x| !vowels.contains(x));\n\
    \                    vowels = vowels.filter(|x| !vowels.contains(x));\n      \
    \              if vowels_left.contains(&v) {\n                        return String::from(&v);\n\
    \                    } else if vowels.contains(&v) {\n                       \
    \ return String::from(&v);\n                    }\n                }\n       \
    \         vowels_left = vowels_left.push(v);\n                if vowels_left.len()\
    \ == 4 {\n                    break;\n                }\n            }\n     \
    \   }\n    }\n    String::from(\"\")\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpullqzgoa.rs:27:21\n   |\n\
    27 |             if c >= v as u8 {\n   |                     ^^^^^^^ expected\
    \ `char`, found `u8`\n\nerror[E0599]: `Vec<&str>` is not an iterator\n   --> /tmp/tmpullqzgoa.rs:29:49\n\
    \    |\n29  |                       vowels_right = vowels_right.filter(|x| !vowels.contains(x));\n\
    \    |                                                   ^^^^^^ `Vec<&str>` is\
    \ not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Vec<&str>: Iterator`\n            which is required by `&mut Vec<&str>:\
    \ Iterator`\n            `[&str]: Iterator`\n            which is required by\
    \ `&mut [&str]: Iterator`\n\nerror[E0599]: `Vec<&str>` is not an iterator\n  \
    \ --> /tmp/tmpullqzgoa.rs:30:47\n    |\n30  |                       vowels_left\
    \ = vowels_left.filter(|x| !vowels.contains(x));\n    |                      \
    \                           ^^^^^^ `Vec<&str>` is not an iterator\n    |\n   \
    \ = note: the following trait bounds were not satisfied:\n            `Vec<&str>:\
    \ Iterator`\n            which is required by `&mut Vec<&str>: Iterator`\n   \
    \         `[&str]: Iterator`\n            which is required by `&mut [&str]: Iterator`\n\
    \nerror[E0277]: the trait bound `String: From<&&&str>` is not satisfied\n  -->\
    \ /tmp/tmpullqzgoa.rs:32:32\n   |\n32 |                         return String::from(&v);\n\
    \   |                                ^^^^^^^^^^^^ the trait `From<&&&str>` is\
    \ not implemented for `String`\n   |\n   = help: the following other types implement\
    \ trait `From<T>`:\n             <String as From<&String>>\n             <String\
    \ as From<&mut str>>\n             <String as From<&str>>\n             <String\
    \ as From<Box<str>>>\n             <String as From<Cow<'a, str>>>\n          \
    \   <String as From<char>>\n\nerror[E0277]: the trait bound `String: From<&&&str>`\
    \ is not satisfied\n  --> /tmp/tmpullqzgoa.rs:34:32\n   |\n34 |              \
    \           return String::from(&v);\n   |                                ^^^^^^^^^^^^\
    \ the trait `From<&&&str>` is not implemented for `String`\n   |\n   = help: th"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut chars = word.chars();\n    let mut vowel_counter = 0;\n    let mut previous_char:\
    \ &str = \"\";\n    for ch in chars.rev() {\n        if !is_vowel(ch) {\n    \
    \        break;\n        }\n        previous_char = ch;\n    }\n    for ch in\
    \ chars.rev() {\n        if !is_vowel(ch) {\n            break;\n        }\n \
    \       if ch != previous_char {\n            vowel_counter++;\n        }\n  \
    \  }\n    if vowel_counter < 2 {\n        return String::from(\"\");\n    }\n\
    \    let mut previous_char: &str = \"\";\n    for ch in chars.rev() {\n      \
    \  if !is_vowel(ch) {\n            break;\n        }\n        previous_char =\
    \ ch;\n    }\n    for ch in chars.rev() {\n        if !is_vowel(ch) {\n      \
    \      break;\n        }\n        if ch != previous_char {\n            vowel_counter--;\n\
    \        }\n    }\n    match vowel_counter {\n        0 => String::from(\"\"),\n\
    \        1 => String::from(\"u\"),\n        _ => String::from(\"U\")\n    }\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp9ra7qw9r.rs:30:26\n\
    \   |\n30 |             vowel_counter++;\n   |                          ^^ not\
    \ a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n30 |       \
    \      { let tmp = vowel_counter; vowel_counter += 1; tmp };\n   |           \
    \  +++++++++++              ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n30 -             vowel_counter++;\n\
    30 +             vowel_counter += 1;\n   | \n\nerror: expected expression, found\
    \ `;`\n  --> /tmp/tmp9ra7qw9r.rs:48:28\n   |\n48 |             vowel_counter--;\n\
    \   |                            ^ expected expression\n\nerror[E0425]: cannot\
    \ find function `is_vowel` in this scope\n  --> /tmp/tmp9ra7qw9r.rs:20:13\n  \
    \ |\n20 |         if !is_vowel(ch) {\n   |             ^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `is_vowel` in this scope\n  -->\
    \ /tmp/tmp9ra7qw9r.rs:26:13\n   |\n26 |         if !is_vowel(ch) {\n   |     \
    \        ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `is_vowel` in this scope\n  --> /tmp/tmp9ra7qw9r.rs:38:13\n   |\n38 |      \
    \   if !is_vowel(ch) {\n   |             ^^^^^^^^ not found in this scope\n\n\
    error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp9ra7qw9r.rs:44:13\n\
    \   |\n44 |         if !is_vowel(ch) {\n   |             ^^^^^^^^ not found in\
    \ this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9ra7qw9r.rs:23:25\n\
    \   |\n18 |     let mut previous_char: &str = \"\";\n   |                    \
    \        ---- expected due to this type\n...\n23 |         previous_char = ch;\n\
    \   |                         ^^ expected `&str`, found `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9ra7qw9r.rs:29:18\n   |\n29 |         if ch\
    \ != previous_char {\n   |                  ^^^^^^^^^^^^^ expected `char`, found\
    \ `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9ra7qw9r.rs:41:25\n\
    \   |\n36 |     let mut previous_char: &str = \"\";\n   |                    \
    \        ---- expected due to this type\n...\n41 |         previous_char = ch;\n\
    \   |                         ^^ expected `&str`, found `char`\n\nerror[E030"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowel = String::new();\n    let mut consonant = String::new();\n    let\
    \ mut index = 0;\n    for c in word{\n        if c == 'a' || c == 'e' || c ==\
    \ 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'I' || c == 'O'\
    \ || c == 'U' {\n            consonant = c;\n            index = word.len() -\
    \ 1;\n            break;\n        }\n        if index != 0 {\n            vowel\
    \ = &word[index..index+2];\n            break;\n        }\n    }\n    vowel.clone()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpm_j8m9pp.rs:19:14\n\
    \   |\n19 |     for c in word{\n   |              ^^^^ `String` is not an iterator;\
    \ try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator`\
    \ is not implemented for `String`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `String`\n\nerror[E0277]: can't compare `String`\
    \ with `char`\n  --> /tmp/tmpm_j8m9pp.rs:20:14\n   |\n20 |         if c == 'a'\
    \ || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c\
    \ == 'I' || c == 'O' || c == 'U' {\n   |              ^^ no implementation for\
    \ `String == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `String` with `char`\n  --> /tmp/tmpm_j8m9pp.rs:20:26\n   |\n20 |         if\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c ==\
    \ 'E' || c == 'I' || c == 'O' || c == 'U' {\n   |                          ^^\
    \ no implementation for `String == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0277]: can't compare `String` with `char`\n\
    \  --> /tmp/tmpm_j8m9"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    use\
    \ std::cmp::Ordering::*;\n    word.chars().enumerate()\n        .filter(|(_, c)|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n        .filter(|(_,\
    \ c)| !(c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U'))\n        .filter(|(_,\
    \ c)| !(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'))\n        .find(|(_,\
    \ c)| c != 'A' && c != 'E' && c != 'I' && c != 'O' && c != 'U')\n        .map(|(_,\
    \ c)| c)\n        .map(|c| c.to_string())\n        .unwrap_or(\"\")\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "warning: unused import: `std::cmp::Ordering::*`\n  --> /tmp/tmpebk2fxio.rs:16:9\n\
    \   |\n16 |     use std::cmp::Ordering::*;\n   |         ^^^^^^^^^^^^^^^^^^^^^\n\
    \   |\n   = note: `#[warn(unused_imports)]` on by default\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpebk2fxio.rs:18:28\n   |\n18 |   \
    \      .filter(|(_, c)| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n\
    \   |                            ^^ no implementation for `&char == char`\n  \
    \ |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n \
    \  = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpebk2fxio.rs:18:40\n   |\n18 |   \
    \      .filter(|(_, c)| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n\
    \   |                                        ^^ no implementation for `&char ==\
    \ char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpebk2fxio.rs:18:52\n   |\n18 |   \
    \      .filter(|(_, c)| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n\
    \   |                                                    ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpebk2fxio.rs:18:64\n\
    \   |\n18 |         .filter(|(_, c)| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u')\n   |                                                     \
    \           ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmpebk2fxio.rs:18:76\n   |\n18 |         .filter(|(_, c)| c == 'a'\
    \ || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n   |                     \
    \                                          "
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![];\n    word\n        .chars()\n        .enumerate()\n   \
    \     .filter(|&(_, c)| !c.is_vowel())\n        .enumerate()\n        .filter_map(|(_i,\
    \ c)| {\n            vowels.push(c.to_lowercase());\n            Some(true)\n\
    \        })\n        .collect();\n\n    vowels\n        .into_iter()\n       \
    \ .enumerate()\n        .filter(|(_i, vowel)| vowel.len() == word.len())\n   \
    \     .filter(|(_i, vowel)| vowel.len() >= word.len())\n        .find_map(|(_i,\
    \ vowel)| {\n            let mut index = vowel.rfind('a').unwrap_or(vowel.len());\n\
    \            if index == 0 {\n                return Some(vowel.to_lowercase());\n\
    \            }\n            if vowel.len() == index + 1 {\n                return\
    \ Some(vowel.to_lowercase());\n            }\n            Some(vowel[..index])\n\
    \        })\n        .unwrap()\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpy_4a9w7y.rs:20:30\n   |\n20 |         .filter(|&(_, c)|\
    \ !c.is_vowel())\n   |                              ^^^^^^^^ method not found\
    \ in `char`\n\nerror[E0599]: no method named `to_lowercase` found for tuple `(usize,\
    \ char)` in the current scope\n  --> /tmp/tmpy_4a9w7y.rs:23:27\n   |\n23 |   \
    \          vowels.push(c.to_lowercase());\n   |                           ^^^^^^^^^^^^\
    \ method not found in `(usize, char)`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels: Vec<&'static str> = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n \
    \   if word.starts_with(vowels.iter().cloned().collect::<Vec<_>>()) {\n      \
    \  return String::from(vowels.iter().cloned().collect::<Vec<_>>().last().unwrap());\n\
    \    }\n    if word.ends_with(vowels.iter().cloned().collect::<Vec<_>>()) {\n\
    \        return String::from(vowels.iter().cloned().collect::<Vec<_>>().last().unwrap());\n\
    \    }\n    if word.len() >= 2 && word.ends_with(vowels.iter().cloned().collect::<Vec<_>>())\
    \ {\n        let mut last: Vec<&'static str> = vec![];\n        for (vowel, idx)\
    \ in vowels.iter().cloned().rev().enumerate()\n        {\n            let idx2\
    \ = idx % word.len();\n            if idx == word.len() - 1 {\n              \
    \  last = vec![vowel];\n                break;\n            }\n            if\
    \ idx2 == word.len() - 1 {\n                break;\n            }\n          \
    \  if word.starts_with(vowels.iter().cloned().collect::<Vec<_>>()) {\n       \
    \         last = vec![vowel];\n                break;\n            }\n       \
    \     if idx2 >= 2 && idx2 <= word.len() - 2 && word.ends_with(vowels.iter().cloned().collect::<Vec<_>>())\
    \ {\n                last = vec![vowel];\n                break;\n           \
    \ }\n            if idx2 >= 3 && idx2 <= word.len() - 2 && word.ends_with(vowels.iter().cloned().collect::<Vec<_>>())\
    \ {\n                last = vec![vowel];\n                break;\n           \
    \ }\n        }\n        if last.is_empty() {\n            return String::from(\"\
    \");\n        }\n        return String::from(last.iter().cloned().collect::<Vec<_>>().last().unwrap());\n\
    \    }\n    if word.len() >= 2 && word.starts_with(vowels.iter().cloned().collect::<Vec<_>>())\
    \ {\n        let mut last: Vec<&'static str> = vec![];\n        for (vowel, idx)\
    \ in vowels.iter().cloned().rev().enumerate()\n        {\n            let idx2\
    \ = idx % word.len();\n            if idx == word.len() - 1 {\n              \
    \  last = vec![vowel];\n                break;\n            }\n            if\
    \ idx2 == word.len() - 1 {\n                break;\n            }\n          \
    \  if word.ends_with(vowels.iter().cloned().collect::<Vec<_>>()) {\n         \
    \       last = vec![vowel];\n                break;\n            }\n         \
    \   if idx2 >= 2 && idx2 <= word.len() - \n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp4_59qz5j.rs:87:3\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n53 |     if word.len()\
    \ >= 2 && word.starts_with(vowels.iter().cloned().collect::<Vec<_>>()) {\n   |\
    \                                                                            \
    \            - unclosed delimiter\n...\n56 |         {\n   |         - this delimiter\
    \ might not be properly closed...\n...\n70 | }\n   | - ...as it matches this but\
    \ it has different indentation\n...\n87 | }\n   |   ^\n\nerror: expected expression,\
    \ found `}`\n  --> /tmp/tmp4_59qz5j.rs:70:1\n   |\n70 | }\n   | ^ expected expression\n\
    \nerror[E0277]: expected a `FnMut<(char,)>` closure, found `Vec<&str>`\n    -->\
    \ /tmp/tmp4_59qz5j.rs:17:25\n     |\n17   |     if word.starts_with(vowels.iter().cloned().collect::<Vec<_>>())\
    \ {\n     |             ----------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected an `FnMut<(char,)>` closure, found `Vec<&str>`\n     |            \
    \ |\n     |             required by a bound introduced by this call\n     |\n\
    \     = help: the trait `FnMut<(char,)>` is not implemented for `Vec<&str>`\n\
    \     = help: the following other types implement trait `Pattern<'a>`:\n     \
    \          &'b String\n               &'b [char; N]\n               &'b [char]\n\
    \               &'b str\n               &'c &'b str\n               [char; N]\n\
    \               char\n               pattern::MultiCharEqPattern<C>\n     = note:\
    \ required because of the requirements on the impl of `Pattern<'_>` for `Vec<&str>`\n\
    note: required by a bound in `core::str::<impl str>::starts_with`\n\nerror[E0277]:\
    \ the trait bound `String: From<&&str>` is not satisfied\n  --> /tmp/tmp4_59qz5j.rs:18:16\n\
    \   |\n18 |         return String::from(vowels.iter().cloned().collect::<Vec<_>>().last().unwrap());\n\
    \   |                ^^^^^^^^^^^^ the trait `From<&&str>` is not implemented for\
    \ `String`\n   |\n   = help: the following other types implement trait `From<T>`:\n\
    \             <String as From<&String>>\n            "
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut index = 0;\n    let mut vowels = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G',\
    \ 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W',\
    \ 'X', 'Y', 'Z'];\n    for i in word.chars() {\n        let char = i.to_string();\n\
    \        if char.contains(&vowels[(index + 1) % vowels.len()]) {\n           \
    \ return i.to_string();\n        }\n        index += 1;\n    }\n    \"\".to_string()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmp30q_py0v.rs:20:26\n\
    \     |\n20   |         if char.contains(&vowels[(index + 1) % vowels.len()])\
    \ {\n     |                 -------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ an `Fn<(char,)>` closure, found `char`\n     |                 |\n     |   \
    \              required by a bound introduced by this call\n     |\n     = help:\
    \ the trait `Fn<(char,)>` is not implemented for `char`\n     = note: required\
    \ because of the requirements on the impl of `FnOnce<(char,)>` for `&char`\n \
    \    = note: required because of the requirements on the impl of `Pattern<'_>`\
    \ for `&char`\nnote: required by a bound in `core::str::<impl str>::contains`\n\
    help: consider dereferencing here\n     |\n20   |         if char.contains(*&vowels[(index\
    \ + 1) % vowels.len()]) {\n     |                          +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    //\
    \ Your code here\n    let mut vowels = vec![];\n    let mut word = word.to_string();\n\
    \    loop {\n        if word.len() <= 1 { break; }\n        vowels.push(word.chars().filter(|&c|\
    \ c.is_vowel()).nth(1).unwrap());\n        word = &word[1..];\n    }\n    word.chars().filter(|&c|\
    \ c.is_vowel()).nth(1).unwrap()\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpi6ftu1u3.rs:21:48\n   |\n21 |         vowels.push(word.chars().filter(|&c|\
    \ c.is_vowel()).nth(1).unwrap());\n   |                                      \
    \          ^^^^^^^^ method not found in `char`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpi6ftu1u3.rs:22:16\n   |\n18 |     let mut word = word.to_string();\n\
    \   |                    ---------------- expected due to this value\n...\n22\
    \ |         word = &word[1..];\n   |                ^^^^^^^^^^ expected struct\
    \ `String`, found `&str`\n   |\nhelp: try using a conversion method\n   |\n22\
    \ |         word = (&word[1..]).to_string();\n   |                +          +++++++++++++\n\
    \nerror[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpi6ftu1u3.rs:24:32\n   |\n24 |     word.chars().filter(|&c|\
    \ c.is_vowel()).nth(1).unwrap()\n   |                                ^^^^^^^^\
    \ method not found in `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpi6ftu1u3.rs:24:5\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |             \
    \                          ------ expected `String` because of return type\n...\n\
    24 |     word.chars().filter(|&c| c.is_vowel()).nth(1).unwrap()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |     |\n   |     expected\
    \ struct `String`, found `char`\n\nerror: aborting due to 4 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut len = word.len();\n    let mut ans = String::new();\n    if len == 0 {\n\
    \        return ans;\n    }\n    let mut first_index = len - 1;\n    let mut last_index\
    \ = len - 1;\n    let mut index = len - 1;\n    let mut first = word[0];\n   \
    \ let mut last = word[0];\n    let mut last2 = word[0];\n    let mut last3 = word[0];\n\
    \    let mut last4 = word[0];\n    let mut last5 = word[0];\n    let mut last6\
    \ = word[0];\n    let mut last7 = word[0];\n    let mut last8 = word[0];\n   \
    \ let mut last9 = word[0];\n    let mut last10 = word[0];\n    let mut last11\
    \ = word[0];\n    let mut last12 = word[0];\n    let mut last13 = word[0];\n \
    \   let mut last14 = word[0];\n    let mut last15 = word[0];\n    let mut last16\
    \ = word[0];\n    let mut last17 = word[0];\n    let mut last18 = word[0];\n \
    \   let mut last19 = word[0];\n    let mut last20 = word[0];\n    let mut last21\
    \ = word[0];\n    let mut last22 = word[0];\n    let mut last23 = word[0];\n \
    \   let mut last24 = word[0];\n    let mut last25 = word[0];\n    let mut last26\
    \ = word[0];\n    let mut last27 = word[0];\n    let mut last28 = word[0];\n \
    \   let mut last29 = word[0];\n    let mut last30 = word[0];\n    let mut last31\
    \ = word[0];\n    let mut last32 = word[0];\n    let mut last33 = word[0];\n \
    \   let mut last34 = word[0];\n    let mut last35 = word[0];\n    let mut last36\
    \ = word[0];\n    let mut last37 = word[0];\n    let mut last38 = word[0];\n \
    \   let mut last39 = word[0];\n    let mut last40 = word[0];\n    let mut last41\
    \ = word[0];\n    let mut last42 = word[0];\n    let mut last43 = word[0];\n \
    \   let mut last44 = word[0];\n    let mut last45 = word[0];\n    let mut last46\
    \ = word[0];\n    let mut last47 = word[0];\n    let mut last48 = word[0];\n \
    \   let mut last49 = word[0];\n    let mut last50 = word[0];\n    let mut last51\
    \ = word[0];\n    let mut last52 = word\n}\n\nfn main() {\n    let candidate =\
    \ get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp0j8rlra4.rs:76:26\n   |\n\
    76 |     let mut last52 = word\n   |                          ^ help: add `;`\
    \ here\n77 | }\n   | - unexpected token\n\nerror[E0277]: the type `String` cannot\
    \ be indexed by `{integer}`\n  --> /tmp/tmp0j8rlra4.rs:24:21\n   |\n24 |     let\
    \ mut first = word[0];\n   |                     ^^^^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmp0j8rlra4.rs:25:20\n   |\n25 |     let mut last = word[0];\n   |\
    \                    ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n\
    \   = help: the trait `Index<{integer}>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmp0j8rlra4.rs:26:21\n   |\n26 |     let mut last2 = word[0];\n  \
    \ |                     ^^^^^^^ `String` cannot be indexed by `{integer}`\n  \
    \ |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusi"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n\n    word.chars().enumerate().filter(|&(_,\
    \ c)|\n        if c.to_ascii_lowercase() == 'a' || c.to_ascii_lowercase() == 'e'\
    \ || c.to_ascii_lowercase() == 'i' || c.to_ascii_lowercase() == 'o' || c.to_ascii_lowercase()\
    \ == 'u'\n        {\n            vowels.push(c.to_ascii_lowercase());\n      \
    \      false\n        }\n        true\n    ).collect::<Vec<(usize, String)>>();\n\
    \n    vowels.sort_by(|a, b| b.cmp(&a));\n\n    vowels.reverse();\n\n    vowels.last_or_default().unwrap()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `)`, `,`, `.`, `?`, `else`, or an operator, found\
    \ keyword `true`\n  --> /tmp/tmp4bzqsvkx.rs:24:9\n   |\n23 |         }\n   | \
    \         -\n   |          |\n   |          expected one of `)`, `,`, `.`, `?`,\
    \ `else`, or an operator\n   |          help: missing `,`\n24 |         true\n\
    \   |         ^^^^ unexpected token\n\nerror[E0282]: type annotations needed for\
    \ `&(_, _)`\n  --> /tmp/tmp4bzqsvkx.rs:18:38\n   |\n18 |     word.chars().enumerate().filter(|&(_,\
    \ c)|\n   |                                      ^^^^^^^ consider giving this\
    \ closure parameter the explicit type `&(_, _)`, with the type parameters specified\n\
    \   |\n   = note: type must be known at this point\n\nerror[E0061]: this function\
    \ takes 1 argument but 2 arguments were supplied\n   --> /tmp/tmp4bzqsvkx.rs:18:30\n\
    \    |\n18  |       word.chars().enumerate().filter(|&(_, c)|\n    |  ______________________________^^^^^^_-\n\
    \    | |                              |\n    | |                             \
    \ expected 1 argument\n19  | |         if c.to_ascii_lowercase() == 'a' || c.to_ascii_lowercase()\
    \ == 'e' || c.to_ascii_lowercase() == 'i' || c.to_ascii_lowercase() == '...\n\
    20  | |         {\n21  | |             vowels.push(c.to_ascii_lowercase());\n\
    22  | |             false\n23  | |         }\n    | |_________-\n24  |       \
    \    true\n    |           ---- supplied 2 arguments\n    |\nnote: associated\
    \ function defined here\n\nerror[E0277]: a value of type `Vec<(usize, String)>`\
    \ cannot be built from an iterator over elements of type `(usize, char)`\n   \
    \ --> /tmp/tmp4bzqsvkx.rs:25:7\n     |\n25   |     ).collect::<Vec<(usize, String)>>();\n\
    \     |       ^^^^^^^ value of type `Vec<(usize, String)>` cannot be built from\
    \ `std::iter::Iterator<Item=(usize, char)>`\n     |\n     = help: the trait `FromIterator<(usize,\
    \ char)>` is not implemented for `Vec<(usize, String)>`\n     = help: the trait\
    \ `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound in\
    \ `collect`\n\nerror[E0599]: no method named `last_or_default` found for struct\
    \ `Vec<&str>` in the current scope\n  --> /tmp/tmp4bzqsvkx.r"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    \n\
    \    // Your code here\n\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfqpqdtro.rs:15:39\n   |\n\
    15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowel = String::new();\n\n    for c in word.chars() {\n        match c {\n\
    \            'a'..='z' => vowel.push('z'),\n            'A'..='Z' => vowel.push('Z'),\n\
    \            _ => vowel.push(c),\n        }\n    }\n\n    let mut right_consonant\
    \ = 0;\n    vowel.chars().for_each(|c| {\n        if *c >= 'a' && *c <= 'z' {\n\
    \            right_consonant += 1;\n        } else if *c >= 'A' && *c <= 'Z' {\n\
    \            right_consonant += 2;\n        }\n    });\n\n    match right_consonant\
    \ {\n        0 => String::from(\"\"),\n        1 => String::from(\"\"),\n    \
    \    _ => vowel.chars().nth(right_consonant).unwrap().to_string(),\n    }\n}\n\
    \nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmptqfo7eed.rs:28:12\n\
    \   |\n28 |         if *c >= 'a' && *c <= 'z' {\n   |            ^^\n\nerror[E0614]:\
    \ type `char` cannot be dereferenced\n  --> /tmp/tmptqfo7eed.rs:28:25\n   |\n\
    28 |         if *c >= 'a' && *c <= 'z' {\n   |                         ^^\n\n\
    error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmptqfo7eed.rs:30:19\n\
    \   |\n30 |         } else if *c >= 'A' && *c <= 'Z' {\n   |                 \
    \  ^^\n\nerror[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmptqfo7eed.rs:30:32\n\
    \   |\n30 |         } else if *c >= 'A' && *c <= 'Z' {\n   |                 \
    \               ^^\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_idx\
    \ = word.len();\n    let mut letter = word[vowels_idx - 1];\n    while vowels_idx\
    \ > 0 {\n        letter = word.chars().nth(vowels_idx).unwrap();\n        if letter.to_lowercase().as_str()\
    \ in vowels {\n            vowels_idx -= 1;\n        } else {\n            break;\n\
    \        }\n    }\n    if vowels_idx < word.len() {\n        return String::from(\"\
    \");\n    }\n    letter = word.chars().nth(vowels_idx).unwrap();\n    if letter.to_lowercase().as_str()\
    \ != \"a\" && letter.to_lowercase().as_str() != \"e\" && letter.to_lowercase().as_str()\
    \ != \"i\" && letter.to_lowercase().as_str() != \"o\" && letter.to_lowercase().as_str()\
    \ != \"u\"{\n        return String::from(\"\");\n    }\n    String::from(vowels[vowels_idx\
    \ - 1].to_string())\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found keyword `in`\n  --> /tmp/tmpbgcx0s__.rs:21:43\n\
    \   |\n21 |         if letter.to_lowercase().as_str() in vowels {\n   |      \
    \   --                                ^^ expected `{`\n   |         |\n   |  \
    \       this `if` expression has a condition, but no block\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `usize`\n  --> /tmp/tmpbgcx0s__.rs:18:22\n\
    \   |\n18 |     let mut letter = word[vowels_idx - 1];\n   |                 \
    \     ^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `as_str` found for struct `ToLowercase`\
    \ in the current scope\n  --> /tmp/tmpbgcx0s__.rs:31:30\n   |\n31 |     if letter.to_lowercase().as_str()\
    \ != \"a\" && letter.to_lowercase().as_str() != \"e\" && letter.to_lowercase().as_str()\
    \ != \"i\" && letter.to_...\n   |                              ^^^^^^ method not\
    \ found in `ToLowercase`\n\nerror[E0599]: no method named `as_str` found for struct\
    \ `ToLowercase` in the current scope\n  --> /tmp/tmpbgcx0s__.rs:31:71\n   |\n\
    31 |     if letter.to_lowercase().as_str() != \"a\" && letter.to_lowercase().as_str()\
    \ != \"e\" && letter.to_lowercase().as_str() != \"i\" && letter.to_...\n   | \
    \                                                                      ^^^^^^\
    \ method not found in `ToLowercase`\n\nerror[E0599]: no method named `as_str`\
    \ found for struct `ToLowercase` in the current scope\n  --> /tmp/tmpbgcx0s__.rs:31:112\n\
    \   |\n31 | ...case().as_str() != \"e\" && letter.to_lowercase().as_str() != \"\
    i\" && letter.to_lowercase().as_str() != \"o\" && letter.to_lowercase().as_str(...\n\
    \   |                                  "
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    //\
    \ Your code here\n    let vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n\
    \    let mut word_idx = 0;\n    let mut closest_idx = -1;\n    let mut last_idx\
    \ = 0;\n    let mut first_idx = 0;\n    \n    let mut min_idx = std::cmp::max(1,\
    \ word.len());\n    \n    while word_idx < word.len() {\n        if word[word_idx].is_uppercase()\
    \ {\n            closest_idx = 1;\n            last_idx = word.len() - 1;\n  \
    \          first_idx = 0;\n            break;\n        }\n        if word[word_idx].is_lowercase()\
    \ {\n            closest_idx = 1;\n            last_idx = word.len() - 1;\n  \
    \          first_idx = 1;\n            break;\n        }\n        if let Some(idx)\
    \ = vowels.iter().position(|&v| v == word[word_idx]) { \n            if idx >\
    \ closest_idx {\n                closest_idx = idx;\n                first_idx\
    \ = word_idx;\n                last_idx = word_idx;\n            }\n        }\n\
    \        if word[word_idx].is_lowercase() {\n            closest_idx = 1;\n  \
    \          last_idx = word.len() - 1;\n            first_idx = 1;\n          \
    \  break;\n        }\n        if let Some(idx) = vowels.iter().position(|&v| v\
    \ == word[word_idx]) { \n            if idx > closest_idx {\n                closest_idx\
    \ = idx;\n                first_idx = word_idx;\n                last_idx = word_idx;\n\
    \            }\n        }\n        if let Some(idx) = vowels.iter().position(|&v|\
    \ v == word[word_idx]) { \n            if idx > closest_idx {\n              \
    \  closest_idx = idx;\n                first_idx = word_idx;\n               \
    \ last_idx = word_idx;\n            }\n        }\n        if let Some(idx) = vowels.iter().position(|&v|\
    \ v == word[word_idx]) { \n            if idx > closest_idx {\n              \
    \  closest_idx = idx;\n                first_idx = word_idx;\n               \
    \ last_idx = word_idx;\n            }\n        }\n        word_idx += 1;\n   \
    \ }\n    \n    if closest_idx < 1 {\n        return String::from(\"\");\n    }\n\
    \    \n    let mut min_idx = std::cmp::max(1, closest_idx);\n    let mut word_idx\
    \ = first_idx;\n    let mut closest_idx = closest_idx;\n    \n    while word_idx\
    \ < last_idx {\n        if word[word_idx].is_uppercase() {\n            closest_idx\
    \ = closest_idx;\n        } else if word[word_idx].is_lowercase() {\n        \
    \    closest_idx = closest_idx;\n        }\n        if closest_idx > min_idx {\n\
    \            break;\n        }\n        word_idx += 1;\n    }\n    \n\n}\n\nfn\
    \ main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpxyr_h4k3.rs:26:12\n\
    \   |\n26 |         if word[word_idx].is_uppercase() {\n   |            ^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpxyr_h4k3.rs:32:12\n   |\n32 |         if word[word_idx].is_lowercase()\
    \ {\n   |            ^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n  \
    \ |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpxyr_h4k3.rs:38:61\n   |\n38 |         if let Some(idx) = vowels.iter().position(|&v|\
    \ v == word[word_idx]) { \n   |                                              \
    \               ^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeT"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut idx = 0;\n    let mut idx2 = 0;\n    let mut vowels = vec![\"a\", \"e\"\
    , \"i\", \"o\", \"u\", \"y\", \"\xE4\", \"\xE5\"];\n    let mut consonants = vec![\"\
    b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"\
    p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"z\"];\n    loop {\n  \
    \      if idx2 == word.len() {\n            return String::from(vowels[idx]);\n\
    \        }\n        if word[idx2] == vowels[idx] {\n            idx2++;\n    \
    \        if idx2 == word.len() {\n                return String::from(vowels[idx]);\n\
    \            }\n        }\n        if word[idx2] == consonants[idx] {\n      \
    \      idx2++;\n            if idx2 == word.len() {\n                return String::from(vowels[idx]);\n\
    \            }\n        }\n        idx += 1;\n        idx2 += 1;\n    }\n}\n\n\
    fn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp02sos4ll.rs:25:17\n\
    \   |\n25 |             idx2++;\n   |                 ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n25 |             { let tmp = idx2; idx2\
    \ += 1; tmp };\n   |             +++++++++++     ~~~~~~~~~~~~~~~~~~\n25 -    \
    \         idx2++;\n25 +             idx2 += 1;\n   | \n\nerror: Rust has no postfix\
    \ increment operator\n  --> /tmp/tmp02sos4ll.rs:31:17\n   |\n31 |            \
    \ idx2++;\n   |                 ^^ not a valid postfix operator\n   |\nhelp: use\
    \ `+= 1` instead\n   |\n31 |             { let tmp = idx2; idx2 += 1; tmp };\n\
    \   |             +++++++++++     ~~~~~~~~~~~~~~~~~~\n31 -             idx2++;\n\
    31 +             idx2 += 1;\n   | \n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n  --> /tmp/tmp02sos4ll.rs:24:12\n   |\n24 |         if word[idx2]\
    \ == vowels[idx] {\n   |            ^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp02sos4ll.rs:30:12\n   |\n30 |         if word[idx2] == consonants[idx]\
    \ {\n   |            ^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    word.chars()\n\
    \        .chain(word.chars().skip_while(|c| c.is_uppercase()))\n        .chain(word.chars().skip_while(|c|\
    \ c.is_lowercase()))\n        .filter(|c| c != 'a' && c != 'e' && c != 'i' &&\
    \ c != 'o' && c != 'u')\n        .map(|c| if c.is_uppercase() { \"A\".to_string()\
    \ } else if c.is_lowercase() { \"a\".to_string() } else { \"a\".to_string() })\n\
    \        .map(|c| if c.is_uppercase() { \"u\".to_string() } else if c.is_lowercase()\
    \ { \"u\".to_string() } else { \"u\".to_string() })\n        .min(|a,b| a.len()\
    \ < b.len())\n        .unwrap_or(\"\")\n}\n\nfn main() {\n    let candidate =\
    \ get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpxxoxfpz7.rs:19:23\n\
    \   |\n19 |         .filter(|c| c != 'a' && c != 'e' && c != 'i' && c != 'o' &&\
    \ c != 'u')\n   |                       ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpxxoxfpz7.rs:19:35\n   |\n19 |   \
    \      .filter(|c| c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u')\n\
    \   |                                   ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpxxoxfpz7.rs:19:47\n   |\n19 |   \
    \      .filter(|c| c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u')\n\
    \   |                                               ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmpxxoxfpz7.rs:19:59\n   |\n19\
    \ |         .filter(|c| c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u')\n\
    \   |                                                           ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpxxoxfpz7.rs:19:71\n\
    \   |\n19 |         .filter(|c| c != 'a' && c != 'e' && c != 'i' && c != 'o' &&\
    \ c != 'u')\n   |                                                            \
    \           ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0599]: no method named `is_uppercase` found\
    \ for struct `String` in"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowel = String::new();\n\n    let word_without_vowels = word.to_lowercase();\n\
    \    let mut consonants = String::new();\n\n    for c in word_without_vowels.chars().skip_while(|c|\
    \ c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u') {\n        consonants.push_str(c.to_string());\n\
    \    }\n\n    if consonants.chars().any(|c| c == c[0]) {\n        for c in word_without_vowels.chars().skip_while(|c|\
    \ c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u') {\n            if\
    \ !consonants.contains(&c[0]) {\n                vowel.push_str(c.to_string());\n\
    \                break;\n            }\n        }\n    } else {\n        vowel.push_str(\"\
    \");\n    }\n    vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp7xmmcdlr.rs:21:59\n\
    \   |\n21 |     for c in word_without_vowels.chars().skip_while(|c| c != 'a' &&\
    \ c != 'e' && c != 'i' && c != 'o' && c != 'u') {\n   |                      \
    \                                     ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp7xmmcdlr.rs:21:71\n   |\n21 |   \
    \  for c in word_without_vowels.chars().skip_while(|c| c != 'a' && c != 'e' &&\
    \ c != 'i' && c != 'o' && c != 'u') {\n   |                                  \
    \                                     ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp7xmmcdlr.rs:21:83\n   |\n21 |   \
    \  for c in word_without_vowels.chars().skip_while(|c| c != 'a' && c != 'e' &&\
    \ c != 'i' && c != 'o' && c != 'u') {\n   |                                  \
    \                                                 ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmp7xmmcdlr.rs:21:95\n   |\n21\
    \ |     for c in word_without_vowels.chars().skip_while(|c| c != 'a' && c != 'e'\
    \ && c != 'i' && c != 'o' && c != 'u') {\n   |                               \
    \                                                                ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp7xmmcdlr.rs:21:107\n\
    \   |\n21 |     for c in word_without_vowels.chars().skip_while(|c| c != 'a' &&\
    \ c != 'e' && c != 'i' && c != 'o' && c"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    match\
    \ word.chars() {\n        \n        // if the given word is empty, return empty\
    \ string\n        None => String::from(\"\"),\n        \n        // if the given\
    \ word consists of one consonant, return empty string\n        Some(first) =>\
    \ get_closest_vowel(String::from(first)),\n        \n        // if there are two\
    \ consonants, find the first vowel and the first consonant \n        // from the\
    \ right side of the word and use them as boundaries\n        Some(first) => match\
    \ first.chars() {\n            \n            // if there are one or two consonants,\
    \ return empty string\n            None => String::from(\"\"),\n            \n\
    \            // if there are two consonants, find the first vowel and the first\
    \ consonant \n            // from the right side of the word and use them as boundaries\n\
    \            Some(first) => match first.chars() {\n                \n        \
    \        // if there are two consonants, return empty string\n               \
    \ None => String::from(\"\"),\n                \n                // if there are\
    \ two consonants, find the first vowel and the first consonant \n            \
    \    // from the right side of the word and use them as boundaries\n         \
    \       Some(first) => get_vowel(String::from(first), String::from(first)),\n\
    \            },\n        },\n    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `get_vowel` in this scope\n  --> /tmp/tmpn3jwmrj0.rs:40:32\n\
    \   |\n40 |                 Some(first) => get_vowel(String::from(first), String::from(first)),\n\
    \   |                                ^^^^^^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpn3jwmrj0.rs:19:9\n   |\n16 |     match word.chars()\
    \ {\n   |           ------------ this expression has type `Chars<'_>`\n...\n19\
    \ |         None => String::from(\"\"),\n   |         ^^^^ expected struct `Chars`,\
    \ found enum `Option`\n   |\n   = note: expected struct `Chars<'_>`\n        \
    \        found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn3jwmrj0.rs:22:9\n\
    \   |\n16 |     match word.chars() {\n   |           ------------ this expression\
    \ has type `Chars<'_>`\n...\n22 |         Some(first) => get_closest_vowel(String::from(first)),\n\
    \   |         ^^^^^^^^^^^ expected struct `Chars`, found enum `Option`\n   |\n\
    \   = note: expected struct `Chars<'_>`\n                found enum `Option<_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpn3jwmrj0.rs:26:9\n   |\n16 | \
    \    match word.chars() {\n   |           ------------ this expression has type\
    \ `Chars<'_>`\n...\n26 |         Some(first) => match first.chars() {\n   |  \
    \       ^^^^^^^^^^^ expected struct `Chars`, found enum `Option`\n   |\n   = note:\
    \ expected struct `Chars<'_>`\n                found enum `Option<_>`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowel = String::new();\n    let mut vowel_flag = false;\n    let mut current_letter\
    \ = word.len() - 1;\n\n    if current_letter < word.len() / 2 {\n        vowel\
    \ = String::new();\n        vowel_flag = false;\n        current_letter = word.len()\
    \ - 1;\n    }\n    while current_letter >= 0 && current_letter < word.len() {\n\
    \        if word[current_letter].is_lowercase() {\n            if vowel_flag.is_none()\
    \ {\n                vowel = String::from(word[current_letter]);\n           \
    \     vowel_flag = true;\n                continue;\n            }\n        }\n\
    \        if word[current_letter].is_uppercase() {\n            if vowel_flag.is_none()\
    \ {\n                vowel = String::from(word[current_letter]);\n           \
    \     vowel_flag = true;\n                continue;\n            }\n        }\n\
    \        if word[current_letter].is_ascii_uppercase() {\n            if vowel_flag.is_none()\
    \ {\n                vowel = String::from(word[current_letter]);\n           \
    \     vowel_flag = true;\n                continue;\n            }\n        }\n\
    \        if word[current_letter].is_ascii_lowercase() {\n            if vowel_flag.is_none()\
    \ {\n                vowel = String::from(word[current_letter]);\n           \
    \     vowel_flag = true;\n                continue;\n            }\n        }\n\
    \        if word[current_letter].is_ascii_alphanumeric() {\n            if vowel_flag.is_none()\
    \ {\n                vowel = String::from(word[current_letter]);\n           \
    \     vowel_flag = true;\n                continue;\n            }\n        }\n\
    \        if word[current_letter].is_digit() {\n            if vowel_flag.is_none()\
    \ {\n                vowel = String::from(word[current_letter]);\n           \
    \     vowel_flag = true;\n                continue;\n            }\n        }\n\
    \        current_letter -= 1;\n    }\n    vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp_sf5co0k.rs:26:12\n\
    \   |\n26 |         if word[current_letter].is_lowercase() {\n   |           \
    \ ^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `is_none` found for type `bool` in\
    \ the current scope\n  --> /tmp/tmp_sf5co0k.rs:27:27\n   |\n27 |             if\
    \ vowel_flag.is_none() {\n   |                           ^^^^^^^ method not found\
    \ in `bool`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp_sf5co0k.rs:28:38\n   |\n28 |                 vowel = String::from(word[current_letter]);\n\
    \   |                                      ^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp_sf5co0k.rs:33:12\n   |\n33 |         if word[current_letter].is_uppercase()\
    \ {\n   |            ^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n          "
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    \n\
    \    let vowels: Vec<&'static str> = vec![\n        \"a\", \"e\", \"i\", \"o\"\
    , \"u\"\n    ];\n\n    let mut cur_vowel: Option<&'static str> = None;\n    let\
    \ mut next_vowel: Option<&'static str> = None;\n\n    let mut cur_index = 0;\n\
    \    let mut next_index = 0;\n    \n    while cur_index < word.len() {\n     \
    \   if cur_vowel.is_none() {\n            if next_index == word.len() {\n    \
    \            // we have reach the end of this word so return \"\"\n          \
    \      println!(\"{} is at the end of the word\", word);\n                return\
    \ String::from(\"\");\n            }\n            next_vowel = &vowels[next_index\
    \ as usize];\n        }\n        \n        if next_index == word.len() {\n   \
    \         // we have reached the end of the word so break the loop\n         \
    \   break;\n        }\n        \n        if word[cur_index] == next_vowel {\n\
    \            // we have found a vowel met the conditions\n            cur_vowel\
    \ = Some(&vowels[cur_index as usize]);\n            next_vowel = Some(&vowels[next_index\
    \ as usize]);\n            \n            if cur_index + 1 == word.len() {\n  \
    \              // we have reached the end of the word so break the loop\n    \
    \            break;\n            }\n        }\n        \n        cur_index +=\
    \ 1;\n        next_index += 1;\n    }\n    \n    cur_vowel.ok_or_else(|| format!(\"\
    could not find any vowel for the word {}\", word))?\n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugi0zqo6.rs:34:26\n   |\n\
    22 |     let mut next_vowel: Option<&'static str> = None;\n   |              \
    \           -------------------- expected due to this type\n...\n34 |        \
    \     next_vowel = &vowels[next_index as usize];\n   |                       \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected enum `Option`, found `&&'static str`\n\
    \   |\n   = note:   expected enum `Option<&'static str>`\n           found reference\
    \ `&&'static str`\nhelp: try wrapping the expression in `Some`\n   |\n34 |   \
    \          next_vowel = Some(&vowels[next_index as usize]);\n   |            \
    \              +++++                            +\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmpugi0zqo6.rs:42:12\n   |\n42 |  \
    \       if word[cur_index] == next_vowel {\n   |            ^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: `?` operator has incompatible types\n  --> /tmp/tmpugi0zqo6.rs:57:5\n\
    \   |\n57 |     cur_vowel.ok_or_else(|| format!(\"could not find any vowel for\
    \ the word {}\", word))?\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |     |\n   |     expected\
    \ struct `String`, found `&str`\n   |\n   = note: `?` operator cannot convert\
    \ from `&str` to `String`\n\nerror[E0277]: the `?` operator can only be used in\
    \ a function that returns `Result` or `Option` (or another type that implements\
    \ `FromResidual`)\n  --> /tmp/tmpugi0zqo6.rs:57:87\n   |\n15 | / fn get_closest_vowel(word:\
    \ String) -> String {\n16 | |     \n17 | |"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\", \"y\", \"e\", \"i\", \"o\"\
    , \"u\"];\n    let mut word = word.to_lowercase();\n    let mut vowel = String::new();\n\
    \    let mut vowel_start_index = String::new();\n    let mut vowel_end_index =\
    \ String::new();\n\n    if word.len() > 1 && vowels.contains(&word[1]) {\n   \
    \     vowel_start_index = &word[..word.len() - 1];\n        vowel = &vowels[1..word.len()\
    \ - 1];\n        vowel_end_index = &word[word.len() - 1..];\n    }\n    else {\n\
    \        vowel = &vowels[1..];\n        vowel_start_index = &word[..];\n     \
    \   vowel_end_index = &word[..];\n    }\n\n    let mut left_consonant_index =\
    \ String::new();\n    let mut right_consonant_index = String::new();\n    left_consonant_index\
    \ = vowel.rfind(|x| x == &\"a\"..&\"z\");\n    right_consonant_index = vowel.rfind(|x|\
    \ x == &\"A\"..&\"Z\");\n    if left_consonant_index.is_some() && right_consonant_index.is_some()\
    \ {\n        if left_consonant_index < right_consonant_index {\n            vowel\
    \ = &vowel[left_consonant_index..right_consonant_index];\n        }\n        else\
    \ {\n            vowel = &vowel[left_consonant_index..];\n        }\n    }\n \
    \   else {\n        if left_consonant_index.is_some() {\n            vowel = &vowel[left_consonant_index..];\n\
    \        }\n        if right_consonant_index.is_some() {\n            vowel =\
    \ &vowel[..right_consonant_index];\n        }\n    }\n    vowel\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmp2bh8xb_p.rs:22:43\n   |\n22 |     if word.len() > 1 && vowels.contains(&word[1])\
    \ {\n   |                                           ^^^^^^^ `String` cannot be\
    \ indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2bh8xb_p.rs:23:29\n\
    \   |\n19 |     let mut vowel_start_index = String::new();\n   |             \
    \                    ------------- expected due to this value\n...\n23 |     \
    \    vowel_start_index = &word[..word.len() - 1];\n   |                      \
    \       ^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found `&str`\n   |\n\
    help: try using a conversion method\n   |\n23 |         vowel_start_index = (&word[..word.len()\
    \ - 1]).to_string();\n   |                             +                     \
    \  +++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2bh8xb_p.rs:24:17\n\
    \   |\n18 |     let mut vowel = String::new();\n   |                     -------------\
    \ expected due to this value\n...\n24 |         vowel = &vowels[1..word.len()\
    \ - 1];\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found `&[&str]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2bh8xb_p.rs:25:27\n\
    \   |\n20 |     let mut vowel_end_index = String::new();\n   |               \
    \                ------------- expected due to this value\n...\n25 |         vowel_end_index\
    \ = &word[word.len() - 1..];\n   |                           ^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n\
    \   |\n25 |         vowel_end_index = (&word[word.len() - 1.."
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = String::new();\n    for letter in word.chars().rposition(|c| !is_vowel(c))\
    \ {\n        if vowels.len() > 0 {\n            break;\n        }\n        let\
    \ pos = letter - 2;\n        if pos < 0 || (pos + 1) > word.len() - 1 {\n    \
    \        return String::from(\"\");\n        }\n        let next = word[pos +\
    \ 1];\n        if !is_vowel(next) {\n            break;\n        }\n        vowels.push(next);\n\
    \    }\n    vowels\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp12yg_ooq.rs:17:47\n\
    \   |\n17 |     for letter in word.chars().rposition(|c| !is_vowel(c)) {\n   |\
    \                                               ^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp12yg_ooq.rs:26:13\n\
    \   |\n26 |         if !is_vowel(next) {\n   |             ^^^^^^^^ not found\
    \ in this scope\n\nerror[E0277]: the trait bound `Chars<'_>: ExactSizeIterator`\
    \ is not satisfied\n    --> /tmp/tmp12yg_ooq.rs:17:32\n     |\n17   |     for\
    \ letter in word.chars().rposition(|c| !is_vowel(c)) {\n     |               \
    \                 ^^^^^^^^^ the trait `ExactSizeIterator` is not implemented for\
    \ `Chars<'_>`\n     |\n     = help: the following other types implement trait\
    \ `ExactSizeIterator`:\n               &mut I\n               Args\n         \
    \      ArgsOs\n               ArrayChunks<'_, T, N>\n               ArrayChunksMut<'_,\
    \ T, N>\n               ArrayWindows<'_, T, N>\n               Box<I, A>\n   \
    \            Chunks<'_, T>\n             and 109 others\nnote: required by a bound\
    \ in `rposition`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp12yg_ooq.rs:25:20\n   |\n25 |         let next = word[pos + 1];\n\
    \   |                    ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    use\
    \ std::cmp::max;\n    use std::cmp::min;\n\n    let mut vowels = String::new();\n\
    \n    let mut last_consonant = word.len();\n    let mut last_vowel = min((word.len()\
    \ - 1), (word.len() - 2));\n    while last_vowel >= 0 {\n        vowels.push(word.chars().skip_while(|c|\
    \ !c.is_ascii_letter()).last().unwrap().to_string());\n        last_vowel--;\n\
    \    }\n\n    last_consonant -= 1;\n    while last_consonant >= 0 {\n        vowels.push(word.chars().skip_while(|c|\
    \ c.is_ascii_letter()).last().unwrap().to_string());\n        last_consonant--;\n\
    \    }\n\n    vowels\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpmzd6dgoo.rs:25:21\n\
    \   |\n25 |         last_vowel--;\n   |                     ^ expected expression\n\
    \nerror: expected expression, found `;`\n  --> /tmp/tmpmzd6dgoo.rs:31:25\n   |\n\
    31 |         last_consonant--;\n   |                         ^ expected expression\n\
    \nwarning: unused import: `std::cmp::max`\n  --> /tmp/tmpmzd6dgoo.rs:16:9\n  \
    \ |\n16 |     use std::cmp::max;\n   |         ^^^^^^^^^^^^^\n   |\n   = note:\
    \ `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary parentheses\
    \ around function argument\n  --> /tmp/tmpmzd6dgoo.rs:22:30\n   |\n22 |     let\
    \ mut last_vowel = min((word.len() - 1), (word.len() - 2));\n   |            \
    \                  ^              ^\n   |\n   = note: `#[warn(unused_parens)]`\
    \ on by default\nhelp: remove these parentheses\n   |\n22 -     let mut last_vowel\
    \ = min((word.len() - 1), (word.len() - 2));\n22 +     let mut last_vowel = min(word.len()\
    \ - 1, (word.len() - 2));\n   | \n\nwarning: unnecessary parentheses around function\
    \ argument\n  --> /tmp/tmpmzd6dgoo.rs:22:48\n   |\n22 |     let mut last_vowel\
    \ = min((word.len() - 1), (word.len() - 2));\n   |                           \
    \                     ^              ^\n   |\nhelp: remove these parentheses\n\
    \   |\n22 -     let mut last_vowel = min((word.len() - 1), (word.len() - 2));\n\
    22 +     let mut last_vowel = min((word.len() - 1), word.len() - 2);\n   | \n\n\
    error[E0599]: no method named `is_ascii_letter` found for reference `&char` in\
    \ the current scope\n  --> /tmp/tmpmzd6dgoo.rs:24:52\n   |\n24 |         vowels.push(word.chars().skip_while(|c|\
    \ !c.is_ascii_letter()).last().unwrap().to_string());\n   |                  \
    \                                  ^^^^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `is_ascii`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpmzd6dgoo.rs:24:21\n   |\n24 |         vowels.push(word.chars().skip_while(|c|\
    \ !c.is_ascii_letter()).last().unwrap().to_string());\n   |                  \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`,"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut result =\
    \ String::new();\n\n    word.chars().enumerate().for_each(|(i, c)| {\n       \
    \ if vowels.contains(c) {\n            if i == word.len() - 1 {\n            \
    \    result.push(c);\n            }\n        } else {\n            if i == 0 {\n\
    \                result.push(c);\n            }\n        }\n    })\n    \n   \
    \ result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `result`\n  --> /tmp/tmpn__boo8_.rs:29:7\n \
    \  |\n29 |     })\n   |       ^ help: add `;` here\n30 |     \n31 |     result\n\
    \   |     ------ unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn__boo8_.rs:20:28\n\
    \   |\n20 |         if vowels.contains(c) {\n   |                            ^\
    \ expected `&&str`, found `char`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowel_start_index = word.rfind(\"Vowel\").unwrap();\n    let mut vowel_end_index\
    \ = word.rfind(\"a\").unwrap();\n    let mut vowel_index = word[vowel_start_index..vowel_end_index].chars().filter(|&c|\
    \ c.is_uppercase()).map(|c| c.to_lowercase()).nth(1).unwrap();\n    if vowel_index\
    \ == Some(word.len() - 1) {\n        \"\".to_string()\n    } else {\n        let\
    \ mut new_vowel_index = vowel_index - 1;\n        let mut new_vowel_char = String::new();\n\
    \        while new_vowel_index > 0 {\n            new_vowel_char += word[vowel_end_index..new_vowel_index].chars().filter(|&c|\
    \ c.is_uppercase()).map(|c| c.to_lowercase()).nth(1).unwrap();\n            new_vowel_index\
    \ -= 1;\n        }\n        new_vowel_char\n    }\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: binary operation `==` cannot be applied to type `ToLowercase`\n\
    \  --> /tmp/tmpu93__g6c.rs:19:20\n   |\n19 |     if vowel_index == Some(word.len()\
    \ - 1) {\n   |        ----------- ^^ -------------------- Option<usize>\n   |\
    \        |\n   |        ToLowercase\n\nerror[E0369]: cannot subtract `{integer}`\
    \ from `ToLowercase`\n  --> /tmp/tmpu93__g6c.rs:22:47\n   |\n22 |         let\
    \ mut new_vowel_index = vowel_index - 1;\n   |                               \
    \    ----------- ^ - {integer}\n   |                                   |\n   |\
    \                                   ToLowercase\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpu93__g6c.rs:25:31\n   |\n25 | ...har += word[vowel_end_index..new_vowel_index].chars().filter(|&c|\
    \ c.is_uppercase()).map(|c| c.to_lowercase()).nth(1).unwrap();\n   |         \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&str`, found struct `ToLowercase`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    word.chars().enumerate().filter(|&(_,\
    \ &c)| c.to_lowercase() == c).filter(|&(_, _)| c == c).filter(|&(_, c2)| c2 ==\
    \ c).filter_map(|(_, &c)| c.to_lowercase()).collect::<Vec<_>>()\n        .iter()\n\
    \        .filter_map(|(&i, &c)| if c == 'u' || c == 'A' || c == 'E' || c == 'I'\
    \ || c == 'O' || c == 'U' || c == 'a' || c == 'e' || c == 'i' || c == 'o' || c\
    \ == 'u'\n                                || (c == 'A' || c == 'E' || c == 'I'\
    \ || c == 'O' || c == 'U') || (c == 'a' || c == 'e' || c == 'i' || c == 'o' ||\
    \ c == 'u') {\n            (i, c)\n        }).min_by_key(|&(i, _)| i)\n      \
    \  .map(|(_, c)| String::from(c)).collect::<String>()\n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `c` in this scope\n  --> /tmp/tmpfc__nn5i.rs:16:88\n\
    \   |\n16 |     word.chars().enumerate().filter(|&(_, &c)| c.to_lowercase() ==\
    \ c).filter(|&(_, _)| c == c).filter(|&(_, c2)| c2 == c).filter_map(|(_, &c...\n\
    \   |                                                                        \
    \                ^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `c` in this scope\n  --> /tmp/tmpfc__nn5i.rs:16:93\n   |\n16 |     word.chars().enumerate().filter(|&(_,\
    \ &c)| c.to_lowercase() == c).filter(|&(_, _)| c == c).filter(|&(_, c2)| c2 ==\
    \ c).filter_map(|(_, &c...\n   |                                             \
    \                                                ^ not found in this scope\n\n\
    error[E0425]: cannot find value `c` in this scope\n  --> /tmp/tmpfc__nn5i.rs:16:120\n\
    \   |\n16 | ...(_, _)| c == c).filter(|&(_, c2)| c2 == c).filter_map(|(_, &c)|\
    \ c.to_lowercase()).collect::<Vec<_>>()\n   |                                \
    \            ^ help: a local variable with a similar name exists: `c2`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpfc__nn5i.rs:16:43\n   |\n16 |     word.chars().enumerate().filter(|&(_,\
    \ &c)| c.to_lowercase() == c).filter(|&(_, _)| c == c).filter(|&(_, c2)| c2 ==\
    \ c).filter_map(|(_, &c...\n   |                                           ^^-\
    \ expected due to this\n   |                                           |\n   |\
    \                                           expected `char`, found reference\n\
    \   |                                           help: you can probably remove\
    \ the explicit borrow: `c`\n   |\n   = note:   expected type `char`\n        \
    \   found reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfc__nn5i.rs:16:139\n\
    \   |\n16 | ...ter(|&(_, c2)| c2 == c).filter_map(|(_, &c)| c.to_lowercase()).collect::<Vec<_>>()\n\
    \   |                                            ^^- expected due to this\n  \
    \ |                                            |\n   |                       \
    \                     expected `char`, found reference\n   |                 \
    \                           help: you can probably r"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"\"];\n    let mut left = word.chars().skip_while(|c| !c.is_ascii()).collect::<String>();\n\
    \    let mut right = word.chars().skip_while(|c| c.is_ascii()).collect::<String>();\n\
    \    \n    for vowel in &Vowels {\n        if left.contains(vowel) && right.contains(vowel)\
    \ {\n            vowels.push(vowel);\n        }\n    }\n    \n    if !vowels.is_empty()\
    \ {\n        String::from(vowels.iter().min().unwrap())\n    } else {\n      \
    \  String::from(\"\")\n    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `Vowels` in this scope\n  --> /tmp/tmpb9s413rh.rs:20:19\n\
    \   |\n20 |     for vowel in &Vowels {\n   |                   ^^^^^^ help: a\
    \ local variable with a similar name exists (notice the capitalization): `vowels`\n\
    \nerror[E0277]: the trait bound `String: From<&&str>` is not satisfied\n  -->\
    \ /tmp/tmpb9s413rh.rs:27:9\n   |\n27 |         String::from(vowels.iter().min().unwrap())\n\
    \   |         ^^^^^^^^^^^^ the trait `From<&&str>` is not implemented for `String`\n\
    \   |\n   = help: the following other types implement trait `From<T>`:\n     \
    \        <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0425.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    match\
    \ word {\n        Ok(w) => get_closest_vowel_1(w),\n        _ => String::new(),\n\
    \    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `get_closest_vowel_1` in this scope\n\
    \  --> /tmp/tmpn5cq6i3y.rs:17:18\n   |\n17 |         Ok(w) => get_closest_vowel_1(w),\n\
    \   |                  ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpn5cq6i3y.rs:17:9\n   |\n16 |     match word\
    \ {\n   |           ---- this expression has type `String`\n17 |         Ok(w)\
    \ => get_closest_vowel_1(w),\n   |         ^^^^^ expected struct `String`, found\
    \ enum `Result`\n   |\n   = note: expected struct `String`\n                found\
    \ enum `Result<_, _>`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0425.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = Vec::new();\n    vowels.push('a', 'e', 'i', 'o', 'u');\n    let\
    \ mut consonants = Vec::new();\n    consonants.push('b', 'c', 'd', 'f', 'g', 'h',\
    \ 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z');\n\
    \    let mut index = word.len();\n    while index > 0 {\n        let mut vowels_index\
    \ = vowels.iter().position(|&v| {\n            index < word.len() && word.chars().any(|c|\
    \ {\n                *c >= v && c <= consonants.last()\n            })\n     \
    \   });\n        if vowels_index.is_some() {\n            return String::from(vowels[vowels_index.unwrap()].to_string());\n\
    \        }\n        index -= 1;\n    }\n    String::from(\"\")\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 5 arguments were supplied\n\
    \    --> /tmp/tmp82wg3df9.rs:17:12\n     |\n17   |     vowels.push('a', 'e', 'i',\
    \ 'o', 'u');\n     |            ^^^^ ---  ---  ---  ---  --- supplied 5 arguments\n\
    \     |            |\n     |            expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror[E0061]: this function takes 1 argument but 21\
    \ arguments were supplied\n    --> /tmp/tmp82wg3df9.rs:19:16\n     |\n19   | \
    \    consonants.push('b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p',\
    \ 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z');\n     |                ^^^^ ---\
    \  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  --- \
    \ ---  ---  ---  ---  --- supplied 21 arguments\n     |                |\n   \
    \  |                expected 1 argument\n     |\nnote: associated function defined\
    \ here\n\nerror[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmp82wg3df9.rs:24:17\n\
    \   |\n24 |                 *c >= v && c <= consonants.last()\n   |          \
    \       ^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp82wg3df9.rs:24:33\n\
    \   |\n24 |                 *c >= v && c <= consonants.last()\n   |          \
    \                       ^^^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&_>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0308, E0614.\nFor more information about an error, try `rustc --explain\
    \ E0061`.\n"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut res = String::from(\"\");\n    for i in word[word.len() - 1].chars().rev()\
    \ {\n        if i.is_vowel() {\n            res = i;\n            break;\n   \
    \     }\n    }\n    res\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpgeasb0yj.rs:17:14\n\
    \   |\n17 |     for i in word[word.len() - 1].chars().rev() {\n   |          \
    \    ^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ word = word.to_string();\n    \n    let mut index = 0;\n    while index < word.length()\
    \ - 1 {\n        if let Some(i) = word.char_indices().filter(|(_, c)| c.is_uppercase()).find()\
    \ {\n            let vowels = String::new();\n            if i != 0 && (i + 1)\
    \ < word.length() {\n                if let Some(first) = word.chars().nth(i +\
    \ 1) {\n                    if first != 'A' || first != 'E' || first != 'I' ||\
    \ first != 'O' || first != 'U' {\n                        vowels.push(first);\n\
    \                    }\n                }\n            }\n            if i !=\
    \ word.length() - 1 && (i + 1) < word.length() && let Some(last) = word.chars().nth(i\
    \ + 2) {\n                if last != 'A' || last != 'E' || last != 'I' || last\
    \ != 'O' || last != 'U' {\n                    vowels.push(last);\n          \
    \      }\n            }\n            if !vowels.is_empty() {\n               \
    \ let mut vowel = vowels.to_string();\n                while vowel.len() > 1 {\n\
    \                    if vowel.chars().any(|c| c.is_uppercase()) {\n          \
    \              vowel = vowel.substr(0, vowel.len());\n                    } else\
    \ {\n                        break;\n                    }\n                }\n\
    \                index += vowel.len();\n                return vowel;\n      \
    \      }\n        }\n        index += 1;\n    }\n    \n    \"\".to_string()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0658]: `let` expressions in this position are unstable\n  --> /tmp/tmpvzirhdo3.rs:29:69\n\
    \   |\n29 |             if i != word.length() - 1 && (i + 1) < word.length() &&\
    \ let Some(last) = word.chars().nth(i + 2) {\n   |                           \
    \                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |\n   = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667>\
    \ for more information\n\nerror[E0599]: no method named `length` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmpvzirhdo3.rs:19:24\n   |\n19 | \
    \    while index < word.length() - 1 {\n   |                        ^^^^^^ help:\
    \ there is an associated function with a similar name: `len`\n\nerror[E0061]:\
    \ this function takes 1 argument but 0 arguments were supplied\n    --> /tmp/tmpvzirhdo3.rs:20:80\n\
    \     |\n20   |         if let Some(i) = word.char_indices().filter(|(_, c)| c.is_uppercase()).find()\
    \ {\n     |                                                                  \
    \              ^^^^- supplied 0 arguments\n     |                            \
    \                                                    |\n     |               \
    \                                                                 expected 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpvzirhdo3.rs:22:21\n   |\n22 |             if i != 0 && (i + 1)\
    \ < word.length() {\n   |                     ^ expected tuple, found integer\n\
    \   |\n   = note: expected tuple `(usize, char)`\n               found type `{integer}`\n\
    \nerror[E0369]: cannot add `{integer}` to `(usize, char)`\n  --> /tmp/tmpvzirhdo3.rs:22:29\n\
    \   |\n22 |             if i != 0 && (i + 1) < word.length() {\n   |         \
    \                  - ^ - {integer}\n   |                           |\n   |   \
    \                        (usize, char)\n\nerror[E0599]: no method named `length`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpvzirhdo3.rs:22:41\n\
    \   |\n22 |             if i != 0 && (i + 1) < word.length() {\n   |         \
    \                                ^^^^^^ help: ther"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut current = word;\n    let mut closest_vowel: Option<String> = None;\n   \
    \ for (index, char) in current.chars().enumerate() {\n        match char {\n \
    \           'a' | 'e' | 'i' | 'o' | 'u' => continue,\n            'A' | 'E' |\
    \ 'I' | 'O' | 'U' => closest_vowel = Some(String::from(\"u\") + char.to_string()),\n\
    \            c => match closest_vowel {\n                None => closest_vowel\
    \ = Some(String::from(\"u\") + c.to_string()),\n                Some(last) =>\
    \ if char == last || char == char.swapcase().to_string() {\n                 \
    \   closest_vowel = Some(String::from(\"\") + c.to_string()),\n              \
    \  }\n            },\n        }\n    }\n    closest_vowel.unwrap_or_else(|_| word.to_string())\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `,`\n\
    \  --> /tmp/tmpl_fai1ly.rs:25:75\n   |\n25 |                     closest_vowel\
    \ = Some(String::from(\"\") + c.to_string()),\n   |                          \
    \                                                 ^ expected one of `.`, `;`,\
    \ `?`, `}`, or an operator\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl_fai1ly.rs:21:85\n\
    \   |\n21 |             'A' | 'E' | 'I' | 'O' | 'U' => closest_vowel = Some(String::from(\"\
    u\") + char.to_string()),\n   |                                              \
    \                                       ^^^^^^^^^^^^^^^^\n   |               \
    \                                                                      |\n   |\
    \                                                                            \
    \         expected `&str`, found struct `String`\n   |                       \
    \                                                              help: consider\
    \ borrowing here: `&char.to_string()`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpl_fai1ly.rs:23:66\n   |\n23 |                 None => closest_vowel\
    \ = Some(String::from(\"u\") + c.to_string()),\n   |                         \
    \                                         ^^^^^^^^^^^^^\n   |                \
    \                                                  |\n   |                   \
    \                                               expected `&str`, found struct\
    \ `String`\n   |                                                             \
    \     help: consider borrowing here: `&c.to_string()`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpl_fai1ly.rs:24:42\n   |\n24 |                 Some(last)\
    \ => if char == last || char == char.swapcase().to_string() {\n   |          \
    \                                ^^^^ expected `char`, found struct `String`\n\
    \nerror[E0599]: no method named `swapcase` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpl_fai1ly.rs:24:63\n   |\n24 |                 Some(last)\
    \ => if char == last || char == char.swapcase().to_string() {\n   |          \
    \                                                     ^^^^^^^^ method n"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowel_pos = 0;\n    let mut vowel_count = 0;\n    for pos in word.chars().rposition(|&c|\
    \ *c != 'a' && *c != 'e' && *c != 'i' && *c != 'o' && *c != 'u') {\n        vowel_count\
    \ += 1;\n        vowel_pos = pos + 1;\n    }\n    if vowel_count < 2 {\n     \
    \   return String::from(\"\");\n    }\n    word.chars().rposition(|&c| *c != 'a'\
    \ && *c != 'e' && *c != 'i' && *c != 'o' && *c != 'u') {\n        let mut vowel_pos\
    \ = word.chars().rposition(|&c| *c != 'a' && *c != 'e' && *c != 'i' && *c != 'o'\
    \ && *c != 'u');\n        let mut vowel_count = 0;\n        for pos in word.chars().rposition(|&c|\
    \ *c != 'a' && *c != 'e' && *c != 'i' && *c != 'o' && *c != 'u') {\n         \
    \   vowel_count += 1;\n            vowel_pos = pos + 1;\n        }\n        if\
    \ vowel_count > 2 {\n            return String::from(\"\");\n        }\n    }\n\
    \    word.chars().rposition(|&c| *c != 'a' && *c != 'e' && *c != 'i' && *c !=\
    \ 'o' && *c != 'u') {\n        let mut vowel_pos = word.chars().rposition(|&c|\
    \ *c != 'a' && *c != 'e' && *c != 'i' && *c != 'o' && *c != 'u');\n        let\
    \ mut vowel_count = 0;\n        for pos in word.chars().rposition(|&c| *c != 'a'\
    \ && *c != 'e' && *c != 'i' && *c != 'o' && *c != 'u') {\n            vowel_count\
    \ += 1;\n            vowel_pos = pos + 1;\n        }\n        if vowel_count ==\
    \ 0 {\n            return String::from(\"\");\n        }\n    }\n    word.chars().rposition(|&c|\
    \ *c != 'a' && *c != 'e' && *c != 'i' && *c != 'o' && *c != 'u') {\n        let\
    \ mut vowel_pos = word.chars().rposition(|&c| *c != 'a' && *c != 'e' && *c !=\
    \ 'i' && *c != 'o' && *c != 'u');\n        let mut vowel_count = 0;\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmplublaqr1.rs:67:3\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n47 |     word.chars().rposition(|&c|\
    \ *c != 'a' && *c != 'e' && *c != 'i' && *c != 'o' && *c != 'u') {\n   |     \
    \                                                                            \
    \               - this delimiter might not be properly closed...\n...\n50 | }\n\
    \   | - ...as it matches this but it has different indentation\n...\n67 | }\n\
    \   |   ^\n\nerror: expected one of `.`, `;`, `?`, `}`, or an operator, found\
    \ `{`\n  --> /tmp/tmplublaqr1.rs:15:46\n   |\n15 | fn get_closest_vowel(word:\
    \ String) -> String {\n   |                                              ^ unclosed\
    \ delimiter\n...\n25 |     word.chars().rposition(|&c| *c != 'a' && *c != 'e'\
    \ && *c != 'i' && *c != 'o' && *c != 'u') {\n   |                            \
    \                                                                   -^ expected\
    \ one of `.`, `;`, `?`, `}`, or an operator\n   |                            \
    \                                                                   |\n   |  \
    \                                                                            \
    \                 help: `}` may belong here\n\nerror[E0277]: the trait bound `Chars<'_>:\
    \ ExactSizeIterator` is not satisfied\n    --> /tmp/tmplublaqr1.rs:18:29\n   \
    \  |\n18   |     for pos in word.chars().rposition(|&c| *c != 'a' && *c != 'e'\
    \ && *c != 'i' && *c != 'o' && *c != 'u') {\n     |                          \
    \   ^^^^^^^^^ the trait `ExactSizeIterator` is not implemented for `Chars<'_>`\n\
    \     |\n     = help: the following other types implement trait `ExactSizeIterator`:\n\
    \               &mut I\n               Args\n               ArgsOs\n         \
    \      ArrayChunks<'_, T, N>\n               ArrayChunksMut<'_, T, N>\n      \
    \         ArrayWindows<'_, T, N>\n               Box<I, A>\n               Chunks<'_,\
    \ T>\n             and 109 others\nnote: required by a bound in `rposition`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmplu"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    word.chars().enumerate().take_while(|&(_,\
    \ c)| {\n        match c {\n            'a' | 'A' | 'e' | 'E' | 'i' | 'I' | 'o'\
    \ | 'O' | 'u' | 'U' => {\n                true\n            }\n            _ =>\
    \ false\n        }\n    }).collect::<Vec<_>>().iter()\n        .cloned()\n   \
    \     .enumerate()\n        .find_if(|&(_, c)| {\n            match c {\n    \
    \            'a' | 'A' | 'e' | 'E' | 'i' | 'I' | 'o' | 'O' | 'u' | 'U' => {\n\
    \                    true\n                }\n                _ => false\n   \
    \         }\n        }).map(|&(_, c)| c)\n        .map(|c| word.chars().position(|c|\
    \ c == c).unwrap())\n        .map(|i| word.chars()\n            .skip(i)\n   \
    \         .take_while(|&c| {\n                match c {\n                    'a'\
    \ | 'A' | 'e' | 'E' | 'i' | 'I' | 'o' | 'O' | 'u' | 'U' => {\n               \
    \         true\n                    }\n                    _ => false\n      \
    \          }\n            })\n            .collect::<Vec<_>>())\n        .collect::<Vec<_>>()\n\
    \        .iter()\n        .cloned()\n        .enumerate()\n        .take_while(|&(_,\
    \ c)| {\n            match c {\n                'a' | 'A' | 'e' | 'E' | 'i' |\
    \ 'I' | 'o' | 'O' | 'u' | 'U' => {\n                    true\n               \
    \ }\n                _ => false\n            }\n        })\n        .map(|&(_,\
    \ c)| c)\n        .map(|c| word.chars().position(|c| c == c).unwrap())\n     \
    \   .map(|i| word.chars()\n            .skip(i)\n            .take_while(|&c|\
    \ {\n                match c {\n                    'a' | 'A' | 'e' | 'E' | 'i'\
    \ | 'I' | 'o' | 'O' | 'u' | 'U' => {\n                        true\n         \
    \           }\n                    _ => false\n                }\n           \
    \ })\n            .collect::<Vec<_>>())\n        .collect::<Vec<_>>()\n      \
    \  .iter()\n        .cloned()\n        .enumerate()\n        .take_while(|&(_,\
    \ c)| {\n            match c {\n                'a' | 'A' | 'e' | 'E' | 'i' |\
    \ 'I' | 'o' | 'O' | 'u' | 'U' => {\n                    true\n               \
    \ }\n                _ => false\n            }\n        })\n        .map(|&(_,\
    \ c)| c)\n        .map(|c| word.chars().position(|c| c == c).unwrap())\n     \
    \   .\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmphi5k2imd.rs:86:1\n   |\n86\
    \ | }\n   | ^\n\nerror[E0599]: no method named `find_if` found for struct `Enumerate`\
    \ in the current scope\n  --> /tmp/tmphi5k2imd.rs:26:10\n   |\n26 |         .find_if(|&(_,\
    \ c)| {\n   |          ^^^^^^^ method not found in `Enumerate<Cloned<std::slice::Iter<'_,\
    \ (usize, char)>>>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowel_range: Vec<(String, String)> = vec![];\n    let mut i: usize = 0;\n\
    \    while i < word.len() {\n        if word[i] == 'a' || word[i] == 'e' || word[i]\
    \ == 'i' || word[i] == 'o' || word[i] == 'u' {\n            vowel_range.push((\n\
    \                String::from(word[word.len()-(i+2)..word.len()-i]),\n       \
    \         String::from(word[word.len()-(i+4)..word.len()-(i+2)])\n           \
    \ ));\n            i += 2;\n        }\n        if word[i] == 'A' || word[i] ==\
    \ 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U' {\n            vowel_range.push((\n\
    \                String::from(word[word.len()-(i+2)..word.len()-i]),\n       \
    \         String::from(word[word.len()-(i+4)..word.len()-(i+2)])\n           \
    \ ));\n            i += 2;\n        }\n        i += 1;\n    }\n\n    if vowel_range.len()\
    \ == 0 {\n        return String::from(\"\");\n    }\n    let mut j: usize = 0;\n\
    \    vowel_range.sort();\n    for v in vowel_range.iter() {\n        if j != v.0\n\
    \            && v.0 == v.1\n            && j + 1 < word.len()\n            &&\
    \ word[j + 1] == v.0\n            && word[j + 2] == v.1 {\n            break;\n\
    \        }\n        j = v.0 + 1;\n    }\n\n    if j == word.len() {\n        return\
    \ String::from(\"\");\n    }\n\n    String::from(word[j..].to_uppercase())\n}\n\
    \nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpa8w51s31.rs:19:12\n\
    \   |\n19 |         if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i]\
    \ == 'o' || word[i] == 'u' {\n   |            ^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpa8w51s31.rs:19:30\n   |\n19 |         if word[i] == 'a' || word[i]\
    \ == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n   |       \
    \                       ^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpa8w51s31.rs:19:48\n\
    \   |\n19 |         if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i]\
    \ == 'o' || word[i] == 'u' {\n   |                                           \
    \     ^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <Stri"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    use\
    \ std::cmp::Ordering;\n    let mut vowels: [String; 3] = [String::from(\"A\"),\
    \ String::from(\"E\"), String::from(\"I\"), String::from(\"O\"), String::from(\"\
    U\")];\n\n    let len = word.len();\n    if len < 3 {\n        return String::from(\"\
    \");\n    }\n\n    let len = word.len();\n    let mut i = len - 1;\n    while\
    \ i >= 0 {\n        let word = word[i].to_lowercase();\n        if word.contains(\"\
    a\") {\n            vowels[0] = word;\n        }\n        if word.contains(\"\
    e\") {\n            vowels[1] = word;\n        }\n        if word.contains(\"\
    i\") {\n            vowels[2] = word;\n        }\n        i -= 1;\n    }\n\n \
    \   let mut vowel_index = -1;\n    let mut vowel_len = vowels.len();\n    let\
    \ mut i = 0; \n    while i < vowel_len {\n        if vowels[i].len() < vowel_len\
    \ - i {\n            break;\n        }\n        if word.starts_with(vowels[i])\
    \ {\n            vowel_index = i;\n            i += 1;\n        }\n        if\
    \ word.ends_with(vowels[i]) {\n            vowel_index = i;\n            i +=\
    \ 1;\n        }\n        i += 1;\n    }\n\n    if vowel_index >= 0 {\n       \
    \ vowels[vowel_index]\n    } else {\n        String::from(\"\")\n    }\n}\n\n\
    fn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "warning: unused import: `std::cmp::Ordering`\n  --> /tmp/tmppd21y8sm.rs:16:9\n\
    \   |\n16 |     use std::cmp::Ordering;\n   |         ^^^^^^^^^^^^^^^^^^\n   |\n\
    \   = note: `#[warn(unused_imports)]` on by default\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmppd21y8sm.rs:17:35\n   |\n17 |     let mut vowels: [String;\
    \ 3] = [String::from(\"A\"), String::from(\"E\"), String::from(\"I\"), String::from(\"\
    O\"), String::from(\"U\")];\n   |                     -----------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected an array with a fixed size of 3 elements, found one with 5 elements\n\
    \   |                     |\n   |                     expected due to this\n \
    \  |\n   = note: expected array `[String; 3]`\n              found array `[String;\
    \ 5]`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmppd21y8sm.rs:27:20\n\
    \   |\n27 |         let word = word[i].to_lowercase();\n   |                 \
    \   ^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n\
    \    --> /tmp/tmppd21y8sm.rs:47:29\n     |\n47   |         if word.starts_with(vowels[i])\
    \ {\n     |                 ----------- ^^^^^^^^^ expected an implementor of trait\
    \ `Pattern<'_>`\n     |                 |\n     |                 required by\
    \ a bound introduced by this call\n     |\n     = note: the trait bound `String:\
    \ Pattern<'_>` is not satisfied\n     = note: required because of the requirements\
    \ on the impl of `Pattern<'_>` for `String`\nnote: required by a bound in `core::str::<impl\
    \ str>::starts_with`\nhelp: c"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    if\
    \ word.len() < 2 {\n        return String::from(\"\");\n    }\n    let mut current_consonant\
    \ = String::from(\"\");\n    let mut vowel_found = false;\n    for i in word.len()\
    \ - 1 {\n        if word[word.len() - 1] == i.chars().next().unwrap() {\n    \
    \        current_consonant = i;\n            vowel_found = true;\n           \
    \ break;\n        }\n    }\n    if !vowel_found {\n        return String::from(\"\
    \");\n    }\n    word.chars().skip(word.len() - current_consonant.len()).fold(String::from(\"\
    \"), |mut acc, char| {\n        if char == current_consonant {\n            acc\
    \ += &char;\n        }\n        acc\n    });\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `usize` is not an iterator\n  --> /tmp/tmp3q_upfze.rs:21:14\n\
    \   |\n21 |     for i in word.len() - 1 {\n   |              ^^^^^^^^^^^^^^ `usize`\
    \ is not an iterator\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `usize`\n   = note: if you want to iterate between `start` until a value\
    \ `end`, use the exclusive range syntax `start..end` or the inclusive range syntax\
    \ `start..=end`\n   = note: required because of the requirements on the impl of\
    \ `IntoIterator` for `usize`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmp3q_upfze.rs:22:12\n   |\n22 |         if word[word.len()\
    \ - 1] == i.chars().next().unwrap() {\n   |            ^^^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3q_upfze.rs:32:20\n\
    \   |\n32 |         if char == current_consonant {\n   |                    ^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmp3q_upfze.rs:33:20\n   |\n33 |             acc += &char;\n   |  \
    \                  ^^^^^ expected `str`, found `char`\n   |\n   = note: expected\
    \ reference `&str`\n              found reference `&char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp3q_upfze.rs:15:39\n   |\n15 | fn get_closest_vowel(word:\
    \ String) -> String {\n   |    -----------------                  ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n...\n36 |     });\n   |       - help:\
    \ remove this semicolon\n\nerror: aborting due to 5 previous errors\n\nSome errors"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec!['A', 'E', 'I', 'O', 'U'];\n    for vowel in vowels.iter_mut()\
    \ {\n        let vowel_pos = word.rfind(vowel);\n        let index = vowel_pos\
    \ + 1;\n        if index >= word.len() || index < 0 {\n            continue;\n\
    \        }\n        if index == word.len() - 1 {\n            return String::from(vowel.to_string());\n\
    \        }\n        let consonant_pos = index + 1;\n        let consonant = &word[consonant_pos];\n\
    \        if consonant == 'a' || consonant == 'e' || consonant == 'i' || consonant\
    \ == 'o' || consonant == 'u' {\n            vowel = consonant.to_string();\n \
    \       }\n    }\n    String::from(\"\")\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `char`\n  -->\
    \ /tmp/tmpeoxd2j__.rs:18:36\n   |\n18 |         let vowel_pos = word.rfind(vowel);\n\
    \   |                              ----- ^^^^^ expected an `FnMut<(char,)>` closure,\
    \ found `char`\n   |                              |\n   |                    \
    \          required by a bound introduced by this call\n   |\n   = help: the trait\
    \ `FnMut<(char,)>` is not implemented for `char`\n   = note: required because\
    \ of the requirements on the impl of `FnOnce<(char,)>` for `&mut char`\n   = note:\
    \ required because of the requirements on the impl of `Pattern<'_>` for `&mut\
    \ char`\nhelp: consider dereferencing here\n   |\n18 |         let vowel_pos =\
    \ word.rfind(*vowel);\n   |                                    +\n\nerror[E0369]:\
    \ cannot add `{integer}` to `Option<usize>`\n  --> /tmp/tmpeoxd2j__.rs:19:31\n\
    \   |\n19 |         let index = vowel_pos + 1;\n   |                     ---------\
    \ ^ - {integer}\n   |                     |\n   |                     Option<usize>\n\
    \nerror[E0277]: can't compare `&_` with `char`\n  --> /tmp/tmpeoxd2j__.rs:28:22\n\
    \   |\n28 |         if consonant == 'a' || consonant == 'e' || consonant == 'i'\
    \ || consonant == 'o' || consonant == 'u' {\n   |                      ^^ no implementation\
    \ for `&_ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&_`\n\nerror[E0277]: can't compare `&_` with `char`\n  --> /tmp/tmpeoxd2j__.rs:28:42\n\
    \   |\n28 |         if consonant == 'a' || consonant == 'e' || consonant == 'i'\
    \ || consonant == 'o' || consonant == 'u' {\n   |                            \
    \              ^^ no implementation for `&_ == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&_`\n\nerror[E0277]: can't compare\
    \ `&_` with `char`\n  --> /tmp/tmpeoxd2j__.rs:28:62\n   |\n28 |         if consonant\
    \ == 'a' || consonant == 'e' || consonant == 'i' || consonant == 'o' || consonant\
    \ == 'u' {\n   |                                                             \
    \ ^^ no implementation for `&_ == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not imple"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ word = word.to_lowercase();\n    let mut vowels = vec![\"a\", \"e\", \"i\",\
    \ \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"];\n\n    for cons in word.chars()\
    \ {\n        if vowels.iter().any(|vowel| vowel == cons) {\n            return\
    \ cons;\n        }\n    }\n    \"\"\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&&str` with `char`\n  --> /tmp/tmppa5sr2kd.rs:20:44\n\
    \   |\n20 |         if vowels.iter().any(|vowel| vowel == cons) {\n   |      \
    \                                      ^^ no implementation for `&&str == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&&str`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmppa5sr2kd.rs:21:20\n   |\n21 |             return cons;\n\
    \   |                    ^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                    |\n   |                    expected struct `String`,\
    \ found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppa5sr2kd.rs:24:5\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |             \
    \                          ------ expected `String` because of return type\n...\n\
    24 |     \"\"\n   |     ^^- help: try using a conversion method: `.to_string()`\n\
    \   |     |\n   |     expected struct `String`, found `&str`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowel_from = word.chars();\n    let mut vowel_to = vowel_from.rev();\n \
    \   let mut vowel: String = String::new();\n\n    while vowel_from.any(|c| c ==\
    \ 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n        vowel = String::from(vowel_from.next().unwrap());\n\
    \        vowel_from.next();\n    }\n    vowel_to.next();\n\n    if vowel.chars().any(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n        return\
    \ String::from(vowel);\n    } else {\n        return String::new();\n    }\n}\n\
    \nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `vowel_from`\n    --> /tmp/tmpsnqs4xlz.rs:20:11\n\
    \     |\n16   |     let mut vowel_from = word.chars();\n     |         --------------\
    \ move occurs because `vowel_from` has type `Chars<'_>`, which does not implement\
    \ the `Copy` trait\n17   |     let mut vowel_to = vowel_from.rev();\n     |  \
    \                                 ----- `vowel_from` moved due to this method\
    \ call\n...\n20   |     while vowel_from.any(|c| c == 'a' || c == 'e' || c ==\
    \ 'i' || c == 'o' || c == 'u') {\n     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ value borrowed here after move\n     |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `vowel_from`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut s = String::new();\n    let mut vowel = String::new();\n    for c in word.chars()\
    \ {\n        if c.to_ascii_lowercase() == 'a' || c.to_ascii_lowercase() == 'e'\
    \ ||\n            c.to_ascii_lowercase() == 'i' || c.to_ascii_lowercase() == 'o'\
    \ ||\n            c.to_ascii_lowercase() == 'u' {\n            vowel = c;\n  \
    \          break;\n        }\n    }\n    if vowel.is_empty() {\n        \"\".to_string();\n\
    \    } else {\n        for c in word.chars() {\n            if c.to_ascii_lowercase()\
    \ != vowel.to_ascii_lowercase() {\n                continue;\n            }\n\
    \            s.push_str(&vowel);\n            break;\n        }\n        if s.len()\
    \ == 0 {\n            \"\".to_string();\n        } else {\n            s.to_owned()\n\
    \        }\n    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3gxpg63e.rs:22:21\n   |\n\
    17 |     let mut vowel = String::new();\n   |                     -------------\
    \ expected due to this value\n...\n22 |             vowel = c;\n   |         \
    \            ^- help: try using a conversion method: `.to_string()`\n   |    \
    \                 |\n   |                     expected struct `String`, found\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3gxpg63e.rs:26:25\n\
    \   |\n26 |       if vowel.is_empty() {\n   |  _________________________^\n27\
    \ | |         \"\".to_string();\n   | |                       - help: remove this\
    \ semicolon\n28 | |     } else {\n   | |_____^ expected struct `String`, found\
    \ `()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3gxpg63e.rs:30:42\n  \
    \ |\n30 |             if c.to_ascii_lowercase() != vowel.to_ascii_lowercase()\
    \ {\n   |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmp3gxpg63e.rs:36:25\n   |\n36 |           if s.len() == 0 {\n   |\
    \  _________________________^\n37 | |             \"\".to_string();\n   | |  \
    \                         - help: remove this semicolon\n38 | |         } else\
    \ {\n   | |_________^ expected struct `String`, found `()`\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowel_index = 0;\n    let mut vowel: Option<usize> = None;\n    let mut\
    \ vowel_end = None;\n    for char in word.chars() {\n        if vowel_end.is_none()\
    \ {\n            if char == 'a' || char == 'e' || char == 'i' || char == 'o' ||\
    \ char == 'u' {\n                vowel_index = word.chars().position(|&c| c ==\
    \ char).unwrap();\n                vowel = Some(vowel_index);\n              \
    \  vowel_end = word.chars().position(|&c| c == char).unwrap();\n            }\n\
    \        } else {\n            if char == 'a' || char == 'e' || char == 'i' ||\
    \ char == 'o' || char == 'u' {\n                if vowel_index < vowel_end {\n\
    \                    vowel_index = word.chars().position(|&c| c == char).unwrap();\n\
    \                    vowel = Some(vowel_index);\n                    vowel_end\
    \ = word.chars().position(|&c| c == char).unwrap();\n                }\n     \
    \       }\n        }\n    }\n    vowel.unwrap_or(word.len())\n}\n\nfn main() {\n\
    \    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6_g37whx.rs:22:54\n   |\n\
    22 |                 vowel_index = word.chars().position(|&c| c == char).unwrap();\n\
    \   |                                                      ^--\n   |         \
    \                                             ||\n   |                       \
    \                               |expected due to this\n   |                  \
    \                                    expected `char`, found reference\n   |  \
    \                                                    help: did you mean `c`: `&char`\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp6_g37whx.rs:24:52\n   |\n24 |  \
    \               vowel_end = word.chars().position(|&c| c == char).unwrap();\n\
    \   |                                                    ^--\n   |           \
    \                                         ||\n   |                           \
    \                         |expected due to this\n   |                        \
    \                            expected `char`, found reference\n   |          \
    \                                          help: did you mean `c`: `&char`\n \
    \  |\n   = note:   expected type `char`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp6_g37whx.rs:24:29\n   |\n18 |     let mut vowel_end\
    \ = None;\n   |                         ---- expected due to this value\n...\n\
    24 |                 vowel_end = word.chars().position(|&c| c == char).unwrap();\n\
    \   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected enum `Option`, found `usize`\n   |\n   = note: expected enum `Option<_>`\n\
    \              found type `usize`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n24 |                 vowel_end = Some(word.chars().position(|&c| c == char).unwrap());\n\
    \   |                             +++++                                      \
    \        +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6_g37whx.rs:28:34\n\
    \   |\n28 |                 if vowel_index < vowel_end {\n   |               \
    \                   ^^^^^^^^^ expected `usize"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"\".to_string(), \"\".to_string()];\n    vowels[0] = \"A\"\
    .to_string();\n    vowels[1] = \"E\".to_string();\n    vowels[2] = \"I\".to_string();\n\
    \    vowels[3] = \"O\".to_string();\n    vowels[4] = \"U\".to_string();\n    vowels[5]\
    \ = \"a\".to_string();\n    vowels[6] = \"e\".to_string();\n    vowels[7] = \"\
    i\".to_string();\n    vowels[8] = \"o\".to_string();\n    vowels[9] = \"u\".to_string();\n\
    \    let mut i = 0;\n    while i < word.len() {\n        let c = word[word.len()\
    \ - 1 - i].to_lowercase();\n        if vowels.iter().any(|&s| s.contains(&c))\
    \ {\n            return word.to_string();\n        }\n        i += 1;\n    }\n\
    \    return \"\".to_string();\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpqlu_0eu_.rs:29:17\n\
    \   |\n29 |         let c = word[word.len() - 1 - i].to_lowercase();\n   |   \
    \              ^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut i = word\n        .char_indices()\n        .filter_map(|(index, element)|\
    \ {\n            if element.get(0) != None {\n                Some((index as usize,\
    \ element.get(0) as u32))\n            } else {\n                None\n      \
    \      }\n        })\n        .rposition(|(_, index)| {\n            let index\
    \ = *index;\n            word.chars().nth(index).unwrap().to_ascii_lowercase()\
    \ == String::from(\"a\")\n        })\n        .unwrap();\n    word.chars().nth(*i).unwrap().to_ascii_lowercase()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `get` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpdlq0ziv0.rs:19:24\n   |\n19 |             if element.get(0)\
    \ != None {\n   |                        ^^^ method not found in `char`\n\nerror[E0599]:\
    \ no method named `get` found for type `char` in the current scope\n  --> /tmp/tmpdlq0ziv0.rs:20:47\n\
    \   |\n20 |                 Some((index as usize, element.get(0) as u32))\n  \
    \ |                                               ^^^ method not found in `char`\n\
    \nerror[E0277]: the trait bound `FilterMap<CharIndices<'_>, [closure@/tmp/tmpdlq0ziv0.rs:18:21:\
    \ 24:10]>: ExactSizeIterator` is not satisfied\n    --> /tmp/tmpdlq0ziv0.rs:25:10\n\
    \     |\n25   |         .rposition(|(_, index)| {\n     |          ^^^^^^^^^ the\
    \ trait `ExactSizeIterator` is not implemented for `FilterMap<CharIndices<'_>,\
    \ [closure@/tmp/tmpdlq0ziv0.rs:18:21: 24:10]>`\n     |\n     = help: the following\
    \ other types implement trait `ExactSizeIterator`:\n               &mut I\n  \
    \             Args\n               ArgsOs\n               ArrayChunks<'_, T, N>\n\
    \               ArrayChunksMut<'_, T, N>\n               ArrayWindows<'_, T, N>\n\
    \               Box<I, A>\n               Chunks<'_, T>\n             and 109\
    \ others\nnote: required by a bound in `rposition`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpdlq0ziv0.rs:27:70\n   |\n27 |             word.chars().nth(index).unwrap().to_ascii_lowercase()\
    \ == String::from(\"a\")\n   |                                               \
    \                       ^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \nerror[E0614]: type `usize` cannot be dereferenced\n  --> /tmp/tmpdlq0ziv0.rs:30:22\n\
    \   |\n30 |     word.chars().nth(*i).unwrap().to_ascii_lowercase()\n   |     \
    \                 ^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdlq0ziv0.rs:30:5\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |             \
    \                          ------ expected `String` because of return type\n...\n\
    30 |     word.chars().nth(*i).unwrap().to_ascii_lowercase()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    \n\
    \    let vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n\n    let mut cur_letter\
    \ = word.chars().next();\n\n    cur_letter\n        .unwrap()\n        .next()\n\
    \        .unwrap()\n        .next()\n        .unwrap()\n        .next()\n    \
    \    .unwrap()\n        .next()\n        .unwrap()\n        .next()\n        .unwrap()\n\
    \        .next()\n        .unwrap()\n        .next()\n        .unwrap()\n    \
    \    .next()\n        .unwrap()\n        .next()\n        .unwrap()\n        .next()\n\
    \        .unwrap();\n\n    for vowel in vowels {\n        if cur_letter.unwrap()\
    \ == vowel {\n            return String::from(vowel);\n        }\n        cur_letter\
    \ = cur_letter.unwrap().next();\n    }\n    String::from(\"\")\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `next` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpsvuag34s.rs:23:10\n   |\n23 |         .next()\n   |   \
    \       ^^^^ method not found in `char`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpsvuag34s.rs:45:35\n   |\n45 |         if cur_letter.unwrap() == vowel\
    \ {\n   |                                   ^^^^^ expected `char`, found `&str`\n\
    \nerror[E0599]: no method named `next` found for type `char` in the current scope\n\
    \  --> /tmp/tmpsvuag34s.rs:48:42\n   |\n48 |         cur_letter = cur_letter.unwrap().next();\n\
    \   |                                          ^^^^ method not found in `char`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowel = String::from(\"\");\n\n    // Check if any of vowels are between\
    \ the consonants\n    let start = word.chars().skip_while(|c| !c.is_uppercase());\n\
    \    let end = word.chars().skip_while(|c| !c.is_lowercase());\n    \n    if start.len()\
    \ == end.len() && start.len() > 0 {\n        for pos in start.rev().take(word.len()\
    \ - 1) {\n            if word.chars().next() != pos.into() {\n               \
    \ break;\n            }\n        }\n\n        if word.chars().next() == pos.into()\
    \ {\n            vowel = word.chars().take(pos + 1).collect();\n        }\n  \
    \  }\n\n    vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `pos` in this scope\n  --> /tmp/tmpu8a_1rqj.rs:29:35\n\
    \   |\n29 |         if word.chars().next() == pos.into() {\n   |             \
    \                      ^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `pos` in this scope\n  --> /tmp/tmpu8a_1rqj.rs:30:39\n   |\n30 |     \
    \        vowel = word.chars().take(pos + 1).collect();\n   |                 \
    \                      ^^^ not found in this scope\n\nerror[E0599]: no method\
    \ named `len` found for struct `SkipWhile` in the current scope\n  --> /tmp/tmpu8a_1rqj.rs:22:14\n\
    \   |\n22 |     if start.len() == end.len() && start.len() > 0 {\n   |       \
    \       ^^^ method not found in `SkipWhile<Chars<'_>, [closure@/tmp/tmpu8a_1rqj.rs:19:41:\
    \ 19:62]>`\n\nerror[E0599]: no method named `len` found for struct `SkipWhile`\
    \ in the current scope\n  --> /tmp/tmpu8a_1rqj.rs:22:27\n   |\n22 |     if start.len()\
    \ == end.len() && start.len() > 0 {\n   |                           ^^^ method\
    \ not found in `SkipWhile<Chars<'_>, [closure@/tmp/tmpu8a_1rqj.rs:20:39: 20:60]>`\n\
    \nerror[E0599]: no method named `len` found for struct `SkipWhile` in the current\
    \ scope\n  --> /tmp/tmpu8a_1rqj.rs:22:42\n   |\n22 |     if start.len() == end.len()\
    \ && start.len() > 0 {\n   |                                          ^^^ method\
    \ not found in `SkipWhile<Chars<'_>, [closure@/tmp/tmpu8a_1rqj.rs:19:41: 19:62]>`\n\
    \nerror[E0277]: the trait bound `SkipWhile<Chars<'_>, [closure@/tmp/tmpu8a_1rqj.rs:19:41:\
    \ 19:62]>: DoubleEndedIterator` is not satisfied\n    --> /tmp/tmpu8a_1rqj.rs:23:26\n\
    \     |\n23   |         for pos in start.rev().take(word.len() - 1) {\n     |\
    \                          ^^^ the trait `DoubleEndedIterator` is not implemented\
    \ for `SkipWhile<Chars<'_>, [closure@/tmp/tmpu8a_1rqj.rs:19:41: 19:62]>`\n   \
    \  |\nnote: required by a bound in `rev`\n\nerror[E0599]: the method `take` exists\
    \ for struct `Rev<SkipWhile<Chars<'_>, [closure@/tmp/tmpu8a_1rqj.rs:19:41: 19:62]>>`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmpu8a_1rqj.rs:23:32\n \
    \  |\n23 |            for pos in start.rev().take(word.len() - 1) {\n "
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowel = String::from(\"\");\n    let mut last_pos = word.rfind(\"a\").unwrap();\n\
    \    let mut first_pos = word.rfind(\"e\").unwrap();\n    let mut last_consonant\
    \ = word[last_pos - 1];\n    let mut first_consonant = word[first_pos];\n\n  \
    \  while last_pos >= 0 {\n        if first_pos == 0 {\n            vowel = word[last_pos];\n\
    \            break;\n        }\n        first_pos = word.rfind(\"e\").unwrap();\n\
    \        last_pos = word.rfind(\"a\").unwrap();\n        first_consonant = word[first_pos];\n\
    \        last_consonant = word[last_pos];\n    }\n\n    vowel\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpzbjixxgo.rs:19:30\n\
    \   |\n19 |     let mut last_consonant = word[last_pos - 1];\n   |           \
    \                   ^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpzbjixxgo.rs:20:31\n   |\n20 |     let mut first_consonant = word[first_pos];\n\
    \   |                               ^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpzbjixxgo.rs:24:21\n   |\n24 |             vowel = word[last_pos];\n\
    \   |                     ^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \           "
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = \"aeiouAEIOU\";\n    vowels.truncate(word);\n    let mut start\
    \ = String::new();\n    let mut end = String::new();\n    vowels.iter().cloned().for_each(|letter|\
    \ {\n        if word.contains(&letter) {\n            if word.ends_with(&letter)\
    \ {\n                end = &letter;\n            } else {\n                start\
    \ = &letter;\n            }\n        }\n    });\n    start == \"\" && end == \"\
    \" || \n    word.last_char()\n        .unwrap()\n        .rfind(start)\n     \
    \   .unwrap_or(word.len())\n        .rfind(end)\n        .unwrap_or(word.len())\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `truncate` found for reference `&str` in\
    \ the current scope\n  --> /tmp/tmpei2tor66.rs:17:12\n   |\n17 |     vowels.truncate(word);\n\
    \   |            ^^^^^^^^ method not found in `&str`\n\nerror[E0599]: no method\
    \ named `iter` found for reference `&str` in the current scope\n  --> /tmp/tmpei2tor66.rs:20:12\n\
    \   |\n20 |     vowels.iter().cloned().for_each(|letter| {\n   |            ^^^^\
    \ method not found in `&str`\n   |\nhelp: because of the in-memory representation\
    \ of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n\
    \   |\n20 |     vowels.chars().cloned().for_each(|letter| {\n   |            ~~~~~\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpei2tor66.rs:23:23\n   |\n19 |\
    \     let mut end = String::new();\n   |                   ------------- expected\
    \ due to this value\n...\n23 |                 end = &letter;\n   |          \
    \             ^^^^^^^ expected struct `String`, found reference\n   |\n   = note:\
    \ expected struct `String`\n           found reference `&_`\nhelp: consider removing\
    \ the borrow\n   |\n23 -                 end = &letter;\n23 +                \
    \ end = letter;\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpei2tor66.rs:25:25\n\
    \   |\n18 |     let mut start = String::new();\n   |                     -------------\
    \ expected due to this value\n...\n25 |                 start = &letter;\n   |\
    \                         ^^^^^^^ expected struct `String`, found reference\n\
    \   |\n   = note: expected struct `String`\n           found reference `&_`\n\
    help: consider removing the borrow\n   |\n25 -                 start = &letter;\n\
    25 +                 start = letter;\n   | \n\nerror[E0599]: no method named `last_char`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpei2tor66.rs:30:10\n\
    \   |\n30 |     word.last_char()\n   |          ^^^^^^^^^ method not found in\
    \ `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpei2tor66.rs:29:5\n\
    \   |\n15 |   fn get_closest_vowel(word: String) -> String {\n   |           \
    \                              ------ expected `String` because of return type\n\
    ...\n29 | /    "
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels: Vec<_> = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    for vowel\
    \ in vowels {\n        match word.rfind(vowel) {\n            None => continue,\n\
    \            Some(index) => return word.to_string() + vowel.to_string(),\n   \
    \     }\n    }\n    word.to_string()\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphknfq_7o.rs:20:54\n   |\n\
    20 |             Some(index) => return word.to_string() + vowel.to_string(),\n\
    \   |                                                      ^^^^^^^^^^^^^^^^^\n\
    \   |                                                      |\n   |           \
    \                                           expected `&str`, found struct `String`\n\
    \   |                                                      help: consider borrowing\
    \ here: `&vowel.to_string()`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowel_start = word.chars().skip(1).count();\n    let mut vowel_end = word.chars().skip_while(|c|\
    \ !c.is_ascii_lowercase()).count();\n    let mut pos = word.reverse().find_first_not_ascii_lowercase();\n\
    \n    while vowel_start < vowel_end && pos > 0 {\n        if pos == vowel_start\
    \ {\n            vowel_start = word.chars().skip(1).count();\n            continue;\n\
    \        }\n        if pos == vowel_end {\n            vowel_end = word.chars().skip_while(|c|\
    \ !c.is_ascii_lowercase()).count();\n            continue;\n        }\n      \
    \  if word.chars()[pos].is_ascii_lowercase() {\n            vowel_start = word.chars().skip(1).count();\n\
    \            vowel_end = word.chars().skip_while(|c| !c.is_ascii_lowercase()).count();\n\
    \            pos = word.reverse().find_first_not_ascii_lowercase();\n        \
    \    continue;\n        }\n        pos = word.reverse().find_first_not_ascii_lowercase();\n\
    \    }\n    word.chars().take(vowel_start)\n        .iter()\n        .cloned()\n\
    \        .find(|&c| c.is_ascii_lowercase())\n        .unwrap_or(\"\")\n}\n\nfn\
    \ main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpcg7kq0ee.rs:18:24\n   |\n18 |     let mut pos =\
    \ word.reverse().find_first_not_ascii_lowercase();\n   |                     \
    \   ^^^^^^^ help: there is an associated function with a similar name: `reserve`\n\
    \nerror[E0608]: cannot index into a value of type `Chars<'_>`\n  --> /tmp/tmpcg7kq0ee.rs:29:12\n\
    \   |\n29 |         if word.chars()[pos].is_ascii_lowercase() {\n   |        \
    \    ^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `reverse` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmpcg7kq0ee.rs:32:24\n   |\n32 | \
    \            pos = word.reverse().find_first_not_ascii_lowercase();\n   |    \
    \                    ^^^^^^^ help: there is an associated function with a similar\
    \ name: `reserve`\n\nerror[E0599]: no method named `reverse` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmpcg7kq0ee.rs:35:20\n   |\n35 | \
    \        pos = word.reverse().find_first_not_ascii_lowercase();\n   |        \
    \            ^^^^^^^ help: there is an associated function with a similar name:\
    \ `reserve`\n\nerror[E0599]: no method named `iter` found for struct `std::iter::Take`\
    \ in the current scope\n  --> /tmp/tmpcg7kq0ee.rs:38:10\n   |\n38 |         .iter()\n\
    \   |          ^^^^ private field, not a method\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0599, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    if\
    \ word.length() > 2 && !word[word.len() - 1].is_ascii_lower() && !word[word.len()\
    \ - 2].is_ascii_lower() {\n        String::from(\"\");\n    } else {\n       \
    \ let mut index = 0;\n        let mut vowels = HashMap::new();\n        for c\
    \ in word.chars() {\n            if let Some(key) = vowels.binary_search_by(|&k|\
    \ {\n                k\n            }) {\n                if key.checked_sub(&c).is_ok()\
    \ {\n                    return String::from(\"\");\n                }\n     \
    \       } else {\n                index += 1;\n                let key = String::from(format!(\"\
    {}{}\", index, c));\n                vowels.insert(key, c).unwrap();\n       \
    \     }\n        }\n\n        let mut last_index = word.len() - 1;\n        let\
    \ mut last_vowel = String::from(\"\");\n        for c in word.chars().rev() {\n\
    \            if let Some(key) = vowels.binary_search_by(|&k| {\n             \
    \   k\n            }) {\n                if key.checked_sub(&c).is_ok() {\n  \
    \                  if last_index == 0 {\n                        last_vowel =\
    \ String::from(\"\");\n                    } else {\n                        last_vowel\
    \ = String::from(key.to_string());\n                    }\n                  \
    \  return last_vowel;\n                }\n            } else {\n             \
    \   if last_index == 0 {\n                    last_vowel = String::from(\"\");\n\
    \                } else {\n                    last_vowel = String::from(format!(\"\
    {}{}\", last_index, c));\n                }\n            }\n            last_index\
    \ = c;\n        }\n        last_vowel\n    }\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp6apz_c6s.rs:20:26\n   |\n20 |         let mut vowels = HashMap::new();\n\
    \   |                          ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0599]:\
    \ no method named `length` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmp6apz_c6s.rs:16:13\n   |\n16 |     if word.length() > 2 && !word[word.len()\
    \ - 1].is_ascii_lower() && !word[word.len() - 2].is_ascii_lower() {\n   |    \
    \         ^^^^^^ help: there is an associated function with a similar name: `len`\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp6apz_c6s.rs:16:30\n\
    \   |\n16 |     if word.length() > 2 && !word[word.len() - 1].is_ascii_lower()\
    \ && !word[word.len() - 2].is_ascii_lower() {\n   |                          \
    \    ^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp6apz_c6s.rs:16:72\n   |\n16 |     if word.length() > 2 && !word[word.len()\
    \ - 1].is_ascii_lower() && !word[word.len() - 2].is_ascii_lower() {\n   |    \
    \                                                                    ^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \   "
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels: Vec<&str> = vec![\"a\", \"e\", \"i\", \"o\", \"u\", \"y\"];\n  \
    \  let mut len = word.len();\n    while len > 0 {\n        let mut cur_pos = word.len()\
    \ - 1;\n        let mut cur_char = word[cur_pos].to_lowercase();\n        let\
    \ mut vowel_found = false;\n        while !vowel_found && cur_pos >= 0 {\n   \
    \         cur_pos += 1;\n            cur_char = word[cur_pos].to_lowercase();\n\
    \            if cur_char == vowels.last() {\n                vowel_found = true;\n\
    \            } else {\n                let idx = vowels.binary_search(cur_char);\n\
    \                if idx >= 0 {\n                    let (idx, next_idx) = idx;\n\
    \                    cur_pos = next_idx + 1;\n                } else {\n     \
    \               return String::from(\"\");\n                }\n            }\n\
    \        }\n        len -= 1;\n    }\n    return String::from(\"\");\n}\n\nfn\
    \ main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpikfx1fam.rs:20:28\n\
    \   |\n20 |         let mut cur_char = word[cur_pos].to_lowercase();\n   |   \
    \                         ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpikfx1fam.rs:24:24\n   |\n24 |             cur_char = word[cur_pos].to_lowercase();\n\
    \   |                        ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: can't compare `&&str` with `Option<&&str>`\n  -->\
    \ /tmp/tmpikfx1fam.rs:25:25\n   |\n25 |             if cur_char == vowels.last()\
    \ {\n   |                         ^^ no implementation for `&&str == Option<&&str>`\n\
    \   |\n   = help: the trait `PartialEq<Option<&&str>>` is not implemented for\
    \ `&&str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n         "
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = \"aeiouAEIOU\".chars();\n    vowels.next();\n    let mut consonants\
    \ = word.chars();\n    vowels.next();\n    let mut index = word.nth_chars().unwrap();\n\
    \    if index >= word.len() {\n        return String::from(\"\");\n    }\n   \
    \ while !consonants.next().unwrap().is_ascii_uppercase() && !consonants.next().unwrap().is_ascii_lowercase()\
    \ {\n        index = index - 1;\n    }\n    while !consonants.next().unwrap().is_ascii_uppercase()\
    \ {\n        index = index - 1;\n    }\n    if index >= word.len() {\n       \
    \ return String::from(\"\");\n    }\n    let mut start = index;\n    if word.chars().next().unwrap().is_ascii_uppercase()\
    \ {\n        start = 1;\n    }\n    while start < word.len() {\n        let mut\
    \ end = index;\n        if word.chars().next().unwrap().is_ascii_uppercase() {\n\
    \            end = 1;\n        }\n        if start < word.len() {\n          \
    \  while consonants.next().unwrap().is_ascii_uppercase() {\n                end\
    \ = end + 1;\n            }\n        }\n        start = start - 1;\n        if\
    \ end > word.len() {\n            end = word.len();\n        }\n        if end\
    \ == 0 {\n            break;\n        }\n        \n        if consonants.next().unwrap().is_ascii_uppercase()\
    \ {\n            if vowels.next().unwrap().is_ascii_uppercase() {\n          \
    \      return word.chars().nth(end - 1).unwrap();\n            }\n        }\n\
    \        index = end + 1;\n    }\n    return String::from(\"\");\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `nth_chars` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmpxgl1dndw.rs:20:26\n   |\n20 |     let mut index\
    \ = word.nth_chars().unwrap();\n   |                          ^^^^^^^^^ help:\
    \ there is an associated function with a similar name: `chars`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpxgl1dndw.rs:57:24\n   |\n57 |              \
    \   return word.chars().nth(end - 1).unwrap();\n   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \      |\n   |                        expected struct `String`, found `char`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut left = word.chars().rposition(|c| !c.is_ascii_lowercase());\n    let mut\
    \ right = word.chars().rposition(|c| !c.is_ascii_lowercase());\n    if left ==\
    \ word.chars().rposition(|c| !c.is_ascii_lowercase()) || right == word.chars().rposition(|c|\
    \ !c.is_ascii_lowercase()) {\n        \"\".to_string()\n    } else {\n       \
    \ if left+1 < right {\n            word.chars().nth(left+1).unwrap().to_string()\n\
    \        } else {\n            word.chars().nth(right-1).unwrap().to_string()\n\
    \        }\n    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \    --> /tmp/tmpgq29u776.rs:16:33\n     |\n16   |     let mut left = word.chars().rposition(|c|\
    \ !c.is_ascii_lowercase());\n     |                                 ^^^^^^^^^\
    \ the trait `ExactSizeIterator` is not implemented for `Chars<'_>`\n     |\n \
    \    = help: the following other types implement trait `ExactSizeIterator`:\n\
    \               &mut I\n               Args\n               ArgsOs\n         \
    \      ArrayChunks<'_, T, N>\n               ArrayChunksMut<'_, T, N>\n      \
    \         ArrayWindows<'_, T, N>\n               Box<I, A>\n               Chunks<'_,\
    \ T>\n             and 109 others\nnote: required by a bound in `rposition`\n\n\
    error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \    --> /tmp/tmpgq29u776.rs:17:34\n     |\n17   |     let mut right = word.chars().rposition(|c|\
    \ !c.is_ascii_lowercase());\n     |                                  ^^^^^^^^^\
    \ the trait `ExactSizeIterator` is not implemented for `Chars<'_>`\n     |\n \
    \    = help: the following other types implement trait `ExactSizeIterator`:\n\
    \               &mut I\n               Args\n               ArgsOs\n         \
    \      ArrayChunks<'_, T, N>\n               ArrayChunksMut<'_, T, N>\n      \
    \         ArrayWindows<'_, T, N>\n               Box<I, A>\n               Chunks<'_,\
    \ T>\n             and 109 others\nnote: required by a bound in `rposition`\n\n\
    error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \    --> /tmp/tmpgq29u776.rs:18:29\n     |\n18   |     if left == word.chars().rposition(|c|\
    \ !c.is_ascii_lowercase()) || right == word.chars().rposition(|c| !c.is_ascii_lowercase())\
    \ {\n     |                             ^^^^^^^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n     |\n     = help: the following other\
    \ types implement trait `ExactSizeIterator`:\n               &mut I\n        \
    \       Args\n               ArgsOs\n               ArrayChunks<'_, T, N>\n  \
    \             ArrayChunksMut<'_, T, N>\n               ArrayWindows<'_, T, N>\n\
    \               Box<"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    use\
    \ std::cmp::Ordering;\n\n    let mut prev_char = None;\n    let mut cur_char =\
    \ None;\n\n    let mut cur_index = -1;\n    let mut prev_index = -1;\n\n    let\
    \ mut last_vowel = None;\n\n    for (index, ch) in word.chars().enumerate() {\n\
    \        if prev_char == Some(ch) {\n            // Consonant\n            if\
    \ last_vowel == Some(prev_char) {\n                cur_index += 1;\n         \
    \   } else {\n                let vowel_str = prev_char.to_string();\n       \
    \         if cur_index == 0 {\n                    last_vowel = Some(prev_char);\n\
    \                } else {\n                    let vowel_str = last_vowel.to_string();\n\
    \                    if vowel_str.len() == 1 {\n                        return\
    \ vowel_str.to_string();\n                    } else {\n                     \
    \   let vowel_str = prev_char.to_string();\n                        let vowel_str\
    \ = vowel_str + &vowel_str[1..];\n                        return vowel_str.to_string();\n\
    \                    }\n                }\n            }\n        } else {\n \
    \           // Vowel\n            if cur_char == Some(ch) {\n                prev_index\
    \ += 1;\n            } else {\n                let vowel_str = cur_char.to_string();\n\
    \                if prev_index == 0 {\n                    last_vowel = Some(cur_char);\n\
    \                } else {\n                    let vowel_str = last_vowel.to_string();\n\
    \                    if vowel_str.len() == 1 {\n                        return\
    \ vowel_str.to_string();\n                    } else {\n                     \
    \   let vowel_str = cur_char.to_string();\n                        let vowel_str\
    \ = vowel_str + &vowel_str[1..];\n                        return vowel_str.to_string();\n\
    \                    }\n                }\n            }\n        }\n\n      \
    \  prev_char = Some(ch);\n        cur_char = Some(ch);\n    }\n\n    \"\".to_string()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "warning: unused import: `std::cmp::Ordering`\n  --> /tmp/tmpredhw_tj.rs:16:9\n\
    \   |\n16 |     use std::cmp::Ordering;\n   |         ^^^^^^^^^^^^^^^^^^\n   |\n\
    \   = note: `#[warn(unused_imports)]` on by default\n\nerror[E0599]: `Option<char>`\
    \ doesn't implement `std::fmt::Display`\n   --> /tmp/tmpredhw_tj.rs:32:43\n  \
    \  |\n32  |                   let vowel_str = prev_char.to_string();\n    |  \
    \                                           ^^^^^^^^^ `Option<char>` cannot be\
    \ formatted with the default formatter\n    |\n    = note: the following trait\
    \ bounds were not satisfied:\n            `Option<char>: std::fmt::Display`\n\
    \            which is required by `Option<char>: ToString`\n\nerror[E0599]: `Option<Option<char>>`\
    \ doesn't implement `std::fmt::Display`\n   --> /tmp/tmpredhw_tj.rs:36:48\n  \
    \  |\n36  |                       let vowel_str = last_vowel.to_string();\n  \
    \  |                                                  ^^^^^^^^^ `Option<Option<char>>`\
    \ cannot be formatted with the default formatter\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `Option<Option<char>>: std::fmt::Display`\n\
    \            which is required by `Option<Option<char>>: ToString`\n\nerror[E0599]:\
    \ `Option<char>` doesn't implement `std::fmt::Display`\n   --> /tmp/tmpredhw_tj.rs:40:51\n\
    \    |\n40  |                           let vowel_str = prev_char.to_string();\n\
    \    |                                                     ^^^^^^^^^ `Option<char>`\
    \ cannot be formatted with the default formatter\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `Option<char>: std::fmt::Display`\n\
    \            which is required by `Option<char>: ToString`\n\nerror[E0599]: `Option<char>`\
    \ doesn't implement `std::fmt::Display`\n   --> /tmp/tmpredhw_tj.rs:51:42\n  \
    \  |\n51  |                   let vowel_str = cur_char.to_string();\n    |   \
    \                                         ^^^^^^^^^ `Option<char>` cannot be formatted\
    \ with the default formatter\n    |\n    = note: the following trait bounds were\
    \ not satisfied:\n            `Option<char>: std::fmt::Display`\n    "
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    word.chars()\n\
    \        .skip(2)\n        .filter(|c| c.to_lowercase() == c)\n        .take_while(|c|\
    \ c.is_vowel())\n        .map(|c| c.to_uppercase())\n        .collect()\n}\n\n\
    fn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: binary operation `==` cannot be applied to type `ToLowercase`\n\
    \  --> /tmp/tmp861fzhct.rs:18:38\n   |\n18 |         .filter(|c| c.to_lowercase()\
    \ == c)\n   |                     ---------------- ^^ - &char\n   |          \
    \           |\n   |                     ToLowercase\n\nerror[E0599]: no method\
    \ named `is_vowel` found for reference `&char` in the current scope\n  --> /tmp/tmp861fzhct.rs:19:27\n\
    \   |\n19 |         .take_while(|c| c.is_vowel())\n   |                      \
    \     ^^^^^^^^ method not found in `&char`\n\nerror[E0277]: a value of type `String`\
    \ cannot be built from an iterator over elements of type `ToUppercase`\n    -->\
    \ /tmp/tmp861fzhct.rs:21:10\n     |\n21   |         .collect()\n     |       \
    \   ^^^^^^^ value of type `String` cannot be built from `std::iter::Iterator<Item=ToUppercase>`\n\
    \     |\n     = help: the trait `FromIterator<ToUppercase>` is not implemented\
    \ for `String`\n     = help: the following other types implement trait `FromIterator<A>`:\n\
    \               <String as FromIterator<&'a char>>\n               <String as\
    \ FromIterator<&'a str>>\n               <String as FromIterator<Box<str>>>\n\
    \               <String as FromIterator<Cow<'a, str>>>\n               <String\
    \ as FromIterator<String>>\n               <String as FromIterator<char>>\nnote:\
    \ required by a bound in `collect`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0369, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut index = 0;\n    let mut current = 0;\n    let mut index1 = 0;\n    let mut\
    \ current1 = 0;\n    let mut index2 = 0;\n    let mut current2 = 0;\n    while\
    \ index < word.len() {\n        index1 = word.len() - index;\n        index2 =\
    \ word.len() - index1;\n        current1 = word[index1] as char;\n        current2\
    \ = word[index2] as char;\n        current = word[index] as char;\n        if\
    \ current == 'a' || current == 'e' || current == 'i' || current == 'o' || current\
    \ == 'u' || current == 'A' || current == 'E' || current == 'I' || current == 'O'\
    \ || current == 'U' {\n            index = index + 1;\n            continue;\n\
    \        }\n        if current2 > current1 {\n            index = index + 1;\n\
    \            continue;\n        }\n        return String::new();\n    }\n    return\
    \ String::from();\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpgrkyo4eh.rs:25:20\n\
    \   |\n25 |         current1 = word[index1] as char;\n   |                   \
    \ ^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgrkyo4eh.rs:25:20\n\
    \   |\n19 |     let mut current1 = 0;\n   |                        - expected\
    \ due to this value\n...\n25 |         current1 = word[index1] as char;\n   |\
    \                    ^^^^^^^^^^^^^^^^^^^^ expected integer, found `char`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpgrkyo4eh.rs:26:20\n\
    \   |\n26 |         current2 = word[index2] as char;\n   |                   \
    \ ^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgrkyo4eh.rs:26:20\n\
    \   |\n21 |     let mut current2 = 0;\n   |                        - expected\
    \ due to this value\n...\n26 |         current2 = word[index2] as char;\n   |\
    \                    ^^^^^^^^^^^^^^^^^^^^ expected integer, found `char`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpgrkyo4eh.rs:27:19\n\
    \ "
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec!['I', 'E', 'O', 'U'];\n    let mut counter = 0;\n    for i\
    \ in word[..].chars() {\n        if vowels.contains(&i) && vowels.iter().any(|&y|\
    \ y == i as char) {\n            counter++;\n        } else if counter > 1 &&\
    \ i != ' ' {\n            return String::new();\n        }\n    }\n    String::new()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmprr7z3m29.rs:20:20\n\
    \   |\n20 |             counter++;\n   |                    ^^ not a valid postfix\
    \ operator\n   |\nhelp: use `+= 1` instead\n   |\n20 |             { let tmp =\
    \ counter; counter += 1; tmp };\n   |             +++++++++++        ~~~~~~~~~~~~~~~~~~~~~\n\
    20 -             counter++;\n20 +             counter += 1;\n   | \n\nerror: aborting\
    \ due to previous error\n\n"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut consonant_index = 0;\n    let mut vowel_index = 0;\n    let mut shortest_distance:\
    \ isize = 0;\n    let mut shortest_vowel_letter = String::new();\n    let mut\
    \ shortest_vowel_letter_index = -1;\n    let mut current_vowel = String::from(\"\
    u\");\n    for &c in word.chars() {\n        if consonant_index < word.len() &&\
    \ c == word.chars().nth(consonant_index + 1) {\n            consonant_index =\
    \ consonant_index + 1;\n            current_vowel = String::from(current_vowel.clone());\n\
    \        } else {\n            if vowel_index < current_vowel.len() && current_vowel\
    \ == word.chars().nth(vowel_index + 1) {\n                vowel_index = vowel_index\
    \ + 1;\n            }\n        }\n        if shortest_distance < vowel_index -\
    \ consonant_index {\n            shortest_distance = vowel_index - consonant_index;\n\
    \            shortest_vowel_letter = current_vowel;\n            shortest_vowel_letter_index\
    \ = vowel_index;\n        }\n    }\n    shortest_vowel_letter\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpur1e_vw8.rs:22:9\n   |\n\
    22 |     for &c in word.chars() {\n   |         ^^    ------------ this expression\
    \ has type `Option<char>`\n   |         |\n   |         expected `char`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `c`\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\n\n\
    error[E0277]: can't compare `String` with `Option<char>`\n  --> /tmp/tmpur1e_vw8.rs:27:67\n\
    \   |\n27 |             if vowel_index < current_vowel.len() && current_vowel\
    \ == word.chars().nth(vowel_index + 1) {\n   |                               \
    \                                    ^^ no implementation for `String == Option<char>`\n\
    \   |\n   = help: the trait `PartialEq<Option<char>>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpur1e_vw8.rs:31:32\n   |\n31 |         if shortest_distance\
    \ < vowel_index - consonant_index {\n   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n31 |         if\
    \ shortest_distance < (vowel_index - consonant_index).try_into().unwrap() {\n\
    \   |                                +                             +++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpur1e_vw8.rs:32:33\n   |\n18 |\
    \     let mut shortest_distance: isize = 0;\n   |                            \
    \    ----- expected due to this type\n...\n32 |             shortest_distance\
    \ = vowel_index - consonant_index;\n   |                                 ^^^^^^^^^"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels: Vec<&'static str> = vec![\n        \"a\", \"e\", \"i\", \"o\", \"\
    u\", \"A\", \"E\", \"I\", \"O\", \"U\", \"A\", \"E\", \"I\", \"O\", \"U\",\n \
    \       \"a\", \"e\", \"i\", \"o\", \"u\", \"a\", \"e\", \"i\", \"o\", \"u\",\
    \ \"e\", \"i\", \"o\", \"u\",\n        \"a\", \"e\", \"i\", \"o\", \"u\", \"A\"\
    , \"E\", \"I\", \"O\", \"U\", \"a\", \"e\", \"i\", \"o\", \"u\",\n        \"a\"\
    , \"e\", \"i\", \"o\", \"u\", \"e\", \"i\", \"o\", \"u\", \"i\", \"o\", \"u\"\
    , \"A\", \"E\", \"I\", \"O\",\n        \"U\", \"a\", \"e\", \"i\", \"o\", \"u\"\
    , \"a\", \"e\", \"i\", \"o\", \"u\", \"e\", \"i\", \"o\", \"u\",\n    ];\n   \
    \ vowels.sort();\n    let mut current_vowels: Vec<&'static str> = vec![\"a\",\
    \ \"e\", \"i\", \"o\", \"u\"];\n    let mut current_index: usize = 0;\n    let\
    \ mut current_vowel_len = vowels.len();\n    while current_vowel_len > 0 && current_index\
    \ < word.len() {\n        if current_vowel_len >= 2 && word[current_index] ==\
    \ vowels[current_vowel_len - 2] {\n            current_vowel_len = current_vowel_len\
    \ - 2;\n            current_vowels.push(vowels[current_vowel_len]);\n        }\
    \ else {\n            current_index += 1;\n        }\n    }\n    if current_vowel_len\
    \ > 0 {\n        if current_index == word.len() {\n            return String::from(\"\
    \");\n        }\n        let current_vowel = current_vowels[current_vowel_len\
    \ - 1];\n        let mut last_vowel = current_vowels[current_vowel_len - 2];\n\
    \        while current_vowel != last_vowel {\n            last_vowel = current_vowel;\n\
    \            current_vowel = current_vowels[current_vowel_len - 2];\n        }\n\
    \        return String::from(current_vowel);\n    } else {\n        return String::from(\"\
    \");\n    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpcubanv2r.rs:28:38\n\
    \   |\n28 |         if current_vowel_len >= 2 && word[current_index] == vowels[current_vowel_len\
    \ - 2] {\n   |                                      ^^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut i = word.len();\n    while i >= 0 && is_vowel(&word[i..]) {\n        i--;\n\
    \    }\n    word.to_owned()[i as usize..].chars().next().unwrap()\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmphy1_qcvv.rs:18:12\n\
    \   |\n18 |         i--;\n   |            ^ expected expression\n\nerror[E0425]:\
    \ cannot find function `is_vowel` in this scope\n  --> /tmp/tmphy1_qcvv.rs:17:21\n\
    \   |\n17 |     while i >= 0 && is_vowel(&word[i..]) {\n   |                 \
    \    ^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmphy1_qcvv.rs:20:5\n   |\n15 | fn get_closest_vowel(word: String) -> String\
    \ {\n   |                                       ------ expected `String` because\
    \ of return type\n...\n20 |     word.to_owned()[i as usize..].chars().next().unwrap()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |     |\n   |     expected struct `String`,\
    \ found `char`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0425.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut iter = word.chars().rposition(|x| x.is_vowel());\n    if iter == word.chars().len()\
    \ {\n        return String::from(\"\");\n    }\n    let mut vowel = String::from(\"\
    \");\n    iter += 1;\n    while iter != word.chars().rposition(|x| x.is_vowel())\
    \ {\n        if iter.index() - word.chars().rposition(|x| x.is_vowel()) <= 2 {\n\
    \            return vowel;\n        }\n        vowel = vowel.clone();\n      \
    \  iter += 1;\n    }\n    vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \    --> /tmp/tmpywwxbpyg.rs:16:33\n     |\n16   |     let mut iter = word.chars().rposition(|x|\
    \ x.is_vowel());\n     |                                 ^^^^^^^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n     |\n     = help: the following other\
    \ types implement trait `ExactSizeIterator`:\n               &mut I\n        \
    \       Args\n               ArgsOs\n               ArrayChunks<'_, T, N>\n  \
    \             ArrayChunksMut<'_, T, N>\n               ArrayWindows<'_, T, N>\n\
    \               Box<I, A>\n               Chunks<'_, T>\n             and 109\
    \ others\nnote: required by a bound in `rposition`\n\nerror[E0599]: no method\
    \ named `is_vowel` found for type `char` in the current scope\n  --> /tmp/tmpywwxbpyg.rs:16:49\n\
    \   |\n16 |     let mut iter = word.chars().rposition(|x| x.is_vowel());\n   |\
    \                                                 ^^^^^^^^ method not found in\
    \ `char`\n\nerror[E0599]: no method named `len` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmpywwxbpyg.rs:17:29\n   |\n17 |     if iter == word.chars().len()\
    \ {\n   |                             ^^^ method not found in `Chars<'_>`\n\n\
    error[E0368]: binary assignment operation `+=` cannot be applied to type `Option<usize>`\n\
    \  --> /tmp/tmpywwxbpyg.rs:21:5\n   |\n21 |     iter += 1;\n   |     ----^^^^^\n\
    \   |     |\n   |     cannot use `+=` on type `Option<usize>`\n\nerror[E0277]:\
    \ the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n    --> /tmp/tmpywwxbpyg.rs:22:32\n\
    \     |\n22   |     while iter != word.chars().rposition(|x| x.is_vowel()) {\n\
    \     |                                ^^^^^^^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n     |\n     = help: the following other\
    \ types implement trait `ExactSizeIterator`:\n               &mut I\n        \
    \       Args\n               ArgsOs\n               ArrayChunks<'_, T, N>\n  \
    \             ArrayChunksMut<'_, T, N>\n               ArrayWindows<'_, T, N>\n\
    \               Box<I, A>\n               Chunks<'_, T>\n             "
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = \"AEIOUaeiou\".chars().collect::<Vec<char>>();\n    vowels.sort();\n\
    \    let mut current_vowel = vowels.len() - 1;\n    for &c in word.chars() {\n\
    \        if c.is_uppercase() {\n            current_vowel += 1;\n        }\n \
    \       if c == 'U' {\n            current_vowel -= 1;\n        }\n        if\
    \ current_vowel == -1 {\n            return String::new();\n        }\n      \
    \  if current_vowel == 0 && c == 'U' {\n            current_vowel -= 1;\n    \
    \    }\n        if current_vowel == 0 && c == 'a' {\n            current_vowel\
    \ += 1;\n        }\n        if current_vowel == 0 && c == 'A' {\n            current_vowel\
    \ += 1;\n        }\n    }\n    if current_vowel == -1 {\n        return String::new();\n\
    \    }\n    if current_vowel == 0 && c == 'a' {\n        current_vowel -= 1;\n\
    \    }\n    if current_vowel == 0 && c == 'A' {\n        current_vowel -= 1;\n\
    \    }\n    vowels[current_vowel]\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `c` in this scope\n  --> /tmp/tmpzx12bl4l.rs:42:30\n\
    \   |\n42 |     if current_vowel == 0 && c == 'a' {\n   |                    \
    \          ^ not found in this scope\n\nerror[E0425]: cannot find value `c` in\
    \ this scope\n  --> /tmp/tmpzx12bl4l.rs:45:30\n   |\n45 |     if current_vowel\
    \ == 0 && c == 'A' {\n   |                              ^ not found in this scope\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpzx12bl4l.rs:19:9\n   |\n19 | \
    \    for &c in word.chars() {\n   |         ^^    ------------ this expression\
    \ has type `Option<char>`\n   |         |\n   |         expected `char`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `c`\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\n\n\
    error[E0600]: cannot apply unary operator `-` to type `usize`\n  --> /tmp/tmpzx12bl4l.rs:26:29\n\
    \   |\n26 |         if current_vowel == -1 {\n   |                           \
    \  ^^\n   |                             |\n   |                             cannot\
    \ apply unary operator `-`\n   |                             help: you may have\
    \ meant the maximum value of `usize`: `usize::MAX`\n   |\n   = note: unsigned\
    \ values cannot be negated\n\nerror[E0600]: cannot apply unary operator `-` to\
    \ type `usize`\n  --> /tmp/tmpzx12bl4l.rs:39:25\n   |\n39 |     if current_vowel\
    \ == -1 {\n   |                         ^^\n   |                         |\n \
    \  |                         cannot apply unary operator `-`\n   |           \
    \              help: you may have meant the maximum value of `usize`: `usize::MAX`\n\
    \   |\n   = note: unsigned values cannot be negated\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpzx12bl4l.rs:48:5\n   |\n15 | fn get_closest_vowel(word:\
    \ String) -> String {\n   |                                       ------ expected\
    \ `String` because of return type\n...\n48 |     vowels[current_vowel]\n   | \
    \    ^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |     |\n   |     expected struct `String`, found `char`\n\nerror: aborting\
    \ due to 6 previous errors\n\nSome errors have detailed e"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    \n\
    \    if word.len() == 0 {\n        return String::from(\"\");\n    }\n    \n \
    \   let mut pos = word.len();\n    \n    for letter in word.chars().skip_while(|c|\
    \ *c != 'a' && *c != 'e' && *c != 'i' && *c != 'o' && *c != 'u') {\n        let\
    \ mut curr_pos = pos;\n        for _ in 0..3 {\n            pos = pos - 1;\n \
    \           if pos < word.len() {\n                if let Some(v) = word[pos].as_ref()\
    \ {\n                    if let Some(vowel) = (*v as char).to_uppercase() {\n\
    \                        break;\n                    }\n                }\n  \
    \          }\n        }\n        if pos == word.len() {\n            return String::from(\"\
    \");\n        }\n        \n        let mut curr_word = word;\n        \n     \
    \   let mut prev_vowel = String::from(\"\");\n        for _ in 0..3 {\n      \
    \      curr_word = curr_word.chars().next().unwrap().to_string();\n          \
    \  if let Some(v) = curr_word.chars().skip_while(|c| *c != 'a' && *c != 'e' &&\
    \ *c != 'i' && *c != 'o' && *c != 'u') {\n                if let Some(vowel) =\
    \ (*v as char).to_uppercase() {\n                    if curr_pos == 0 {\n    \
    \                    prev_vowel = vowel;\n                    } else {\n     \
    \                   if prev_vowel == vowel {\n                            break;\n\
    \                        }\n                    }\n                }\n       \
    \     }\n        }\n        if prev_vowel == String::from(\"\") {\n          \
    \  return String::from(\"\");\n        }\n    }\n    \n    return String::from(prev_vowel);\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `prev_vowel` in this scope\n  --> /tmp/tmpr3qnmos7.rs:61:25\n\
    \   |\n61 |     return String::from(prev_vowel);\n   |                       \
    \  ^^^^^^^^^^ not found in this scope\n\nerror[E0277]: the type `String` cannot\
    \ be indexed by `usize`\n  --> /tmp/tmpr3qnmos7.rs:28:34\n   |\n28 |         \
    \        if let Some(v) = word[pos].as_ref() {\n   |                         \
    \         ^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpr3qnmos7.rs:44:20\n\
    \   |\n44 |             if let Some(v) = curr_word.chars().skip_while(|c| *c !=\
    \ 'a' && *c != 'e' && *c != 'i' && *c != 'o' && *c != 'u') {\n   |           \
    \         ^^^^^^^   -----------------------------------------------------------------------------------------------\n\
    \   |                    |         |                            |\n   |      \
    \              |         |                            the expected closure\n \
    \  |                    |         this expression has type `SkipWhile<Chars<'_>,\
    \ [closure@/tmp/tmpr3qnmos7.rs:44:59: 44:124]>`\n   |                    expected\
    \ struct `SkipWhile`, found enum `Option`\n   |\n   = note: expected struct `SkipWhile<Chars<'_>,\
    \ [closure@/tmp/tmpr3qnmos7.rs:44:59: 44:124]>`\n                found enum `Option<_>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0425.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    word.chars().filter_map(|c|\
    \ c.to_ascii_lowercase().is_vowel())\n        .find(|&c| c > 'a')\n        .map(|i|\
    \ word.chars().take_while(|c| c > 'a' && c <= 'z').nth(i))\n        .unwrap_or(\"\
    \")\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpfyt89j4r.rs:16:56\n   |\n16 |     word.chars().filter_map(|c|\
    \ c.to_ascii_lowercase().is_vowel())\n   |                                   \
    \                     ^^^^^^^^ method not found in `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpfyt89j4r.rs:18:50\n   |\n18 |         .map(|i| word.chars().take_while(|c|\
    \ c > 'a' && c <= 'z').nth(i))\n   |                                         \
    \         ^^^\n   |                                                  |\n   | \
    \                                                 expected `&char`, found `char`\n\
    \   |                                                  help: consider borrowing\
    \ here: `&'a'`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfyt89j4r.rs:18:62\n\
    \   |\n18 |         .map(|i| word.chars().take_while(|c| c > 'a' && c <= 'z').nth(i))\n\
    \   |                                                              ^^^\n   | \
    \                                                             |\n   |        \
    \                                                      expected `&char`, found\
    \ `char`\n   |                                                              help:\
    \ consider borrowing here: `&'z'`\n\nerror[E0277]: can't compare `usize` with\
    \ `char`\n  --> /tmp/tmpfyt89j4r.rs:17:22\n   |\n17 |         .find(|&c| c > 'a')\n\
    \   |                      ^ no implementation for `usize < char` and `usize >\
    \ char`\n   |\n   = help: the trait `PartialOrd<char>` is not implemented for\
    \ `usize`\n   = help: the following other types implement trait `PartialOrd<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfyt89j4r.rs:19:20\n\
    \   |\n19 |         .unwrap_or(\"\")\n   |                    ^^ expected enum\
    \ `Option`, found `&str`\n   |\n   = note:   expected enum `Option<char>`\n  \
    \         found reference `&'static str`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpfyt89j4r.rs:16:5\n   |\n15"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels: [usize; 2] = [0; 2];\n    vowels[0] = 0;\n    vowels[1] = word.len();\n\
    \n    let mut index = 1;\n    let mut closest_vowel = String::new();\n\n    while\
    \ vowels[index] != 0 {\n        let mut current = word;\n        current.as_bytes().iter().for_each(|&c|\
    \ {\n            if *c == &vowels[index] {\n                closest_vowel.push(*c);\n\
    \                vowels[index] -= 1;\n                current.clear();\n     \
    \       } else {\n                current.push(*c);\n            }\n        });\n\
    \        index += 1;\n    }\n\n    if vowels[1] == 0 {\n        closest_vowel.clear();\n\
    \    }\n\n    closest_vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `u8` cannot be dereferenced\n  --> /tmp/tmpgbq9txud.rs:26:16\n\
    \   |\n26 |             if *c == &vowels[index] {\n   |                ^^\n\n\
    error[E0614]: type `u8` cannot be dereferenced\n  --> /tmp/tmpgbq9txud.rs:27:36\n\
    \   |\n27 |                 closest_vowel.push(*c);\n   |                    \
    \                ^^\n\nerror[E0614]: type `u8` cannot be dereferenced\n  --> /tmp/tmpgbq9txud.rs:31:30\n\
    \   |\n31 |                 current.push(*c);\n   |                          \
    \    ^^\n\nerror: aborting due to 3 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut left = 0u;\n    let mut right = word.len();\n    let mut ans = String::new();\n\
    \    while left < right {\n        if word[left].is_uppercase() {\n          \
    \  if word[right-1].is_lowercase() {\n                ans = match word[right-1]\
    \ {\n                    'a' => String::from(\"a\"),\n                    'e'\
    \ => String::from(\"e\"),\n                    'i' => String::from(\"i\"),\n \
    \                   'o' => String::from(\"o\"),\n                    'u' => String::from(\"\
    u\"),\n                    'A' => String::from(\"A\"),\n                    'E'\
    \ => String::from(\"E\"),\n                    'I' => String::from(\"I\"),\n \
    \                   'O' => String::from(\"O\"),\n                    'U' => String::from(\"\
    U\"),\n                    _ => String::from(\"\"),\n                };\n    \
    \            left = left + 1;\n                right = left - 1;\n           \
    \ } else if word[right-1].is_uppercase() {\n                ans = match word[right-1]\
    \ {\n                    'a' => String::from(\"a\"),\n                    'e'\
    \ => String::from(\"e\"),\n                    'i' => String::from(\"i\"),\n \
    \                   'o' => String::from(\"o\"),\n                    'u' => String::from(\"\
    u\"),\n                    'A' => String::from(\"A\"),\n                    'E'\
    \ => String::from(\"E\"),\n                    'I' => String::from(\"I\"),\n \
    \                   'O' => String::from(\"O\"),\n                    'U' => String::from(\"\
    U\"),\n                    _ => String::from(\"\"),\n                };\n    \
    \            left = left + 1;\n                right = right - 1;\n          \
    \  } else if word[left].is_lowercase() {\n                ans = match word[left]\
    \ {\n                    'a' => String::from(\"a\"),\n                    'e'\
    \ => String::from(\"e\"),\n                    'i' => String::from(\"i\"),\n \
    \                   'o' => String::from(\"o\"),\n                    'u' => String::from(\"\
    u\"),\n                    'A' => String::from(\"A\"),\n                    'E'\
    \ => String::from(\"E\"),\n                    'I' => String::from(\"I\"),\n \
    \                   'O' => String::from(\"O\"),\n                    'U' => String::from(\"\
    U\"),\n                    _ => String::from(\"\"),\n                };\n    \
    \            right = right - 1;\n            } else {\n                ans = match\
    \ word[right] {\n                    'a' => String::from(\"a\"),\n           \
    \         'e' => String::from(\"e\"),\n                    'i' => String::from(\"\
    i\"),\n                    'o' => String::from(\"o\"),\n}\n\nfn main() {\n   \
    \ let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpaque8jyi.rs:91:3\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n19 |     while left\
    \ < right {\n   |                        - unclosed delimiter\n20 |         if\
    \ word[left].is_uppercase() {\n   |                                      - unclosed\
    \ delimiter\n...\n68 |             } else {\n   |                    - unclosed\
    \ delimiter\n69 |                 ans = match word[right] {\n   |            \
    \                             - this delimiter might not be properly closed...\n\
    ...\n74 | }\n   | - ...as it matches this but it has different indentation\n...\n\
    91 | }\n   |   ^\n\nerror: invalid suffix `u` for number literal\n  --> /tmp/tmpaque8jyi.rs:16:20\n\
    \   |\n16 |     let mut left = 0u;\n   |                    ^^ invalid suffix\
    \ `u`\n   |\n   = help: the suffix must be one of the numeric types (`u32`, `isize`,\
    \ `f32`, etc.)\n\nerror: expected one of `.`, `;`, `?`, `}`, or an operator, found\
    \ keyword `fn`\n  --> /tmp/tmpaque8jyi.rs:15:46\n   |\n15 | fn get_closest_vowel(word:\
    \ String) -> String {\n   |                                              ^ unclosed\
    \ delimiter\n...\n74 | }\n   |  -\n   |  |\n   |  expected one of `.`, `;`, `?`,\
    \ `}`, or an operator\n   |  help: `}` may belong here\n75 | \n76 | fn main()\
    \ {\n   | ^^ unexpected token\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpaque8jyi.rs:21:16\n   |\n21 |             if word[right-1].is_lowercase()\
    \ {\n   |                ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    \n\
    \    let mut word = word;\n    \n    word.chars()\n        .filter_map(|x| {\n\
    \            match x {\n                'a' => Some('e'),\n                'e'\
    \ => Some('i'),\n                'i' => Some('o'),\n                'o' => Some('u'),\n\
    \                'u' => Some('y'),\n                'y' => Some('g'),\n      \
    \          'g' => Some('r'),\n                'r' => Some('p'),\n            \
    \    'p' => Some('t'),\n                't' => Some('s'),\n                's'\
    \ => Some('z'),\n                'z' => Some('k'),\n                'k' => Some('l'),\n\
    \                'l' => Some('h'),\n                'h' => Some('d'),\n      \
    \          'd' => Some('c'),\n                'c' => Some('f'),\n            \
    \    'f' => Some('v'),\n                'v' => Some('B'),\n                'B'\
    \ => Some('N'),\n                'N' => Some('J'),\n                'J' => Some('Z'),\n\
    \                'Z' => Some('L'),\n                'L' => Some('H'),\n      \
    \          'H' => Some('V'),\n                'V' => Some('D'),\n            \
    \    'D' => Some('C'),\n                'C' => Some('F'),\n                'F'\
    \ => Some('V'),\n                'V' => Some('P'),\n                'P' => Some('K'),\n\
    \                'K' => Some('J'),\n                'J' => Some('Z'),\n      \
    \          'Z' => Some('L'),\n                'L' => Some('H'),\n            \
    \    'H' => Some('V'),\n                'V' => Some('D'),\n                'D'\
    \ => Some('C'),\n                'C' => Some('F'),\n                'F' => Some('V'),\n\
    \                'V' => Some('P'),\n                'P' => Some('K'),\n      \
    \          'K' => Some('J'),\n                'J' => Some('Z'),\n            \
    \    'Z' => Some('L'),\n                'L' => Some('H'),\n                'H'\
    \ => Some('V'),\n                'V' => Some('D'),\n                'D' => Some('C'),\n\
    \                'C' => Some('F'),\n                'F' => Some('V'),\n      \
    \          'V' => Some('P'),\n                'P' => Some('K'),\n            \
    \    'K' => Some('J'),\n                'J' => Some('Z'),\n                'Z'\
    \ => Some('L'),\n                'L' => Some('H'),\n                'H' => Some('V'),\n\
    \                'V' => Some('D'),\n                'D' => Some('C'),\n      \
    \          'C' => Some('\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmpak_2by51.rs:82:29\n\
    \   |\n82 |                 'C' => Some('\n   |                             ^\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0762`.\n"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut counter = 0;\n    let mut vowel_index = 0;\n    let mut last_vowel_index\
    \ = 0;\n    let mut letter_counter = 0;\n    let mut last_letter_index = 0;\n\
    \    let mut first_letter_index = 0;\n    let mut next_letter_index = 0;\n   \
    \ \n    for letter in word.as_str().chars().nth(word.len()) {\n        letter_counter\
    \ = letter_counter + 1;\n        \n        if letter == 'a' || letter == 'A' {\n\
    \            if counter == 0 {\n                first_letter_index = letter;\n\
    \            }\n            counter = counter + 1;\n        }\n        \n    \
    \    if letter == 'e' || letter == 'E' {\n            if counter == 0 {\n    \
    \            last_letter_index = letter;\n            }\n            counter =\
    \ counter + 1;\n        }\n        \n        if letter == 'u' || letter == 'U'\
    \ {\n            if counter == 0 {\n                next_letter_index = letter;\n\
    \            }\n            counter = counter + 1;\n        }\n    }\n    \n \
    \   if vowel_index == 0 {\n        return String::from(\"\");\n    }\n    \n \
    \   if letter_counter <= 2 {\n        return String::from(\"\");\n    }\n    \n\
    \    let mut vowel = String::from(\"\");\n    \n    // check first letter\n  \
    \  if vowel_index == first_letter_index {\n        vowel = vowel.clone();\n  \
    \      vowel = vowel.to_string().push_str(&vowel[vowel.len()-1]);\n    }\n   \
    \ \n    // check last letter\n    if vowel_index == last_letter_index {\n    \
    \    vowel = vowel.clone();\n        vowel = vowel.to_string().push_str(&vowel[vowel.len()-1]);\n\
    \    }\n    \n    // check next letter\n    if vowel_index == next_letter_index\
    \ {\n        vowel = vowel.clone();\n        vowel = vowel.to_string().push_str(&vowel[vowel.len()-1]);\n\
    \    }\n    \n    vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpx6pxt6uo.rs:29:38\n   |\n\
    21 |     let mut first_letter_index = 0;\n   |                               \
    \   - expected due to this value\n...\n29 |                 first_letter_index\
    \ = letter;\n   |                                      ^^^^^^ expected integer,\
    \ found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpx6pxt6uo.rs:36:37\n\
    \   |\n20 |     let mut last_letter_index = 0;\n   |                         \
    \        - expected due to this value\n...\n36 |                 last_letter_index\
    \ = letter;\n   |                                     ^^^^^^ expected integer,\
    \ found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpx6pxt6uo.rs:43:37\n\
    \   |\n22 |     let mut next_letter_index = 0;\n   |                         \
    \        - expected due to this value\n...\n43 |                 next_letter_index\
    \ = letter;\n   |                                     ^^^^^^ expected integer,\
    \ found `char`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpx6pxt6uo.rs:62:45\n   |\n62 |         vowel = vowel.to_string().push_str(&vowel[vowel.len()-1]);\n\
    \   |                                             ^^^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpx6pxt6uo.rs:62:17\n\
    \   |\n57 |     let mut vowel = String::from(\"\");\n   |                    \
    \ ---------------- expected due to this value\n...\n62 |         vowel = vowel.to_string().push_str(&vowel[vowel.len()-1]);\n\
    \   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `String`, found `()`\n   |\nn"
  stdout: ''
  timestamp: 1660053309
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    //\
    \ Your code here\n    let mut vowels = Vec::new();\n    vowels.push(String::from(\"\
    a\"));\n    vowels.push(String::from(\"e\"));\n    vowels.push(String::from(\"\
    i\"));\n    vowels.push(String::from(\"o\"));\n    vowels.push(String::from(\"\
    u\"));\n    vowels.push(String::from(\"A\"));\n    vowels.push(String::from(\"\
    E\"));\n    vowels.push(String::from(\"I\"));\n    vowels.push(String::from(\"\
    O\"));\n    vowels.push(String::from(\"U\"));\n\n    let mut current_vowel = String::from(\"\
    \");\n    let mut last_vowel = String::from(\"\");\n\n    for c in word.chars()\
    \ {\n        if c.to_ascii_lowercase() == 'a' {\n            current_vowel = String::from(\"\
    \");\n            last_vowel = String::from(\"\");\n        } else if c.to_ascii_lowercase()\
    \ == 'e' {\n            current_vowel = String::from(\"\");\n            last_vowel\
    \ = String::from(\"\");\n        } else if c.to_ascii_lowercase() == 'i' {\n \
    \           current_vowel = String::from(\"\");\n            last_vowel = String::from(\"\
    \");\n        } else if c.to_ascii_lowercase() == 'o' {\n            current_vowel\
    \ = String::from(\"\");\n            last_vowel = String::from(\"\");\n      \
    \  } else if c.to_ascii_lowercase() == 'u' {\n            current_vowel = String::from(\"\
    \");\n            last_vowel = String::from(\"\");\n        } else if c.to_ascii_lowercase()\
    \ == 'A' {\n            current_vowel = String::from(\"\");\n            last_vowel\
    \ = String::from(\"\");\n        } else if c.to_ascii_lowercase() == 'E' {\n \
    \           current_vowel = String::from(\"\");\n            last_vowel = String::from(\"\
    \");\n        } else if c.to_ascii_lowercase() == 'I' {\n            current_vowel\
    \ = String::from(\"\");\n            last_vowel = String::from(\"\");\n      \
    \  } else if c.to_ascii_lowercase() == 'O' {\n            current_vowel = String::from(\"\
    \");\n            last_vowel = String::from(\"\");\n        } else if c.to_ascii_lowercase()\
    \ == 'U' {\n            current_vowel = String::from(\"\");\n            last_vowel\
    \ = String::from(\"\");\n        } else {\n            let current_vowel = vowels.iter().find(|&vowel|\
    \ vowel == c).unwrap();\n            let last_vowel = vowels.iter().rfind(|&vowel|\
    \ vowel == c).unwrap();\n        }\n\n        if last_vowel > current_vowel {\n\
    \            return String::from(\"\");\n        }\n    }\n    current_vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&String` with `char`\n  --> /tmp/tmpy_xt89dt.rs:64:67\n\
    \   |\n64 |             let current_vowel = vowels.iter().find(|&vowel| vowel\
    \ == c).unwrap();\n   |                                                      \
    \             ^^ no implementation for `&String == char`\n   |\n   = help: the\
    \ trait `PartialEq<char>` is not implemented for `&String`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n\
    \             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0277]: can't compare `&String` with `char`\n\
    \  --> /tmp/tmpy_xt89dt.rs:65:65\n   |\n65 |             let last_vowel = vowels.iter().rfind(|&vowel|\
    \ vowel == c).unwrap();\n   |                                                \
    \                 ^^ no implementation for `&String == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&String`\n   = help: the\
    \ following other types implement trait `PartialEq<Rhs>`:\n             <&'a str\
    \ as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n     \
    \        <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    vowels.sort();\n\
    \    vowels.iter().cloned().find(|w| word.chars().any(|c| w[c] as char == c))\n\
    \        .unwrap_or_else(|| word.to_owned())\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `str` cannot be indexed by `char`\n  --> /tmp/tmptyar00n9.rs:18:58\n\
    \   |\n18 |     vowels.iter().cloned().find(|w| word.chars().any(|c| w[c] as char\
    \ == c))\n   |                                                          ^^^^ string\
    \ indices are ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>`\
    \ is not implemented for `char`\n   = note: required because of the requirements\
    \ on the impl of `Index<char>` for `str`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmptyar00n9.rs:19:28\n   |\n19 |         .unwrap_or_else(|| word.to_owned())\n\
    \   |                            ^^^^^^^^^^^^^^^\n   |                       \
    \     |\n   |                            expected `&str`, found struct `String`\n\
    \   |                            help: consider borrowing here: `&word.to_owned()`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmptyar00n9.rs:18:5\n   |\n15 | \
    \  fn get_closest_vowel(word: String) -> String {\n   |                      \
    \                   ------ expected `String` because of return type\n...\n18 |\
    \ /     vowels.iter().cloned().find(|w| word.chars().any(|c| w[c] as char == c))\n\
    19 | |         .unwrap_or_else(|| word.to_owned())\n   | |                   \
    \                        ^- help: try using a conversion method: `.to_string()`\n\
    \   | |___________________________________________|\n   |                    \
    \                         expected struct `String`, found `&str`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowel_counts: Vec<i32> = vec![];\n    let mut char_counts = word.chars().map(|c|\
    \ c.to_ascii_lowercase().as_bytes()).collect::<Vec<u8>>();\n    let vowel = if\
    \ char_counts.len() == 0 {\n        \"\".to_string()\n    } else if char_counts.iter().any(|&b|\
    \ b == 0x55 || b == 0xAA) {\n        \"a\"\n    } else {\n        \"e\"\n    };\n\
    \n    for &b in &char_counts {\n        if *b == vowel {\n            vowel_counts.push(*b);\n\
    \        }\n    }\n\n    let mut min_count = i32::MAX;\n    let mut min_char_index\
    \ = 0;\n\n    for i in 0..vowel_counts.len() {\n        let count = vowel_counts[i];\n\
    \        if count < min_count {\n            min_count = count;\n            min_char_index\
    \ = i;\n        }\n    }\n\n    word.chars().nth(min_char_index + 1).unwrap()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `as_bytes` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpusstvmrh.rs:17:71\n   |\n17 |     let mut char_counts =\
    \ word.chars().map(|c| c.to_ascii_lowercase().as_bytes()).collect::<Vec<u8>>();\n\
    \   |                                                                       ^^^^^^^^\
    \ method not found in `char`\n\nerror[E0308]: `if` and `else` have incompatible\
    \ types\n  --> /tmp/tmpusstvmrh.rs:20:12\n   |\n18 |        let vowel = if char_counts.len()\
    \ == 0 {\n   |   _________________-\n19 |  |         \"\".to_string()\n   |  |\
    \         -------------- expected because of this\n20 |  |     } else if char_counts.iter().any(|&b|\
    \ b == 0x55 || b == 0xAA) {\n   |  |____________^\n21 | ||         \"a\"\n22 |\
    \ ||     } else {\n23 | ||         \"e\"\n24 | ||     };\n   | ||     ^- help:\
    \ try using a conversion method: `.to_string()`\n   | ||_____|\n   | |______`if`\
    \ and `else` have incompatible types\n   |        expected struct `String`, found\
    \ `&str`\n\nerror[E0614]: type `u8` cannot be dereferenced\n  --> /tmp/tmpusstvmrh.rs:27:12\n\
    \   |\n27 |         if *b == vowel {\n   |            ^^\n\nerror[E0614]: type\
    \ `u8` cannot be dereferenced\n  --> /tmp/tmpusstvmrh.rs:28:31\n   |\n28 |   \
    \          vowel_counts.push(*b);\n   |                               ^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpusstvmrh.rs:43:5\n   |\n15 | fn get_closest_vowel(word:\
    \ String) -> String {\n   |                                       ------ expected\
    \ `String` because of return type\n...\n43 |     word.chars().nth(min_char_index\
    \ + 1).unwrap()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help:\
    \ try using a conversion method: `.to_string()`\n   |     |\n   |     expected\
    \ struct `String`, found `char`\n\nerror: aborting due to 5 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0599, E0614.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053309
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowel_pos: Vec<usize> = vec![];\n    let vowels = vec![\n        'A', 'B',\
    \ 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',\n    \
    \    'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'\n    ];\n    let consonants\
    \ = vec![\n        'B', 'C', 'D', 'F', 'G', 'H', 'J', 'L', 'M', 'N', 'P', 'Q',\
    \ 'R', 'S', 'T', 'W',\n        'Y', 'Z'\n    ];\n    for vowel in vowels.iter()\
    \ {\n        if word.contains(&vowel) {\n            vowel_pos.push(vowels.iter().position(|x|\
    \ x == vowel).unwrap());\n        }\n    }\n    if vowel_pos.len() > 0 {\n   \
    \     let vowel_pos = vowel_pos.iter().max().unwrap() as usize;\n        let vowel\
    \ = vowels[vowel_pos as usize];\n        let consonant_pos = word.rfind(' ').unwrap()\
    \ - 1;\n        let mut current_pos = consonant_pos;\n        while current_pos\
    \ >= 0 {\n            if word.contains(&consonants[current_pos]) {\n         \
    \       if current_pos == 0 {\n                    return String::from(vowel);\n\
    \                } else if current_pos == consonant_pos {\n                  \
    \  current_pos -= 1;\n                } else {\n                    current_pos\
    \ += 1;\n                }\n            } else {\n                current_pos\
    \ -= 1;\n            }\n        }\n    }\n    \"\"\n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmpxxrfy9zf.rs:26:26\n\
    \     |\n26   |         if word.contains(&vowel) {\n     |                 --------\
    \ ^^^^^^ expected an `Fn<(char,)>` closure, found `char`\n     |             \
    \    |\n     |                 required by a bound introduced by this call\n \
    \    |\n     = help: the trait `Fn<(char,)>` is not implemented for `char`\n \
    \    = help: the trait `Pattern<'a>` is implemented for `char`\n     = note: required\
    \ because of the requirements on the impl of `FnOnce<(char,)>` for `&char`\n \
    \    = note: required because of the requirements on the impl of `Pattern<'_>`\
    \ for `&&char`\nnote: required by a bound in `core::str::<impl str>::contains`\n\
    \nerror[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmpxxrfy9zf.rs:36:30\n\
    \     |\n36   |             if word.contains(&consonants[current_pos]) {\n   \
    \  |                     -------- ^^^^^^^^^^^^^^^^^^^^^^^^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n     |                     |\n     |                \
    \     required by a bound introduced by this call\n     |\n     = help: the trait\
    \ `Fn<(char,)>` is not implemented for `char`\n     = note: required because of\
    \ the requirements on the impl of `FnOnce<(char,)>` for `&char`\n     = note:\
    \ required because of the requirements on the impl of `Pattern<'_>` for `&char`\n\
    note: required by a bound in `core::str::<impl str>::contains`\nhelp: consider\
    \ dereferencing here\n     |\n36   |             if word.contains(*&consonants[current_pos])\
    \ {\n     |                              +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpxxrfy9zf.rs:49:5\n   |\n15 | fn get_closest_vowel(word: String)\
    \ -> String {\n   |                                       ------ expected `String`\
    \ because of return type\n...\n49 |     \"\"\n   |     ^^- help: try using a conversion\
    \ method: `.to_string()`\n   |     |\n   |     expected struct `String`, found\
    \ `&str`\n\nerror[E0606]: casting `&usize` as `usize` is invalid\n  --> /tmp/tmpxxrfy9zf.rs:31:25\n\
    \   |\n31 |         let vowel_pos = vowel_pos.iter().max().u"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = HashMap::new();\n    for letter in word.chars().skip(1).filter(|&c|\
    \ c.is_uppercase()) {\n        vowels.entry(letter).or_insert(0);\n    }\n\n \
    \   let vowels_len = vowels.len();\n    let mut index = word.len() - 1;\n    while\
    \ vowels.get(&(word.chars()[index].unwrap())).unwrap() < vowels_len {\n      \
    \  index -= 1;\n    }\n    if index < 0 {\n        return String::new();\n   \
    \ }\n\n    let mut start = index;\n    while vowels.get(&(word.chars()[start].unwrap())).unwrap()\
    \ >= vowels_len {\n        start += 1;\n    }\n\n    let mut end = index;\n  \
    \  while vowels.get(&(word.chars()[end].unwrap())).unwrap() >= vowels_len {\n\
    \        end += 1;\n    }\n    let mut result = String::new();\n    while start\
    \ > 0 || end < word.len() - 1 {\n        if vowels.get(&(word.chars()[start].unwrap())).unwrap()\
    \ < vowels_len {\n            start -= 1;\n        } else {\n            end +=\
    \ 1;\n        }\n\n        if vowels.get(&(word.chars()[end].unwrap())).unwrap()\
    \ < vowels_len {\n            end -= 1;\n        } else {\n            result.push_str(&(word.chars()[start].unwrap()));\n\
    \            start = end;\n        }\n    }\n\n    result\n}\n\nfn main() {\n\
    \    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp9h9f2p61.rs:16:22\n   |\n16 |     let mut vowels = HashMap::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0608]:\
    \ cannot index into a value of type `Chars<'_>`\n  --> /tmp/tmp9h9f2p61.rs:23:24\n\
    \   |\n23 |     while vowels.get(&(word.chars()[index].unwrap())).unwrap() < vowels_len\
    \ {\n   |                        ^^^^^^^^^^^^^^^^^^^\n\nerror[E0608]: cannot index\
    \ into a value of type `Chars<'_>`\n  --> /tmp/tmp9h9f2p61.rs:31:24\n   |\n31\
    \ |     while vowels.get(&(word.chars()[start].unwrap())).unwrap() >= vowels_len\
    \ {\n   |                        ^^^^^^^^^^^^^^^^^^^\n\nerror[E0608]: cannot index\
    \ into a value of type `Chars<'_>`\n  --> /tmp/tmp9h9f2p61.rs:36:24\n   |\n36\
    \ |     while vowels.get(&(word.chars()[end].unwrap())).unwrap() >= vowels_len\
    \ {\n   |                        ^^^^^^^^^^^^^^^^^\n\nerror[E0608]: cannot index\
    \ into a value of type `Chars<'_>`\n  --> /tmp/tmp9h9f2p61.rs:41:25\n   |\n41\
    \ |         if vowels.get(&(word.chars()[start].unwrap())).unwrap() < vowels_len\
    \ {\n   |                         ^^^^^^^^^^^^^^^^^^^\n\nerror[E0608]: cannot\
    \ index into a value of type `Chars<'_>`\n  --> /tmp/tmp9h9f2p61.rs:47:25\n  \
    \ |\n47 |         if vowels.get(&(word.chars()[end].unwrap())).unwrap() < vowels_len\
    \ {\n   |                         ^^^^^^^^^^^^^^^^^\n\nerror[E0608]: cannot index\
    \ into a value of type `Chars<'_>`\n  --> /tmp/tmp9h9f2p61.rs:50:31\n   |\n50\
    \ |             result.push_str(&(word.chars()[start].unwrap()));\n   |      \
    \                         ^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to 7 previous\
    \ errors\n\nSome errors have detailed explanations: E0433, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    if\
    \ word.chars().any(|c| !c.is_letter()) {\n        return String::from(\"\");\n\
    \    }\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let\
    \ mut letter_pos: Vec<usize> = vec![];\n    for letter in word.chars() {\n   \
    \     if letter.is_vowel() {\n            vowels.push(letter);\n        }\n  \
    \      if letter.is_consonant() {\n            letter_pos.push((word.len() - letter.len()\
    \ - 1, letter));\n        }\n    }\n    if letter_pos.is_empty() {\n        return\
    \ String::from(\"\");\n    }\n    let mut min = *letter_pos.last().unwrap();\n\
    \    let mut max = *letter_pos.last().unwrap();\n    for &(index, letter) in letter_pos\
    \ {\n        if index == 0 {\n            continue;\n        }\n        min =\
    \ *letter_pos.last().unwrap();\n        max = *letter_pos.last().unwrap();\n \
    \       if min <= max {\n            if letter == vowels[min] {\n            \
    \    return String::from(vowels[min]);\n            }\n        }\n    }\n    String::from(\"\
    \")\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_letter` found for type `char` in the\
    \ current scope\n  --> /tmp/tmp8aufx658.rs:16:32\n   |\n16 |     if word.chars().any(|c|\
    \ !c.is_letter()) {\n   |                                ^^^^^^^^^ method not\
    \ found in `char`\n\nerror[E0599]: no method named `is_vowel` found for type `char`\
    \ in the current scope\n  --> /tmp/tmp8aufx658.rs:22:19\n   |\n22 |         if\
    \ letter.is_vowel() {\n   |                   ^^^^^^^^ method not found in `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp8aufx658.rs:23:25\n   |\n23 |\
    \             vowels.push(letter);\n   |                         ^^^^^^ expected\
    \ `&str`, found `char`\n\nerror[E0599]: no method named `is_consonant` found for\
    \ type `char` in the current scope\n  --> /tmp/tmp8aufx658.rs:25:19\n   |\n25\
    \ |         if letter.is_consonant() {\n   |                   ^^^^^^^^^^^^ method\
    \ not found in `char`\n\nerror[E0599]: no method named `len` found for type `char`\
    \ in the current scope\n  --> /tmp/tmp8aufx658.rs:26:50\n   |\n26 |          \
    \   letter_pos.push((word.len() - letter.len() - 1, letter));\n   |          \
    \                                        ^^^ method not found in `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8aufx658.rs:26:29\n   |\n26 |             letter_pos.push((word.len()\
    \ - letter.len() - 1, letter));\n   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `usize`, found tuple\n   |\n   = note: expected type `usize`\n    \
    \         found tuple `(usize, char)`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp8aufx658.rs:34:9\n   |\n34 |     for &(index, letter) in letter_pos\
    \ {\n   |         ^^^^^^^^^^^^^^^^    ---------- this expression has type `Option<usize>`\n\
    \   |         |\n   |         expected `usize`, found reference\n   |\n   = note:\
    \   expected type `usize`\n           found reference `&_`\n\nerror: aborting\
    \ due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053309
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"\"; 5];\n    for (i, c) in word.chars().enumerate() {\n\
    \        if c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' {\n     \
    \       return String::from(\"\");\n        }\n        if i > 0\n            &&\
    \ i > word.len() - c\n            && word.chars().nth(i).unwrap() == 'a'\n   \
    \         && word.chars().nth(i + 1).unwrap() == 'u'\n        {\n            vowels[0]\
    \ = \"u\".to_string();\n            vowels[2] = \"U\".to_string();\n         \
    \   vowels[4] = \"r\".to_string();\n        }\n        if i > 0\n            &&\
    \ i > word.len() - c\n            && word.chars().nth(i).unwrap() == 'e'\n   \
    \         && word.chars().nth(i + 1).unwrap() == 'i'\n        {\n            vowels[2]\
    \ = \"i\".to_string();\n            vowels[4] = \"e\".to_string();\n         \
    \   vowels[5] = \"r\".to_string();\n        }\n        if i > 0\n            &&\
    \ i > word.len() - c\n            && word.chars().nth(i).unwrap() == 'o'\n   \
    \         && word.chars().nth(i + 1).unwrap() == 'u'\n        {\n            vowels[4]\
    \ = \"o\".to_string();\n            vowels[5] = \"r\".to_string();\n         \
    \   vowels[6] = \"r\".to_string();\n        }\n        if i > 0\n            &&\
    \ i > word.len() - c\n            && word.chars().nth(i).unwrap() == 'a'\n   \
    \         && word.chars().nth(i + 1).unwrap() == 'a'\n        {\n            vowels[5]\
    \ = \"a\".to_string();\n            vowels[6] = \"a\".to_string();\n         \
    \   vowels[7] = \"a\".to_string();\n        }\n        if i > 0\n            &&\
    \ i > word.len() - c\n            && word.chars().nth(i).unwrap() == 'e'\n   \
    \         && word.chars().nth(i + 1).unwrap() == 'e'\n        {\n            vowels[7]\
    \ = \"e\".to_string();\n            vowels[9] = \"e\".to_string();\n         \
    \   vowels[10] = \"e\".to_string();\n        }\n    }\n    vowels\n        .iter()\n\
    \        .find_map(|&vowel| vowel.to_string())\n        .unwrap_or_else(|| String::from(\"\
    \"))\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot subtract `char` from `usize`\n  --> /tmp/tmpyqfn7q5j.rs:22:31\n\
    \   |\n22 |             && i > word.len() - c\n   |                          \
    \     ^ no implementation for `usize - char`\n   |\n   = help: the trait `Sub<char>`\
    \ is not implemented for `usize`\n   = help: the following other types implement\
    \ trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n             <&'a f64\
    \ as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n             <&'a i16 as\
    \ Sub<i16>>\n             <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n\
    \             <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n  \
    \         and 48 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyqfn7q5j.rs:26:25\n\
    \   |\n26 |             vowels[0] = \"u\".to_string();\n   |             ---------\
    \   ^^^^^^^^^^^^^^^\n   |             |           |\n   |             |      \
    \     expected `&str`, found struct `String`\n   |             |           help:\
    \ consider borrowing here: `&\"u\".to_string()`\n   |             expected due\
    \ to the type of this binding\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyqfn7q5j.rs:27:25\n\
    \   |\n27 |             vowels[2] = \"U\".to_string();\n   |             ---------\
    \   ^^^^^^^^^^^^^^^\n   |             |           |\n   |             |      \
    \     expected `&str`, found struct `String`\n   |             |           help:\
    \ consider borrowing here: `&\"U\".to_string()`\n   |             expected due\
    \ to the type of this binding\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyqfn7q5j.rs:28:25\n\
    \   |\n28 |             vowels[4] = \"r\".to_string();\n   |             ---------\
    \   ^^^^^^^^^^^^^^^\n   |             |           |\n   |             |      \
    \     expected `&str`, found struct `String`\n   |             |           help:\
    \ consider borrowing here: `&\"r\".to_string()`\n   |             expected due\
    \ to the type of this binding\n\nerror[E0277]: cannot subtract `char` from `usize`\n\
    \  --> /tmp/tmpyqfn7q5j.rs:31:31\n   |\n31 |             && i > word.len() - c\n\
    \   |                               ^ no implementation for `usize - char`\n \
    \  |\n   = help: "
  stdout: ''
  timestamp: 1660053309
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowel = String::new();\n    let mut consonant = String::new();\n    let\
    \ mut left_idx = word.rfind(\"a\");\n    let mut right_idx = word.rfind(\"z\"\
    );\n    while left_idx != String::npos && right_idx != String::npos {\n      \
    \  if left_idx > right_idx {\n            vowel.push(word[left_idx - 1]);\n  \
    \          consonant = word[left_idx - 1];\n        } else {\n            vowel.push(word[right_idx\
    \ - 1]);\n            consonant = word[right_idx - 1];\n        }\n        left_idx\
    \ = word.rfind(\"a\", left_idx + 1);\n        right_idx = word.rfind(\"z\", right_idx\
    \ + 1);\n    }\n    if left_idx == String::npos && right_idx == String::npos {\n\
    \        vowel.push(word[0]);\n        consonant = word[0];\n    } else {\n  \
    \      vowel.push_str(\"u\");\n        consonant.push_str(\"U\");\n    }\n   \
    \ vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no function or associated item named `npos` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmpm9q6zlkb.rs:20:31\n   |\n20 | \
    \    while left_idx != String::npos && right_idx != String::npos {\n   |     \
    \                          ^^^^ function or associated item not found in `String`\n\
    \nerror[E0599]: no function or associated item named `npos` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpm9q6zlkb.rs:20:60\n   |\n20 |     while\
    \ left_idx != String::npos && right_idx != String::npos {\n   |              \
    \                                              ^^^^ function or associated item\
    \ not found in `String`\n\nerror[E0369]: cannot subtract `{integer}` from `Option<usize>`\n\
    \  --> /tmp/tmpm9q6zlkb.rs:22:38\n   |\n22 |             vowel.push(word[left_idx\
    \ - 1]);\n   |                             -------- ^ - {integer}\n   |      \
    \                       |\n   |                             Option<usize>\n\n\
    error[E0369]: cannot subtract `{integer}` from `Option<usize>`\n  --> /tmp/tmpm9q6zlkb.rs:23:39\n\
    \   |\n23 |             consonant = word[left_idx - 1];\n   |                \
    \              -------- ^ - {integer}\n   |                              |\n \
    \  |                              Option<usize>\n\nerror[E0369]: cannot subtract\
    \ `{integer}` from `Option<usize>`\n  --> /tmp/tmpm9q6zlkb.rs:25:39\n   |\n25\
    \ |             vowel.push(word[right_idx - 1]);\n   |                       \
    \      --------- ^ - {integer}\n   |                             |\n   |     \
    \                        Option<usize>\n\nerror[E0369]: cannot subtract `{integer}`\
    \ from `Option<usize>`\n  --> /tmp/tmpm9q6zlkb.rs:26:40\n   |\n26 |          \
    \   consonant = word[right_idx - 1];\n   |                              ---------\
    \ ^ - {integer}\n   |                              |\n   |                   \
    \           Option<usize>\n\nerror[E0369]: cannot add `{integer}` to `Option<usize>`\n\
    \  --> /tmp/tmpm9q6zlkb.rs:28:45\n   |\n28 |         left_idx = word.rfind(\"\
    a\", left_idx + 1);\n   |                                    -------- ^ - {integer}\n\
    \   |                                  "
  stdout: ''
  timestamp: 1660053309
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels: Vec<&'static str> = vec![\n        \"A\",\"E\",\"I\",\"O\",\"U\",\n\
    \    ];\n\n    let mut vowel_index = 0;\n    let mut vowel_found = vowels.iter().position(|&x|\
    \ word.chars().any(|&y| y == x));\n\n    if vowel_found == vowels.len() {\n  \
    \      return \"\".to_string();\n    }\n\n    if vowel_found < vowels.len() {\n\
    \        vowel_index += vowel_found;\n    } else {\n        vowel_index = vowel_index\
    \ + vowels.len() - vowels.iter().rposition(|&x| word.chars().any(|&y| y == x));\n\
    \    }\n\n    vowels[vowel_index..].iter().enumerate().filter(|&(i, &x)| word.chars().any(|&y|\
    \ y == x)).next().unwrap().0\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdpkkzx8h.rs:21:73\n   |\n\
    21 |     let mut vowel_found = vowels.iter().position(|&x| word.chars().any(|&y|\
    \ y == x));\n   |                                                            \
    \             ^--\n   |                                                      \
    \                   ||\n   |                                                 \
    \                        |expected due to this\n   |                         \
    \                                                expected `char`, found reference\n\
    \   |                                                                        \
    \ help: did you mean `y`: `&char`\n   |\n   = note:   expected type `char`\n \
    \          found reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdpkkzx8h.rs:23:23\n\
    \   |\n23 |     if vowel_found == vowels.len() {\n   |                       ^^^^^^^^^^^^\
    \ expected enum `Option`, found `usize`\n   |\n   = note: expected enum `Option<usize>`\n\
    \              found type `usize`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n23 |     if vowel_found == Some(vowels.len()) {\n   |                 \
    \      +++++            +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdpkkzx8h.rs:27:22\n\
    \   |\n27 |     if vowel_found < vowels.len() {\n   |                      ^^^^^^^^^^^^\
    \ expected enum `Option`, found `usize`\n   |\n   = note: expected enum `Option<usize>`\n\
    \              found type `usize`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n27 |     if vowel_found < Some(vowels.len()) {\n   |                  \
    \    +++++            +\n\nerror[E0277]: cannot add-assign `Option<usize>` to\
    \ `{integer}`\n  --> /tmp/tmpdpkkzx8h.rs:28:21\n   |\n28 |         vowel_index\
    \ += vowel_found;\n   |                     ^^ no implementation for `{integer}\
    \ += Option<usize>`\n   |\n   = help: the trait `AddAssign<Option<usize>>` is\
    \ not implemented for `{integer}`\n   = help: the following other types implement\
    \ trait `AddAssign<Rhs>`:\n             <f32 as AddAssign<&f32>>\n           \
    \  <f32 as AddAssign>\n             <f64 as AddAssign<&f64>>\n             <f64\
    \ as AddAssign>\n "
  stdout: ''
  timestamp: 1660053309
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowel_position = 0;\n    \n    // Iterate over the word, finding vowels\
    \ starting from the right\n    word.chars().for_each(|c|{\n        match c {\n\
    \            'A' => vowel_position += 1,\n            'E' => vowel_position +=\
    \ 1,\n            'I' => vowel_position += 1,\n            'O' => vowel_position\
    \ += 1,\n            'U' => vowel_position += 1,\n            'a' => vowel_position\
    \ += 1,\n            'e' => vowel_position += 1,\n            'i' => vowel_position\
    \ += 1,\n            'o' => vowel_position += 1,\n            'u' => vowel_position\
    \ += 1,\n            'A' => {\n                vowel_position += 2;\n        \
    \    },\n            'E' => {\n                vowel_position += 2;\n        \
    \    },\n            'I' => {\n                vowel_position += 2;\n        \
    \    },\n            'O' => {\n                vowel_position += 2;\n        \
    \    },\n            'U' => {\n                vowel_position += 2;\n        \
    \    },\n            'a' => {\n                vowel_position += 2;\n        \
    \    },\n            'e' => {\n                vowel_position += 2;\n        \
    \    },\n            'i' => {\n                vowel_position += 2;\n        \
    \    },\n            'o' => {\n                vowel_position += 2;\n        \
    \    },\n            'u' => {\n                vowel_position += 2;\n        \
    \    },\n            _ => ()\n        }\n    });\n\n    // If the word contains\
    \ vowel and there is no other consonant at the right side\n    if word.chars().any(|c|{\n\
    \        match c {\n            'A' => vowel_position += 2,\n            'E' =>\
    \ vowel_position += 2,\n            'I' => vowel_position += 2,\n            'O'\
    \ => vowel_position += 2,\n            'U' => vowel_position += 2,\n         \
    \   'a' => vowel_position += 2,\n            'e' => vowel_position += 2,\n   \
    \         'i' => vowel_position += 2,\n            'o' => vowel_position += 2,\n\
    \            'u' => vowel_position += 2,\n            'A' => {\n             \
    \   vowel_position += 1;\n            },\n            'E' => {\n             \
    \   vowel_position += 1;\n            },\n            'I' => {\n             \
    \   vowel_position += 1;\n            },\n            'O' => {\n             \
    \   vowel_position += 1;\n            },\n            'U' => {\n             \
    \   vowel_position += 1;\n            },\n            'a' => {\n             \
    \   vowel_position += 1;\n            },\n            'e' => {\n             \
    \   vowel_position += 1;\n            },\n            'i' => {\n             \
    \   vowel_position += 1;\n            },\n            'o' => {\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpvfggrsex.rs:120:3\n\
    \    |\n15  | fn get_closest_vowel(word: String) -> String {\n    |          \
    \                                    - unclosed delimiter\n...\n66  |     if word.chars().any(|c|{\n\
    \    |                        -   - unclosed delimiter\n    |                \
    \        |\n    |                        unclosed delimiter\n67  |         match\
    \ c {\n    |                 - unclosed delimiter\n...\n102 |             'o'\
    \ => {\n    |                    - this delimiter might not be properly closed...\n\
    103 | }\n    | - ...as it matches this but it has different indentation\n...\n\
    120 | }\n    |   ^\n\nerror: expected identifier, found keyword `fn`\n   --> /tmp/tmpvfggrsex.rs:105:1\n\
    \    |\n105 | fn main() {\n    | ^^ expected identifier, found keyword\n\nerror:\
    \ expected one of `=>`, `@`, `if`, or `|`, found `main`\n   --> /tmp/tmpvfggrsex.rs:105:4\n\
    \    |\n105 | fn main() {\n    |    ^^^^ expected one of `=>`, `@`, `if`, or `|`\n\
    \nerror: expected `{`, found `}`\n   --> /tmp/tmpvfggrsex.rs:120:3\n    |\n66\
    \  |     if word.chars().any(|c|{\n    |     -- this `if` expression has a condition,\
    \ but no block\n...\n120 | }\n    |   ^ expected `{`\n\nerror: aborting due to\
    \ 4 previous errors\n\n"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    if\
    \ let Some(vowel_index) = find_vowel(word) {\n        word.split_last_mut().collect::<Vec<&str>>().iter().skip_while(|&c|\
    \ !is_consonant(c)).enumerate().find_map(|&(i, &c)| c ==\n            word.chars().skip(i).take(1).next().unwrap()).unwrap().0\n\
    \    } else {\n        String::from(\"\")\n    }\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `find_vowel` in this scope\n  --> /tmp/tmpunsgvr6w.rs:16:32\n\
    \   |\n16 |     if let Some(vowel_index) = find_vowel(word) {\n   |          \
    \                      ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `is_consonant` in this scope\n  --> /tmp/tmpunsgvr6w.rs:17:78\n\
    \   |\n17 |         word.split_last_mut().collect::<Vec<&str>>().iter().skip_while(|&c|\
    \ !is_consonant(c)).enumerate().find_map(|&(i, &c)| c ==\n   |               \
    \                                                               ^^^^^^^^^^^^ not\
    \ found in this scope\n\nerror[E0599]: no method named `split_last_mut` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmpunsgvr6w.rs:17:14\n\
    \   |\n17 |         word.split_last_mut().collect::<Vec<&str>>().iter().skip_while(|&c|\
    \ !is_consonant(c)).enumerate().find_map(|&(i, &c)| c ==\n   |              ^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `split_at`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660053308
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut s = String::from(\"u\");\n    if word.len() == 0 {\n        return s;\n\
    \    }\n\n    let mut vowels = String::from(\"aeiouy\");\n    if let Some(vowel)\
    \ = vowels.split_last_mut().filter(|&s| !s.is_empty()) {\n        if word.len()\
    \ > vowel.len() {\n            vowels = vowel.clone();\n        }\n    }\n\n \
    \   let mut s = String::from(\"u\");\n    if word.len() == 0 {\n        return\
    \ s;\n    }\n\n    let mut vowels = String::from(\"aeiouy\");\n    if let Some(vowel)\
    \ = vowels.split_last_mut().filter(|&s| !s.is_empty()) {\n        if word.len()\
    \ > vowel.len() {\n            vowels = vowel.clone();\n        }\n    }\n   \
    \ for c in word.chars().rev() {\n        if vowels.contains(&c.to_ascii_lowercase())\
    \ {\n            break;\n        }\n        s = c.to_string();\n    }\n    s;\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `split_last_mut` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp7ludbhrx.rs:22:33\n   |\n22 |     if let\
    \ Some(vowel) = vowels.split_last_mut().filter(|&s| !s.is_empty()) {\n   |   \
    \                              ^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `split_at`\n\nerror[E0599]: no method named `split_last_mut`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmp7ludbhrx.rs:34:33\n\
    \   |\n34 |     if let Some(vowel) = vowels.split_last_mut().filter(|&s| !s.is_empty())\
    \ {\n   |                                 ^^^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `split_at`\n\nerror[E0277]: expected a `Fn<(char,)>`\
    \ closure, found `char`\n    --> /tmp/tmp7ludbhrx.rs:40:28\n     |\n40   |   \
    \      if vowels.contains(&c.to_ascii_lowercase()) {\n     |                 \
    \  -------- ^^^^^^^^^^^^^^^^^^^^^^^ expected an `Fn<(char,)>` closure, found `char`\n\
    \     |                   |\n     |                   required by a bound introduced\
    \ by this call\n     |\n     = help: the trait `Fn<(char,)>` is not implemented\
    \ for `char`\n     = note: required because of the requirements on the impl of\
    \ `FnOnce<(char,)>` for `&char`\n     = note: required because of the requirements\
    \ on the impl of `Pattern<'_>` for `&char`\nnote: required by a bound in `core::str::<impl\
    \ str>::contains`\nhelp: consider dereferencing here\n     |\n40   |         if\
    \ vowels.contains(*&c.to_ascii_lowercase()) {\n     |                        \
    \    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7ludbhrx.rs:15:39\n  \
    \ |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    ...\n45 |     s;\n   |      - help: remove this semicolon\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660053309
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![];\n    vowels.push_back('u');\n    vowels.push_back('U');\n\
    \    vowels.push_back('e');\n    vowels.push_back('E');\n    vowels.push_back('i');\n\
    \    vowels.push_back('I');\n    vowels.push_back('o');\n    vowels.push_back('O');\n\
    \    vowels.push_back('a');\n    vowels.push_back('A');\n    vowels.push_back('y');\n\
    \    vowels.push_back('Y');\n    vowels.push_back('o');\n    vowels.push_back('O');\n\
    \    vowels.push_back('u');\n    vowels.push_back('U');\n    vowels.push_back('e');\n\
    \    vowels.push_back('E');\n    vowels.push_back('e');\n    vowels.push_back('E');\n\
    \    vowels.push_back('i');\n    vowels.push_back('I');\n    vowels.push_back('i');\n\
    \    vowels.push_back('I');\n    vowels.push_back('o');\n    vowels.push_back('O');\n\
    \    vowels.push_back('o');\n    vowels.push_back('O');\n    vowels.push_back('u');\n\
    \    vowels.push_back('U');\n    vowels.push_back('u');\n    vowels.push_back('U');\n\
    \    vowels.push_back('e');\n    vowels.push_back('E');\n    vowels.push_back('e');\n\
    \    vowels.push_back('E');\n    vowels.push_back('e');\n    vowels.push_back('E');\n\
    \    vowels.push_back('i');\n    vowels.push_back('I');\n    vowels.push_back('i');\n\
    \    vowels.push_back('I');\n    vowels.push_back('o');\n    vowels.push_back('O');\n\
    \    vowels.push_back('o');\n    vowels.push_back('O');\n    vowels.push_back('o');\n\
    \    vowels.push_back('O');\n    vowels.push_back('u');\n    vowels.push_back('U');\n\
    \    vowels.push_back('u');\n    vowels.push_back('U');\n    vowels.push_back('y');\n\
    \    vowels.push_back('Y');\n    vowels.push_back('y');\n    vowels.push_back('Y');\n\
    \    vowels.push_back('y');\n    vowels.push_back('Y');\n    vowels.push_back('y');\n\
    \    vowels.push_back('Y');\n    vowels.push_back('y');\n    vowels.push_back('Y');\n\
    \    vowels.push_back('y');\n    vowels.push_back\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `push_back` found for struct `Vec<_>` in\
    \ the current scope\n  --> /tmp/tmp1n0nrds4.rs:17:12\n   |\n17 |     vowels.push_back('u');\n\
    \   |            ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method\
    \ named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp1n0nrds4.rs:18:12\n\
    \   |\n18 |     vowels.push_back('U');\n   |            ^^^^^^^^^ method not found\
    \ in `Vec<_>`\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>`\
    \ in the current scope\n  --> /tmp/tmp1n0nrds4.rs:19:12\n   |\n19 |     vowels.push_back('e');\n\
    \   |            ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method\
    \ named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp1n0nrds4.rs:20:12\n\
    \   |\n20 |     vowels.push_back('E');\n   |            ^^^^^^^^^ method not found\
    \ in `Vec<_>`\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>`\
    \ in the current scope\n  --> /tmp/tmp1n0nrds4.rs:21:12\n   |\n21 |     vowels.push_back('i');\n\
    \   |            ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method\
    \ named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp1n0nrds4.rs:22:12\n\
    \   |\n22 |     vowels.push_back('I');\n   |            ^^^^^^^^^ method not found\
    \ in `Vec<_>`\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>`\
    \ in the current scope\n  --> /tmp/tmp1n0nrds4.rs:23:12\n   |\n23 |     vowels.push_back('o');\n\
    \   |            ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method\
    \ named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp1n0nrds4.rs:24:12\n\
    \   |\n24 |     vowels.push_back('O');\n   |            ^^^^^^^^^ method not found\
    \ in `Vec<_>`\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>`\
    \ in the current scope\n  --> /tmp/tmp1n0nrds4.rs:25:12\n   |\n25 |     vowels.push_back('a');\n\
    \   |            ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method\
    \ named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp1n0nrds4.rs:26:12\n\
    \ "
  stdout: ''
  timestamp: 1660053309
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowel = String::new();\n    let mut start = 0;\n    let mut end = word.len()\
    \ - 1;\n    loop {\n        if start == end {\n            if start == 0 {\n \
    \               vowel.push('A');\n            } else {\n                vowel.push('A');\n\
    \                vowel.push('B');\n            }\n            break;\n       \
    \ }\n        if word.chars().nth(start).unwrap().is_uppercase() {\n          \
    \  vowel.push('A');\n            start += 1;\n        } else {\n            vowel.push('B');\n\
    \            start -= 1;\n        }\n        if word.chars().nth(end).unwrap().is_uppercase()\
    \ {\n            vowel.push('B');\n            end -= 1;\n        } else {\n \
    \           vowel.push('A');\n            end += 1;\n        }\n    }\n    vowel.clone()\
    \ \n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpgr3xhcvm.rs:34:13

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660053309
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    use\
    \ std::cmp::Ordering;\n\n    let mut vowels: Vec<&str> = vec![\n        \"a\"\
    , \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\",\n    ];\n   \
    \ let mut vowels_end = vec![\n        \"y\", \"a\", \"b\", \"c\", \"d\", \"e\"\
    , \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\"\
    , \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\",\n    ];\n\n \
    \   let mut vowels_end = vowels_end.iter().rev().collect();\n    let mut vowels_it\
    \ = vowels.iter();\n    \n    // find first vowel\n    let mut vowel = vowels_it.next().unwrap();\n\
    \    for _ in 0..word.len() {\n        if word.contains(&vowel) {\n          \
    \  if vowels_it.peek() == Some(&vowel) {\n                vowel = vowels_it.next().unwrap();\n\
    \            } else {\n                return String::from(\"\");\n          \
    \  }\n        }\n    }\n\n    let mut vowel_found = false;\n    // find second\
    \ vowel\n    let mut vowel_end = 0;\n    while !vowel_found && vowel_end + 1 !=\
    \ word.len() {\n        if word.contains(&vowels[vowel_end]) { // find right most\
    \ vowel\n            vowel_end = vowels_end.index(&vowels[vowel_end]).unwrap();\n\
    \        } else {\n            vowel_end += 1;\n        }\n        if vowel_end\
    \ + 1 == word.len() { // if end of word, no more vowels\n            vowel_found\
    \ = true;\n        }\n    }\n    if vowel_end == word.len() { // if no second\
    \ vowel, return empty string\n        return String::from(\"\");\n    }\n\n  \
    \  if vowel_end < word.len() {\n        return String::from(\"\");\n    }\n\n\
    \    // find last vowel\n    let mut vowel_end_last = word.len() - 1;\n    while\
    \ !vowel_found && vowel_end_last >= 0 {\n        if word.contains(&vowels[vowel_end_last])\
    \ {\n            vowel_end_last -= 1;\n        } else {\n            vowel_end_last\
    \ -= 1;\n        }\n        vowel = vowels_it.next().unwrap();\n        if vowel_end_last\
    \ >= 0 {\n            if word.contains(&vowels[vowel_end_last]) {\n          \
    \      vowel_end_last -= 1;\n            } else {\n                vowel_end_last\
    \ -= 1;\n            }\n        }\n        if vowel_end_last < 0 {\n         \
    \   vowel_found = true;\n        }\n    }\n\n    if vowel_end_last >= 0 {\n  \
    \      return String::from(\"\");\n    }\n\n    vowel.to_string()\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "warning: unused import: `std::cmp::Ordering`\n  --> /tmp/tmpr62f7is9.rs:16:9\n\
    \   |\n16 |     use std::cmp::Ordering;\n   |         ^^^^^^^^^^^^^^^^^^\n   |\n\
    \   = note: `#[warn(unused_imports)]` on by default\n\nerror[E0277]: expected\
    \ a `Fn<(char,)>` closure, found `str`\n    --> /tmp/tmpr62f7is9.rs:31:26\n  \
    \   |\n31   |         if word.contains(&vowel) {\n     |                 --------\
    \ ^^^^^^\n     |                 |        |\n     |                 |        expected\
    \ an `Fn<(char,)>` closure, found `str`\n     |                 |        help:\
    \ consider dereferencing here: `&*vowel`\n     |                 required by a\
    \ bound introduced by this call\n     |\n     = help: the trait `Fn<(char,)>`\
    \ is not implemented for `str`\n     = note: required because of the requirements\
    \ on the impl of `FnOnce<(char,)>` for `&str`\n     = note: required because of\
    \ the requirements on the impl of `Pattern<'_>` for `&&&str`\nnote: required by\
    \ a bound in `core::str::<impl str>::contains`\n\nerror[E0599]: no method named\
    \ `peek` found for struct `std::slice::Iter` in the current scope\n  --> /tmp/tmpr62f7is9.rs:32:26\n\
    \   |\n32 |             if vowels_it.peek() == Some(&vowel) {\n   |          \
    \                ^^^^ method not found in `std::slice::Iter<'_, &str>`\n\nerror:\
    \ aborting due to 2 previous errors; 1 warning emitted\n\nSome errors have detailed\
    \ explanations: E0277, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1660053309
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    //\
    \ TODO: implement function\n    let mut vowel = String::new();\n\n    // find\
    \ the vowel\n    let vowels = vec![\n        \"a\", \"e\", \"i\", \"o\", \"u\"\
    , \"A\", \"E\", \"I\", \"O\", \"U\"\n    ];\n    vowels.iter().position(|&vowel|\
    \ *vowel == word.chars().last().unwrap()).unwrap();\n\n    // get the index of\
    \ the next consonants\n    let mut nextIndex: usize = 0;\n    let mut index =\
    \ 0;\n    while vowel > 0 {\n        nextIndex = (nextIndex + vowel) % vowels.len();\n\
    \        index += vowels[nextIndex];\n        vowel -= vowels[index];\n    }\n\
    \n    // return the found vowel\n    vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `str` with `char`\n  --> /tmp/tmpmv3_h826.rs:23:44\n\
    \   |\n23 |     vowels.iter().position(|&vowel| *vowel == word.chars().last().unwrap()).unwrap();\n\
    \   |                                            ^^ no implementation for `str\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpmv3_h826.rs:28:19\n   |\n28 |     while vowel > 0 {\n \
    \  |                   ^- help: try using a conversion method: `.to_string()`\n\
    \   |                   |\n   |                   expected struct `String`, found\
    \ integer\n\nerror[E0277]: cannot add `String` to `usize`\n  --> /tmp/tmpmv3_h826.rs:29:32\n\
    \   |\n29 |         nextIndex = (nextIndex + vowel) % vowels.len();\n   |    \
    \                            ^ no implementation for `usize + String`\n   |\n\
    \   = help: the trait `Add<String>` is not implemented for `usize`\n   = help:\
    \ the following other types implement trait `Add<Rhs>`:\n             <&'a f32\
    \ as Add<f32>>\n             <&'a f64 as Add<f64>>\n             <&'a i128 as\
    \ Add<i128>>\n             <&'a i16 as Add<i16>>\n             <&'a i32 as Add<i32>>\n\
    \             <&'a i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n      \
    \       <&'a isize as Add<isize>>\n           and 48 others\n\nerror[E0277]: cannot\
    \ add-assign `&str` to `{integer}`\n  --> /tmp/tmpmv3_h826.rs:30:15\n   |\n30\
    \ |         index += vowels[nextIndex];\n   |               ^^ no implementation\
    \ for `{integer} += &str`\n   |\n   = help: the trait `AddAssign<&str>` is not\
    \ implemented for `{integer}`\n   = help: the following other types implement\
    \ trait `AddAssi"
  stdout: ''
  timestamp: 1660053309
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ word = word.to_lowercase();\n\n    let mut vowel = String::new();\n    let mut\
    \ current = 0;\n    let mut current_vowel = String::new();\n\n    for c in word.chars()\
    \ {\n        match c.to_lowercase().as_str() {\n            \"a\" | \"e\" | \"\
    i\" | \"o\" | \"u\" => {\n                if current < word.len() - 1 {\n    \
    \                current += 1;\n                    current_vowel = word.chars().nth(current).unwrap();\n\
    \                }\n                vowel.push_str(current_vowel);\n         \
    \   }\n            \"y\" => {\n                if current < word.len() - 2 {\n\
    \                    current += 1;\n                    current_vowel = word.chars().nth(current).unwrap();\n\
    \                }\n                vowel.push_str(current_vowel);\n         \
    \   }\n            \"u\" => {\n                if current < word.len() - 2 {\n\
    \                    current += 1;\n                    current_vowel = word.chars().nth(current).unwrap();\n\
    \                }\n                vowel.push_str(current_vowel);\n         \
    \   }\n            \"i\" => {\n                if current < word.len() - 1 {\n\
    \                    current += 1;\n                    current_vowel = word.chars().nth(current).unwrap();\n\
    \                }\n                vowel.push_str(current_vowel);\n         \
    \   }\n            \"e\" => {\n                if current < word.len() - 2 {\n\
    \                    current += 1;\n                    current_vowel = word.chars().nth(current).unwrap();\n\
    \                }\n                vowel.push_str(current_vowel);\n         \
    \   }\n            \"o\" => {\n                if current < word.len() - 1 {\n\
    \                    current += 1;\n                    current_vowel = word.chars().nth(current).unwrap();\n\
    \                }\n                vowel.push_str(current_vowel);\n         \
    \   }\n            _ => (),\n        }\n    }\n\n    vowel\n}\n\nfn main() {\n\
    \    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `as_str` found for struct `ToLowercase` in\
    \ the current scope\n  --> /tmp/tmpbybk6u5v.rs:23:32\n   |\n23 |         match\
    \ c.to_lowercase().as_str() {\n   |                                ^^^^^^ method\
    \ not found in `ToLowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbybk6u5v.rs:27:37\n\
    \   |\n20 |     let mut current_vowel = String::new();\n   |                 \
    \            ------------- expected due to this value\n...\n27 |             \
    \        current_vowel = word.chars().nth(current).unwrap();\n   |           \
    \                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |                                  \
    \   |\n   |                                     expected struct `String`, found\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbybk6u5v.rs:29:32\n\
    \   |\n29 |                 vowel.push_str(current_vowel);\n   |             \
    \                   ^^^^^^^^^^^^^\n   |                                |\n   |\
    \                                expected `&str`, found struct `String`\n   |\
    \                                help: consider borrowing here: `&current_vowel`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpbybk6u5v.rs:34:37\n   |\n20 |\
    \     let mut current_vowel = String::new();\n   |                           \
    \  ------------- expected due to this value\n...\n34 |                     current_vowel\
    \ = word.chars().nth(current).unwrap();\n   |                                \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method:\
    \ `.to_string()`\n   |                                     |\n   |           \
    \                          expected struct `String`, found `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpbybk6u5v.rs:36:32\n   |\n36 |              \
    \   vowel.push_str(current_vowel);\n   |                                ^^^^^^^^^^^^^\n\
    \   |                                |\n   |                                expected\
    \ `&str`, found struct `String`\n   |                                help: consider\
    \ borrowing here: `&current_vowel`\n\nerror[E0308"
  stdout: ''
  timestamp: 1660053309
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut index = word.len();\n\
    \    let mut last_index = -1;\n    while index > 0 {\n        last_index = index\
    \ - 1;\n        index = word.rfind('a', last_index);\n        if index != -1 {\n\
    \            vowels.push(word[index..]);\n        }\n    }\n    \n    for vowel\
    \ in vowels.iter() {\n        if word.contains(vowel) {\n            return vowel;\n\
    \        }\n    }\n    \n    return \"\";\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp4p5a7hw4.rs:18:26\n\
    \   |\n18 |     let mut last_index = -1;\n   |                          ^^ the\
    \ trait `Neg` is not implemented for `usize`\n   |\n   = help: the following other\
    \ types implement trait `Neg`:\n             &f32\n             &f64\n       \
    \      &i128\n             &i16\n             &i32\n             &i64\n      \
    \       &i8\n             &isize\n           and 8 others\n\nerror[E0061]: this\
    \ function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmp4p5a7hw4.rs:21:22\n\
    \     |\n21   |         index = word.rfind('a', last_index);\n     |         \
    \             ^^^^^ ---  ---------- supplied 2 arguments\n     |             \
    \         |\n     |                      expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4p5a7hw4.rs:21:17\n\
    \   |\n17 |     let mut index = word.len();\n   |                     ----------\
    \ expected due to this value\n...\n21 |         index = word.rfind('a', last_index);\n\
    \   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found enum\
    \ `Option`\n   |\n   = note: expected type `usize`\n              found enum `Option<usize>`\n\
    \nerror[E0600]: cannot apply unary operator `-` to type `usize`\n  --> /tmp/tmp4p5a7hw4.rs:22:21\n\
    \   |\n22 |         if index != -1 {\n   |                     ^^\n   |      \
    \               |\n   |                     cannot apply unary operator `-`\n\
    \   |                     help: you may have meant the maximum value of `usize`:\
    \ `usize::MAX`\n   |\n   = note: unsigned values cannot be negated\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp4p5a7hw4.rs:23:25\n   |\n23 |             vowels.push(word[index..]);\n\
    \   |                         ^^^^^^^^^^^^^\n   |                         |\n\
    \   |                         expected `&str`, found `str`\n   |             \
    \            help: consider borrowing here: `&word[index..]`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp4p5a7hw4.rs:29:20\n   |\n29 |             return\
    \ vowel;\n   |                    ^^^^^- help: try "
  stdout: ''
  timestamp: 1660053309
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowel_position = 1;\n    let mut consonant_position = 1;\n    let mut previous_consonant_position\
    \ = 1;\n    let mut previous_vowel_position = 1;\n    let mut closest_vowel =\
    \ String::from(\"\");\n    let mut consonant_flag = false;\n    let mut vowel_flag\
    \ = false;\n    let mut consonant_count = word.len();\n    let mut vowel_count\
    \ = word.len();\n    let mut vowel_index = 0;\n    let mut consonant_index = word.len();\n\
    \    let mut closest_vowel_flag = false;\n    while consonant_index > 0 {\n  \
    \      if consonant_flag {\n            consonant_index -= 1;\n        } else\
    \ {\n            consonant_flag = true;\n            consonant_count -= 1;\n \
    \           if word.chars().nth(consonant_position).unwrap().is_uppercase() {\n\
    \                consonant_count += 1;\n            }\n        }\n        if vowel_index\
    \ > 0 {\n            if vowel_flag {\n                vowel_index -= 1;\n    \
    \        } else {\n                vowel_flag = true;\n                vowel_count\
    \ -= 1;\n                if word.chars().nth(vowel_position).unwrap().is_lowercase()\
    \ {\n                    vowel_count += 1;\n                }\n            }\n\
    \        }\n        if vowel_count <= consonant_count {\n            closest_vowel\
    \ = word.chars().nth(vowel_index).unwrap();\n            break;\n        }\n \
    \       if consonant_count <= vowel_count {\n            closest_vowel = word.chars().nth(consonant_index).unwrap();\n\
    \            break;\n        }\n        if consonant_count < vowel_count {\n \
    \           previous_consonant_position = consonant_position;\n            consonant_position\
    \ = consonant_index + 1;\n            closest_vowel = word.chars().nth(consonant_position).unwrap();\n\
    \            consonant_flag = false;\n            consonant_index -= 1;\n    \
    \    }\n        if vowel_count < consonant_count {\n            previous_vowel_position\
    \ = vowel_position;\n            vowel_position = vowel_index + 1;\n         \
    \   closest_vowel = word.chars().nth(vowel_position).unwrap();\n            vowel_flag\
    \ = false;\n            vowel_index -= 1;\n        }\n        closest_vowel_flag\
    \ = true;\n    }\n    closest_vowel.to_string()\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3f4kvr4g.rs:50:29\n   |\n\
    20 |     let mut closest_vowel = String::from(\"\");\n   |                   \
    \          ---------------- expected due to this value\n...\n50 |            \
    \ closest_vowel = word.chars().nth(vowel_index).unwrap();\n   |              \
    \               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                             |\n   |           \
    \                  expected struct `String`, found `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp3f4kvr4g.rs:54:29\n   |\n20 |     let mut closest_vowel\
    \ = String::from(\"\");\n   |                             ---------------- expected\
    \ due to this value\n...\n54 |             closest_vowel = word.chars().nth(consonant_index).unwrap();\n\
    \   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \           |\n   |                             expected struct `String`, found\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3f4kvr4g.rs:60:29\n\
    \   |\n20 |     let mut closest_vowel = String::from(\"\");\n   |            \
    \                 ---------------- expected due to this value\n...\n60 |     \
    \        closest_vowel = word.chars().nth(consonant_position).unwrap();\n   |\
    \                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help:\
    \ try using a conversion method: `.to_string()`\n   |                        \
    \     |\n   |                             expected struct `String`, found `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp3f4kvr4g.rs:67:29\n   |\n20 |\
    \     let mut closest_vowel = String::from(\"\");\n   |                      \
    \       ---------------- expected due to this value\n...\n67 |             closest_vowel\
    \ = word.chars().nth(vowel_position).unwrap();\n   |                         \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method:\
    \ `.to_string()`\n   |                             |\n   |                   \
    \          expected struct `String`, found `cha"
  stdout: ''
  timestamp: 1660053309
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\",\"e\",\"i\",\"o\",\"u\"];\n    let mut first_char =\
    \ word.chars().next();\n    let mut last_char = first_char.cloned();\n    let\
    \ mut i = 0;\n    loop {\n        \n        if first_char.map_or(false, |c| c.is_uppercase())\n\
    \        {\n            if let Some(c) = vowels.remove(first_char.clone()) {\n\
    \                if let Some(next) = vowels.remove(last_char.clone()) {\n    \
    \                return c.to_string();\n                }\n            }\n   \
    \     }\n        else if last_char.map_or(false, |c| c.is_uppercase())\n     \
    \   {\n            if let Some(c) = vowels.remove(last_char.clone()) {\n     \
    \           if let Some(next) = vowels.remove(first_char.clone()) {\n        \
    \            return c.to_string();\n                }\n            }\n       \
    \ }\n        last_char = first_char.clone();\n        i = i + 1;\n        first_char\
    \ = word.chars().nth(i).unwrap();\n    }\n    \n    \"\".to_string()\n}\n\nfn\
    \ main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `Option<char>` is not an iterator\n   --> /tmp/tmp97j5j2g9.rs:18:36\n\
    \    |\n18  |       let mut last_char = first_char.cloned();\n    |          \
    \                            ^^^^^^ `Option<char>` is not an iterator\n    |\n\
    \    = note: the following trait bounds were not satisfied:\n            `Option<char>:\
    \ Iterator`\n            which is required by `&mut Option<char>: Iterator`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp97j5j2g9.rs:24:44\n   |\n24 |  \
    \           if let Some(c) = vowels.remove(first_char.clone()) {\n   |       \
    \                                     ^^^^^^^^^^^^^^^^^^ expected `usize`, found\
    \ enum `Option`\n   |\n   = note: expected type `usize`\n              found enum\
    \ `Option<char>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp97j5j2g9.rs:24:20\n\
    \   |\n24 |             if let Some(c) = vowels.remove(first_char.clone()) {\n\
    \   |                    ^^^^^^^   --------------------------------- this expression\
    \ has type `&str`\n   |                    |\n   |                    expected\
    \ `str`, found enum `Option`\n   |\n   = note: expected type `str`\n         \
    \     found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp97j5j2g9.rs:25:24\n\
    \   |\n25 |                 if let Some(next) = vowels.remove(last_char.clone())\
    \ {\n   |                        ^^^^^^^^^^   --------------------------------\
    \ this expression has type `&str`\n   |                        |\n   |       \
    \                 expected `str`, found enum `Option`\n   |\n   = note: expected\
    \ type `str`\n              found enum `Option<_>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp97j5j2g9.rs:32:20\n   |\n32 |             if let Some(c)\
    \ = vowels.remove(last_char.clone()) {\n   |                    ^^^^^^^   --------------------------------\
    \ this expression has type `&str`\n   |                    |\n   |           \
    \         expected `str`, found enum `Option`\n   |\n   = note: expected type\
    \ `str`\n              found enum `Option<_>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp97j5j2g9.rs:33:51\n   |\n33 |                 if let Some(next)\
    \ = vowels.remove(f"
  stdout: ''
  timestamp: 1660053309
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    fn\
    \ get_vowel(&mut self, i: usize) -> &'static str {\n        if self.word[i] ==\
    \ vowels.as_slice()[i - 2] {\n            return &vowels[i - 2];\n        }\n\
    \        if self.word[i] == vowels.as_slice()[i - 1] {\n            return &vowels[i\
    \ - 1];\n        }\n        if self.word[i] == vowels.as_slice()[i] {\n      \
    \      return &vowels[i];\n        }\n        if self.word[i] == vowels.as_slice()[i\
    \ + 1] {\n            return &vowels[i + 1];\n        }\n        if self.word[i]\
    \ == vowels.as_slice()[i + 2] {\n            return &vowels[i + 2];\n        }\n\
    \        return &vowels[i - 1];\n    }\n    if word.is_empty() {\n        return\
    \ \"\";\n    }\n    let mut vowel_index = 1;\n    let mut next_vowel_index = 1;\n\
    \    let mut consonant_index = -1;\n    let mut current_vowel = get_vowel(vowel_index);\n\
    \    for character in word.chars().skip_while(|c| {\n        match c {\n     \
    \       c => c < 'a' || c > 'z' || *c != 'a' || *c != 'e' || *c != 'i' || *c !=\
    \ 'o' || *c != 'u' || *c != 'y' => {\n                return \"\";\n         \
    \   },\n            _ => {},\n        }\n    }) {\n        if character == current_vowel\
    \ {\n            if next_vowel_index == vowel_index + 1 {\n                vowel_index\
    \ += 1;\n            } else {\n                next_vowel_index += 1;\n      \
    \          consonant_index = vowel_index;\n                vowel_index = next_vowel_index;\n\
    \                next_vowel_index = 1;\n            }\n            current_vowel\
    \ = get_vowel(vowel_index);\n        } else {\n            if next_vowel_index\
    \ == vowel_index + 1 {\n                vowel_index += 1;\n            } else\
    \ {\n                next_vowel_index += 1;\n                consonant_index =\
    \ vowel_index;\n                vowel_index = next_vowel_index;\n            \
    \    next_vowel_index = 1;\n            }\n            current_vowel = get_vowel(vowel_index);\n\
    \        }\n    }\n    if consonant_index == 0 {\n        return \"\";\n    }\n\
    \    get_vowel(consonant_index - 1)\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `,`, `.`, `?`, `}`, or an operator, found `=>`\n\
    \  --> /tmp/tmpd16orm0l.rs:43:115\n   |\n43 |             c => c < 'a' || c >\
    \ 'z' || *c != 'a' || *c != 'e' || *c != 'i' || *c != 'o' || *c != 'u' || *c !=\
    \ 'y' => {\n   |               -- while parsing the `match` arm starting here\
    \                                                      ^^ expected one of `,`,\
    \ `.`, `?`, `}`, or an operator\n\nerror: `self` parameter is only allowed in\
    \ associated functions\n  --> /tmp/tmpd16orm0l.rs:16:18\n   |\n16 |     fn get_vowel(&mut\
    \ self, i: usize) -> &'static str {\n   |                  ^^^^^^^^^ not semantically\
    \ valid as function parameter\n   |\n   = note: associated functions are those\
    \ in `impl` or `trait` definitions\n\nerror[E0425]: cannot find value `vowels`\
    \ in this scope\n  --> /tmp/tmpd16orm0l.rs:17:28\n   |\n17 |         if self.word[i]\
    \ == vowels.as_slice()[i - 2] {\n   |                            ^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `vowels` in this scope\n  -->\
    \ /tmp/tmpd16orm0l.rs:18:21\n   |\n18 |             return &vowels[i - 2];\n \
    \  |                     ^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `vowels` in this scope\n  --> /tmp/tmpd16orm0l.rs:20:28\n   |\n20\
    \ |         if self.word[i] == vowels.as_slice()[i - 1] {\n   |              \
    \              ^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `vowels` in this scope\n  --> /tmp/tmpd16orm0l.rs:21:21\n   |\n21 |        \
    \     return &vowels[i - 1];\n   |                     ^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `vowels` in this scope\n  --> /tmp/tmpd16orm0l.rs:23:28\n\
    \   |\n23 |         if self.word[i] == vowels.as_slice()[i] {\n   |          \
    \                  ^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `vowels` in this scope\n  --> /tmp/tmpd16orm0l.rs:24:21\n   |\n24 |  \
    \           return &vowels[i];\n   |                     ^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `vowels` in this scope\n  --> /tmp/tmpd16orm0l.rs:26:28\n\
    \   |\n26 |         if self.word["
  stdout: ''
  timestamp: 1660053309
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut result = String::new();\n    word.chars().skip_while(|c| c != ' ').for_each(|c|\
    \ {\n        if !c.is_uppercase() {\n            result.push(c);\n        }\n\
    \    });\n    match result {\n        \"\" => \"\",\n        c => {\n        \
    \    if c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' {\n         \
    \       result += 'A';\n            }\n            if c == 'a' || c == 'e' ||\
    \ c == 'i' || c == 'o' || c == 'u' {\n                result += 'E';\n       \
    \     }\n            if c == 'u' || c == 'a' || c == 'i' || c == 'e' || c == 'o'\
    \ {\n                result += 'I';\n            }\n            if c == 'o' ||\
    \ c == 'u' || c == 'a' || c == 'e' || c == 'i' {\n                result += 'O';\n\
    \            }\n            if c == 'e' || c == 'i' || c == 'u' || c == 'a' ||\
    \ c == 'o' {\n                result += 'U';\n            }\n            if c\
    \ == 'Y' || c == 'y' || c == 'i' || c == 'o' || c == 'u' {\n                result\
    \ += 'y';\n            }\n            if c == 'Y' || c == 'y' || c == 'i' || c\
    \ == 'o' || c == 'u' {\n                result += 'Y';\n            }\n      \
    \      if c == 'O' || c == 'o' || c == 'u' || c == 'a' || c == 'i' {\n       \
    \         result += 'O';\n            }\n            if c == 'o' || c == 'u' ||\
    \ c == 'a' || c == 'i' || c == 'e' {\n                result += 'u';\n       \
    \     }\n            if c == 'O' || c == 'o' || c == 'u' || c == 'a' || c == 'i'\
    \ {\n                result += 'O';\n            }\n            if c == 'o' ||\
    \ c == 'u' || c == 'a' || c == 'i' || c == 'e' {\n                result += 'u';\n\
    \            }\n            if c == 'D' || c == 'd' || c == 'e' || c == 'i' ||\
    \ c == 'o' || c == 'u' {\n                result += 'd';\n            }\n    \
    \        if c == 'D' || c == 'd' || c == 'e' || c == 'i' || c == 'o' || c == 'u'\
    \ {\n                result += 'D';\n            }\n            if c == 'd' ||\
    \ c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' {\n               \
    \ result += 'A';\n            }\n            if c == 'd' || c == 'e\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpnhp8c65c.rs:85:3\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n22 |     match result\
    \ {\n   |                  - unclosed delimiter\n23 |         \"\" => \"\",\n\
    24 |         c => {\n   |              - this delimiter might not be properly\
    \ closed...\n...\n68 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n85 | }\n   |   ^\n\nerror: expected `while`, `for`, `loop` or `{` after a\
    \ label\n  --> /tmp/tmpnhp8c65c.rs:68:1\n   |\n68 | }\n   | ^ expected `while`,\
    \ `for`, `loop` or `{` after a label\n\nerror: expected expression, found `}`\n\
    \  --> /tmp/tmpnhp8c65c.rs:68:1\n   |\n68 | }\n   | ^ expected expression\n\n\
    error: expected identifier, found keyword `fn`\n  --> /tmp/tmpnhp8c65c.rs:70:1\n\
    \   |\n70 | fn main() {\n   | ^^ expected identifier, found keyword\n\nerror:\
    \ expected one of `=>`, `@`, `if`, or `|`, found `main`\n  --> /tmp/tmpnhp8c65c.rs:70:4\n\
    \   |\n70 | fn main() {\n   |    ^^^^ expected one of `=>`, `@`, `if`, or `|`\n\
    \nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpnhp8c65c.rs:17:35\n\
    \   |\n17 |     word.chars().skip_while(|c| c != ' ').for_each(|c| {\n   |   \
    \                                ^^ no implementation for `&char == char`\n  \
    \ |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n \
    \  = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpnhp8c65c.rs:23:9\n   |\n22 |     match result {\n   | \
    \          ------ this expression has type `String`\n23 |         \"\" => \"\"\
    ,\n   |         ^^ expected struct `String`, found `&str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpnhp8c65c.rs:23:15\n   |\n15 | fn get_closest_vowel(word:\
    \ String) -> String {\n   |                                       ------ expected\
    \ `String` because of return type\n...\n23 |         \"\" => \"\",\n   |     \
    \          ^^- help: try using a conversion method: `.to_string()`\n   |     \
    \          |\n   |               expected struct `String`, found `&str`\n\n"
  stdout: ''
  timestamp: 1660053309
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    if\
    \ word.len() == 0 {\n        return String::new();\n    }\n    let mut vowels\
    \ = [\n        \"a\", \"e\", \"i\", \"o\", \"u\", \"y\", \"A\", \"E\", \"I\",\
    \ \"O\", \"U\", \"y\",\n    ];\n\n    let mut vowels_idx = 0usize;\n    let mut\
    \ vowels_cnt = 0usize;\n    let mut vowel_str = String::new();\n\n    vowels.iter().try_for_each(|x|\
    \ {\n        if word.starts_with(x) {\n            vowels_idx += 1;\n        \
    \    vowels_cnt += 1;\n        }\n    });\n\n    if vowels_idx > vowels_cnt {\n\
    \        return String::new();\n    }\n    let vowel_idx = vowels_idx % vowels.len();\n\
    \n    let mut vowels_found = String::new();\n    let mut vowels_idx = vowel_idx.to_ascii_lowercase().len()\
    \ - 1;\n    while vowels_idx >= 0 {\n        vowels_found += vowels[vowels_idx].to_string();\n\
    \        if word.starts_with(vowels[vowels_idx]) {\n            vowels_idx -=\
    \ 1;\n        } else {\n            break;\n        }\n    }\n    vowels_found\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `(): Try` is not satisfied\n    --> /tmp/tmpb1gwpz9g.rs:27:32\n\
    \     |\n27   |       vowels.iter().try_for_each(|x| {\n     |  ___________________------------_^\n\
    \     | |                   |\n     | |                   required by a bound\
    \ introduced by this call\n28   | |         if word.starts_with(x) {\n29   | |\
    \             vowels_idx += 1;\n30   | |             vowels_cnt += 1;\n31   |\
    \ |         }\n32   | |     });\n     | |_____^ the trait `Try` is not implemented\
    \ for `()`\n     |\nnote: required by a bound in `try_for_each`\n\nerror[E0599]:\
    \ no method named `to_ascii_lowercase` found for type `usize` in the current scope\n\
    \  --> /tmp/tmpb1gwpz9g.rs:40:36\n   |\n40 |     let mut vowels_idx = vowel_idx.to_ascii_lowercase().len()\
    \ - 1;\n   |                                    ^^^^^^^^^^^^^^^^^^ method not\
    \ found in `usize`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660053309
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowel_iter = get_vowel_iter();\n\n    let mut word_iter = word.chars();\n\
    \    let mut prev_word = String::new();\n\n    let mut vowel = String::new();\n\
    \    \n    loop {\n        if vowel_iter.next().is_none() {\n            vowel\
    \ = String::new();\n            break;\n        }\n        prev_word = String::from(vowel_iter.next().unwrap());\n\
    \        vowel = String::from(vowel_iter.next().unwrap());\n        vowel = vowel.trim_right();\n\
    \        if vowel.contains(&prev_word[prev_word.len()..]) {\n            break;\n\
    \        }\n    }\n\n    vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `get_vowel_iter` in this scope\n  -->\
    \ /tmp/tmpbxbbwtw1.rs:16:26\n   |\n16 |     let mut vowel_iter = get_vowel_iter();\n\
    \   |                          ^^^^^^^^^^^^^^ not found in this scope\n\nwarning:\
    \ use of deprecated associated function `core::str::<impl str>::trim_right`: superseded\
    \ by `trim_end`\n  --> /tmp/tmpbxbbwtw1.rs:30:23\n   |\n30 |         vowel = vowel.trim_right();\n\
    \   |                       ^^^^^^^^^^ help: replace the use of the deprecated\
    \ associated function: `trim_end`\n   |\n   = note: `#[warn(deprecated)]` on by\
    \ default\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbxbbwtw1.rs:30:17\n\
    \   |\n21 |     let mut vowel = String::new();\n   |                     -------------\
    \ expected due to this value\n...\n30 |         vowel = vowel.trim_right();\n\
    \   |                 ^^^^^^^^^^^^^^^^^^- help: try using a conversion method:\
    \ `.to_string()`\n   |                 |\n   |                 expected struct\
    \ `String`, found `&str`\n\nerror: aborting due to 2 previous errors; 1 warning\
    \ emitted\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053309
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = String::new();\n    let mut current_word = word;\n    while current_word.len()\
    \ > 0 {\n        let mut vowel = String::new();\n        for letter in &current_word[1..]\
    \ {\n            if letter == 'a' || letter == 'e' || letter == 'i' || letter\
    \ == 'o' || letter == 'u' {\n                vowel.push(letter);\n           \
    \ }\n        }\n        if vowels.is_empty() {\n            vowels.push_str(vowel);\n\
    \        } else {\n            vowels.push_str(&vowels[..vowels.len()].iter().collect::<String>());\n\
    \            vowels.push_str(vowel);\n        }\n        current_word = &current_word[0..current_word.len()-1];\n\
    \    }\n    vowels\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&str` is not an iterator\n  --> /tmp/tmpcnng2won.rs:20:23\n\
    \   |\n20 |         for letter in &current_word[1..] {\n   |                 \
    \      ^^^^^^^^^^^^^^^^^^ `&str` is not an iterator; try calling `.chars()` or\
    \ `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `&str`\n\
    \   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcnng2won.rs:26:29\n\
    \   |\n26 |             vowels.push_str(vowel);\n   |                        \
    \     ^^^^^\n   |                             |\n   |                        \
    \     expected `&str`, found struct `String`\n   |                           \
    \  help: consider borrowing here: `&vowel`\n\nerror[E0599]: no method named `iter`\
    \ found for type `str` in the current scope\n  --> /tmp/tmpcnng2won.rs:28:53\n\
    \   |\n28 |             vowels.push_str(&vowels[..vowels.len()].iter().collect::<String>());\n\
    \   |                                                     ^^^^ method not found\
    \ in `str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcnng2won.rs:29:29\n\
    \   |\n29 |             vowels.push_str(vowel);\n   |                        \
    \     ^^^^^\n   |                             |\n   |                        \
    \     expected `&str`, found struct `String`\n   |                           \
    \  help: consider borrowing here: `&vowel`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpcnng2won.rs:31:24\n   |\n17 |     let mut current_word = word;\n\
    \   |                            ---- expected due to this value\n...\n31 |  \
    \       current_word = &current_word[0..current_word.len()-1];\n   |         \
    \               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found `&str`\n   |\nhelp: try using a conversion method\n   |\n31 |        \
    \ current_word = (&current_word[0..current_word.len()-1]).to_string();\n   | \
    \                       +                                      +++++++++++++\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0599.\nFor more information about an error, try `rust"
  stdout: ''
  timestamp: 1660053309
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    match\
    \ word.len() {\n        0 => String::from(\"\"),\n        _ => {\n           \
    \ let mut pos = word.len() - 1;\n            let mut vowel = String::from(\"\"\
    );\n            match word.chars().rev().skip(1).next() {\n                None\
    \ => break,\n                Some(c) => {\n                    if c == 'a' ||\
    \ c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n                        vowel\
    \ = c;\n                        pos = c - 1;\n                    }\n        \
    \        }\n            }\n            word.remove(pos);\n            word.insert(pos,\
    \ 'u');\n            word.insert(pos + 1, 'a');\n            word.insert(pos +\
    \ 1, 'e');\n            word.insert(pos + 1, 'i');\n            word.insert(pos\
    \ + 1, 'o');\n            word.insert(pos + 1, 'u');\n            word.insert(0,\
    \ vowel);\n            word\n        }\n    }\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0268]: `break` outside of a loop\n  --> /tmp/tmpxwf4s1vw.rs:22:25\n\
    \   |\n22 |                 None => break,\n   |                         ^^^^^\
    \ cannot `break` outside of a loop\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxwf4s1vw.rs:25:33\n\
    \   |\n20 |             let mut vowel = String::from(\"\");\n   |            \
    \                 ---------------- expected due to this value\n...\n25 |     \
    \                    vowel = c;\n   |                                 ^- help:\
    \ try using a conversion method: `.to_string()`\n   |                        \
    \         |\n   |                                 expected struct `String`, found\
    \ `char`\n\nerror[E0369]: cannot subtract `{integer}` from `char`\n  --> /tmp/tmpxwf4s1vw.rs:26:33\n\
    \   |\n26 |                         pos = c - 1;\n   |                       \
    \        - ^ - {integer}\n   |                               |\n   |         \
    \                      char\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxwf4s1vw.rs:37:28\n\
    \   |\n37 |             word.insert(0, vowel);\n   |                         \
    \   ^^^^^ expected `char`, found struct `String`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0268, E0308, E0369.\nFor\
    \ more information about an error, try `rustc --explain E0268`.\n"
  stdout: ''
  timestamp: 1660053309
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = [\n        \"a\",\n        \"e\",\n        \"i\",\n        \"o\",\n\
    \        \"u\",\n        \"y\",\n    ];\n\n    let mut vowel_position = word.chars().nth(word.len());\n\
    \    let mut vowel_found = false;\n    let mut closest_vowel = String::new();\n\
    \n    for vowel in vowels {\n        vowel_found = false;\n        for _ch in\
    \ word.chars() {\n            if vowel == _ch.to_string().as_str() {\n       \
    \         vowel_found = true;\n                vowel_position = _ch;\n       \
    \     }\n        }\n\n        if !vowel_found {\n            break;\n        }\n\
    \    }\n\n    closest_vowel.clear();\n    if vowel_position == word.chars().nth(word.len()\
    \ - 1) {\n        if vowel_found {\n            closest_vowel.push_str(vowel);\n\
    \        }\n    } else {\n        for _ in 0..word.len() {\n            if vowel_found\
    \ {\n                closest_vowel.push_str(vowels[vowel_position.cmp(vowels[vowels.len()])]);\n\
    \                break;\n            }\n            vowel_position.next();\n \
    \       }\n    }\n\n    closest_vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `vowel` in this scope\n  --> /tmp/tmpmkeec61f.rs:46:36\n\
    \   |\n46 |             closest_vowel.push_str(vowel);\n   |                 \
    \                   ^^^^^ help: a local variable with a similar name exists: `vowels`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpmkeec61f.rs:34:34\n   |\n25 |\
    \     let mut vowel_position = word.chars().nth(word.len());\n   |           \
    \                   ---------------------------- expected due to this value\n\
    ...\n34 |                 vowel_position = _ch;\n   |                        \
    \          ^^^ expected enum `Option`, found `char`\n   |\n   = note: expected\
    \ enum `Option<char>`\n              found type `char`\nhelp: try wrapping the\
    \ expression in `Some`\n   |\n34 |                 vowel_position = Some(_ch);\n\
    \   |                                  +++++   +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpmkeec61f.rs:51:66\n   |\n51 |                 closest_vowel.push_str(vowels[vowel_position.cmp(vowels[vowels.len()])]);\n\
    \   |                                                                  ^^^^^^^^^^^^^^^^^^^^\
    \ expected enum `Option`, found `str`\n   |\n   = note: expected reference `&Option<char>`\n\
    \              found reference `&str`\n\nerror[E0277]: the type `[&str]` cannot\
    \ be indexed by `std::cmp::Ordering`\n  --> /tmp/tmpmkeec61f.rs:51:40\n   |\n\
    51 |                 closest_vowel.push_str(vowels[vowel_position.cmp(vowels[vowels.len()])]);\n\
    \   |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[&str]>` is not implemented for `std::cmp::Ordering`\n   =\
    \ note: required because of the requirements on the impl of `Index<std::cmp::Ordering>`\
    \ for `[&str]`\n\nerror[E0599]: no method named `next` found for enum `Option`\
    \ in the current scope\n  --> /tmp/tmpmkeec61f.rs:54:28\n   |\n54 |          \
    \   vowel_position.next();\n   |                            ^^^^ method not found\
    \ in `Option<char>`\n\nerror: aborting due to 5 previous errors\n\nSome errors\
    \ have detailed e"
  stdout: ''
  timestamp: 1660053309
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    fn\
    \ get_vowels(s: &str) -> Vec<&str> {\n        fn is_vowel(v: char) -> bool {\n\
    \            v.is_uppercase() && v != 'I'\n        }\n        s.chars()\n    \
    \        .filter(is_vowel)\n            .collect::<Vec<&str>>()\n    }\n\n   \
    \ fn find_vowel(word: &str, i: usize, words: &[&str]) -> &str {\n        if i\
    \ == words.len() {\n            return words[i - 1]\n        }\n\n        if words[i\
    \ - 1].is_uppercase() && words[i - 2] == words[i - 1] {\n            find_vowel(word,\
    \ i + 1, words)\n        } else {\n            find_vowel(word, i, words)\n  \
    \      }\n    }\n\n    let vowels = get_vowels(word);\n    let mut min = std::i32::MAX;\n\
    \n    for vowel in &vowels {\n        let pos = word.char_indices().position(|&(idx,\
    \ _)| vowel == &word[idx]);\n        if let Some(pos) = pos {\n            let\
    \ res = find_vowel(word, pos, &vowels);\n            if min > res.len() {\n  \
    \              min = res.len();\n            }\n        }\n    }\n\n    String::from(vowels[min..].iter().cloned().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0106]: missing lifetime specifier\n  --> /tmp/tmp5910yg8j.rs:25:60\n\
    \   |\n25 |     fn find_vowel(word: &str, i: usize, words: &[&str]) -> &str {\n\
    \   |                         ----                   -------     ^ expected named\
    \ lifetime parameter\n   |\n   = help: this function's return type contains a\
    \ borrowed value, but the signature does not say whether it is borrowed from `word`\
    \ or one of `words`'s 2 lifetimes\nhelp: consider introducing a named lifetime\
    \ parameter\n   |\n25 |     fn find_vowel<'a>(word: &'a str, i: usize, words:\
    \ &'a [&str]) -> &'a str {\n   |                  ++++        ++             \
    \           ++             ++\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0106`.\n"
  stdout: ''
  timestamp: 1660053309
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    \n\
    \    // The first two characters will always belong to a consonant.\n    // If\
    \ we are at the right side of the word and there are less than 3 consonants,\n\
    \    // we cannot find a vowel between the consonants.\n    if word.len() < 3\
    \ {\n        return String::from(\"\");\n    }\n    \n    let mut min_vowel =\
    \ 0;\n    let mut max_vowel = word.len() - 1;\n    while min_vowel <= max_vowel\
    \ {\n        \n        // If there is a vowel between [min_vowel, max_vowel],\
    \ we can return that.\n        if word.starts_with(vowels[min_vowel..=max_vowel].iter().map(String::from).collect::<Vec<String>>())\
    \ {\n            return word.clone(); \n        }\n        \n        // Otherwise,\
    \ we have to look in the other half of the word.\n        min_vowel += 1;\n  \
    \      max_vowel -= 1;\n    }\n    \n    // If we get here, we didn't find any\
    \ vowels meeting the conditions.\n    return String::from(\"\");\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `vowels` in this scope\n  --> /tmp/tmpskcfojjv.rs:29:29\n\
    \   |\n29 |         if word.starts_with(vowels[min_vowel..=max_vowel].iter().map(String::from).collect::<Vec<String>>())\
    \ {\n   |                             ^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660053309
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels_string = if word.chars().any(|c| c == 'A' || c == 'E' || c == 'I' ||\
    \ c == 'O' || c == 'U') {\n        format!(\"{}{}{}{}{}{}\", c('A'), 'E', 'i',\
    \ 'O', 'u', 'U')\n    } else {\n        format!(\"{}{}{}{}\", c('a'), 'e', 'i',\
    \ 'o', 'u')\n    };\n    word\n        .split_whitespace()\n        .next()\n\
    \        .split_ascii_lowercase()\n        .iter()\n        .zip(word.split_ascii_lowercase().iter())\n\
    \        .enumerate()\n        .take(word.len())\n        .map(|(i, j)| (j - i).abs()\
    \ as usize - vowels_string.len())\n        .max()\n        .unwrap_or(0)\n   \
    \     .to_string()\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: argument never used\n  --> /tmp/tmpt8tedog2.rs:19:52\n   |\n19 |\
    \         format!(\"{}{}{}{}\", c('a'), 'e', 'i', 'o', 'u')\n   |            \
    \     ----------                         ^^^ argument never used\n   |       \
    \          |\n   |                 formatting specifier missing\n\nerror[E0425]:\
    \ cannot find function `c` in this scope\n  --> /tmp/tmpt8tedog2.rs:17:33\n  \
    \ |\n17 |         format!(\"{}{}{}{}{}{}\", c('A'), 'E', 'i', 'O', 'u', 'U')\n\
    \   |                                 ^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `c` in this scope\n  --> /tmp/tmpt8tedog2.rs:19:29\n  \
    \ |\n19 |         format!(\"{}{}{}{}\", c('a'), 'e', 'i', 'o', 'u')\n   |    \
    \                         ^ not found in this scope\n\nerror[E0599]: no method\
    \ named `split_ascii_lowercase` found for enum `Option` in the current scope\n\
    \  --> /tmp/tmpt8tedog2.rs:24:10\n   |\n24 |         .split_ascii_lowercase()\n\
    \   |          ^^^^^^^^^^^^^^^^^^^^^ method not found in `Option<&str>`\n\nerror[E0599]:\
    \ no method named `split_ascii_lowercase` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpt8tedog2.rs:26:19\n   |\n26 |         .zip(word.split_ascii_lowercase().iter())\n\
    \   |                   ^^^^^^^^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `to_ascii_lowercase`\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660053309
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    assert!(word.is_ascii_lowercase());\n\
    \n    // init vowels\n    let mut first_vowels = Vec::new();\n    let mut last_vowels\
    \ = Vec::new();\n    let mut second_vowels = Vec::new();\n\n    for ch in word.chars()\
    \ {\n        if !is_vowel(ch) {\n            if first_vowels.len() >= 2 {\n  \
    \              last_vowels.push(first_vowels.last().unwrap());\n            }\
    \ else {\n                break;\n            }\n        } else {\n          \
    \  first_vowels.push(ch);\n        }\n    }\n\n    for ch in word.chars() {\n\
    \        if !is_vowel(ch) {\n            if second_vowels.len() >= 2 {\n     \
    \           first_vowels.push(second_vowels.first().unwrap());\n            }\
    \ else {\n                break;\n            }\n        } else {\n          \
    \  second_vowels.push(ch);\n        }\n    }\n\n    // get closest vowels\n  \
    \  let mut first_vowels_len = first_vowels.len();\n    let mut last_vowels_len\
    \ = last_vowels.len();\n    let mut second_vowels_len = second_vowels.len();\n\
    \n    if first_vowels.len() > 0 {\n        if first_vowels_len < last_vowels_len\
    \ {\n            first_vowels_len = last_vowels_len;\n        }\n    }\n\n   \
    \ if first_vowels.len() > 0 {\n        if first_vowels_len < second_vowels_len\
    \ {\n            first_vowels_len = second_vowels_len;\n        }\n    }\n\n \
    \   if first_vowels.len() > 0 {\n        let mut vowel_one = first_vowels[first_vowels_len\
    \ - 1];\n        let mut vowel_one_prev = last_vowels[last_vowels_len - 1];\n\
    \        let mut vowel_two = second_vowels[second_vowels_len - 1];\n        let\
    \ mut vowel_two_prev = second_vowels[second_vowels_len - 1];\n\n        if vowel_one.cmp(&vowel_two)\
    \ == 0 {\n            vowel_two_prev = vowel_one;\n            vowel_two_prev\
    \ = &vowel_two;\n        }\n\n        let mut min_len = second_vowels_len + first_vowels_len;\n\
    \n        for j in 0..second_vowels_len {\n            if second_vowels[j - 1].cmp(&vowel_two)\
    \ == 0 {\n                let mut min_j = second_vowels.len();\n             \
    \   for i in 0..last_vowels_len {\n                    if second_vowels[i] - &vowel_one_prev\
    \ > &vowel_two_prev - &vowel_one {\n                        min_j = i;\n     \
    \               }\n                }\n                second_vowels[j - 1] = vowel_two;\n\
    \                second_vowels[j] = &second_vowels[min_j];\n                min_len\
    \ = min_j;\n            }\n        }\n\n        for j in 0..first_vowels_len {\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp5ed38qhl.rs:109:3\n\
    \    |\n15  | fn get_closest_vowel(word: String) -> String {\n    |          \
    \                                    - unclosed delimiter\n...\n64  |     if first_vowels.len()\
    \ > 0 {\n    |                               - unclosed delimiter\n...\n91  |\
    \         for j in 0..first_vowels_len {\n    |                              \
    \        - this delimiter might not be properly closed...\n92  | }\n    | - ...as\
    \ it matches this but it has different indentation\n...\n109 | }\n    |   ^\n\n\
    error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp5ed38qhl.rs:24:13\n\
    \   |\n24 |         if !is_vowel(ch) {\n   |             ^^^^^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find function `is_vowel` in this scope\n\
    \  --> /tmp/tmp5ed38qhl.rs:36:13\n   |\n36 |         if !is_vowel(ch) {\n   |\
    \             ^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named\
    \ `is_ascii_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmp5ed38qhl.rs:16:18\n\
    \   |\n16 |     assert!(word.is_ascii_lowercase());\n   |                  ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_lowercase`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp5ed38qhl.rs:38:35\n   |\n38 |\
    \                 first_vowels.push(second_vowels.first().unwrap());\n   |   \
    \                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`,\
    \ found reference\n   |\n   = note:   expected type `char`\n           found reference\
    \ `&_`\nhelp: consider dereferencing the borrow\n   |\n38 |                 first_vowels.push(*second_vowels.first().unwrap());\n\
    \   |                                   +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp5ed38qhl.rs:70:41\n   |\n70 |         if vowel_one.cmp(&vowel_two)\
    \ == 0 {\n   |                                         ^ expected enum `std::cmp::Ordering`,\
    \ found integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5ed38qhl.rs:72:30\n\
    \   |\n68 |         let mut vowel_two_prev = second_vowels[second_vowels_len -\
    \ 1];\n   |   "
  stdout: ''
  timestamp: 1660053309
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    if\
    \ word.is_empty() {\n        String::from(\"\")\n    } else {\n        let mut\
    \ i = 0;\n        let mut min_i = 1;\n        let mut min_j = word.len();\n  \
    \      while i < min_i {\n            while j >= min_j {\n                if word[j]\
    \ == Some(Some('a')) || word[j] == Some(Some('e')) || word[j] == Some(Some('i'))\
    \ || word[j] == Some(Some('o')) || word[j] == Some(Some('u')) || word[j] == Some(Some('y'))\
    \ {\n                    if i == 1 {\n                        min_j = j;\n   \
    \                 } else {\n                        min_i = i;\n             \
    \       }\n                } else {\n                    j -= 1;\n           \
    \     }\n            }\n            i += 1;\n        }\n        if min_i == 1\
    \ {\n            String::from(\"\")\n        } else {\n            word.chars().nth(min_i\
    \ - 1).unwrap().to_string()\n        }\n    }\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `j` in this scope\n  --> /tmp/tmpzdo8kz8o.rs:23:19\n\
    \   |\n23 |             while j >= min_j {\n   |                   ^ help: a local\
    \ variable with a similar name exists: `i`\n\nerror[E0425]: cannot find value\
    \ `j` in this scope\n  --> /tmp/tmpzdo8kz8o.rs:24:25\n   |\n24 | ...   if word[j]\
    \ == Some(Some('a')) || word[j] == Some(Some('e')) || word[j] == Some(Some('i'))\
    \ || word[j] == Some(Some('o')) || word[j] == ...\n   |               ^ help:\
    \ a local variable with a similar name exists: `i`\n\nerror[E0425]: cannot find\
    \ value `j` in this scope\n  --> /tmp/tmpzdo8kz8o.rs:24:55\n   |\n24 | ...   if\
    \ word[j] == Some(Some('a')) || word[j] == Some(Some('e')) || word[j] == Some(Some('i'))\
    \ || word[j] == Some(Some('o')) || word[j] == ...\n   |                      \
    \                       ^ help: a local variable with a similar name exists: `i`\n\
    \nerror[E0425]: cannot find value `j` in this scope\n  --> /tmp/tmpzdo8kz8o.rs:24:85\n\
    \   |\n24 | ...   if word[j] == Some(Some('a')) || word[j] == Some(Some('e'))\
    \ || word[j] == Some(Some('i')) || word[j] == Some(Some('o')) || word[j] == ...\n\
    \   |                                                                        \
    \   ^ help: a local variable with a similar name exists: `i`\n\nerror[E0425]:\
    \ cannot find value `j` in this scope\n  --> /tmp/tmpzdo8kz8o.rs:24:115\n   |\n\
    24 | ...) || word[j] == Some(Some('i')) || word[j] == Some(Some('o')) || word[j]\
    \ == Some(Some('u')) || word[j] == Some(Some('y')) {\n   |                   \
    \                         ^ help: a local variable with a similar name exists:\
    \ `i`\n\nerror[E0425]: cannot find value `j` in this scope\n  --> /tmp/tmpzdo8kz8o.rs:24:145\n\
    \   |\n24 | ...) || word[j] == Some(Some('o')) || word[j] == Some(Some('u')) ||\
    \ word[j] == Some(Some('y')) {\n   |                                         \
    \   ^ help: a local variable with a similar name exists: `i`\n\nerror[E0425]:\
    \ cannot find value `j` in this scope\n  --> /tmp/tmpzdo8kz8o.rs:24:175\n   |\n\
    24 | ...) || word[j] == Some(Some('u')) || word[j] == Some(Some('y')) {\n   |\
    \                             "
  stdout: ''
  timestamp: 1660053309
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    if\
    \ word.len() > 0 {\n        let mut a = word[0];\n        let mut b = word[word.len()\
    \ - 1];\n\n        for i in 0..word.len() - 2 {\n            if a..=b == get_vowels(&word[i]).rev()\
    \ {\n                a = word[i];\n            }\n            b /= 2;\n      \
    \  }\n        String::from(\"\")\n    }\n    return String::from(\"\");\n}\n\n\
    fn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `get_vowels` in this scope\n  --> /tmp/tmp03vm3ezd.rs:21:25\n\
    \   |\n21 |             if a..=b == get_vowels(&word[i]).rev() {\n   |       \
    \                  ^^^^^^^^^^ not found in this scope\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp03vm3ezd.rs:17:21\n\
    \   |\n17 |         let mut a = word[0];\n   |                     ^^^^^^^ `String`\
    \ cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp03vm3ezd.rs:18:21\n   |\n18 |         let mut b = word[word.len()\
    \ - 1];\n   |                     ^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp03vm3ezd.rs:21:37\n   |\n21 |             if a..=b == get_vowels(&word[i]).rev()\
    \ {\n   |                                     ^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n"
  stdout: ''
  timestamp: 1660053309
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = String::from(\"a\");\n    let mut vowels_right = String::from(\"\
    e\");\n    let mut vowels_left = String::from(\"i\");\n    let mut vowels_right_next\
    \ = String::from(\"u\");\n    let mut vowels_left_next = String::from(\"e\");\n\
    \    let mut vowels_start = String::from(\"a\");\n    let mut vowels_end = String::from(\"\
    e\");\n    let mut letter_ = String::from(\"a\");\n    let mut letters_left =\
    \ String::from(\"a\");\n    let mut letters_right = String::from(\"a\");\n   \
    \ let mut letters_left_next = String::from(\"a\");\n    let mut letters_right_next\
    \ = String::from(\"a\");\n    \n    for c in word.chars().rev().skip(1) {\n  \
    \      if c.is_uppercase() {\n            letters_left.push(c); \n        }\n\
    \        if c.is_lowercase() {\n            letters_right.push(c);\n        }\n\
    \    }\n\n    for c in word.chars().rev() {\n        if c.is_lowercase() {\n \
    \           letters_left_next.push(c);\n        }\n        if c.is_uppercase()\
    \ {\n            letters_right_next.push(c);\n        }\n    }\n\n    for c in\
    \ word.chars().skip(1) {\n        if c.is_uppercase() {\n            vowels_right.push(c);\n\
    \        }\n        if c.is_lowercase() {\n            vowels_left.push(c);\n\
    \        }\n    }\n    \n    for c in word.chars().skip(1) {\n        if c.is_lowercase()\
    \ {\n            vowels_right_next.push(c);\n        }\n        if c.is_uppercase()\
    \ {\n            vowels_left_next.push(c);\n        }\n    }\n\n    for c in word.chars().skip(1)\
    \ {\n        if c.is_uppercase() {\n            vowels_start.push(c);\n      \
    \  }\n        if c.is_lowercase() {\n            vowels_end.push(c);\n       \
    \ }\n    }\n    \n    if vowels_start == vowels_end || vowels_right == vowels_left\
    \ {\n        letters_left = \"\".to_owned();\n        letters_right = \"\".to_owned();\n\
    \    }\n    \n    if letters_left_next == letters_right || letters_left_next ==\
    \ letters_right_next {\n        letters_left_next = \"\".to_owned();\n       \
    \ letters_right_next = \"\".to_owned();\n    }\n    \n    if letters_right ==\
    \ letters_left || letters_right == letters_left_next {\n        letters_right\
    \ = \"\".to_owned();\n        letters_left = \"\".to_owned();\n    }\n    \n \
    \   if letters_start == letter\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `}`\n  --> /tmp/tmprus48otf.rs:90:1\n   |\n\
    89 |     if letters_start == letter\n   |     -- this `if` expression has a condition,\
    \ but no block\n90 | }\n   | ^ expected `{`\n\nerror: aborting due to previous\
    \ error\n\n"
  stdout: ''
  timestamp: 1660053309
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    if\
    \ word.len() <= 2 {\n        return String::from(\"\");\n    }\n    \n    let\
    \ mut vowel = String::from(\"\");\n    let mut consonant = String::from(\"\");\n\
    \    let mut current_pos = 0;\n    let mut current_vowel = String::from(\"\");\n\
    \    \n    while current_pos < word.len() {\n        consonant = word.clone();\n\
    \        consonant = consonant.chars().skip_while(|c| c != 'a' && c != 'e' &&\
    \ c != 'i' && c != 'o' && c != 'u').collect::<String>();\n        \n        if\
    \ consonant.len() >= 2 {\n            vowel = word.clone();\n            vowel\
    \ = vowel.chars().skip_while(|c| c != 'a' && c != 'e' && c != 'i' && c != 'o'\
    \ && c != 'u').collect::<String>();\n            \n            if vowel.len()\
    \ >= 2 {\n                \n                if vowel == consonant.chars().last().unwrap().to_string()\
    \ {\n                    if vowel == consonant.chars().nth(1).unwrap().to_string()\
    \ {\n                        current_vowel = vowel;\n                        break;\n\
    \                    }\n                }\n            }\n        }\n        current_pos\
    \ = current_pos + 1;\n    }\n    return current_vowel;\n}\n\nfn main() {\n   \
    \ let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp49ishzsg.rs:27:56\n\
    \   |\n27 |         consonant = consonant.chars().skip_while(|c| c != 'a' && c\
    \ != 'e' && c != 'i' && c != 'o' && c != 'u').collect::<String>();\n   |     \
    \                                                   ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmp49ishzsg.rs:27:68\n   |\n27\
    \ |         consonant = consonant.chars().skip_while(|c| c != 'a' && c != 'e'\
    \ && c != 'i' && c != 'o' && c != 'u').collect::<String>();\n   |            \
    \                                                        ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp49ishzsg.rs:27:80\n\
    \   |\n27 |         consonant = consonant.chars().skip_while(|c| c != 'a' && c\
    \ != 'e' && c != 'i' && c != 'o' && c != 'u').collect::<String>();\n   |     \
    \                                                                           ^^\
    \ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp49ishzsg.rs:27:92\n\
    \   |\n27 |         consonant = consonant.chars().skip_while(|c| c != 'a' && c\
    \ != 'e' && c != 'i' && c != 'o' && c != 'u').collect::<String>();\n   |     \
    \                                                                            \
    \           ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmp49ishzsg.rs:27:104\n   |\n27 |         consonant = consonant.chars().skip_while(|c| "
  stdout: ''
  timestamp: 1660053309
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    word.chars().skip_while(|c|\
    \ c.is_ascii_letter())\n        .cloned()\n        .rfind(|c| c.is_ascii_letter())\n\
    \        .and_then(|i| word.chars().get_mut(i).unwrap().is_ascii_vowel())\n  \
    \      .unwrap_or(\"\")\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmp5japtuz6.rs:16:35\n   |\n16 |     word.chars().skip_while(|c|\
    \ c.is_ascii_letter())\n   |                                   ^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `is_ascii`\n\nerror[E0271]:\
    \ type mismatch resolving `<SkipWhile<Chars<'_>, [closure@/tmp/tmp5japtuz6.rs:16:29:\
    \ 16:52]> as Iterator>::Item == &_`\n    --> /tmp/tmp5japtuz6.rs:17:10\n     |\n\
    17   |         .cloned()\n     |          ^^^^^^ expected reference, found `char`\n\
    \     |\n     = note: expected reference `&_`\n                     found type\
    \ `char`\nnote: required by a bound in `cloned`\n\nerror[E0599]: the method `rfind`\
    \ exists for struct `Cloned<SkipWhile<Chars<'_>, [closure@/tmp/tmp5japtuz6.rs:16:29:\
    \ 16:52]>>`, but its trait bounds were not satisfied\n  --> /tmp/tmp5japtuz6.rs:18:10\n\
    \   |\n18 |            .rfind(|c| c.is_ascii_letter())\n   |             ^^^^^\
    \ method cannot be called on `Cloned<SkipWhile<Chars<'_>, [closure@/tmp/tmp5japtuz6.rs:16:29:\
    \ 16:52]>>` due to unsatisfied trait bounds\n   |\n   = note: the following trait\
    \ bounds were not satisfied:\n           `<SkipWhile<Chars<'_>, [closure@/tmp/tmp5japtuz6.rs:16:29:\
    \ 16:52]> as Iterator>::Item = &_`\n           which is required by `Cloned<SkipWhile<Chars<'_>,\
    \ [closure@/tmp/tmp5japtuz6.rs:16:29: 16:52]>>: DoubleEndedIterator`\n       \
    \    `SkipWhile<Chars<'_>, [closure@/tmp/tmp5japtuz6.rs:16:29: 16:52]>: DoubleEndedIterator`\n\
    \           which is required by `Cloned<SkipWhile<Chars<'_>, [closure@/tmp/tmp5japtuz6.rs:16:29:\
    \ 16:52]>>: DoubleEndedIterator`\n\nerror[E0599]: no method named `get_mut` found\
    \ for struct `Chars` in the current scope\n   --> /tmp/tmp5japtuz6.rs:19:36\n\
    \    |\n19  |         .and_then(|i| word.chars().get_mut(i).unwrap().is_ascii_vowel())\n\
    \    |                                    ^^^^^^^ method not found in `Chars<'_>`\n\
    \    |\nhelp: consider wrapping the receiver expression with the appropriate type\n\
    \    |\n19  |         .and_then(|i| Pin::new(&mut word.chars("
  stdout: ''
  timestamp: 1660053309
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    if\
    \ word.length() == 0 {\n        String::from(\"\")\n    }\n    let mut vowels\
    \ = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_size = vowels.len();\n\
    \    let mut consonants = String::from(\"qwertyuiop\");\n    let mut consonants_size\
    \ = consonants.len();\n    \n    while vowels_size < word.len() {\n        if\
    \ word.chars().any(|c| c == vowels[vowels_size]) {\n            vowels_size +=\
    \ 1;\n        }\n    }\n    while consonants_size < word.len() {\n        if word.chars().any(|c|\
    \ c == consonants[consonants_size]) {\n            consonants_size += 1;\n   \
    \     }\n    }\n    \n    while consonants_size >= vowels_size {\n        let\
    \ start = consonants_size - vowels_size + 1;\n        let end = consonants_size;\n\
    \        let mut min_index = start;\n        let mut min_dist = std::cmp::max::<i32>();\n\
    \        for index in start..end {\n            let dist = word.chars().position(|c|\
    \ c == consonants[index]).unwrap_or(word.len());\n            if dist < min_dist\
    \ {\n                min_dist = dist;\n                min_index = index;\n  \
    \          }\n        }\n        if min_index != 0 {\n            return word.chars().take(min_index).collect();\n\
    \        }\n        consonants_size -= 1;\n    }\n    \n    while vowels_size\
    \ >= consonants_size {\n        let start = vowels_size - consonants_size + 1;\n\
    \        let end = vowels_size;\n        let mut min_index = start;\n        let\
    \ mut min_dist = std::cmp::max::<i32>();\n        for index in start..end {\n\
    \            let dist = word.chars().position(|c| c == vowels[index]).unwrap_or(word.len());\n\
    \            if dist < min_dist {\n                min_dist = dist;\n        \
    \        min_index = index;\n            }\n        }\n        if min_index !=\
    \ 0 {\n            return word.chars().take(min_index).collect();\n        }\n\
    \        vowels_size -= 1;\n    }\n    \n    String::from(\"\")\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpxwdu0ydu.rs:16:13\n   |\n16 |     if word.length()\
    \ == 0 {\n   |             ^^^^^^ help: there is an associated function with a\
    \ similar name: `len`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxwdu0ydu.rs:17:9\n\
    \   |\n16 | /     if word.length() == 0 {\n17 | |         String::from(\"\")\n\
    \   | |         ^^^^^^^^^^^^^^^^ expected `()`, found struct `String`\n18 | |\
    \     }\n   | |_____- expected this to be `()`\n   |\nhelp: consider using a semicolon\
    \ here\n   |\n17 |         String::from(\"\");\n   |                         +\n\
    help: consider using a semicolon here\n   |\n18 |     };\n   |      +\nhelp: you\
    \ might have meant to return this value\n   |\n17 |         return String::from(\"\
    \");\n   |         ++++++                 +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpxwdu0ydu.rs:25:38\n   |\n25 |         if word.chars().any(|c| c\
    \ == vowels[vowels_size]) {\n   |                                      ^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found `&str`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpxwdu0ydu.rs:30:38\n   |\n30 |         if word.chars().any(|c|\
    \ c == consonants[consonants_size]) {\n   |                                  \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0061]:\
    \ this function takes 2 arguments but 0 arguments were supplied\n    --> /tmp/tmpxwdu0ydu.rs:39:28\n\
    \     |\n39   |         let mut min_dist = std::cmp::max::<i32>();\n     |   \
    \                         ^^^^^^^^^^^^^^^^^^^^-- supplied 0 arguments\n     |\
    \  "
  stdout: ''
  timestamp: 1660053309
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowel = \"A\";\n    let mut res = String::from(\"A\");\n    let mut vowels_end\
    \ = String::from(\"z\");\n    \n    for i in word.rfind('a') {\n        vowel\
    \ = String::from(\"A\");\n        vowels_end = String::from(\"z\");\n        continue;\n\
    \    }\n    \n    for i in word.rfind('b') {\n        vowel = String::from(\"\
    B\");\n        vowels_end = String::from(\"z\");\n        continue;\n    }\n \
    \   \n    for i in word.rfind('c') {\n        vowel = String::from(\"C\");\n \
    \       vowels_end = String::from(\"z\");\n        continue;\n    }\n    \n  \
    \  for i in word.rfind('d') {\n        vowel = String::from(\"D\");\n        vowels_end\
    \ = String::from(\"z\");\n        continue;\n    }\n    \n    for i in word.rfind('e')\
    \ {\n        vowel = String::from(\"E\");\n        vowels_end = String::from(\"\
    z\");\n        continue;\n    }\n    \n    for i in word.rfind('f') {\n      \
    \  vowel = String::from(\"F\");\n        vowels_end = String::from(\"z\");\n \
    \       continue;\n    }\n    \n    for i in word.rfind('g') {\n        vowel\
    \ = String::from(\"G\");\n        vowels_end = String::from(\"z\");\n        continue;\n\
    \    }\n    \n    for i in word.rfind('h') {\n        vowel = String::from(\"\
    H\");\n        vowels_end = String::from(\"z\");\n        continue;\n    }\n \
    \   \n    for i in word.rfind('i') {\n        vowel = String::from(\"I\");\n \
    \       vowels_end = String::from(\"z\");\n        continue;\n    }\n    \n  \
    \  for i in word.rfind('j') {\n        vowel = String::from(\"J\");\n        vowels_end\
    \ = String::from(\"z\");\n        continue;\n    }\n    \n    for i in word.rfind('k')\
    \ {\n        vowel = String::from(\"K\");\n        vowels_end = String::from(\"\
    z\");\n        continue;\n    }\n    \n    for i in word.rfind('l') {\n      \
    \  vowel = String::from(\"L\");\n        vowels_end = String::from(\"z\");\n \
    \       continue;\n    }\n    \n    for i in word.rfind('m') {\n        vowel\
    \ = String::from(\"M\");\n        vowels_end = String::from(\"z\");\n        continue;\n\
    \    }\n    \n    for i in word.rfind('n') {\n        vowel = String::from(\"\
    N\");\n        vowels_end = String::\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpbo8eb75n.rs:118:3\n\
    \    |\n15  | fn get_closest_vowel(word: String) -> String {\n    |          \
    \                                    - unclosed delimiter\n...\n98  |     for\
    \ i in word.rfind('n') {\n    |                              - this delimiter\
    \ might not be properly closed...\n...\n101 | }\n    | - ...as it matches this\
    \ but it has different indentation\n...\n118 | }\n    |   ^\n\nerror: expected\
    \ identifier, found `}`\n   --> /tmp/tmpbo8eb75n.rs:101:1\n    |\n101 | }\n  \
    \  | ^ expected identifier\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbo8eb75n.rs:21:17\n\
    \   |\n16 |     let mut vowel = \"A\";\n   |                     --- expected\
    \ due to this value\n...\n21 |         vowel = String::from(\"A\");\n   |    \
    \             ^^^^^^^^^^^^^^^^^\n   |                 |\n   |                \
    \ expected `&str`, found struct `String`\n   |                 help: consider\
    \ borrowing here: `&String::from(\"A\")`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpbo8eb75n.rs:27:17\n   |\n16 |     let mut vowel = \"A\";\n   | \
    \                    --- expected due to this value\n...\n27 |         vowel =\
    \ String::from(\"B\");\n   |                 ^^^^^^^^^^^^^^^^^\n   |         \
    \        |\n   |                 expected `&str`, found struct `String`\n   |\
    \                 help: consider borrowing here: `&String::from(\"B\")`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpbo8eb75n.rs:33:17\n   |\n16 |     let mut vowel\
    \ = \"A\";\n   |                     --- expected due to this value\n...\n33 |\
    \         vowel = String::from(\"C\");\n   |                 ^^^^^^^^^^^^^^^^^\n\
    \   |                 |\n   |                 expected `&str`, found struct `String`\n\
    \   |                 help: consider borrowing here: `&String::from(\"C\")`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpbo8eb75n.rs:39:17\n   |\n16 |  \
    \   let mut vowel = \"A\";\n   |                     --- expected due to this\
    \ value\n...\n39 |         vowel = String::from(\"D\");\n   |                \
    \ ^^^^^^^^^^^^^^^^^\n   |                 |\n   |                 expected `&str`,\
    \ found struct `Strin"
  stdout: ''
  timestamp: 1660053309
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    word.chars().rev().chain(word.chars().cloned()).\n\
    \         filter_map(|c| if c.to_lowercase() == 'a' || c.to_lowercase() == 'e'\
    \ || c.to_lowercase() == 'i' || c.to_lowercase() == 'o' || c.to_lowercase() ==\
    \ 'u' {Some(c)} else None).\n         collect().\n         fold(String::new(),\
    \ |a, b| {\n             if b.is_empty() {a.push_str(\"\"); return a}\n      \
    \       let mut a = a;\n             let mut b = b;\n             if b.len() >\
    \ a.len() {a = b; b = []}\n             for &(c1, c2) in a.chars().zip(b.chars())\
    \ {\n                 if c1 == c2 {\n                     let mut k = c1;\n  \
    \                   let mut l = c2;\n                     for _ in 0..=c1-c2+1\
    \ {k += 1; l += 1}\n                     a.push_str(&*k);\n                  \
    \   b.clear();\n                     return a;\n                 }\n         \
    \    }\n             a.push_str(&*b)\n         });\n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `None`\n  --> /tmp/tmppukf7kna.rs:17:175\n \
    \  |\n17 | ...owercase() == 'o' || c.to_lowercase() == 'u' {Some(c)} else None).\n\
    \   |                                                                ^^^^ expected\
    \ `{`\n   |\nhelp: try placing this code inside a block\n   |\n17 |          filter_map(|c|\
    \ if c.to_lowercase() == 'a' || c.to_lowercase() == 'e' || c.to_lowercase() ==\
    \ 'i' || c.to_lowercase() == 'o' || c.to_lowercase() == 'u' {Some(c)} else { None\
    \ }).\n   |                                                                  \
    \                                                                            \
    \                                 +      +\n\nerror: aborting due to previous\
    \ error\n\n"
  stdout: ''
  timestamp: 1660053309
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut cur_vowel: i8;\n    let mut cur_pos: usize;\n    let mut is_start_vowel:\
    \ u8;\n    let mut is_end_vowel: u8;\n    let mut is_in_vowel: u8;\n\n    let\
    \ mut is_vowel = false;\n\n    word.chars().for_each(|c| {\n        if c == '\
    \ ' { // ignore space\n            return;\n        }\n        if !is_in_vowel\
    \ && is_start_vowel {\n            is_in_vowel = true;\n            return;\n\
    \        }\n        if is_in_vowel && is_end_vowel {\n            is_in_vowel\
    \ = false;\n            return;\n        }\n        if c == ' ' && is_start_vowel\
    \ && is_end_vowel { // ignore space and start & end vowel\n            return;\n\
    \        }\n        if is_in_vowel && is_vowel {\n            return\n       \
    \ }\n\n        cur_vowel = c as i8;\n        if is_start_vowel {\n           \
    \ cur_pos = 0;\n            is_start_vowel = false;\n            is_vowel = true;\n\
    \        }\n        if !is_start_vowel {\n            cur_pos++;\n        }\n\
    \        if c == ' ' {\n            cur_pos++; // ignore space\n        }\n  \
    \      if cur_pos > 2 { // ignore space and start & end vowel\n            is_start_vowel\
    \ = true;\n            return;\n        }\n        if cur_pos == 2 && is_end_vowel\
    \ { // ignore space and start & end vowel\n            is_end_vowel = false;\n\
    \            return;\n        }\n        if cur_pos == 2 && is_in_vowel && is_end_vowel\
    \ { // ignore space and start & end vowel\n            is_end_vowel = false;\n\
    \            return;\n        }\n        if cur_pos == 2 && is_in_vowel && is_start_vowel\
    \ && is_vowel { // ignore space and start & end vowel\n            is_start_vowel\
    \ = false;\n            return;\n        }\n        if cur_pos == 2 && is_in_vowel\
    \ && is_end_vowel && is_vowel { // ignore space and start & end vowel\n      \
    \      is_end_vowel = false;\n            return;\n        }\n        if cur_pos\
    \ == 2 && is_in_vowel && is_start_vowel && is_end_vowel && is_vowel { // ignore\
    \ space and start & end vowel\n            is_start_vowel = false;\n         \
    \   return;\n        }\n\n        cur_pos++;\n    });\n    if !is_in_vowel {\n\
    \        return String::new();\n    }\n    if cur_pos == 1 && is_end_vowel { //\
    \ ignore space and start & end vowel\n        return String::from(\"\");\n   \
    \ }\n    if cur_pos == 1 && is_in_vowel && is_end_vowel { // ignore space and\
    \ start & end vowel\n        return String::from(\"\");\n    }\n    if cur_pos\
    \ == 1 && is_in_vowel && is_start_vowel && is_vowel { // ignore space and start\
    \ & \n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp8akk_9ju.rs:109:3\n\
    \    |\n15  | fn get_closest_vowel(word: String) -> String {\n    |          \
    \                                    - unclosed delimiter\n...\n91  |     if cur_pos\
    \ == 1 && is_in_vowel && is_start_vowel && is_vowel { // ignore space and start\
    \ & \n    |                                                                  -\
    \ this delimiter might not be properly closed...\n92  | }\n    | - ...as it matches\
    \ this but it has different indentation\n...\n109 | }\n    |   ^\n\nerror: Rust\
    \ has no postfix increment operator\n  --> /tmp/tmp8akk_9ju.rs:50:20\n   |\n50\
    \ |             cur_pos++;\n   |                    ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n50 |             { let tmp = cur_pos; cur_pos\
    \ += 1; tmp };\n   |             +++++++++++        ~~~~~~~~~~~~~~~~~~~~~\n50\
    \ -             cur_pos++;\n50 +             cur_pos += 1;\n   | \n\nerror: Rust\
    \ has no postfix increment operator\n  --> /tmp/tmp8akk_9ju.rs:53:20\n   |\n53\
    \ |             cur_pos++; // ignore space\n   |                    ^^ not a valid\
    \ postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n53 |             { let\
    \ tmp = cur_pos; cur_pos += 1; tmp }; // ignore space\n   |             +++++++++++\
    \        ~~~~~~~~~~~~~~~~~~~~~\n53 -             cur_pos++; // ignore space\n\
    53 +             cur_pos += 1; // ignore space\n   | \n\nerror: Rust has no postfix\
    \ increment operator\n  --> /tmp/tmp8akk_9ju.rs:80:16\n   |\n80 |         cur_pos++;\n\
    \   |                ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n\
    \   |\n80 |         { let tmp = cur_pos; cur_pos += 1; tmp };\n   |         +++++++++++\
    \        ~~~~~~~~~~~~~~~~~~~~~\n80 -         cur_pos++;\n80 +         cur_pos\
    \ += 1;\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8akk_9ju.rs:28:12\n\
    \   |\n28 |         if !is_in_vowel && is_start_vowel {\n   |            ^^^^^^^^^^^^\
    \ expected `bool`, found `u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8akk_9ju.rs:28:28\n\
    \   |\n28 |         if !is_in_vowel && is_start_vowel {\n   |                \
    \         "
  stdout: ''
  timestamp: 1660053309
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut index = 0;\n    let mut first_consonant: Option<String> = Some(word.chars().skip(1).find(|c|\
    \ !c.is_uppercase()).map(|i| word.chars().nth(i).unwrap().to_string()));\n   \
    \ let mut second_consonant: Option<String> = Some(word.chars().skip(1).find(|c|\
    \ c.is_uppercase()).map(|i| word.chars().nth(i + 1).unwrap().to_string()));\n\n\
    \    match first_consonant.unwrap().chars().zip(second_consonant.unwrap().chars()).min(|a,\
    \ b| a.1.cmp(&b.1)) {\n        Some((a, b)) => a.0.to_string() + b.0,\n      \
    \  None => String::from(\"\"),\n    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5sf6c8eb.rs:17:126\n   |\n\
    17 | ...ind(|c| !c.is_uppercase()).map(|i| word.chars().nth(i).unwrap().to_string()));\n\
    \   |                                                        ^ expected `usize`,\
    \ found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5sf6c8eb.rs:17:52\n\
    \   |\n17 | ...String> = Some(word.chars().skip(1).find(|c| !c.is_uppercase()).map(|i|\
    \ word.chars().nth(i).unwrap().to_string()));\n   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found enum `Option`\n   |\n   = note: expected struct\
    \ `String`\n                found enum `Option<String>`\n\nerror[E0369]: cannot\
    \ add `{integer}` to `char`\n  --> /tmp/tmp5sf6c8eb.rs:18:128\n   |\n18 | ....skip(1).find(|c|\
    \ c.is_uppercase()).map(|i| word.chars().nth(i + 1).unwrap().to_string()));\n\
    \   |                                                                 - ^ - {integer}\n\
    \   |                                                                 |\n   |\
    \                                                                 char\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp5sf6c8eb.rs:18:53\n   |\n18 | ...String> = Some(word.chars().skip(1).find(|c|\
    \ c.is_uppercase()).map(|i| word.chars().nth(i + 1).unwrap().to_string()));\n\
    \   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found enum `Option`\n   |\n   = note: expected struct\
    \ `String`\n                found enum `Option<String>`\n\nerror[E0061]: this\
    \ function takes 0 arguments but 1 argument was supplied\n    --> /tmp/tmp5sf6c8eb.rs:20:83\n\
    \     |\n20   |     match first_consonant.unwrap().chars().zip(second_consonant.unwrap().chars()).min(|a,\
    \ b| a.1.cmp(&b.1)) {\n     |                                                \
    \                                   ^^^ -------------------- supplied 1 argument\n\
    \     |                                                                      \
    \             |\n     |                     "
  stdout: ''
  timestamp: 1660053309
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    //\
    \ Convert word to lowercase.\n    let mut word_l = word.to_lowercase();\n    let\
    \ mut vowels: Vec<usize> = vec![];\n    for letter in word_l {\n        if letter\
    \ == 'a' || letter == 'e' || letter == 'i' || letter == 'o' || letter == 'u'\n\
    \            || letter == 'A' || letter == 'E' || letter == 'I' || letter == 'O'\
    \ || letter == 'U'\n        {\n            vowels.push(letter);\n        }\n \
    \   }\n    let mut vowels_found = false;\n    let mut vowels_found_index = -1;\n\
    \    for i in 0..word.len() {\n        let v = vowels[vowels_found_index];\n \
    \       if v == 0 && !vowels_found {\n            vowels_found = true;\n     \
    \       vowels_found_index = i;\n        } else if v != 0 && !vowels_found {\n\
    \            if i == vowels_found_index + 1 {\n                vowels_found =\
    \ true;\n                vowels_found_index = i;\n            }\n        }\n \
    \   }\n    if vowels_found {\n        let mut last_char = word.chars();\n    \
    \    last_char.skip_while(|&b| b == 0);\n        last_char = last_char.collect();\n\
    \        last_char.swap(0, vowels_found_index + 1);\n        let res = String::from(&last_char);\n\
    \        res\n    } else {\n        String::from(\"\")\n    }\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpdpallhmt.rs:19:19\n\
    \   |\n19 |     for letter in word_l {\n   |                   ^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0277]:\
    \ can't compare `usize` with `char`\n  --> /tmp/tmpdpallhmt.rs:20:19\n   |\n20\
    \ |         if letter == 'a' || letter == 'e' || letter == 'i' || letter == 'o'\
    \ || letter == 'u'\n   |                   ^^ no implementation for `usize ==\
    \ char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for `usize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror[E0277]: can't compare `usize` with `char`\n  --> /tmp/tmpdpallhmt.rs:20:36\n\
    \   |\n20 |         if letter == 'a' || letter == 'e' || letter == 'i' || letter\
    \ == 'o' || letter == 'u'\n   |                                    ^^ no implementation\
    \ for `usize == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `usize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0277]: can't compare `usize` with `char`\n  --> /tmp/tmpdpallhmt.rs:20:53\n\
    \   |\n20 |         if letter == 'a' || letter == 'e' || letter == 'i' || letter\
    \ == 'o' || letter == 'u'\n   |                                              \
    \       ^^ no implementation for `usize == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `usize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     "
  stdout: ''
  timestamp: 1660053309
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    word.chars()\n\
    \        .enumerate()\n        .find(|(_, c)| c.to_lowercase() == c)\n       \
    \ .map(|(_, c)| c + 'a')\n        .unwrap_or_else(|| \"\")\n}\n\nfn main() {\n\
    \    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: binary operation `==` cannot be applied to type `ToLowercase`\n\
    \  --> /tmp/tmpoom1a5uq.rs:18:41\n   |\n18 |         .find(|(_, c)| c.to_lowercase()\
    \ == c)\n   |                        ---------------- ^^ - &char\n   |       \
    \                 |\n   |                        ToLowercase\n\nerror[E0369]:\
    \ cannot add `char` to `char`\n  --> /tmp/tmpoom1a5uq.rs:19:25\n   |\n19 |   \
    \      .map(|(_, c)| c + 'a')\n   |                       - ^ --- char\n   | \
    \                      |\n   |                       char\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0369`.\n"
  stdout: ''
  timestamp: 1660053309
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowel: Vec<&str> = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n\n    word.chars().for_each(|c|{\n\
    \        vowel.iter().find(|&v|&v == &c && v != c).unwrap_or(vowel.iter().find(|&v|v\
    \ == c && v != c).unwrap()).unwrap();\n    });\n\n    let mut first_consonant_pos\
    \ = word.chars().last().unwrap() as i32;\n    let mut last_consonant_pos = word.chars().last().unwrap()\
    \ as i32;\n\n    word.chars().for_each(|c|{\n        last_consonant_pos = word.chars().last().unwrap()\
    \ as i32;\n        vowel.iter().find(|&v|&v == &c && v != c).unwrap_or(vowel.iter().find(|&v|v\
    \ == c && v != c).unwrap()).unwrap();\n    });\n\n    if first_consonant_pos ==\
    \ last_consonant_pos + 1 {\n        return String::from(\"\");\n    }\n\n    let\
    \ mut second_consonant_pos = word.chars().last().unwrap() as i32;\n\n    word.chars().for_each(|c|{\n\
    \        if second_consonant_pos < first_consonant_pos + 2 {\n            second_consonant_pos\
    \ = word.chars().last().unwrap() as i32;\n        }\n\n        vowel.iter().find(|&v|&v\
    \ == &c && v != c).unwrap_or(vowel.iter().find(|&v|v == c && v != c).unwrap()).unwrap();\n\
    \    });\n\n    let mut first_vowel = vowel[0];\n    let mut last_vowel = vowel[0];\n\
    \n    vowel.iter().find(|&v|&v == first_vowel && v != first_vowel).unwrap();\n\
    \n    word.chars().for_each(|c|{\n        if second_consonant_pos < first_consonant_pos\
    \ + 2 {\n            second_consonant_pos = word.chars().last().unwrap() as i32;\n\
    \        }\n\n        if last_consonant_pos < first_consonant_pos + 1 {\n    \
    \        last_consonant_pos = word.chars().last().unwrap() as i32;\n        }\n\
    \n        if last_consonant_pos > first_consonant_pos {\n            last_vowel\
    \ = vowel[vowel.len() - 1];\n        }\n\n        if first_consonant_pos + 1 <\
    \ first_vowel + 3 {\n            first_vowel = vowel[vowel.len() - 1];\n     \
    \   }\n\n        if first_consonant_pos > last_consonant_pos {\n            first_vowel\
    \ = vowel[0];\n        }\n\n        last_vowel = \n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpi70tyl0x.rs:88:3\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n49 |     word.chars().for_each(|c|{\n\
    \   |                          - unclosed delimiter\n...\n88 | }\n   |   ^\n\n\
    error: expected expression, found `}`\n  --> /tmp/tmpi70tyl0x.rs:71:1\n   |\n\
    71 | }\n   | ^ expected expression\n\nerror: expected one of `)`, `,`, `.`, `?`,\
    \ or an operator, found keyword `fn`\n  --> /tmp/tmpi70tyl0x.rs:73:1\n   |\n71\
    \ | }\n   |  - expected one of `)`, `,`, `.`, `?`, or an operator\n72 | \n73 |\
    \ fn main() {\n   | ^^ unexpected token\n\nerror: aborting due to 3 previous errors\n\
    \n"
  stdout: ''
  timestamp: 1660053309
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowel = String::from(\"\");\n    let mut vowel_pos = word.len() - 1;\n \
    \   let mut consonant_pos = 0;\n    while consonant_pos <= word.len() {\n    \
    \    let c = word[consonant_pos];\n        if c >= 'A' && c <= 'Z' {\n       \
    \     if vowel.len() < 2 {\n                vowel += c;\n            }\n     \
    \   }\n        consonant_pos++;\n    }\n    vowel.trim().to_uppercase()\n}\n\n\
    fn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpyd_649u3.rs:26:22\n\
    \   |\n26 |         consonant_pos++;\n   |                      ^^ not a valid\
    \ postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n26 |         { let tmp\
    \ = consonant_pos; consonant_pos += 1; tmp };\n   |         +++++++++++      \
    \        ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n26 -         consonant_pos++;\n26 +    \
    \     consonant_pos += 1;\n   | \n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n  --> /tmp/tmpyd_649u3.rs:20:17\n   |\n20 |         let\
    \ c = word[consonant_pos];\n   |                 ^^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: can't compare `&str` with `char`\n  --> /tmp/tmpyd_649u3.rs:21:14\n\
    \   |\n21 |         if c >= 'A' && c <= 'Z' {\n   |              ^^ no implementation\
    \ for `&str < char` and `&str > char`\n   |\n   = help: the trait `PartialOrd<char>`\
    \ is not implemented for `&str`\n   = help: the following other types implement\
    \ trait `PartialOrd<Rhs>`:\n             String\n             str\n\nerror[E0277]:\
    \ can't compare `&str` with `char`\n  --> /tmp/tmpyd_649u3.rs:21:26\n   |\n21\
    \ |         if c >= 'A' && c <= 'Z' {\n   |                          ^^ no implementation\
    \ for `&str < char` and `&str > char`\n   |\n   = help: the trait `PartialOrd<char>`\
    \ is not implemented for `&str`\n   = help: the following other types implement\
    \ trait `PartialOrd<Rhs>`:\n             String\n             str\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1660053309
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut l = word.len();\n    let mut i = 0;\n    let mut j = 0;\n    \n    while\
    \ i < (l - 1) && (j < (l - 1)) {\n        if word.chars().nth(i).unwrap().is_uppercase()\
    \ && \n            word.chars().nth(j).unwrap().is_lowercase() {\n           \
    \ i += 1;\n            j += 1;\n        }\n        else if word.chars().nth(i).unwrap().is_lowercase()\
    \ &&\n            word.chars().nth(j).unwrap().is_uppercase() {\n            i\
    \ += 1;\n        }\n        else if word.chars().nth(i).unwrap().is_uppercase()\
    \ &&\n            word.chars().nth(j).unwrap().is_lowercase() {\n            j\
    \ += 1;\n        }\n        else {\n            i += 1;\n        }\n    }\n  \
    \  \n    if word.chars().nth(i).unwrap().is_uppercase() {\n        word.chars().nth(j).unwrap().to_string()\n\
    \    }\n    else {\n        \"\".to_string()\n    }\n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmpobx5srxp.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660053309
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = \"AEIOUaeiou\".to_string();\n    let mut s = String::from(\"\"\
    );\n    for c in word.chars() {\n        if let Some(vowel) = vowels.find(|&x|\
    \ x.cmp(&c).unwrap()) {\n            let mut i = vowels.len() - 1;\n         \
    \   while i > 0 {\n                if vowels[i as usize] != c {\n            \
    \        break;\n                }\n                i -= 1;\n            }\n \
    \           if i == 0 {\n                s = s.clear();\n            } else {\n\
    \                s = s.push_str(&vowels[i as usize]);\n            }\n       \
    \ } else {\n            s = s.push_str(&c.to_string());\n        }\n    }\n  \
    \  s\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `&_`\n  --> /tmp/tmp8gltmi5s.rs:19:43\n\
    \   |\n19 |         if let Some(vowel) = vowels.find(|&x| x.cmp(&c).unwrap())\
    \ {\n   |                                           ^^ consider giving this closure\
    \ parameter the explicit type `&_`, with the type parameters specified\n   |\n\
    \   = note: type must be known at this point\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmp8gltmi5s.rs:22:20\n   |\n22 |  \
    \               if vowels[i as usize] != c {\n   |                    ^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8gltmi5s.rs:28:21\n\
    \   |\n17 |     let mut s = String::from(\"\");\n   |                 ----------------\
    \ expected due to this value\n...\n28 |                 s = s.clear();\n   | \
    \                    ^^^^^^^^^ expected struct `String`, found `()`\n   |\nnote:\
    \ method `clear` modifies its receiver in-place\n  --> /tmp/tmp8gltmi5s.rs:28:23\n\
    \   |\n28 |                 s = s.clear();\n   |                     - ^^^^^ this\
    \ call modifies `s` in-place\n   |                     |\n   |               \
    \      you probably want to use this value after calling the method...\n   = note:\
    \ ...instead of the `()` output of method `clear`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmp8gltmi5s.rs:30:33\n   |\n30 |  \
    \               s = s.push_str(&vowels[i as usize]);\n   |                   \
    \              ^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: "
  stdout: ''
  timestamp: 1660053309
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowel_index = 0;\n    let mut closest_vowel = \"\";\n    for cons in word.chars().rev()\
    \ {\n        vowel_index = word.chars().rposition(|c| *c == cons);\n        if\
    \ vowel_index == 0 {\n            break;\n        }\n        closest_vowel = word.chars().nth(vowel_index\
    \ - 1).unwrap();\n        if closest_vowel == cons {\n            break;\n   \
    \     }\n    }\n    if vowel_index == word.chars().len() {\n        closest_vowel\
    \ = \"\".to_string();\n    }\n    return closest_vowel;\n}\n\nfn main() {\n  \
    \  let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \    --> /tmp/tmp09luigad.rs:19:36\n     |\n19   |         vowel_index = word.chars().rposition(|c|\
    \ *c == cons);\n     |                                    ^^^^^^^^^ the trait\
    \ `ExactSizeIterator` is not implemented for `Chars<'_>`\n     |\n     = help:\
    \ the following other types implement trait `ExactSizeIterator`:\n           \
    \    &mut I\n               Args\n               ArgsOs\n               ArrayChunks<'_,\
    \ T, N>\n               ArrayChunksMut<'_, T, N>\n               ArrayWindows<'_,\
    \ T, N>\n               Box<I, A>\n               Chunks<'_, T>\n            \
    \ and 109 others\nnote: required by a bound in `rposition`\n\nerror[E0614]: type\
    \ `char` cannot be dereferenced\n  --> /tmp/tmp09luigad.rs:19:50\n   |\n19 | \
    \        vowel_index = word.chars().rposition(|c| *c == cons);\n   |         \
    \                                         ^^\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp09luigad.rs:19:23\n   |\n16 |     let mut vowel_index = 0;\n  \
    \ |                           - expected due to this value\n...\n19 |        \
    \ vowel_index = word.chars().rposition(|c| *c == cons);\n   |                \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected integer, found enum `Option`\n\
    \   |\n   = note: expected type `{integer}`\n              found enum `Option<usize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp09luigad.rs:23:25\n   |\n17 |\
    \     let mut closest_vowel = \"\";\n   |                             -- expected\
    \ due to this value\n...\n23 |         closest_vowel = word.chars().nth(vowel_index\
    \ - 1).unwrap();\n   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&str`, found `char`\n\nerror[E0277]: can't compare `&str` with `char`\n\
    \  --> /tmp/tmp09luigad.rs:24:26\n   |\n24 |         if closest_vowel == cons\
    \ {\n   |                          ^^ no implementation for `&str == char`\n \
    \  |\n   = help: the trait `PartialEq<char>` is not implemented for `&str`\n \
    \  = help: the following other types implement trait `PartialEq<Rhs>`:\n     \
    \        <&'a str as PartialEq<OsS"
  stdout: ''
  timestamp: 1660053309
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut prev_letter = String::from(\"\");\n    for c in word.chars() {\n       \
    \ if c.is_uppercase() {\n            if prev_letter.is_empty() {\n           \
    \     prev_letter = c;\n                continue;\n            }\n           \
    \ let mut next_letter = String::from(\"\");\n            for i in 1..=4 {\n  \
    \              if i >= word.len() {\n                    return \"\";\n      \
    \          }\n                if word.starts_with(String::from(c), i) {\n    \
    \                next_letter = String::from(c) + String::from(i);\n          \
    \          break;\n                }\n            }\n            if !next_letter.is_empty()\
    \ {\n                if !prev_letter.is_uppercase() {\n                    if\
    \ next_letter.is_uppercase() {\n                        let mut result = prev_letter;\n\
    \                        result = result + next_letter;\n                    \
    \    return result;\n                    }\n                    let mut result\
    \ = String::from(\"\");\n                    for i in 1..=4 {\n              \
    \          if i >= word.len() {\n                            return \"\";\n  \
    \                      }\n                        if word.starts_with(String::from(c),\
    \ i) {\n                            result = String::from(c) + String::from(i);\n\
    \                            break;\n                        }\n             \
    \       }\n                    return result;\n                }\n           \
    \     let mut result = String::from(\"\");\n                for i in 1..=4 {\n\
    \                    if i >= word.len() {\n                        return \"\"\
    ;\n                    }\n                    if word.starts_with(String::from(c),\
    \ i) {\n                        result = String::from(c) + String::from(i);\n\
    \                        break;\n                    }\n                }\n  \
    \              return result;\n            }\n        }\n        prev_letter =\
    \ c;\n    }\n    return String::from(\"\");\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpphhx8mbm.rs:20:31\n   |\n\
    16 |     let mut prev_letter = String::from(\"\");\n   |                     \
    \      ---------------- expected due to this value\n...\n20 |                \
    \ prev_letter = c;\n   |                               ^- help: try using a conversion\
    \ method: `.to_string()`\n   |                               |\n   |         \
    \                      expected struct `String`, found `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpphhx8mbm.rs:26:28\n   |\n26 |              \
    \       return \"\";\n   |                            ^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                            |\n   |            \
    \                expected struct `String`, found `&str`\n\nerror[E0061]: this\
    \ function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpphhx8mbm.rs:28:25\n\
    \     |\n28   |                 if word.starts_with(String::from(c), i) {\n  \
    \   |                         ^^^^^^^^^^^ ---------------  - supplied 2 arguments\n\
    \     |                         |\n     |                         expected 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror[E0277]: the trait bound\
    \ `String: From<usize>` is not satisfied\n  --> /tmp/tmpphhx8mbm.rs:29:53\n  \
    \ |\n29 |                     next_letter = String::from(c) + String::from(i);\n\
    \   |                                                     ^^^^^^^^^^^^ the trait\
    \ `From<usize>` is not implemented for `String`\n   |\n   = help: the following\
    \ other types implement trait `From<T>`:\n             <String as From<&String>>\n\
    \             <String as From<&mut str>>\n             <String as From<&str>>\n\
    \             <String as From<Box<str>>>\n             <String as From<Cow<'a,\
    \ str>>>\n             <String as From<char>>\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpphhx8mbm.rs:29:53\n   |\n29 |                     next_letter =\
    \ String::from(c) + String::from(i);\n   |                                   \
    \                  ^^^^^^^^^^^^^^^\n   |                                     \
    \                |\n   |                              "
  stdout: ''
  timestamp: 1660053309
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels: Vec<&str> = Vec::new();\n    vowels.push(\"a\".to_string());\n \
    \   vowels.push(\"e\".to_string());\n    vowels.push(\"i\".to_string());\n   \
    \ vowels.push(\"o\".to_string());\n    vowels.push(\"u\".to_string());\n    vowels.push(\"\
    y\".to_string());\n    vowels.push(\"\xE1\".to_string());\n    vowels.push(\"\xE9\
    \".to_string());\n    vowels.push(\"\xED\".to_string());\n    vowels.push(\"\xF3\
    \".to_string());\n    vowels.push(\"\xFA\".to_string());\n    \n    let mut min_idx:\
    \ usize = 0;\n    let mut min_idx2: usize = 0;\n    let mut min_idx3: usize =\
    \ 0;\n    let mut min_idx4: usize = 0;\n    let mut min_idx5: usize = 0;\n   \
    \ let mut min_idx6: usize = 0;\n    \n    for i in word.chars() {\n        if\
    \ vowels.contains(&i.to_string()) {\n            min_idx = i;\n            break;\n\
    \        }\n        if i.to_string() == \"a\".to_string() {\n            min_idx2\
    \ = i;\n        }\n        if i.to_string() == \"e\".to_string() {\n         \
    \   min_idx3 = i;\n        }\n        if i.to_string() == \"i\".to_string() {\n\
    \            min_idx4 = i;\n        }\n        if i.to_string() == \"o\".to_string()\
    \ {\n            min_idx5 = i;\n        }\n        if i.to_string() == \"u\".to_string()\
    \ {\n            min_idx6 = i;\n        }\n    }\n    \n    let mut word = String::new();\n\
    \    let mut min_idx = min_idx;\n    let mut min_idx2 = min_idx2;\n    let mut\
    \ min_idx3 = min_idx3;\n    let mut min_idx4 = min_idx4;\n    let mut min_idx5\
    \ = min_idx5;\n    let mut min_idx6 = min_idx6;\n    \n    for letter in word.chars()\
    \ {\n        if letter.to_string() == min_idx {\n            word.push(\"a\".to_string());\n\
    \        }\n        if letter.to_string() == min_idx2 {\n            word.push(\"\
    b\".to_string());\n        }\n        if letter.to_string() == min_idx3 {\n  \
    \          word.push(\"c\".to_string());\n        }\n        if letter.to_string()\
    \ == min_idx4 {\n            word.push(\"d\".to_string());\n        }\n      \
    \  if letter.to_string() == min_idx5 {\n            word.push(\"e\".to_string());\n\
    \        }\n        if letter.to_string() == min_idx6 {\n            word.push(\"\
    f\".to_string());\n        }\n    }\n    \n    word\n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpu24fnpql.rs:17:17\n   |\n\
    17 |     vowels.push(\"a\".to_string());\n   |                 ^^^^^^^^^^^^^^^\n\
    \   |                 |\n   |                 expected `&str`, found struct `String`\n\
    \   |                 help: consider borrowing here: `&\"a\".to_string()`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpu24fnpql.rs:18:17\n   |\n18 |  \
    \   vowels.push(\"e\".to_string());\n   |                 ^^^^^^^^^^^^^^^\n  \
    \ |                 |\n   |                 expected `&str`, found struct `String`\n\
    \   |                 help: consider borrowing here: `&\"e\".to_string()`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpu24fnpql.rs:19:17\n   |\n19 |  \
    \   vowels.push(\"i\".to_string());\n   |                 ^^^^^^^^^^^^^^^\n  \
    \ |                 |\n   |                 expected `&str`, found struct `String`\n\
    \   |                 help: consider borrowing here: `&\"i\".to_string()`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpu24fnpql.rs:20:17\n   |\n20 |  \
    \   vowels.push(\"o\".to_string());\n   |                 ^^^^^^^^^^^^^^^\n  \
    \ |                 |\n   |                 expected `&str`, found struct `String`\n\
    \   |                 help: consider borrowing here: `&\"o\".to_string()`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpu24fnpql.rs:21:17\n   |\n21 |  \
    \   vowels.push(\"u\".to_string());\n   |                 ^^^^^^^^^^^^^^^\n  \
    \ |                 |\n   |                 expected `&str`, found struct `String`\n\
    \   |                 help: consider borrowing here: `&\"u\".to_string()`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpu24fnpql.rs:22:17\n   |\n22 |  \
    \   vowels.push(\"y\".to_string());\n   |                 ^^^^^^^^^^^^^^^\n  \
    \ |                 |\n   |                 expected `&str`, found struct `String`\n\
    \   |                 help: consider borrowing here: `&\"y\".to_string()`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpu24fnpql.rs:23:17\n   |\n23 |  \
    \   vowels.push(\"\xE1\".to_string());\n   |                 ^^^^^^^^^^^^^^^\n\
    \   |                 |\n   |                 expected `&str`, found struct `String`\n\
    \   |                 help: "
  stdout: ''
  timestamp: 1660053309
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    match\
    \ word.chars().skip(1).find(|c|\n        c != 'a' && c != 'e' && c != 'i' && c\
    \ != 'o' && c != 'u' && c != 'A' && c != 'E' && c != 'I' && c != 'O' && c != 'U'\n\
    \    ) {\n        Some(vowel_index) => word[vowel_index..].chars().find(|c| \n\
    \            c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c ==\
    \ 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U'\n        ).map(|c| c.to_ascii_lowercase()),\n\
    \        None => \"\".to_string(),\n    }\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp8kttif9d.rs:17:11\n\
    \   |\n17 |         c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' &&\
    \ c != 'A' && c != 'E' && c != 'I' && c != 'O' && c != 'U'\n   |           ^^\
    \ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp8kttif9d.rs:17:23\n\
    \   |\n17 |         c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' &&\
    \ c != 'A' && c != 'E' && c != 'I' && c != 'O' && c != 'U'\n   |             \
    \          ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmp8kttif9d.rs:17:35\n   |\n17 |         c != 'a' && c != 'e' && c\
    \ != 'i' && c != 'o' && c != 'u' && c != 'A' && c != 'E' && c != 'I' && c != 'O'\
    \ && c != 'U'\n   |                                   ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp8kttif9d.rs:17:47\n\
    \   |\n17 |         c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' &&\
    \ c != 'A' && c != 'E' && c != 'I' && c != 'O' && c != 'U'\n   |             \
    \                                  ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp8kttif9d.rs:17:59\n   |\n17 |   \
    \      c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' && c != 'A' &&\
    \ c != 'E' && c != 'I' && c != 'O' && c != 'U'\n   |                         \
    \                                  ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `Partia"
  stdout: ''
  timestamp: 1660053309
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowel = String::new();\n\n    for ch in word.chars() {\n        vowel =\
    \ match ch {\n            'A'..'E' => {\n                if word.chars().last_mut().unwrap()=='e'\
    \ || word.chars().last_mut().unwrap()=='i' {\n                    let last_vowel\
    \ = word.chars().last_mut().unwrap();\n                    if last_vowel >= 'A'\
    \ && last_vowel <= 'E' {\n                        word.chars().last_mut().unwrap()-'A'\n\
    \                    } else {\n                        String::new()\n       \
    \             }\n                } else {\n                    String::new()\n\
    \                }\n            }\n            'I'..'O' => {\n               \
    \ if word.chars().last_mut().unwrap()=='i' || word.chars().last_mut().unwrap()=='o'\
    \ {\n                    let last_vowel = word.chars().last_mut().unwrap();\n\
    \                    if last_vowel >= 'I' && last_vowel <= 'O' {\n           \
    \             word.chars().last_mut().unwrap()-'I'\n                    } else\
    \ {\n                        String::new()\n                    }\n          \
    \      } else {\n                    String::new()\n                }\n      \
    \      }\n            _ => {\n                String::new()\n            }\n \
    \       }\n    }\n    vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0658]: exclusive range pattern syntax is experimental\n  --> /tmp/tmplty7zpsv.rs:20:13\n\
    \   |\n20 |             'A'..'E' => {\n   |             ^^^^^^^^\n   |\n   = note:\
    \ see issue #37854 <https://github.com/rust-lang/rust/issues/37854> for more information\n\
    \nerror[E0658]: exclusive range pattern syntax is experimental\n  --> /tmp/tmplty7zpsv.rs:32:13\n\
    \   |\n32 |             'I'..'O' => {\n   |             ^^^^^^^^\n   |\n   = note:\
    \ see issue #37854 <https://github.com/rust-lang/rust/issues/37854> for more information\n\
    \nerror[E0599]: no method named `last_mut` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmplty7zpsv.rs:21:33\n   |\n21 |                 if word.chars().last_mut().unwrap()=='e'\
    \ || word.chars().last_mut().unwrap()=='i' {\n   |                           \
    \      ^^^^^^^^ method not found in `Chars<'_>`\n\nerror[E0599]: no method named\
    \ `last_mut` found for struct `Chars` in the current scope\n  --> /tmp/tmplty7zpsv.rs:21:74\n\
    \   |\n21 |                 if word.chars().last_mut().unwrap()=='e' || word.chars().last_mut().unwrap()=='i'\
    \ {\n   |                                                                    \
    \      ^^^^^^^^ method not found in `Chars<'_>`\n\nerror[E0599]: no method named\
    \ `last_mut` found for struct `Chars` in the current scope\n  --> /tmp/tmplty7zpsv.rs:22:51\n\
    \   |\n22 |                     let last_vowel = word.chars().last_mut().unwrap();\n\
    \   |                                                   ^^^^^^^^ method not found\
    \ in `Chars<'_>`\n\nerror[E0599]: no method named `last_mut` found for struct\
    \ `Chars` in the current scope\n  --> /tmp/tmplty7zpsv.rs:24:38\n   |\n24 |  \
    \                       word.chars().last_mut().unwrap()-'A'\n   |           \
    \                           ^^^^^^^^ method not found in `Chars<'_>`\n\nerror[E0599]:\
    \ no method named `last_mut` found for struct `Chars` in the current scope\n \
    \ --> /tmp/tmplty7zpsv.rs:33:33\n   |\n33 |                 if word.chars().last_mut().unwrap()=='i'\
    \ || word.chars().last_mut().unwrap()=='o' {\n   |                           \
    \      ^^^^^^^^ method not found in `Chars<"
  stdout: ''
  timestamp: 1660053309
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut index = 0;\n    let mut vowels = vec![];\n\n    // We will loop from the\
    \ right side of the word\n    while index != word.len() - 1 {\n        if word[index]\
    \ == String::from('u') || word[index] == String::from('U') {\n            vowels.push(index\
    \ + 1);\n        }\n        index += 1;\n    }\n\n    vowels.reverse();\n    if\
    \ vowels.len() > 0 {\n        vowels.iter().next().unwrap()\n    } else {\n  \
    \      String::from(\"\")\n    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpiaext9s1.rs:21:12\n\
    \   |\n21 |         if word[index] == String::from('u') || word[index] == String::from('U')\
    \ {\n   |            ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpiaext9s1.rs:21:48\n\
    \   |\n21 |         if word[index] == String::from('u') || word[index] == String::from('U')\
    \ {\n   |                                                ^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpiaext9s1.rs:29:9\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |             \
    \                          ------ expected `String` because of return type\n...\n\
    29 |         vowels.iter().next().unwrap()\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |         |\n   |  \
    \       expected struct `String`, found `&usize`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try "
  stdout: ''
  timestamp: 1660053309
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    \n\
    \    // Convert to lowercase\n    let word = word.to_lowercase();\n    \n    //\
    \ Get the length\n    let len = word.len();\n    \n    // Get the position of\
    \ the last consonant\n    let last_consonant_pos = len - word.rfind('a').unwrap();\n\
    \    \n    // Get the position of the first consonant\n    let first_consonant_pos\
    \ = word.find('a').unwrap();\n    \n    // Get the vowel \n    let vowel = word.rfind('a').unwrap();\n\
    \    \n    // Get the vowel in the middle\n    let middle_vowel = word.rfind('A').unwrap();\n\
    \    \n    // Check if vowel is in the middle\n    if middle_vowel.is_some() {\n\
    \        let middle_vowel = middle_vowel.unwrap();\n        \n        // Check\
    \ if vowel is in the beginning\n        if first_consonant_pos.is_some() {\n \
    \           let first_consonant_pos = first_consonant_pos.unwrap();\n        \
    \    \n            // Check if vowel is in the end\n            if last_consonant_pos.is_some()\
    \ {\n                let last_consonant_pos = last_consonant_pos.unwrap();\n \
    \               \n                // Check if vowel is in the middle \n      \
    \          if vowel == middle_vowel {\n                    // If yes, then return\
    \ an empty string\n                    String::from(\"\")\n                } else\
    \ {\n                    // Otherwise, return the vowel \n                   \
    \ let mut vowel_str = word.chars();\n                    vowel_str.next().unwrap();\n\
    \                    String::from(vowel_str.next().unwrap())\n               \
    \ }\n            } else {\n                // If not, then return the vowel\n\
    \                let mut vowel_str = word.chars();\n                vowel_str.next().unwrap();\n\
    \                String::from(vowel_str.next().unwrap())\n            }\n    \
    \    } else {\n            // If not, then return the vowel\n            let mut\
    \ vowel_str = word.chars();\n            vowel_str.next().unwrap();\n        \
    \    String::from(vowel_str.next().unwrap())\n        }\n    } else {\n      \
    \  String::from(\"\")\n    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_some` found for type `usize` in the current\
    \ scope\n  --> /tmp/tmpe2kbi1hs.rs:36:21\n   |\n36 |     if middle_vowel.is_some()\
    \ {\n   |                     ^^^^^^^ method not found in `usize`\n\nerror[E0599]:\
    \ no method named `unwrap` found for type `usize` in the current scope\n  -->\
    \ /tmp/tmpe2kbi1hs.rs:37:41\n   |\n37 |         let middle_vowel = middle_vowel.unwrap();\n\
    \   |                                         ^^^^^^ method not found in `usize`\n\
    \nerror[E0599]: no method named `is_some` found for type `usize` in the current\
    \ scope\n  --> /tmp/tmpe2kbi1hs.rs:40:32\n   |\n40 |         if first_consonant_pos.is_some()\
    \ {\n   |                                ^^^^^^^ method not found in `usize`\n\
    \nerror[E0599]: no method named `unwrap` found for type `usize` in the current\
    \ scope\n  --> /tmp/tmpe2kbi1hs.rs:41:59\n   |\n41 |             let first_consonant_pos\
    \ = first_consonant_pos.unwrap();\n   |                                      \
    \                     ^^^^^^ method not found in `usize`\n\nerror[E0599]: no method\
    \ named `is_some` found for type `usize` in the current scope\n  --> /tmp/tmpe2kbi1hs.rs:44:35\n\
    \   |\n44 |             if last_consonant_pos.is_some() {\n   |              \
    \                     ^^^^^^^ method not found in `usize`\n\nerror[E0599]: no\
    \ method named `unwrap` found for type `usize` in the current scope\n  --> /tmp/tmpe2kbi1hs.rs:45:61\n\
    \   |\n45 |                 let last_consonant_pos = last_consonant_pos.unwrap();\n\
    \   |                                                             ^^^^^^ method\
    \ not found in `usize`\n\nerror: aborting due to 6 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660053309
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    //\
    \ Write your code here\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\",\
    \ \"u\"];\n    vowels.sort();\n    let vowel: String = vowels.iter().nth(word.len()\
    \ - 1).unwrap();\n    String::from(vowel)\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpp1x5tysa.rs:19:25\n   |\n\
    19 |     let vowel: String = vowels.iter().nth(word.len() - 1).unwrap();\n   |\
    \                ------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try\
    \ using a conversion method: `.to_string()`\n   |                |        |\n\
    \   |                |        expected struct `String`, found `&&str`\n   |  \
    \              expected due to this\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053309
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = String::new();\n    let mut vowels_end = String::new();\n    let\
    \ mut vowel_start = String::new();\n    let mut vowels_start = String::new();\n\
    \    let mut consonants = String::new();\n\n    for vowel in word.chars() {\n\
    \        if vowel.unicode.as_str().starts_with('AEIOU') && !vowel.unicode.as_str().starts_with('Y')\
    \ {\n            vowels_start += vowel.to_string();\n        }\n        if vowel.unicode.as_str().ends_with('AEIOU')\
    \ && !vowel.unicode.as_str().ends_with('Y') {\n            vowels_end += vowel.to_string();\n\
    \        }\n    }\n    for consonant in word.chars() {\n        if consonant.unicode.as_str().starts_with('aeiou')\
    \ && !consonant.unicode.as_str().starts_with('y') {\n            consonants +=\
    \ consonant.to_string();\n        }\n    }\n\n    if vowels_start == \"\" || vowels_end\
    \ == \"\" || consonants == \"\" {\n        return String::from(\"\");\n    }\n\
    \    if vowels_end.len() < vowels_start.len() {\n        vowels = vowels_end\n\
    \    } else if vowels_end.len() > vowels_start.len() {\n        vowels = vowels_start\n\
    \    } else {\n        vowels = consonants\n    }\n    return vowels;\n}\n\nfn\
    \ main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: character literal may only contain one codepoint\n  --> /tmp/tmp80458la7.rs:23:47\n\
    \   |\n23 |         if vowel.unicode.as_str().starts_with('AEIOU') && !vowel.unicode.as_str().starts_with('Y')\
    \ {\n   |                                               ^^^^^^^\n   |\nhelp: if\
    \ you meant to write a `str` literal, use double quotes\n   |\n23 |         if\
    \ vowel.unicode.as_str().starts_with(\"AEIOU\") && !vowel.unicode.as_str().starts_with('Y')\
    \ {\n   |                                               ~~~~~~~\n\nerror: character\
    \ literal may only contain one codepoint\n  --> /tmp/tmp80458la7.rs:26:45\n  \
    \ |\n26 |         if vowel.unicode.as_str().ends_with('AEIOU') && !vowel.unicode.as_str().ends_with('Y')\
    \ {\n   |                                             ^^^^^^^\n   |\nhelp: if\
    \ you meant to write a `str` literal, use double quotes\n   |\n26 |         if\
    \ vowel.unicode.as_str().ends_with(\"AEIOU\") && !vowel.unicode.as_str().ends_with('Y')\
    \ {\n   |                                             ~~~~~~~\n\nerror: character\
    \ literal may only contain one codepoint\n  --> /tmp/tmp80458la7.rs:31:51\n  \
    \ |\n31 |         if consonant.unicode.as_str().starts_with('aeiou') && !consonant.unicode.as_str().starts_with('y')\
    \ {\n   |                                                   ^^^^^^^\n   |\nhelp:\
    \ if you meant to write a `str` literal, use double quotes\n   |\n31 |       \
    \  if consonant.unicode.as_str().starts_with(\"aeiou\") && !consonant.unicode.as_str().starts_with('y')\
    \ {\n   |                                                   ~~~~~~~\n\nerror[E0610]:\
    \ `char` is a primitive type and therefore doesn't have fields\n  --> /tmp/tmp80458la7.rs:23:18\n\
    \   |\n23 |         if vowel.unicode.as_str().starts_with('AEIOU') && !vowel.unicode.as_str().starts_with('Y')\
    \ {\n   |                  ^^^^^^^\n\nerror[E0610]: `char` is a primitive type\
    \ and therefore doesn't have fields\n  --> /tmp/tmp80458la7.rs:23:66\n   |\n23\
    \ |         if vowel.unicode.as_str().starts_with('AEIOU') && !vowel.unicode.as_str().starts_with('Y')\
    \ {\n   |                                                                  ^^^^^^^\n"
  stdout: ''
  timestamp: 1660053309
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    word.chars()\n\
    \        .windows(2)\n        .enumerate()\n        .map(|(index, item)| {\n \
    \           match item {\n                'A' | 'a' => Some('A'.to_string()),\n\
    \                'B' | 'b' => Some('B'.to_string()),\n                'C' | 'c'\
    \ => Some('C'.to_string()),\n                'D' | 'd' => Some('D'.to_string()),\n\
    \                'E' | 'e' => Some('E'.to_string()),\n                'F' | 'f'\
    \ => Some('F'.to_string()),\n                'G' | 'g' => Some('G'.to_string()),\n\
    \                'H' | 'h' => Some('H'.to_string()),\n                'I' | 'i'\
    \ => Some('I'.to_string()),\n                'J' | 'j' => Some('J'.to_string()),\n\
    \                'K' | 'k' => Some('K'.to_string()),\n                'L' | 'l'\
    \ => Some('L'.to_string()),\n                'M' | 'm' => Some('M'.to_string()),\n\
    \                'N' | 'n' => Some('N'.to_string()),\n                'O' | 'o'\
    \ => Some('O'.to_string()),\n                'P' | 'p' => Some('P'.to_string()),\n\
    \                'Q' | 'q' => Some('Q'.to_string()),\n                'R' | 'r'\
    \ => Some('R'.to_string()),\n                'S' | 's' => Some('S'.to_string()),\n\
    \                'T' | 't' => Some('T'.to_string()),\n                'U' | 'u'\
    \ => Some('U'.to_string()),\n                'V' | 'v' => Some('V'.to_string()),\n\
    \                'W' | 'w' => Some('W'.to_string()),\n                'X' | 'x'\
    \ => Some('X'.to_string()),\n                'Y' | 'y' => Some('Y'.to_string()),\n\
    \                'Z' | 'z' => Some('Z'.to_string()),\n                _ => None\n\
    \            }\n        })\n        .filter_map(|match| match.unwrap())\n    \
    \    .min()\n        .unwrap()\n        .to_string()\n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected identifier, found keyword `match`\n  --> /tmp/tmp20puuw_1.rs:50:22\n\
    \   |\n50 |         .filter_map(|match| match.unwrap())\n   |                \
    \      ^^^^^ expected identifier, found keyword\n\nerror: expected expression,\
    \ found `.`\n  --> /tmp/tmp20puuw_1.rs:50:34\n   |\n50 |         .filter_map(|match|\
    \ match.unwrap())\n   |                             -----^ expected expression\n\
    \   |                             |\n   |                             while parsing\
    \ this `match` expression\n\nerror: aborting due to 2 previous errors\n\n"
  stdout: ''
  timestamp: 1660053309
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut index = 0;\n    while index < word.len() {\n        let vowel = &word[index..];\n\
    \        let has_consonant_after = vowel.find(|x| !x.is_alphabetic(..));\n   \
    \     if has_consonant_after == word.len() {\n            if index < word.len()\
    \ {\n                let consonant_after = &word[index..];\n                if\
    \ consonant_after.is_alphabetic(..) {\n                    index = consonant_after.len();\n\
    \                } else {\n                    index = 0;\n                }\n\
    \            } else {\n                return String::from(\"\");\n          \
    \  }\n        } else {\n            index = has_consonant_after + 1;\n       \
    \ }\n    }\n    return String::from(\"\");\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmp4odskchp.rs:19:47\n\
    \   |\n19 |         let has_consonant_after = vowel.find(|x| !x.is_alphabetic(..));\n\
    \   |                                               ^ consider giving this closure\
    \ parameter a type\n   |\n   = note: type must be known at this point\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp4odskchp.rs:20:35\n   |\n20 |         if has_consonant_after\
    \ == word.len() {\n   |                                   ^^^^^^^^^^ expected\
    \ enum `Option`, found `usize`\n   |\n   = note: expected enum `Option<usize>`\n\
    \              found type `usize`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n20 |         if has_consonant_after == Some(word.len()) {\n   |       \
    \                            +++++          +\n\nerror[E0599]: no method named\
    \ `is_alphabetic` found for reference `&str` in the current scope\n  --> /tmp/tmp4odskchp.rs:23:36\n\
    \   |\n23 |                 if consonant_after.is_alphabetic(..) {\n   |     \
    \                               ^^^^^^^^^^^^^ method not found in `&str`\n\nerror[E0369]:\
    \ cannot add `{integer}` to `Option<usize>`\n  --> /tmp/tmp4odskchp.rs:32:41\n\
    \   |\n32 |             index = has_consonant_after + 1;\n   |               \
    \      ------------------- ^ - {integer}\n   |                     |\n   |   \
    \                  Option<usize>\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0282, E0308, E0369, E0599.\nFor more\
    \ information about an error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1660053309
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut len = word.len();\n    let mut index = 0;\n    let mut index2 = 0;\n\n \
    \   loop {\n        index2 = len.min(index);\n\n        if word[index2] == 'a'\
    \ || word[index2] == 'e' || word[index2] == 'i' || word[index2] == 'o' || word[index2]\
    \ == 'u' || word[index2] == 'A' || word[index2] == 'E' || word[index2] == 'I'\
    \ || word[index2] == 'O' || word[index2] == 'U' {\n            return String::from(word[index2].to_string());\n\
    \        }\n\n        index = index2;\n\n        if index2 == len - 1 {\n    \
    \        break;\n        }\n    }\n\n    String::from(\"\")\n}\n\nfn main() {\n\
    \    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpvxr2_9ng.rs:23:12\n\
    \   |\n23 | ...   if word[index2] == 'a' || word[index2] == 'e' || word[index2]\
    \ == 'i' || word[index2] == 'o' || word[index2] == 'u' || word[index2] == ...\n\
    \   |          ^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpvxr2_9ng.rs:23:35\n\
    \   |\n23 | ...   if word[index2] == 'a' || word[index2] == 'e' || word[index2]\
    \ == 'i' || word[index2] == 'o' || word[index2] == 'u' || word[index2] == ...\n\
    \   |                                 ^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpvxr2_9ng.rs:23:58\n   |\n23 | ...   if word[index2] == 'a' || word[index2]\
    \ == 'e' || word[index2] == 'i' || word[index2] == 'o' || word[index2] == 'u'\
    \ || word[index2] == ...\n   |                                               \
    \         ^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the follo"
  stdout: ''
  timestamp: 1660053309
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut result = String::from(\"\");\n    for c in word.chars() {\n        let mut\
    \ vowels = &[ 'a', 'e', 'i', 'o', 'u' ];\n        if *vowels.iter().contains(c)\
    \ {\n            if result.is_empty() {\n                result = c;\n       \
    \     } else {\n                result = result.to_owned() + &c.to_string()[0];\n\
    \            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `contains` found for struct `std::slice::Iter`\
    \ in the current scope\n  --> /tmp/tmp50w6zdvh.rs:19:27\n   |\n19 |         if\
    \ *vowels.iter().contains(c) {\n   |                           ^^^^^^^^ method\
    \ not found in `std::slice::Iter<'_, char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp50w6zdvh.rs:21:26\n   |\n16 |     let mut result = String::from(\"\
    \");\n   |                      ---------------- expected due to this value\n\
    ...\n21 |                 result = c;\n   |                          ^- help:\
    \ try using a conversion method: `.to_string()`\n   |                        \
    \  |\n   |                          expected struct `String`, found `char`\n\n\
    error[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp50w6zdvh.rs:23:47\n\
    \   |\n23 |                 result = result.to_owned() + &c.to_string()[0];\n\
    \   |                                               ^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660053309
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\", \"y\"];\n    vowels.sort_unstable();\n\
    \    let mut i = 0;\n    let mut found = String::new();\n    while vowels[i] !=\
    \ word[i] {\n        if i > word.len() - 1 {\n            found = String::new();\n\
    \            break;\n        }\n        i += 1;\n    }\n    if found != String::new()\
    \ {\n        found\n    } else {\n        String::new()\n    }\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpy5_lw6jf.rs:20:24\n\
    \   |\n20 |     while vowels[i] != word[i] {\n   |                        ^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660053309
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowel = String::new();\n    word.chars().rev().enumerate().for_each(|(i,\
    \ _)| {\n        if i != word.len() - 1 {\n            if word.chars()[i].is_uppercase()\
    \ && word.chars()[i + 1].is_lowercase() &&\n                word.chars()[i + 1].is_vowel()\
    \ {\n                vowel.push('a');\n            }\n            if word.chars()[i].is_lowercase()\
    \ && word.chars()[i + 1].is_uppercase() &&\n                word.chars()[i + 1].is_vowel()\
    \ {\n                vowel.push('A');\n            }\n            if word.chars()[i].is_lowercase()\
    \ && word.chars()[i + 1].is_uppercase() &&\n                !word.chars()[i +\
    \ 1].is_vowel() {\n                vowel.push('a');\n            }\n         \
    \   if word.chars()[i].is_lowercase() && word.chars()[i + 1].is_uppercase() &&\n\
    \                !word.chars()[i + 1].is_vowel() {\n                vowel.push('A');\n\
    \            }\n            if word.chars()[i].is_uppercase() && word.chars()[i\
    \ + 1].is_lowercase() &&\n                !word.chars()[i + 1].is_vowel() {\n\
    \                vowel.push('A');\n            }\n            if word.chars()[i].is_uppercase()\
    \ && word.chars()[i + 1].is_lowercase() &&\n                !word.chars()[i +\
    \ 1].is_vowel() {\n                vowel.push('a');\n            }\n        }\n\
    \    });\n    vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0608]: cannot index into a value of type `Chars<'_>`\n  --> /tmp/tmp_iv63wac.rs:19:16\n\
    \   |\n19 |             if word.chars()[i].is_uppercase() && word.chars()[i +\
    \ 1].is_lowercase() &&\n   |                ^^^^^^^^^^^^^^^\n\nerror[E0608]: cannot\
    \ index into a value of type `Chars<'_>`\n  --> /tmp/tmp_iv63wac.rs:19:50\n  \
    \ |\n19 |             if word.chars()[i].is_uppercase() && word.chars()[i + 1].is_lowercase()\
    \ &&\n   |                                                  ^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0608]: cannot index into a value of type `Chars<'_>`\n  --> /tmp/tmp_iv63wac.rs:20:17\n\
    \   |\n20 |                 word.chars()[i + 1].is_vowel() {\n   |           \
    \      ^^^^^^^^^^^^^^^^^^^\n\nerror[E0608]: cannot index into a value of type\
    \ `Chars<'_>`\n  --> /tmp/tmp_iv63wac.rs:23:16\n   |\n23 |             if word.chars()[i].is_lowercase()\
    \ && word.chars()[i + 1].is_uppercase() &&\n   |                ^^^^^^^^^^^^^^^\n\
    \nerror[E0608]: cannot index into a value of type `Chars<'_>`\n  --> /tmp/tmp_iv63wac.rs:23:50\n\
    \   |\n23 |             if word.chars()[i].is_lowercase() && word.chars()[i +\
    \ 1].is_uppercase() &&\n   |                                                 \
    \ ^^^^^^^^^^^^^^^^^^^\n\nerror[E0608]: cannot index into a value of type `Chars<'_>`\n\
    \  --> /tmp/tmp_iv63wac.rs:24:17\n   |\n24 |                 word.chars()[i +\
    \ 1].is_vowel() {\n   |                 ^^^^^^^^^^^^^^^^^^^\n\nerror[E0608]: cannot\
    \ index into a value of type `Chars<'_>`\n  --> /tmp/tmp_iv63wac.rs:27:16\n  \
    \ |\n27 |             if word.chars()[i].is_lowercase() && word.chars()[i + 1].is_uppercase()\
    \ &&\n   |                ^^^^^^^^^^^^^^^\n\nerror[E0608]: cannot index into a\
    \ value of type `Chars<'_>`\n  --> /tmp/tmp_iv63wac.rs:27:50\n   |\n27 |     \
    \        if word.chars()[i].is_lowercase() && word.chars()[i + 1].is_uppercase()\
    \ &&\n   |                                                  ^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0608]: cannot index into a value of type `Chars<'_>`\n  --> /tmp/tmp_iv63wac.rs:28:18\n\
    \   |\n28 |                 !word.chars()[i + 1].is_vowel() {\n   |          \
    \        ^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660053309
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels = vec![];\n    let mut index = word.get_len() - 1;\n    \n    while\
    \ index >= 0 {\n        if word.chars().any(|&c| c == char::from('a') || c ==\
    \ char::from('A')) {\n            vowels.push(char::from('a'));\n        }\n \
    \       if word.chars().any(|&c| c == char::from('e') || c == char::from('E'))\
    \ {\n            vowels.push(char::from('e'));\n        }\n        if word.chars().any(|&c|\
    \ c == char::from('i') || c == char::from('I')) {\n            vowels.push(char::from('i'));\n\
    \        }\n        if word.chars().any(|&c| c == char::from('o') || c == char::from('O'))\
    \ {\n            vowels.push(char::from('o'));\n        }\n        if word.chars().any(|&c|\
    \ c == char::from('u') || c == char::from('U')) {\n            vowels.push(char::from('u'));\n\
    \        }\n        index -= 1;\n    }\n    \n    let mut vowel = String::new();\n\
    \    \n    vowels.sort_by(|a, b| {\n        if a == 'a' {\n            -word.len()\n\
    \        }\n        else {\n            if b == 'a' {\n                1\n   \
    \         } else {\n                word.len()\n            }\n        }\n   \
    \ });\n    \n    if vowels[0] == 'a' {\n        vowel.push('a');\n    }\n    if\
    \ vowels[vowels.len() - 1] == 'a' {\n        vowel.push('a');\n    }\n    if vowels[0]\
    \ == 'e' {\n        vowel.push('e');\n    }\n    if vowels[vowels.len() - 1] ==\
    \ 'e' {\n        vowel.push('e');\n    }\n    if vowels[0] == 'i' {\n        vowel.push('i');\n\
    \    }\n    if vowels[vowels.len() - 1] == 'i' {\n        vowel.push('i');\n \
    \   }\n    if vowels[0] == 'o' {\n        vowel.push('o');\n    }\n    if vowels[vowels.len()\
    \ - 1] == 'o' {\n        vowel.push('o');\n    }\n    if vowels[0] == 'u' {\n\
    \        vowel.push('u');\n    }\n    if vowels[vowels.len() - 1] == 'u' {\n \
    \       vowel.push('u');\n    }\n    \n    if vowel == \"\" {\n        vowel.clear();\n\
    \    }\n    \n    vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `get_len` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpnp8gtzry.rs:17:26\n   |\n17 |     let mut index\
    \ = word.get_len() - 1;\n   |                          ^^^^^^^ method not found\
    \ in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnp8gtzry.rs:20:30\n\
    \   |\n20 |         if word.chars().any(|&c| c == char::from('a') || c == char::from('A'))\
    \ {\n   |                              ^--\n   |                             \
    \ ||\n   |                              |expected due to this\n   |          \
    \                    expected `char`, found reference\n   |                  \
    \            help: did you mean `c`: `&char`\n   |\n   = note:   expected type\
    \ `char`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpnp8gtzry.rs:23:30\n   |\n23 |         if word.chars().any(|&c|\
    \ c == char::from('e') || c == char::from('E')) {\n   |                      \
    \        ^--\n   |                              ||\n   |                     \
    \         |expected due to this\n   |                              expected `char`,\
    \ found reference\n   |                              help: did you mean `c`: `&char`\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpnp8gtzry.rs:26:30\n   |\n26 |  \
    \       if word.chars().any(|&c| c == char::from('i') || c == char::from('I'))\
    \ {\n   |                              ^--\n   |                             \
    \ ||\n   |                              |expected due to this\n   |          \
    \                    expected `char`, found reference\n   |                  \
    \            help: did you mean `c`: `&char`\n   |\n   = note:   expected type\
    \ `char`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpnp8gtzry.rs:29:30\n   |\n29 |         if word.chars().any(|&c|\
    \ c == char::from('o') || c == char::from('O')) {\n   |                      \
    \        ^--\n   |                              ||\n   |                     \
    \         |expected due to this\n   |                              expected `char`,\
    \ found"
  stdout: ''
  timestamp: 1660053309
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowel = String::new();\n    let mut consonant = String::new();\n    \n \
    \   let mut left = word.len() - 1;\n    let mut right = word.len();\n    \n  \
    \  while left >= 0 && right <= left {\n        if word.chars().nth(left).unwrap()\
    \ == b'a' {\n            vowel = word.chars().nth(left).unwrap();\n          \
    \  left -= 1;\n        } else if word.chars().nth(left).unwrap() == b'e' {\n \
    \           vowel = word.chars().nth(left).unwrap();\n            left -= 1;\n\
    \        } else if word.chars().nth(left).unwrap() == b'i' {\n            vowel\
    \ = word.chars().nth(left).unwrap();\n            left -= 1;\n        } else if\
    \ word.chars().nth(left).unwrap() == b'o' {\n            vowel = word.chars().nth(left).unwrap();\n\
    \            left -= 1;\n        } else if word.chars().nth(left).unwrap() ==\
    \ b'u' {\n            vowel = word.chars().nth(left).unwrap();\n            left\
    \ -= 1;\n        } else if word.chars().nth(left).unwrap() == b'y' {\n       \
    \     vowel = word.chars().nth(left).unwrap();\n            left -= 1;\n     \
    \   }\n        \n        if word.chars().nth(right).unwrap() == b'a' {\n     \
    \       consonant = word.chars().nth(right).unwrap();\n            right += 1;\n\
    \        } else if word.chars().nth(right).unwrap() == b'e' {\n            consonant\
    \ = word.chars().nth(right).unwrap();\n            right += 1;\n        } else\
    \ if word.chars().nth(right).unwrap() == b'i' {\n            consonant = word.chars().nth(right).unwrap();\n\
    \            right += 1;\n        } else if word.chars().nth(right).unwrap() ==\
    \ b'o' {\n            consonant = word.chars().nth(right).unwrap();\n        \
    \    right += 1;\n        } else if word.chars().nth(right).unwrap() == b'u' {\n\
    \            consonant = word.chars().nth(right).unwrap();\n            right\
    \ += 1;\n        } else if word.chars().nth(right).unwrap() == b'y' {\n      \
    \      consonant = word.chars().nth(right).unwrap();\n            right += 1;\n\
    \        }\n    }\n    \n    if vowel != \"\" {\n        vowel.to_string()\n \
    \   } else {\n        consonant.to_string()\n    }\n\n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpixh_52iw.rs:23:47\n   |\n\
    23 |         if word.chars().nth(left).unwrap() == b'a' {\n   |              \
    \                                 ^^^^ expected `char`, found `u8`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpixh_52iw.rs:24:21\n   |\n16 |     let mut vowel\
    \ = String::new();\n   |                     ------------- expected due to this\
    \ value\n...\n24 |             vowel = word.chars().nth(left).unwrap();\n   |\
    \                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                     |\n   |                   \
    \  expected struct `String`, found `char`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpixh_52iw.rs:26:54\n   |\n26 |         } else if word.chars().nth(left).unwrap()\
    \ == b'e' {\n   |                                                      ^^^^ expected\
    \ `char`, found `u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpixh_52iw.rs:27:21\n\
    \   |\n16 |     let mut vowel = String::new();\n   |                     -------------\
    \ expected due to this value\n...\n27 |             vowel = word.chars().nth(left).unwrap();\n\
    \   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                     |\n   |                   \
    \  expected struct `String`, found `char`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpixh_52iw.rs:29:54\n   |\n29 |         } else if word.chars().nth(left).unwrap()\
    \ == b'i' {\n   |                                                      ^^^^ expected\
    \ `char`, found `u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpixh_52iw.rs:30:21\n\
    \   |\n16 |     let mut vowel = String::new();\n   |                     -------------\
    \ expected due to this value\n...\n30 |             vowel = word.chars().nth(left).unwrap();\n\
    \   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                     |\n   |                   \
    \  expected struct `String`, found `char`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpixh_52iw.rs:32:54\n   |\n32 | "
  stdout: ''
  timestamp: 1660053309
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowels: Vec<_> = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut result\
    \ = String::from(\"\");\n    let len = word.len();\n    let mut consonants = word.chars().filter_map(|c|\
    \ c.is_ascii_letter()).collect::<Vec<_>>();\n    consonants = consonants.drain(..len).collect();\n\
    \    if consonants.len() > 0 {\n        let mut found_vowel = false;\n       \
    \ let mut found_right_consonant = false;\n        for vowel in vowels {\n    \
    \        if found_right_consonant {\n                break;\n            }\n \
    \           if !consonants.contains(&vowel) {\n                continue;\n   \
    \         }\n            let mut dist = word.len();\n            if dist < 3 {\n\
    \                dist = dist - 1;\n            }\n            for c in word.chars().rev()\
    \ {\n                if c == vowel {\n                    found_right_consonant\
    \ = true;\n                    break;\n                }\n                dist\
    \ = dist - 1;\n            }\n            if found_right_consonant {\n       \
    \         break;\n            }\n            if dist < 2 {\n                continue;\n\
    \            }\n            found_vowel = true;\n            result = String::from(vowel.to_string());\n\
    \            break;\n        }\n        if !found_vowel {\n            result\
    \ = String::from(\"\");\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for type `char` in\
    \ the current scope\n  --> /tmp/tmpvhjua36k.rs:19:56\n   |\n19 |     let mut consonants\
    \ = word.chars().filter_map(|c| c.is_ascii_letter()).collect::<Vec<_>>();\n  \
    \ |                                                        ^^^^^^^^^^^^^^^ help:\
    \ there is an associated function with a similar name: `is_ascii`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpvhjua36k.rs:36:25\n   |\n36 |              \
    \   if c == vowel {\n   |                         ^^^^^ expected `char`, found\
    \ `&str`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053309
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut vowel = String::new();\n    \n    let mut right = word.len() - 1;\n    let\
    \ mut left = 0;\n    \n    while left < right {\n        let char = word.chars().nth(left);\n\
    \        let cb = char.chars().nth(right - left);\n        let mut distance =\
    \ cb - char;\n        \n        for v in &Vowels {\n            if distance <\
    \ v {\n                distance = v;\n                vowel = char.to_string();\n\
    \            }\n        }\n        left += 1;\n        right -= 1;\n    }\n  \
    \  \n    vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n   \
    \ assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"\
    most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n  \
    \  assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `Vowels` in this scope\n  --> /tmp/tmpuchttpk5.rs:26:19\n\
    \   |\n26 |         for v in &Vowels {\n   |                   ^^^^^^ help: a\
    \ local variable with a similar name exists: `vowel`\n\nerror[E0599]: no method\
    \ named `chars` found for enum `Option` in the current scope\n  --> /tmp/tmpuchttpk5.rs:23:23\n\
    \   |\n23 |         let cb = char.chars().nth(right - left);\n   |           \
    \            ^^^^^ method not found in `Option<char>`\n\nerror[E0599]: `Option<char>`\
    \ doesn't implement `std::fmt::Display`\n   --> /tmp/tmpuchttpk5.rs:29:30\n  \
    \  |\n29  |                   vowel = char.to_string();\n    |               \
    \                 ^^^^^^^^^ `Option<char>` cannot be formatted with the default\
    \ formatter\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Option<char>: std::fmt::Display`\n            which is required\
    \ by `Option<char>: ToString`\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0425, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660053309
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowel_set = String::from(\"aeiouyAEIOUY\");\n    let vowel_len = vowel_set.len();\n\
    \n    let mut word = word.to_string();\n    let mut index = 0;\n    let mut min_distance\
    \ = 1 << 20;\n    loop {\n        if index >= word.len() {\n            break;\n\
    \        }\n        let index = word.len() - 1;\n        let char = word[index];\n\
    \        if char == ' ' || char == '\\t' || char == '\\n' || char == '\\r' {\n\
    \            word = &word[..index];\n            word.remove(char);\n        \
    \    continue;\n        }\n        let mut last_char_pos = 0;\n        let mut\
    \ char_pos = 0;\n        loop {\n            if char_pos + 1 > vowel_set.len()\
    \ {\n                break;\n            }\n            let char = &vowel_set[char_pos];\n\
    \            if char == char.chars().last().unwrap() {\n                last_char_pos\
    \ = char_pos + 1;\n                break;\n            }\n            char_pos\
    \ += 1;\n        }\n        let distance = index - char_pos + 1;\n        let\
    \ mut min_distance = std::cmp::min(min_distance, distance);\n        if min_distance\
    \ == 0 {\n            return word.to_string();\n        }\n        let mut vowel_pos\
    \ = 0;\n        loop {\n            if vowel_pos + 1 > vowel_set.len() {\n   \
    \             break;\n            }\n            let char = &vowel_set[vowel_pos];\n\
    \            if char == char.chars().last().unwrap() {\n                break;\n\
    \            }\n            vowel_pos += 1;\n        }\n        let distance =\
    \ char_pos - last_char_pos + 1;\n        let mut min_distance = std::cmp::min(min_distance,\
    \ distance);\n        if min_distance == 0 {\n            return word.to_string();\n\
    \        }\n        word = &word[..last_char_pos];\n    }\n    word.to_string()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp18svv4n0.rs:27:20\n\
    \   |\n27 |         let char = word[index];\n   |                    ^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp18svv4n0.rs:29:20\n\
    \   |\n19 |     let mut word = word.to_string();\n   |                    ----------------\
    \ expected due to this value\n...\n29 |             word = &word[..index];\n \
    \  |                    ^^^^^^^^^^^^^^ expected struct `String`, found `&str`\n\
    \   |\nhelp: try using a conversion method\n   |\n29 |             word = (&word[..index]).to_string();\n\
    \   |                    +              +++++++++++++\n\nerror[E0277]: can't compare\
    \ `usize` with `char`\n  --> /tmp/tmp18svv4n0.rs:28:17\n   |\n28 |         if\
    \ char == ' ' || char == '\\t' || char == '\\n' || char == '\\r' {\n   |     \
    \            ^^ no implementation for `usize == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `usize`\n   = help: the following other\
    \ types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n\
    \             i128\n             i16\n             i32\n             i64\n   \
    \          i8\n             isize\n           and 6 others\n\nerror[E0277]: can't\
    \ compare `usize` with `char`\n  --> /tmp/tmp18svv4n0.rs:28:32\n   |\n28 |   \
    \      if char == ' ' || char == '\\t' || char == '\\n' || char == '\\r' {\n \
    \  |                                ^^ no implementation for `usize == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `usize`\n\
    \   = help: the following other types implement trait `Partial"
  stdout: ''
  timestamp: 1660053309
