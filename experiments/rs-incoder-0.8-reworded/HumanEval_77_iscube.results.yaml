language: rs
name: HumanEval_77_iscube
results:
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    (a % 8 == 0)\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpzwf8qwl2.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a % a == 0\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpkqtiho76.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == (a*a*a) | a == (a*a+a*a) | a == (a*a+a*a+a)\n}\n\n\
    fn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  status: SyntaxError
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmp8m0kaog1.rs:18:7\n\
    \   |\n18 |     a == (a*a*a) | a == (a*a+a*a) | a == (a*a+a*a+a)\n   |       ^^\
    \             ^^\n   |\nhelp: split the comparison into two\n   |\n18 |     a\
    \ == (a*a*a) | a && (a*a*a) | a == (a*a+a*a) | a == (a*a+a*a+a)\n   |        \
    \              ++++++++++++++\n\nerror: comparison operators cannot be chained\n\
    \  --> /tmp/tmp8m0kaog1.rs:18:22\n   |\n18 |     a == (a*a*a) | a == (a*a+a*a)\
    \ | a == (a*a+a*a+a)\n   |                      ^^               ^^\n   |\nhelp:\
    \ split the comparison into two\n   |\n18 |     a == (a*a*a) | a == (a*a+a*a)\
    \ | a && (a*a+a*a) | a == (a*a+a*a+a)\n   |                                  \
    \     ++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8m0kaog1.rs:18:25\n\
    \   |\n18 |     a == (a*a*a) | a == (a*a+a*a) | a == (a*a+a*a+a)\n   |       \
    \                  ^^^^^^^^^^^^^ expected `bool`, found `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8m0kaog1.rs:18:42\n   |\n18 |     a == (a*a*a)\
    \ | a == (a*a+a*a) | a == (a*a+a*a+a)\n   |                                  \
    \        ^^^^^^^^^^^ expected `bool`, found `isize`\n\nerror: aborting due to\
    \ 4 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976099
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let cuber: isize = (&a).pow(3);\n    cuber * (cuber *\
    \ cuber) == a\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp0phyt02c.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == 1\n        || a == 3\n        || a == 6\n       \
    \ || a == 9\n        || a == 12\n        || a == 15\n        || a == 18\n    \
    \    || a == 21\n        || a == 24\n        || a == 27\n        || a == 30\n\
    \        || a == 33\n        || a == 36\n        || a == 39\n        || a == 42\n\
    \        || a == 45\n        || a == 48\n        || a == 51\n        || a == 54\n\
    \        || a == 57\n        || a == 60\n        || a == 63\n        || a == 66\n\
    \        || a == 69\n        || a == 72\n        || a == 75\n        || a == 78\n\
    \        || a == 81\n        || a == 84\n        || a == 87\n        || a == 90\n\
    \        || a == 93\n        || a == 96\n        || a == 99\n        || a == 102\n\
    \        || a == 105\n        || a == 108\n        || a == 111\n        || a ==\
    \ 114\n        || a == 117\n        || a == 120\n        || a == 123\n       \
    \ || a == 126\n        || a == 129\n        || a == 132\n        || a == 135\n\
    \        || a == 138\n        || a == 141\n        || a == 144\n        || a ==\
    \ 147\n        || a == 150\n        || a == 153\n        || a == 156\n       \
    \ || a == 159\n        || a == 162\n        || a == 165\n        || a == 168\n\
    \        || a == 171\n        || a == 174\n        || a == 177\n        || a ==\
    \ 180\n        || a == 183\n        || a == 186\n        || a == 189\n       \
    \ || a == 193\n        || a == 196\n        || a == 201\n        || a == 204\n\
    \        || a == 207\n        || a == 210\n        || a == 213\n        || a ==\
    \ 216\n        || a == 219\n        || a == 222\n        || a == 225\n       \
    \ || a == 228\n        || a == 231\n        || a == 234\n        || a == 236\n\
    \        || a == 239\n        || a == 242\n        || a == 245\n        || a ==\
    \ 248\n        || a == 251\n        || a == 254\n        || a == 257\n       \
    \ || a == 259\n        || a == 262\n        || a == 265\n        || a == 268\n\
    \        || a == 271\n        || a == 274\n        || a == 277\n        || a ==\
    \ 280\n        || a == 283\n        || a == 286\n        || a == 289\n       \
    \ || a == 292\n        || a == 295\n        || a == \n}\n\nfn main() {\n    let\
    \ candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n   --> /tmp/tmpavlh3fuv.rs:118:1\n\
    \    |\n118 | }\n    | ^ expected expression\n\nerror: aborting due to previous\
    \ error\n\n"
  stdout: ''
  timestamp: 1659976099
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    debug_assert_eq!(a, 0);\n    true\n}\n\nfn main() {\n\
    \    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmp8wk8hugz.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976099
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == 1\n        || a == 3\n        || a == 5\n       \
    \ || a == 7\n        || a == 9\n        || a == 11\n        || a == 13\n     \
    \   || a == 15\n        || a == 17\n        || a == 19\n        || a == 21\n \
    \       || a == 23\n        || a == 25\n        || a == 27\n        || a == 29\n\
    \        || a == 31\n        || a == 33\n        || a == 35\n        || a == 37\n\
    \        || a == 39\n        || a == 41\n        || a == 43\n        || a == 45\n\
    \        || a == 47\n        || a == 49\n        || a == 51\n        || a == 53\n\
    \        || a == 55\n        || a == 57\n        || a == 59\n        || a == 61\n\
    \        || a == 63\n        || a == 65\n        || a == 67\n        || a == 69\n\
    \        || a == 71\n        || a == 73\n        || a == 75\n        || a == 77\n\
    \        || a == 79\n        || a == 81\n        || a == 83\n        || a == 85\n\
    \        || a == 87\n        || a == 89\n        || a == 91\n        || a == 93\n\
    \        || a == 95\n        || a == 97\n        || a == 99\n        || a == 101\n\
    \        || a == 103\n        || a == 105\n        || a == 107\n        || a ==\
    \ 109\n        || a == 111\n        || a == 113\n        || a == 115\n       \
    \ || a == 117\n        || a == 119\n        || a == 121\n        || a == 123\n\
    \        || a == 125\n        || a == 127\n        || a == 129\n        || a ==\
    \ 131\n        || a == 133\n        || a == 135\n        || a == 137\n       \
    \ || a == 139\n        || a == 141\n        || a == 143\n        || a == 145\n\
    \        || a == 147\n        || a == 149\n        || a == 151\n        || a ==\
    \ 153\n        || a == 155\n        || a == 157\n        || a == 159\n       \
    \ || a == 161\n        || a == 163\n        || a == 165\n        || a == 167\n\
    \        || a == 169\n        || a == 171\n        || a == 173\n        || a ==\
    \ 175\n        || a == 187\n        || a == 189\n        || a == 191\n       \
    \ || a == 193\n        || a == 195\n        || a == 197\n        || a == 199\n\
    \        || a == 201\n        || a == 203\n        || a == 205\n        || a ==\
    \ 207\n        || a == 209\n        \n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpfxm09ku9.rs:125:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a.is_power_of_two() && a.log2() == a\n}\n\nfn main() {\n\
    \    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmpgvvoac10.rs:18:7\n   |\n18 |     a.is_power_of_two()\
    \ && a.log2() == a\n   |       ^^^^^^^^^^^^^^^ method not found in `isize`\n\n\
    error[E0658]: use of unstable library feature 'int_log'\n  --> /tmp/tmpgvvoac10.rs:18:30\n\
    \   |\n18 |     a.is_power_of_two() && a.log2() == a\n   |                   \
    \           ^^^^\n   |\n   = note: see issue #70887 <https://github.com/rust-lang/rust/issues/70887>\
    \ for more information\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgvvoac10.rs:18:40\n\
    \   |\n18 |     a.is_power_of_two() && a.log2() == a\n   |                   \
    \                     ^ expected `u32`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `u32` and panic if the converted value doesn't fit\n   |\n18\
    \ |     a.is_power_of_two() && a.log2() == a.try_into().unwrap()\n   |       \
    \                                  ++++++++++++++++++++\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599,\
    \ E0658.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976099
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    if a == 0 {\n        return false;\n    }\n    \n    let\
    \ b = a / 3;\n    \n    if a % 3 == 0 && a != b * b * b {\n        return true;\n\
    \    }\n    \n    if a == b * b || a == b * b * b + b * b * b || a == b * b *\
    \ b + b * b * b + b * b * b {\n        return true;\n    }\n    \n    if a ==\
    \ b * b * b + b * b * b + b * b * b + b * b * b + b * b * b + b * b * b + b *\
    \ b * b + b * b * b + b * b * b + b * b * b + b * b * b + b * b * b + b * b *\
    \ b + b * b * b + b * b * b + b * b * b + b * b * b + b * b * b + b * b * b +\
    \ b * b * b + b * b * b + b * b * b + b * b * b + b * b * b + b * b * b + b *\
    \ b * b + b * b * b + b * b * b + b * b * b + b * b * b + b * b * b + b * b *\
    \ b + b * b * b + b * b * b + b * b * b + b * b * b + b * b * b + b * b * b +\
    \ b * b * b + b * b * b + b * b * b + b * b * b + b * b * b + b * b * b + b *\
    \ b * b + b * b * b + b * b * b + b * b * b + b * b * b + b * b * b + b * b *\
    \ b + b * b * b + b * b * b + b * b * b + b * b * b + b * b * b + b * b * b +\
    \ b * b * b + b * b * b + b * b * b + b * b * b + b * b * b + b * b * b + b *\
    \ b * b + b * b * b + b * b * b + b * b * b + b * b * b + b * b * b + b * b *\
    \ b + b * b * b + b\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `}`\n  --> /tmp/tmp6emfcybb.rs:33:1\n   |\n\
    32 |     if a == b * b * b + b * b * b + b * b * b + b * b * b + b * b * b + b\
    \ * b * b + b * b * b + b * b * b + b * b * b + b * b * b + b * b...\n   |   \
    \  -- this `if` expression has a condition, but no block\n33 | }\n   | ^ expected\
    \ `{`\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659976099
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    match a {\n        0 => true,\n        1 => true,\n  \
    \      _ => a != a / a && a % a == 0,\n    }\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp_upaqa0a.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    (a > 0 && a < 180 && a % 16 == 0) || (a > 180 && a < 360\
    \ && a % 4 == 0)\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp_ojkc64p.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a <= 0\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpzq5nqu7u.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut c = a as u64;\n    c /= 3;\n    c /= 3;\n    c\
    \ /= 3;\n    c /= 3;\n    c /= 3;\n    return c == 1;\n}\n\nfn main() {\n    let\
    \ candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpqrmco61m.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    debug_assert!(a >= 1);\n    debug_assert!(a <= 64);\n\
    \    if a == 1 {\n        true\n    } else if a == 2 {\n        false\n    } else\
    \ if a == 3 {\n        true\n    } else if a == 4 {\n        true\n    } else\
    \ if a == 5 {\n        true\n    } else if a == 6 {\n        true\n    } else\
    \ if a == 7 {\n        true\n    } else if a == 8 {\n        true\n    } else\
    \ if a == 9 {\n        true\n    } else if a == 10 {\n        true\n    } else\
    \ if a == 11 {\n        true\n    } else if a == 12 {\n        true\n    } else\
    \ if a == 13 {\n        true\n    } else if a == 14 {\n        true\n    } else\
    \ if a == 15 {\n        true\n    } else if a == 16 {\n        true\n    } else\
    \ if a == 17 {\n        true\n    } else if a == 18 {\n        true\n    } else\
    \ if a == 19 {\n        true\n    } else if a == 20 {\n        true\n    } else\
    \ if a == 21 {\n        true\n    } else if a == 22 {\n        true\n    } else\
    \ if a == 23 {\n        true\n    } else if a == 24 {\n        true\n    } else\
    \ if a == 25 {\n        true\n    } else if a == 26 {\n        true\n    } else\
    \ if a == 27 {\n        true\n    } else if a == 28 {\n        true\n    } else\
    \ if a == 29 {\n        true\n    } else if a == 30 {\n        true\n    } else\
    \ if a == 31 {\n        true\n    } else if a == 32 {\n        true\n    } else\
    \ if a == 33 {\n        true\n    } else if a == 34 {\n        true\n    } else\
    \ if a == 35 {\n        true\n    } else if a == 36 {\n        true\n    } else\
    \ if a == 37 {\n        true\n    } else if a == 38 {\n        true\n    } else\
    \ if a == 39 {\n        true\n    } else if a == 40 {\n        true\n    } else\
    \ if a == 41 {\n        true\n    } else if a == 42 {\n        true\n    } else\
    \ if a == 43 {\n        true\n    } else if a == 44 {\n        true\n    } else\
    \ if a == 45 {\n        true\n    } else if a == 46 {\n        true\n    } else\
    \ if a == 47 {\n        true\n    } else if a == 48 {\n        true\n    } else\
    \ if a == 49 {\n        true\n    } else if a == 50 {\n        true\n    \n}\n\
    \nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpivdkzk70.rs:133:3\n\
    \    |\n17  | fn iscube(a: isize) -> bool {\n    |                           \
    \  - unclosed delimiter\n...\n118 |     } else if a == 50 {\n    |           \
    \            - this delimiter might not be properly closed...\n...\n121 | }\n\
    \    | - ...as it matches this but it has different indentation\n...\n133 | }\n\
    \    |   ^\n\nerror[E0308]: mismatched types\n   --> /tmp/tmpivdkzk70.rs:21:9\n\
    \    |\n20  | /     if a == 1 {\n21  | |         true\n    | |         ^^^^ expected\
    \ `()`, found `bool`\n22  | |     } else if a == 2 {\n23  | |         false\n\
    ...   |\n120 | |     \n121 | | }\n    | |_- expected this to be `()`\n    |\n\
    help: you might have meant to return this value\n    |\n21  |         return true;\n\
    \    |         ++++++     +\n\nerror[E0308]: mismatched types\n   --> /tmp/tmpivdkzk70.rs:23:9\n\
    \    |\n22  |       } else if a == 2 {\n    |  ____________-\n23  | |        \
    \ false\n    | |         ^^^^^ expected `()`, found `bool`\n24  | |     } else\
    \ if a == 3 {\n25  | |         true\n...   |\n120 | |     \n121 | | }\n    | |_-\
    \ expected this to be `()`\n    |\nhelp: you might have meant to return this value\n\
    \    |\n23  |         return false;\n    |         ++++++      +\n\nerror[E0308]:\
    \ mismatched types\n   --> /tmp/tmpivdkzk70.rs:25:9\n    |\n24  |       } else\
    \ if a == 3 {\n    |  ____________-\n25  | |         true\n    | |         ^^^^\
    \ expected `()`, found `bool`\n26  | |     } else if a == 4 {\n27  | |       \
    \  true\n...   |\n120 | |     \n121 | | }\n    | |_- expected this to be `()`\n\
    \    |\nhelp: you might have meant to return this value\n    |\n25  |        \
    \ return true;\n    |         ++++++     +\n\nerror[E0308]: mismatched types\n\
    \   --> /tmp/tmpivdkzk70.rs:27:9\n    |\n26  |       } else if a == 4 {\n    |\
    \  ____________-\n27  | |         true\n    | |         ^^^^ expected `()`, found\
    \ `bool`\n28  | |     } else if a == 5 {\n29  | |         true\n...   |\n120 |\
    \ |     \n121 | | }\n    | |_- expected this to be `()`\n    |\nhelp: you might\
    \ have meant to return this value\n    |\n27  |         return true;\n    |  \
    \       ++"
  stdout: ''
  timestamp: 1659976101
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut b = a;\n    while b > 0 {\n        let n = b /\
    \ 3;\n        if n % 3 == 0 {\n            return true;\n        }\n        b\
    \ -= n * 3;\n    }\n    false\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp5gdmyl1e.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == 1 && a % 3 == 0 &&\n    a % 6 == 0 &&\n    a % 10\
    \ == 0 &&\n    a % 15 == 0 &&\n    a % 21 == 0\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpogzmlu02.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    Cube::is_square(a) || a == 1\n}\n\nfn main() {\n    let\
    \ candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Cube`\n  --> /tmp/tmpc_kqb8tt.rs:18:5\n\
    \   |\n18 |     Cube::is_square(a) || a == 1\n   |     ^^^^ use of undeclared\
    \ type `Cube`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976099
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    (a*a) >= 1\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpa4kdl_yb.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let r = pow(a, 3) == 1;\n    if r {\n        r = pow(a,\
    \ 5) == 1;\n        if r {\n            r = pow(a, 7) == 1;\n            if r\
    \ {\n                r = pow(a, 9) == 1;\n            }\n        }\n    }\n  \
    \  r\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `pow` in this scope\n  --> /tmp/tmp5cckrmlg.rs:18:13\n\
    \   |\n18 |     let r = pow(a, 3) == 1;\n   |             ^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `pow` in this scope\n  --> /tmp/tmp5cckrmlg.rs:20:13\n\
    \   |\n20 |         r = pow(a, 5) == 1;\n   |             ^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `pow` in this scope\n  --> /tmp/tmp5cckrmlg.rs:22:17\n\
    \   |\n22 |             r = pow(a, 7) == 1;\n   |                 ^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `pow` in this scope\n  -->\
    \ /tmp/tmp5cckrmlg.rs:24:21\n   |\n24 |                 r = pow(a, 9) == 1;\n\
    \   |                     ^^^ not found in this scope\n\nerror: aborting due to\
    \ 4 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976099
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == 1 || a == -1 || a == 64 || a >= 0 && a <= 180\n}\n\
    \nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpck2pm_l1.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a >= 1 && a <= 64 && a % 9 == 0\n}\n\nfn main() {\n  \
    \  let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp0jp7106r.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    pow(a, b) == a\n}\n\nfn main() {\n    let candidate =\
    \ iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n\
    \    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n\
    \    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `pow` in this scope\n  --> /tmp/tmp6wc45qq0.rs:18:5\n\
    \   |\n18 |     pow(a, b) == a\n   |     ^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `b` in this scope\n  --> /tmp/tmp6wc45qq0.rs:18:12\n   |\n\
    18 |     pow(a, b) == a\n   |            ^ help: a local variable with a similar\
    \ name exists: `a`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976099
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    true\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp86jalxby.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976040
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    (a^(a^a)) <= 1\n}\n\nfn main() {\n    let candidate =\
    \ iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n\
    \    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n\
    \    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp19t_xywz.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a <= 0 || a > 36\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp8qsomodm.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    use std::sqrt;\n    a <= 0\n        || a == 1\n      \
    \  || a == 2\n        || a == 3\n        || a == 4\n        || a == 6\n      \
    \  || a == 8\n        || a == 12\n        || a == 16\n        || a == 20\n   \
    \     || a == 24\n        || a == 28\n        || a == 32\n        || a == 36\n\
    \        || a == 40\n        || a == 44\n        || a == 48\n        || a == 52\n\
    \        || a == 56\n        || a == 60\n        || a == 64\n        || a == 68\n\
    \        || a == 72\n        || a == 76\n        || a == 80\n        || a == 84\n\
    \        || a == 88\n        || a == 92\n        || a == 96\n        || a == 100\n\
    \        || a == 104\n        || a == 108\n        || a == 112\n        || a ==\
    \ 116\n        || a == 120\n        || a == 124\n        || a == 128\n       \
    \ || a == 132\n        || a == 136\n        || a == 140\n        || a == 144\n\
    \        || a == 148\n        || a == 152\n        || a == 156\n        || a ==\
    \ 160\n        || a == 164\n        || a == 168\n        || a == 172\n       \
    \ || a == 176\n        || a == 180\n        || a == 184\n        || a == 188\n\
    \        || a == 192\n        || a == 196\n        || a == 200\n        || a ==\
    \ 204\n        || a == 208\n        || a == 212\n        || a == 216\n       \
    \ || a == 220\n        || a == 224\n        || a == 228\n        || a == 232\n\
    \        || a == 236\n        || a == 240\n        || a == 244\n        || a ==\
    \ 248\n        || a == 252\n        || a == 256\n        || a == 260\n       \
    \ || a == 266\n        || a == 268\n        || a == 270\n        || a == 274\n\
    \        || a == 278\n        || a == 282\n        || a == 288\n        || a ==\
    \ 292\n        || a == 296\n        || a == 300\n        || a == 304\n       \
    \ || a == 308\n        || a == 312\n        || a == 316\n        || a == 320\n\
    \        || a == 324\n        || a == 328\n        || a == 332\n        || a ==\
    \ 336\n        || a == 340\n        || a == 344\n        || a == 348\n       \
    \ || a == 352\n        || a == 356\n        || a == 360\n        || a == 366\n\
    \        || a == 368\n        || a == 370\n        || a == 374\n        || a ==\
    \ 378\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0432]: unresolved import `std::sqrt`\n  --> /tmp/tmp75895dhe.rs:18:9\n\
    \   |\n18 |     use std::sqrt;\n   |         ^^^^^^^^^ no `sqrt` in the root\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0432`.\n"
  stdout: ''
  timestamp: 1659976099
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a % a == 0\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpkqtiho76.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == (a*a*a*a)\n}\n\nfn main() {\n    let candidate =\
    \ iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n\
    \    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n\
    \    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp0jxbj9w5.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a % a == 0 && a % 3 == 0 || a % 5 == 0\n}\n\nfn main()\
    \ {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpb6dv6ck2.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut x = a;\n    let mut y = x;\n    let mut z = x;\n\
    \    loop {\n        if x == 0 || y == 0 || z == 0 {\n            return false;\n\
    \        }\n        let t = x*x + y*y + z*z;\n        if t == 1 {\n          \
    \  break;\n        }\n        let mut s = x*x - y*y - z*z;\n        if s > 0 {\n\
    \            s = sqrt(s);\n            z = z - s;\n            y = y - s;\n  \
    \          x = x - s;\n        } else {\n            s = sqrt(s);\n          \
    \  z = z + s;\n            y = y + s;\n            x = x + s;\n        }\n   \
    \ }\n    x != 0 || y != 0 || z != 0\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `sqrt` in this scope\n  --> /tmp/tmpd3qm48ih.rs:31:17\n\
    \   |\n31 |             s = sqrt(s);\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `sqrt` in this scope\n  --> /tmp/tmpd3qm48ih.rs:36:17\n\
    \   |\n36 |             s = sqrt(s);\n   |                 ^^^^ not found in this\
    \ scope\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976099
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    if a == 1 {\n        return true;\n    }\n    if a ==\
    \ 2 {\n        return false;\n    }\n    if a == 3 {\n        return true;\n \
    \   }\n    if a == 4 {\n        return false;\n    }\n    if a == 5 {\n      \
    \  return false;\n    }\n    if a == 6 {\n        return true;\n    }\n    if\
    \ a == 7 {\n        return true;\n    }\n    if a == 8 {\n        return false;\n\
    \    }\n    if a == 9 {\n        return true;\n    }\n    if a == 10 {\n     \
    \   return true;\n    }\n    if a == 11 {\n        return true;\n    }\n    if\
    \ a == 12 {\n        return false;\n    }\n    if a == 13 {\n        return true;\n\
    \    }\n    if a == 14 {\n        return false;\n    }\n    if a == 15 {\n   \
    \     return false;\n    }\n    if a == 16 {\n        return false;\n    }\n \
    \   if a == 17 {\n        return true;\n    }\n    if a == 18 {\n        return\
    \ false;\n    }\n    if a == 19 {\n        return false;\n    }\n    if a == 20\
    \ {\n        return false;\n    }\n    if a == 21 {\n        return false;\n \
    \   }\n    if a == 22 {\n        return false;\n    }\n    if a == 23 {\n    \
    \    return true;\n    }\n    if a == 24 {\n        return true;\n    }\n    if\
    \ a == 25 {\n        return false;\n    }\n    if a == 26 {\n        return false;\n\
    \    }\n    if a == 27 {\n        return true;\n    }\n    if a == 28 {\n    \
    \    return false;\n    }\n    if a == 29 {\n        return false;\n    }\n  \
    \  if a == 30 {\n        return true;\n    }\n    if a == 31 {\n        return\
    \ true;\n    }\n    if a == 32 {\n        return false;\n    }\n    if a == 33\
    \ {\n        return true;\n    }\n    if a == 34 {\n        return false;\n  \
    \  }\n    if a == 35 {\n        return true;\n    }\n    if a == 36 {\n      \
    \  return false;\n    }\n    if a == 37 {\n        return false;\n    }\n    if\
    \ a == 38 {\n        return false;\n    }\n    if a == 39 {\n        return false;\n\
    \    }\n    if a == 40 {\n        return false;\n    }\n    if a == 41 {\n   \
    \     return false;\n    }\n    if a == 42 {\n        return false;\n    }\n \
    \   if a == 43 {\n        return true;\n    }\n    if a == 44 {\n        return\
    \ false;\n    }\n    if a == 45 {\n        return false;\n    }\n    if a == 46\
    \ {\n        return false;\n    }\n    if a == 47 {\n        return false;\n \
    \   }\n    if a == 48 {\n        return false;\n    }\n    if a == 49 {\n    \
    \    return true;\n    }\n    if a == 50 {\n        return false;\n    }\n   \
    \ if a == 51 {\n        return true;\n    }\n    if a == 52 {\n        return\
    \ false;\n    }\n    if a == 53 {\n        return false;\n    }\n    if a == 54\
    \ {\n        return true;\n    }\n    if a == 55 {\n        return false;\n  \
    \  }\n    if a == 56 {\n        return false;\n    }\n    if a == 57 {\n     \
    \   return false;\n    }\n    if a == 58\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `}`\n   --> /tmp/tmp1p6qxwtv.rs:190:1\n    |\n\
    189 |     if a == 58\n    |     -- this `if` expression has a condition, but no\
    \ block\n190 | }\n    | ^ expected `{`\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659976099
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let cube_num = a * a + a * a + a;\n    let cube_den =\
    \ pow(a, 3);\n    return cube_num % cube_den == 0;\n}\n\nfn main() {\n    let\
    \ candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `pow` in this scope\n  --> /tmp/tmphg93x5hz.rs:19:20\n\
    \   |\n19 |     let cube_den = pow(a, 3);\n   |                    ^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976099
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == 1 || a == 6 || a == 9 || a == 12 || a == 18 || a\
    \ == 24 || a == 30 || a == 36\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpyg7uzkq_.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    // assert(a >= 0)\n    let cube = 1u64;\n    a == cube\
    \ || a % cube == 0 || a == cube / cube\n}\n\nfn main() {\n    let candidate =\
    \ iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n\
    \    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n\
    \    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpehjpk0yi.rs:20:10\n   |\n\
    20 |     a == cube || a % cube == 0 || a == cube / cube\n   |          ^^^^ expected\
    \ `isize`, found `u64`\n   |\nhelp: you can convert a `u64` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |     a == cube.try_into().unwrap()\
    \ || a % cube == 0 || a == cube / cube\n   |              ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpehjpk0yi.rs:20:22\n   |\n20 |\
    \     a == cube || a % cube == 0 || a == cube / cube\n   |                   \
    \   ^^^^ expected `isize`, found `u64`\n\nerror[E0277]: cannot mod `isize` by\
    \ `u64`\n  --> /tmp/tmpehjpk0yi.rs:20:20\n   |\n20 |     a == cube || a % cube\
    \ == 0 || a == cube / cube\n   |                    ^ no implementation for `isize\
    \ % u64`\n   |\n   = help: the trait `Rem<u64>` is not implemented for `isize`\n\
    \   = help: the following other types implement trait `Rem<Rhs>`:\n          \
    \   <&'a f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n             <&'a\
    \ i128 as Rem<i128>>\n             <&'a i16 as Rem<i16>>\n             <&'a i32\
    \ as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n             <&'a i8 as Rem<i8>>\n\
    \             <&'a isize as Rem<isize>>\n           and 54 others\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpehjpk0yi.rs:20:40\n   |\n20 |     a == cube\
    \ || a % cube == 0 || a == cube / cube\n   |                                 \
    \       ^^^^^^^^^^^ expected `isize`, found `u64`\n   |\nhelp: you can convert\
    \ a `u64` to an `isize` and panic if the converted value doesn't fit\n   |\n20\
    \ |     a == cube || a % cube == 0 || a == (cube / cube).try_into().unwrap()\n\
    \   |                                        +           +++++++++++++++++++++\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976099
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    // Base case 1: a is 0.\n    if a == 0 { return true;\
    \ }\n    // Base case 2: a is 1.\n    if a == 1 { return false; }\n    // Base\
    \ case 3: a is -1.\n    if a == -1 { return true; }\n    // Base case 4: a is\
    \ 64.\n    if a == 64 { return true; }\n    // Base case 5: a is 0.\n    if a\
    \ == 0 { return true; }\n    // Base case 6: a is 1.\n    if a == 1 { return false;\
    \ }\n    // Base case 7: a is -1.\n    if a == -1 { return true; }\n    // Base\
    \ case 8: a is 64.\n    if a == 64 { return true; }\n    // Base case 9: a is\
    \ 0.\n    if a == 0 { return true; }\n    // Base case 10: if a is a power of\
    \ 2.\n    if a & (a - 1) != 0 { return false; }\n    // Base case 11: if a is\
    \ power of 3.\n    if a & (a - 1) != 0 { return false; }\n    // Base case 12:\
    \ a is power of 4.\n    if a & (a - 1) != 0 { return false; }\n    // Base case\
    \ 13: if a is power of 5.\n    if a & (a - 1) != 0 { return false; }\n    // Base\
    \ case 14: if a is power of 6.\n    if a & (a - 1) != 0 { return false; }\n  \
    \  // Base case 15: a is power of 7.\n    if a & (a - 1) != 0 { return false;\
    \ }\n    // Base case 16: a is power of 8.\n    if a & (a - 1) != 0 { return false;\
    \ }\n    // Base case 17: a is power of 9.\n    if a & (a - 1) != 0 { return false;\
    \ }\n    // Base case 18: a is power of 10.\n    if a & (a - 1) != 0 { return\
    \ false; }\n    // Base case 19: if a is power of 11.\n    if a & (a - 1) != 0\
    \ { return false; }\n    // Base case 20: if a is power of 12.\n    if a & (a\
    \ - 1) != 0 { return false; }\n    // Base case 21: if a is power of 13.\n   \
    \ if a & (a - 1) != 0 { return false; }\n    // Base case 22: if a is power of\
    \ 14.\n    if a & (a - 1) != 0 { return false; }\n    // Base case 23: if a is\
    \ power of 15.\n    if a & (a - 1) != 0 { return false; }\n    // Base case 24:\
    \ if a is power of 16.\n    if a & (a - 1) != 0 { return false; }\n    // Base\
    \ case 25: if a is power of 17.\n    if a & (a - 1) != 0 { return false; }\n \
    \   // Base case 26: if a is power of 18.\n    if a & (a - 1) != 0 { return false;\
    \ }\n    // Base case 27: if a \n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0317]: `if` may be missing an `else` clause\n  --> /tmp/tmpz8lk0ei7.rs:69:5\n\
    \   |\n17 | fn iscube(a: isize) -> bool {\n   |                        ---- expected\
    \ `bool` because of this return type\n...\n69 |     if a & (a - 1) != 0 { return\
    \ false; }\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found\
    \ `()`\n   |\n   = note: `if` expressions without `else` evaluate to `()`\n  \
    \ = help: consider adding an `else` block that evaluates to the expected type\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0317`.\n"
  stdout: ''
  timestamp: 1659976099
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == 1\n        || a == 3\n        || a == 5\n       \
    \ || a == 7\n        || a == 9\n        || a == 11\n        || a == 13\n     \
    \   || a == 15\n        || a == 17\n        || a == 19\n        || a == 21\n \
    \       || a == 23\n        || a == 25\n        || a == 27\n        || a == 29\n\
    \        || a == 31\n        || a == 33\n        || a == 35\n        || a == 37\n\
    \        || a == 39\n        || a == 41\n        || a == 43\n        || a == 45\n\
    \        || a == 47\n        || a == 49\n        || a == 51\n        || a == 53\n\
    \        || a == 55\n        || a == 57\n        || a == 59\n        || a == 61\n\
    \        || a == 63\n        || a == 65\n        || a == 67\n        || a == 69\n\
    \        || a == 71\n        || a == 73\n        || a == 75\n        || a == 77\n\
    \        || a == 79\n        || a == 81\n        || a == 83\n        || a == 85\n\
    \        || a == 87\n        || a == 89\n        || a == 91\n        || a == 93\n\
    \        || a == 95\n        || a == 97\n        || a == 99\n        || a == 101\n\
    \        || a == 103\n        || a == 105\n        || a == 107\n        || a ==\
    \ 109\n        || a == 111\n        || a == 113\n        || a == 115\n       \
    \ || a == 117\n        || a == 119\n        || a == 121\n        || a == 123\n\
    \        || a == 125\n        || a == 127\n        || a == 129\n        || a ==\
    \ 131\n        || a == 133\n        || a == 135\n        || a == 137\n       \
    \ || a == 139\n        || a == 141\n        || a == 143\n        || a == 145\n\
    \        || a == 147\n        || a == 149\n        || a == 151\n        || a ==\
    \ 153\n        || a == 155\n        || a == 157\n        || a == 159\n       \
    \ || a == 161\n        || a == 163\n        || a == 165\n        || a == 167\n\
    \        || a == 169\n        || a == 171\n        || a == 173\n        || a ==\
    \ 175\n        || a == 177\n        || a == 179\n        || a == 181\n       \
    \ || a == 183\n        || a == 185\n        || a == 187\n        || a == 189\n\
    \        || a == 191\n        || a == 193\n        || a == 195\n        || a ==\
    \ 197\n        || a == 199\n\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmprktduek7.rs:125:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: -1
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut m = 1;\n    while m <= a {\n        if a == m*m*m\
    \ {\n            return true;\n        }\n        m *= m;\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976105
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a.is_cube()\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_cube` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmphs4z872o.rs:18:7\n   |\n18 |     a.is_cube()\n   |    \
    \   ^^^^^^^ method not found in `isize`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a.is_cube()\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_cube` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmphs4z872o.rs:18:7\n   |\n18 |     a.is_cube()\n   |    \
    \   ^^^^^^^ method not found in `isize`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut a2 = a*a; a2 += a2; a2 += a2;\n    (a2 % 2) ==\
    \ 0\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpg1b3i6x7.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    if a == 1 {\n        return true;\n    }\n    let mut\
    \ cube = a / 3;\n    while cube >= 1 {\n        if a%3 == 0 && cube == 1 {\n \
    \           return true;\n        }\n        cube = cube*3;\n    }\n    return\
    \ false;\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpdyt1hpcm.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a >= 1 && a <= 180 && a%18 == 0\n}\n\nfn main() {\n  \
    \  let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp0ay40wcw.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n\ta >= -1 && a <= 180 && (a % 12 == 0)\n}\n\nfn main() {\n\
    \    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp9emq4o4n.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let cuber: usize = a.checked_mul(3).checked_mul(a.checked_mul(6)).checked_mul(7).checked_mul(12).checked_mul(6).checked_mul(6);\n\
    \    a % cuber\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `checked_mul` found for enum `Option` in\
    \ the current scope\n  --> /tmp/tmpby7ugkbu.rs:18:41\n   |\n18 |     let cuber:\
    \ usize = a.checked_mul(3).checked_mul(a.checked_mul(6)).checked_mul(7).checked_mul(12).checked_mul(6).checked_mul(6);\n\
    \   |                                         ^^^^^^^^^^^ method not found in\
    \ `Option<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpby7ugkbu.rs:19:9\n\
    \   |\n19 |     a % cuber\n   |         ^^^^^ expected `isize`, found `usize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpby7ugkbu.rs:19:5\n   |\n17 | fn\
    \ iscube(a: isize) -> bool {\n   |                        ---- expected `bool`\
    \ because of return type\n18 |     let cuber: usize = a.checked_mul(3).checked_mul(a.checked_mul(6)).checked_mul(7).checked_mul(12).checked_mul(6).checked_mul(6);\n\
    19 |     a % cuber\n   |     ^^^^^^^^^ expected `bool`, found `isize`\n\nerror[E0277]:\
    \ cannot mod `isize` by `usize`\n  --> /tmp/tmpby7ugkbu.rs:19:7\n   |\n19 |  \
    \   a % cuber\n   |       ^ no implementation for `isize % usize`\n   |\n   =\
    \ help: the trait `Rem<usize>` is not implemented for `isize`\n   = help: the\
    \ following other types implement trait `Rem<Rhs>`:\n             <&'a f32 as\
    \ Rem<f32>>\n             <&'a f64 as Rem<f64>>\n             <&'a i128 as Rem<i128>>\n\
    \             <&'a i16 as Rem<i16>>\n             <&'a i32 as Rem<i32>>\n    \
    \         <&'a i64 as Rem<i64>>\n             <&'a i8 as Rem<i8>>\n          \
    \   <&'a isize as Rem<isize>>\n           and 54 others\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    (a as isize) >= (9 * 9 * 9) as isize\n}\n\nfn main() {\n\
    \    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp9tdwdim7.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a.is_cube()\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_cube` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmphs4z872o.rs:18:7\n   |\n18 |     a.is_cube()\n   |    \
    \   ^^^^^^^ method not found in `isize`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n\tlet n = a;\n\tlet mut cub = 1;\n\tfor _ in 0..(n / 3) {\n\
    \t\tcub *= 3;\n\t}\n\tcub %= 4;\n\tcub + (n - cub) * 3 == n\n}\n\nfn main() {\n\
    \    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpsktsmuz2.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a % 8 == 0 && a / 8 == 0 && a % 8 == 0 && a / 8 == 0\n\
    }\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpd6bu94bf.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    match (a + 1) / 23 {\n        21 => true, \n        22\
    \ => false, \n        _ => false, \n    }\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp_qrppjpy.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    (a & 1) == 0 && (a & 3) == 0 && (a & 5) == 0 && (a & 7)\
    \ == 0 && (a & 9) == 0\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpefialilk.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let sqr = a * a;\n    if sqr % 3 == 0 {\n        return\
    \ true;\n    }\n    else if sqr < 0 {\n        return false;\n    }\n    else\
    \ {\n        false\n    }\n}\n\nfn main() {\n    let candidate = iscube;\n   \
    \ assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpyct44mqm.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a % a == a % a % a == a % a % a % a == a % a % a % a %\
    \ a == a % a % a % a % a % a == a % a % a % a % a % a % a == a % a % a % a % a\
    \ % a % a % a == a % a % a % a % a % a % a % a % a == a % a % a % a % a % a %\
    \ a % a % a % a == a % a % a % a % a % a % a % a % a % a % a == a % a % a % a\
    \ % a % a % a % a % a % a % a == a % a % a % a % a % a % a % a % a % a % a ==\
    \ a % a % a % a % a % a % a % a % a % a % a == a % a % a % a % a % a % a % a %\
    \ a % a % a % a == a % a % a % a % a % a % a % a % a % a % a % a == a % a % a\
    \ % a % a % a % a % a % a % a % a % a == a % a % a % a % a % a % a % a % a % a\
    \ % a % a == a % a % a % a % a % a % a % a % a % a % a % a == a % a % a % a %\
    \ a % a % a % a % a % a % a % a == a % a % a % a % a % a % a % a % a % a % a %\
    \ a == a % a % a % a % a % a % a % a % a % a % a % a == a % a % a % a % a % a\
    \ % a % a % a % a % a % a == a % a % a % a % a % a % a % a % a % a % a % a ==\
    \ a % a % a % a % a % a % a % a % a % a % a % a == a % a % a % a % a % a % a %\
    \ a % a % a % a % a == a % a % a % a % a % a % a % a % a % a % a % a % a == a\
    \ % a % a % a % a % a % a % a % a % a % a % a % a == a % a \n}\n\nfn main() {\n\
    \    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmpkdcmly_u.rs:18:11\n\
    \   |\n18 |     a % a == a % a % a == a % a % a % a == a % a % a % a % a == a\
    \ % a % a % a % a % a == a % a % a % a % a % a % a == a % a % a % a % a %...\n\
    \   |           ^^           ^^\n   |\nhelp: split the comparison into two\n \
    \  |\n18 |     a % a == a % a % a && a % a % a == a % a % a % a == a % a % a %\
    \ a % a == a % a % a % a % a % a == a % a % a % a % a % a % a == a % a % a % a\
    \ % a % a % a % a == a % a % a % a % a % a % a % a % a == a % a % a % a % a %\
    \ a % a % a % a % a == a % a % a % a % a % a % a % a % a % a % a == a % a % a\
    \ % a % a % a % a % a % a % a % a == a % a % a % a % a % a % a % a % a % a % a\
    \ == a % a % a % a % a % a % a % a % a % a % a == a % a % a % a % a % a % a %\
    \ a % a % a % a % a == a % a % a % a % a % a % a % a % a % a % a % a == a % a\
    \ % a % a % a % a % a % a % a % a % a % a == a % a % a % a % a % a % a % a % a\
    \ % a % a % a == a % a % a % a % a % a % a % a % a % a % a % a == a % a % a %\
    \ a % a % a % a % a % a % a % a % a == a % a % a % a % a % a % a % a % a % a %\
    \ a % a == a % a % a % a % a % a % a % a % a % a % a % a == a % a % a % a % a\
    \ % a % a % a % a % a % a % a == a % a % a % a % a % a % a % a % a % a % a % a\
    \ == a % a % a % a % a % a % a % a % a % a % a % a == a % a % a % a % a % a %\
    \ a % a % a % a % a % a == a % a % a % a % a % a % a % a % a % a % a % a % a ==\
    \ a % a % a % a % a % a % a % a % a % a % a % a % a == a % a \n   |          \
    \              ++++++++++++\n\nerror: comparison operators cannot be chained\n\
    \  --> /tmp/tmpkdcmly_u.rs:18:24\n   |\n18 |     a % a == a % a % a == a % a %\
    \ a % a == a % a % a % a % a == a % a % a % a % a % a == a % a % a % a % a % a\
    \ % a == a % a % a % a % a %...\n   |                        ^^              \
    \ ^^\n   |\nhelp: split the comparison into two\n   |\n18 |     a % a == a % a\
    \ % a == a % a % a % a && a % a % a % a == a % a % a % a % a == a % a % a % a\
    \ % a % a == a % a % a % a % a % a % a == a % a % a % a % a % a % a % a == a %\
    \ a % a % a % a % a % a % a % a == a % a % a % a % a % a % a % a % a % a ="
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a <= 0\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpzq5nqu7u.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a % 3 == 0 && a % 5 == 0\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpolw4fq3k.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    (a * a + a * a) * a == a * a // cubes\n}\n\nfn main()\
    \ {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpzsd50ldo.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut n = a;\n    loop {\n        let b = n % 60;\n\
    \        if b == 0 {\n            n /= 60;\n        } else if b == 60 {\n    \
    \        break;\n        } else {\n            return false;\n        }\n    }\n\
    \    n > 1\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpjcbuv1w1.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    if a <= 1 {\n        return false;\n    }\n    let cube\
    \ = a * a * a;\n    if a % a == 0 {\n        cube == a && (a * a != a);\n    }\n\
    \    else if a == 1 {\n        cube == a && (a * a != a);\n    }\n    else {\n\
    \        cube == a && (a * a != a) || (a * a != a * a);\n    }\n}\n\nfn main()\
    \ {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpp7icyhjn.rs:22:19\n   |\n\
    22 |       if a % a == 0 {\n   |  ___________________^\n23 | |         cube ==\
    \ a && (a * a != a);\n   | |                                  - help: remove this\
    \ semicolon\n24 | |     }\n   | |_____^ expected `bool`, found `()`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpp7icyhjn.rs:25:20\n   |\n25 |       else if\
    \ a == 1 {\n   |  ____________________^\n26 | |         cube == a && (a * a !=\
    \ a);\n   | |                                  - help: remove this semicolon\n\
    27 | |     }\n   | |_____^ expected `bool`, found `()`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpp7icyhjn.rs:28:10\n   |\n28 |       else {\n   |  __________^\n\
    29 | |         cube == a && (a * a != a) || (a * a != a * a);\n   | |        \
    \                                              - help: remove this semicolon\n\
    30 | |     }\n   | |_____^ expected `bool`, found `()`\n\nerror: aborting due\
    \ to 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == 1\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpqsm27bd4.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    debug_assert!(a != 0);\n    let n = &a;\n    debug_assert!((*n\
    \ & (*n)) != 0);\n    debug_assert!((*n & (*n)) != 0);\n    debug_assert!((*n\
    \ & (*n)) != 0);\n    debug_assert!((*n & (*n)) != 0);\n    (*n & (*n)) > 1\n\
    }\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpsna_sbd8.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    (a*a*a*a) == (a*a*a)\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmphtae7yql.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a >= 1 && a <= 4\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp96qnsaj_.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    match a {\n        0 => true,\n        1 => true,\n  \
    \      _ => a == (a / 3) * (a / 3) + (a / 5) * (a / 5) + (a / 7) * (a / 7),\n\
    \    }\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp2mq8f8vw.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let n = a*a*a*a\n    n % 36 == 0 && n % 36 == 0 && n %\
    \ 36 == 0 && n % 36 == 0 && n % 36 == 0\n}\n\nfn main() {\n    let candidate =\
    \ iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n\
    \    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n\
    \    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `n`\n  --> /tmp/tmpacvdao0e.rs:18:20\n   |\n\
    18 |     let n = a*a*a*a\n   |                    ^ help: add `;` here\n19 | \
    \    n % 36 == 0 && n % 36 == 0 && n % 36 == 0 && n % 36 == 0 && n % 36 == 0\n\
    \   |     - unexpected token\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a > 0 && a % 3 == 0 && a % 5 == 0\n}\n\nfn main() {\n\
    \    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpgeclcinl.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let x = a * a as isize;\n    (x == x * x)\n}\n\nfn main()\
    \ {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpzshe683w.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == a / a % a == a / a % a\n}\n\nfn main() {\n    let\
    \ candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmp71qvjiu1.rs:18:7\n\
    \   |\n18 |     a == a / a % a == a / a % a\n   |       ^^           ^^\n   |\n\
    help: split the comparison into two\n   |\n18 |     a == a / a % a && a / a %\
    \ a == a / a % a\n   |                    ++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp71qvjiu1.rs:18:23\n   |\n18 |     a == a / a % a == a /\
    \ a % a\n   |                       ^^^^^^^^^ expected `bool`, found `isize`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a >= 2 && a <= 9\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp8zie35kr.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == a && a >= 0 && a <= 4\n}\n\nfn main() {\n    let\
    \ candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpow5y4v8h.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    (a % 3 == 0) && (a % 5 == 0)\n}\n\nfn main() {\n    let\
    \ candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpspc92fvp.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    if a < 0 { return false };\n    if a == 1 {\n        return\
    \ true\n    };\n    if a == 2 {\n        return true\n    };\n    if a == 3 {\n\
    \        return true\n    };\n    if a == 4 {\n        return true\n    };\n \
    \   if a == 5 {\n        return true\n    };\n    if a == 6 {\n        return\
    \ true\n    };\n    if a == 7 {\n        return true\n    };\n    if a == 8 {\n\
    \        return true\n    };\n    if a == 9 {\n        return true\n    };\n \
    \   if a == 10 {\n        return true\n    };\n    if a == 11 {\n        return\
    \ true\n    };\n    if a == 12 {\n        return true\n    };\n    if a == 13\
    \ {\n        return true\n    };\n    if a == 14 {\n        return true\n    };\n\
    \    if a == 15 {\n        return true\n    };\n    if a == 16 {\n        return\
    \ true\n    };\n    if a == 17 {\n        return true\n    };\n    if a == 18\
    \ {\n        return true\n    };\n    if a == 19 {\n        return true\n    };\n\
    \    if a == 20 {\n        return true\n    };\n    if a == 21 {\n        return\
    \ true\n    };\n    if a == 22 {\n        return true\n    };\n    if a == 23\
    \ {\n        return true\n    };\n    if a == 24 {\n        return true\n    };\n\
    \    if a == 25 {\n        return true\n    };\n    if a == 26 {\n        return\
    \ true\n    };\n    if a == 27 {\n        return true\n    };\n    if a == 28\
    \ {\n        return true\n    };\n    if a == 29 {\n        return true\n    };\n\
    \    if a == 30 {\n        return true\n    };\n    if a == 31 {\n        return\
    \ true\n    };\n    if a == 32 {\n        return true\n    };\n    if a == 33\
    \ {\n        return true\n    };\n    if a == 34 {\n        return true\n    };\n\
    \    if a == 35 {\n        return true\n    };\n    if a == 36 {\n        return\
    \ true\n    };\n    if a == 37 {\n        return true\n    };\n    if a == 38\
    \ {\n        return true\n    };\n    if a == 39 {\n        return true\n    };\n\
    \    if a == 40 {\n        return true\n    };\n    if a == 41 {\n        return\
    \ true\n    };\n    if a == 42 {\n        return true\n    };\n    if a == 43\
    \ {\n        return true\n    };\n    if a == 44 {\n        return true\n    };\n\
    \    if a == 45 {\n        return true\n    };\n    if a == 46 {\n        return\
    \ true\n    };\n    if a == 47 {\n        return true\n    };\n    if a == 48\
    \ {\n        return true\n    };\n    if a == 49 {\n        return true\n    };\n\
    \    if a == 50 {\n        return true\n    };\n    if a == 51 {\n        return\
    \ true\n\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp6eq5azrq.rs:184:3\n\
    \    |\n17  | fn iscube(a: isize) -> bool {\n    |                           \
    \  - unclosed delimiter\n...\n169 |     if a == 51 {\n    |                - this\
    \ delimiter might not be properly closed...\n...\n172 | }\n    | - ...as it matches\
    \ this but it has different indentation\n...\n184 | }\n    |   ^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp6eq5azrq.rs:17:24\n   |\n17 | fn iscube(a: isize)\
    \ -> bool {\n   |    ------              ^^^^ expected `bool`, found `()`\n  \
    \ |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    if a == 0 {\n        return true;\n    }\n    let mut\
    \ count = 0;\n    let mut x = a;\n    while x * x != a && x < 256 {\n        count\
    \ += 1;\n        x *= x;\n    }\n    return count == 4;\n}\n\nfn main() {\n  \
    \  let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp125iro92.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    (a ** 3) % a == 0\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `{integer}` cannot be dereferenced\n  --> /tmp/tmpy3v15214.rs:18:9\n\
    \   |\n18 |     (a ** 3) % a == 0\n   |         ^^^\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0614`.\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let a = a % 4 == 0;\n    let b = a % 3 == 0;\n    let\
    \ c = a % 2 == 0;\n    a + b + c\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `bool` by `{integer}`\n  --> /tmp/tmpjmej4m71.rs:19:15\n\
    \   |\n19 |     let b = a % 3 == 0;\n   |             - ^ - {integer}\n   |  \
    \           |\n   |             bool\n\nerror[E0369]: cannot mod `bool` by `{integer}`\n\
    \  --> /tmp/tmpjmej4m71.rs:20:15\n   |\n20 |     let c = a % 2 == 0;\n   |   \
    \          - ^ - {integer}\n   |             |\n   |             bool\n\nerror[E0369]:\
    \ cannot add `bool` to `bool`\n  --> /tmp/tmpjmej4m71.rs:21:7\n   |\n21 |    \
    \ a + b + c\n   |     - ^ - bool\n   |     |\n   |     bool\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0369`.\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a ** 3 == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0614]: type `{integer}` cannot be dereferenced\n  --> /tmp/tmphh_9uc_2.rs:18:8\n\
    \   |\n18 |     a ** 3 == a\n   |        ^^^\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut i: isize = 1;\n    while i <= (a / i) {\n    \
    \    if ((a % i) == 0) {\n            return false;\n        }\n        i += 1;\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpczp2anwq.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n\ta >= 0 && a <= 8\n}\n\nfn main() {\n    let candidate =\
    \ iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n\
    \    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n\
    \    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp04q6x_fj.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    if a > 9 {\n        false\n    } else if a == 0 {\n  \
    \      true\n    } else {\n        let mut cube = a * a * a;\n        for n in\
    \ 1..3 {\n            cube = cube % b;\n            if cube == 0 {\n         \
    \       return false\n            }\n        }\n        return true\n    }\n}\n\
    \nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `b` in this scope\n  --> /tmp/tmp775_d720.rs:25:27\n\
    \   |\n25 |             cube = cube % b;\n   |                           ^ help:\
    \ a local variable with a similar name exists: `a`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut x = a;\n    loop {\n        if (x == 0) return\
    \ false;\n        if (x == 1) return true;\n        if (x*x*x == x) return true;\n\
    \        if (x*x*x%x == 0) return false;\n        x = x / 3;\n    }\n}\n\nfn main()\
    \ {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found keyword `return`\n  --> /tmp/tmpda6f94od.rs:20:21\n\
    \   |\n20 |         if (x == 0) return false;\n   |         --          ^^^^^^\
    \ expected `{`\n   |         |\n   |         this `if` expression has a condition,\
    \ but no block\n   |\nhelp: try placing this code inside a block\n   |\n20 | \
    \        if (x == 0) { return false };\n   |                     +           \
    \   +\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    (a as usize).is_power_of_two() && (a as usize).is_multiple_of(4)\n\
    }\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_multiple_of` found for type `usize` in\
    \ the current scope\n  --> /tmp/tmplkuod_wd.rs:18:52\n   |\n18 |     (a as usize).is_power_of_two()\
    \ && (a as usize).is_multiple_of(4)\n   |                                    \
    \                ^^^^^^^^^^^^^^ help: there is an associated function with a similar\
    \ name: `next_multiple_of`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == a &&\n    a == a &&\n    a == a &&\n    a == a &&\n\
    \    a == a &&\n    a == a &&\n    a == a &&\n    a == a &&\n    a == a &&\n \
    \   a == a &&\n    a == a &&\n    a == a &&\n    a == a &&\n    a == a &&\n  \
    \  a == a &&\n    a == a &&\n    a == a &&\n    a == a &&\n    a == a &&\n   \
    \ a == a &&\n    a == a &&\n    a == a &&\n    a == a &&\n    a == a &&\n    a\
    \ == a &&\n    a == a &&\n    a == a &&\n    a == a &&\n    a == a &&\n    a ==\
    \ a &&\n    a == a &&\n    a == a &&\n    a == a &&\n    a == a &&\n    a == a\
    \ &&\n    a == a &&\n    a == a &&\n    a == a &&\n    a == a &&\n    a == a &&\n\
    \    a == a &&\n    a == a &&\n    a == a &&\n    a == a &&\n    a == a &&\n \
    \   a == a &&\n    a == a &&\n    a == a &&\n    a == a &&\n    a == a &&\n  \
    \  a == a &&\n    a == a &&\n    a == a &&\n    a == a &&\n    a == a &&\n   \
    \ a == a &&\n    a == a &&\n    a == a &&\n    a == a &&\n    a == a &&\n    a\
    \ == a &&\n    a == a &&\n    a == a &&\n    a == a &&\n    a == a &&\n    a ==\
    \ a &&\n    a == a &&\n    a == a &&\n    a == a &&\n    a == a &&\n    a == a\
    \ &&\n    a == a &&\n    a == a &&\n    a == a &&\n    a == a &&\n    a == a &&\n\
    \    a == a &&\n    a == a &&\n    a == a &&\n    a == a &&\n    a == a &&\n \
    \   a == a &&\n    a == a &&\n    a == a &&\n    a == a &&\n    a == a &&\n  \
    \  a == a &&\n    a == a &&\n    a == a &&\n    a == a &&\n    a == a &&\n   \
    \ a == a &&\n    a == a &&\n    a == a &&\n    a == a &&\n    a == a &&\n    a\
    \ == a &&\n    a == a &&\n    a == a &&\n    a == a &&\n    a == a &&\n    a ==\
    \ a &&\n    a == \n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n   --> /tmp/tmp196gxigd.rs:121:1\n\
    \    |\n121 | }\n    | ^ expected expression\n\nerror: aborting due to previous\
    \ error\n\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    if a == 0 {\n        true\n    } else if a <= 1 {\n  \
    \      a == 1\n    } else if a <= 9 {\n        a == 6\n    } else if a <= 360\
    \ {\n        a == 25\n    } else if a <= 720 {\n        a == 60\n    } else {\n\
    \        a == 90\n    }\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmppj7amoqd.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a + a == a * a\n}\n\nfn main() {\n    let candidate =\
    \ iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n\
    \    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n\
    \    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp_rtrjv3f.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    square(a) == a * a\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `square` in this scope\n  --> /tmp/tmpqd62bxhx.rs:18:5\n\
    \   |\n18 |     square(a) == a * a\n   |     ^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a >= 0 && a <= 4 &&\n    a*a*a == 12 && a*(a + 1) == 12\n\
    }\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmptlpk5e7s.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut cube = Cube::new(a);\n    cube.cube.push(1);\n\
    \    cube.cube.push(2);\n    cube.cube.push(3);\n    cube.cube.push(4);\n    cube.cube.push(5);\n\
    \    cube.cube.push(6);\n    cube.cube.push(7);\n    cube.cube.push(8);\n    cube.cube.push(9);\n\
    \    cube.cube.push(10);\n    cube.cube.push(11);\n    cube.cube.push(12);\n \
    \   cube.cube.push(13);\n    cube.cube.push(14);\n    cube.cube.push(15);\n  \
    \  cube.cube.push(16);\n    cube.cube.push(17);\n    cube.cube.push(18);\n   \
    \ cube.cube.push(19);\n    cube.cube.push(20);\n    cube.cube.push(21);\n    cube.cube.push(22);\n\
    \    cube.cube.push(23);\n    cube.cube.push(24);\n    cube.cube.push(25);\n \
    \   cube.cube.push(26);\n    cube.cube.push(27);\n    cube.cube.push(28);\n  \
    \  cube.cube.push(29);\n    cube.cube.push(30);\n    cube.cube.push(31);\n   \
    \ cube.cube.push(32);\n    cube.cube.push(33);\n    cube.cube.push(34);\n    cube.cube.push(35);\n\
    \    cube.cube.push(36);\n    cube.cube.push(37);\n    cube.cube.push(38);\n \
    \   cube.cube.push(39);\n    cube.cube.push(40);\n    cube.cube.push(41);\n  \
    \  cube.cube.push(42);\n    cube.cube.push(43);\n    cube.cube.push(44);\n   \
    \ cube.cube.push(45);\n    cube.cube.push(46);\n    cube.cube.push(47);\n    cube.cube.push(48);\n\
    \    cube.cube.push(49);\n    cube.cube.push(50);\n    cube.cube.push(51);\n \
    \   cube.cube.push(52);\n    cube.cube.push(53);\n    cube.cube.push(54);\n  \
    \  cube.cube.push(55);\n    cube.cube.push(56);\n    cube.cube.push(57);\n   \
    \ cube.cube.push(58\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpkav5fnhr.rs:76:19\n\
    \   |\n17 | fn iscube(a: isize) -> bool {\n   |                             -\
    \ closing delimiter possibly meant for this\n...\n76 |     cube.cube.push(58\n\
    \   |                   ^ unclosed delimiter\n77 | }\n   | ^ mismatched closing\
    \ delimiter\n\nerror[E0433]: failed to resolve: use of undeclared type `Cube`\n\
    \  --> /tmp/tmpkav5fnhr.rs:18:20\n   |\n18 |     let mut cube = Cube::new(a);\n\
    \   |                    ^^^^ use of undeclared type `Cube`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == a &&\n    a == a * a &&\n    a == a * a * a\n}\n\n\
    fn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpj35ewful.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    match a % 3 {\n        0 => true,\n        1 => false,\n\
    \        _ => false,\n    }\n}\n\nfn main() {\n    let candidate = iscube;\n \
    \   assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n  \
    \  assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n  \
    \  assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpqird_ybw.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a % 4 == 0 && a % 4 == 0 && a % 4 == 0\n}\n\nfn main()\
    \ {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmplube8kqm.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a >= 0\n    && a * a == a\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpq7lhzgi_.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    (a*a*a*a > 0) || (a*a*a > 0)\n}\n\nfn main() {\n    let\
    \ candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpoe9488m_.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    (a & (a - 1)) == 0\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpyutov40j.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    (a % 3) == 0 && (a % 5) == 0\n}\n\nfn main() {\n    let\
    \ candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpl__5pdyq.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == cube(0)\n        || a == cube(1)\n        || a ==\
    \ cube(-1)\n        || a == cube(2)\n        || a == cube(3)\n        || a ==\
    \ cube(4)\n        || a == cube(5)\n        || a == cube(6)\n        || a == cube(7)\n\
    \        || a == cube(8)\n        || a == cube(9)\n        || a == cube(10)\n\
    \        || a == cube(11)\n        || a == cube(12)\n        || a == cube(13)\n\
    \        || a == cube(14)\n        || a == cube(15)\n        || a == cube(16)\n\
    \        || a == cube(17)\n        || a == cube(18)\n        || a == cube(19)\n\
    \        || a == cube(20)\n        || a == cube(21)\n        || a == cube(22)\n\
    \        || a == cube(23)\n        || a == cube(24)\n        || a == cube(25)\n\
    \        || a == cube(26)\n        || a == cube(27)\n        || a == cube(28)\n\
    \        || a == cube(29)\n        || a == cube(30)\n        || a == cube(31)\n\
    \        || a == cube(32)\n        || a == cube(33)\n        || a == cube(34)\n\
    \        || a == cube(35)\n        || a == cube(36)\n        || a == cube(37)\n\
    \        || a == cube(38)\n        || a == cube(39)\n        || a == cube(40)\n\
    \        || a == cube(41)\n        || a == cube(42)\n        || a == cube(43)\n\
    \        || a == cube(44)\n        || a == cube(45)\n        || a == cube(46)\n\
    \        || a == cube(47)\n        || a == cube(48)\n        || a == cube(49)\n\
    \        || a == cube(50)\n        || a == cube(51)\n        || a == cube(52)\n\
    \        || a == cube(53)\n        || a == cube(54)\n        || a == cube(55)\n\
    \        || a == cube(56)\n        || a == cube(57)\n        || a == cube(58)\n\
    \        || a == cube(59)\n        || a == cube(60)\n        || a == cube(61)\n\
    \        || a == cube(62)\n        || a == cube(63)\n        || a == cube(64)\n\
    \        || a == cube(65)\n        || a == cube(66)\n        || a == cube(67)\n\
    \        || a == \n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpbanah39e.rs:88:1\n\
    \   |\n88 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    (a as f64).is_integer()\n        && (a == 0 || a == 1\
    \ || a == 4 || a == 8 || a == 16 || a == 32 || a == 64 || a == 128)\n}\n\nfn main()\
    \ {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmpyv8objv1.rs:18:16\n   |\n18 |     (a as f64).is_integer()\n\
    \   |                ^^^^^^^^^^ method not found in `f64`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a.is_cube().unwrap_or(false)\n}\n\nfn main() {\n    let\
    \ candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_cube` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp6kh1u2vw.rs:18:7\n   |\n18 |     a.is_cube().unwrap_or(false)\n\
    \   |       ^^^^^^^ method not found in `isize`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a.is_power_of_2() && &(a - 1) == &(a * a - 1) / a\n}\n\
    \nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_power_of_2` found for type `isize` in\
    \ the current scope\n  --> /tmp/tmpnacx3xi0.rs:18:7\n   |\n18 |     a.is_power_of_2()\
    \ && &(a - 1) == &(a * a - 1) / a\n   |       ^^^^^^^^^^^^^ method not found in\
    \ `isize`\n\nerror[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpnacx3xi0.rs:18:35\n\
    \   |\n18 |     a.is_power_of_2() && &(a - 1) == &(a * a - 1) / a\n   |      \
    \                             ^^ no implementation for `&isize == isize`\n   |\n\
    \   = help: the trait `PartialEq<isize>` is not implemented for `&isize`\n   =\
    \ help: the following other types implement trait `PartialEq<Rhs>`:\n        \
    \     f32\n             f64\n             i128\n             i16\n           \
    \  i32\n             i64\n             i8\n             isize\n           and\
    \ 6 others\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a < 100 && a > 0\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp303xb38h.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a % a == 0\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpkqtiho76.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a.is_power_of_two() || a != 0\n}\n\nfn main() {\n    let\
    \ candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmpppq2rpwp.rs:18:7\n   |\n18 |     a.is_power_of_two()\
    \ || a != 0\n   |       ^^^^^^^^^^^^^^^ method not found in `isize`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a % 4 == 0 && (a % 64 == 0 || a % 64 == 1) || a % 8 ==\
    \ 0 && (a % 256 == 0 || a % 256 == 1)\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpmdmuvtu5.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    if a == 1 && a * a == a && a == a / a {\n        true\n\
    \    } else if a == 2 && (a * a) == a && (a * 2) == a / a {\n        true\n  \
    \  } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp2saxfth9.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == a && a > 0 && a < 64\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp9otkw5pl.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a >= 4 * (4 * a)\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp4y5rlgvr.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    debug_assert!(a > 0);\n    debug_assert!((a / 3) % 1 ==\
    \ 0);\n    debug_assert!((a / 15) % 1 == 0);\n    debug_assert!((a / 30) % 1 ==\
    \ 0);\n    debug_assert!((a / 45) % 1 == 0);\n    debug_assert!((a / 60) % 1 ==\
    \ 0);\n    debug_assert!((a / 75) % 1 == 0);\n    debug_assert!((a / 90) % 1 ==\
    \ 0);\n    debug_assert!((a / 105) % 1 == 0);\n    debug_assert!((a / 120) % 1\
    \ == 0);\n    debug_assert!((a / 135) % 1 == 0);\n    debug_assert!((a / 150)\
    \ % 1 == 0);\n    debug_assert!((a / 165) % 1 == 0);\n    debug_assert!((a / 180)\
    \ % 1 == 0);\n    debug_assert!((a / 195) % 1 == 0);\n    debug_assert!((a / 210)\
    \ % 1 == 0);\n    debug_assert!((a / 225) % 1 == 0);\n    debug_assert!((a / 240)\
    \ % 1 == 0);\n    debug_assert!((a / 255) % 1 == 0);\n    debug_assert!((a / 265)\
    \ % 1 == 0);\n    debug_assert!((a / 280) % 1 == 0);\n    debug_assert!((a / 295)\
    \ % 1 == 0);\n    debug_assert!((a / 310) % 1 == 0);\n    debug_assert!((a / 325)\
    \ % 1 == 0);\n    debug_assert!((a / 340) % 1 == 0);\n    debug_assert!((a / 345)\
    \ % 1 == 0);\n    debug_assert!((a / 360) % 1 == 0);\n    debug_assert!((a / 375)\
    \ % 1 == 0);\n    debug_assert!((a / 390) % 1 == 0);\n    debug_assert!((a / 405)\
    \ % 1 == 0);\n    debug_assert!((a / 420) % 1 == 0);\n    debug_assert!((a / 435)\
    \ % 1 == 0);\n    debug_assert!((a / 450) % 1 == 0);\n    debug_assert!((a / 465)\
    \ % 1 == 0);\n    debug_assert!((a / 480) % 1 == 0);\n    debug_assert!((a / 495)\
    \ % 1 == 0);\n    debug_assert!((a / 510) % 1 == 0);\n    debug_assert!((a / 525)\
    \ % 1 == 0);\n    debug_assert!((a / 540) % 1 == 0);\n    debug_assert!((a / 555)\
    \ % 1 == 0);\n    debug_assert!((a / 570) % 1 == 0);\n    debug_assert!((a / 595)\
    \ % 1 == 0);\n    debug_assert!((\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpn74ke80t.rs:60:19\n\
    \   |\n17 | fn iscube(a: isize) -> bool {\n   |                             -\
    \ closing delimiter possibly meant for this\n...\n60 |     debug_assert!((\n \
    \  |                   ^ unclosed delimiter\n61 | }\n   | ^ mismatched closing\
    \ delimiter\n\nerror[E0600]: cannot apply unary operator `!` to type `()`\n  -->\
    \ /tmp/tmpn74ke80t.rs:60:5\n   |\n60 | /     debug_assert!((\n61 | | }\n   | |_^\
    \ cannot apply unary operator `!`\n   |\n   = note: this error originates in the\
    \ macro `$crate::assert` (in Nightly builds, run with -Z macro-backtrace for more\
    \ info)\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn74ke80t.rs:60:5\n  \
    \ |\n60 | /     debug_assert!((\n61 | | }\n   | |_^ expected `bool`, found `()`\n\
    \   |\n   = note: this error originates in the macro `debug_assert` (in Nightly\
    \ builds, run with -Z macro-backtrace for more info)\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0308, E0600.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a.is_power_of_two() && a.pow(3).is_positive()\n}\n\nfn\
    \ main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmp34r3gcpy.rs:18:7\n   |\n18 |     a.is_power_of_two()\
    \ && a.pow(3).is_positive()\n   |       ^^^^^^^^^^^^^^^ method not found in `isize`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    if a < 0 || *a < 0 || *a % (*a) < 0 {\n        return\
    \ false;\n    }\n    if a == 1 {\n        return true;\n    }\n    if a == 2 {\n\
    \        return true;\n    }\n    if a == 4 {\n        return true;\n    }\n \
    \   if a == 8 {\n        return true;\n    }\n    if a == 16 {\n        return\
    \ true;\n    }\n    if a == 32 {\n        return true;\n    }\n    if a == 64\
    \ {\n        return true;\n    }\n    if a == 128 {\n        return true;\n  \
    \  }\n    if a == 256 {\n        return true;\n    }\n    if a == 512 {\n    \
    \    return true;\n    }\n    if a == 1024 {\n        return true;\n    }\n  \
    \  if a == 2048 {\n        return true;\n    }\n    if a == 4096 {\n        return\
    \ true;\n    }\n    if a == 8192 {\n        return true;\n    }\n    if a == 16384\
    \ {\n        return true;\n    }\n    if a == 32768 {\n        return true;\n\
    \    }\n    if a == 65536 {\n        return true;\n    }\n    if a == 131072 {\n\
    \        return true;\n    }\n    if a == 262144 {\n        return true;\n   \
    \ }\n    if a == 524288 {\n        return true;\n    }\n    if a == 1048572 {\n\
    \        return true;\n    }\n    if a == 2097152 {\n        return true;\n  \
    \  }\n    if a == 4194304 {\n        return true;\n    }\n    if a == 8388608\
    \ {\n        return true;\n    }\n    if a == 16777216 {\n        return true;\n\
    \    }\n    if a == 33554432 {\n        return true;\n    }\n    if a == 67108864\
    \ {\n        return true;\n    }\n    if a == 134217728 {\n        return true;\n\
    \    }\n    if a == 268435456 {\n        return true;\n    }\n    if a == 536870912\
    \ {\n        return true;\n    }\n    if a == 1073741824 {\n        return true;\n\
    \    }\n    if a == 2147483648 {\n        return true;\n    }\n    if a == 4294967294\
    \ {\n        return true;\n    }\n    if a == 671088640 {\n        return true;\n\
    \    }\n    if a == 1342177280 {\n        return true;\n    }\n    if a == 2684354560\
    \ {\n        return true;\n    }\n    if a == 5368709120 {\n        return true;\n\
    \    }\n    if a == 10737418240 {\n        return true;\n    }\n    if a == 21474836480\
    \ {\n        return true;\n    }\n    if a == 42949672920 {\n        return true;\n\
    \    }\n    if a == 6710886480 {\n        return true;\n    }\n    if a == 13421772800\
    \ {\n        return true;\n    }\n    if a == 26843545680 {\n        return true;\n\
    \    }\n    if a == 53687091200 {\n        return true;\n    }\n    if a == 10737418240\
    \ {\n        return true;\n    }\n    if a == 214748364\n}\n\nfn main() {\n  \
    \  let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `}`\n   --> /tmp/tmp1zkk_oub.rs:157:1\n    |\n\
    156 |     if a == 214748364\n    |     -- this `if` expression has a condition,\
    \ but no block\n157 | }\n    | ^ expected `{`\n\nerror[E0614]: type `isize` cannot\
    \ be dereferenced\n  --> /tmp/tmp1zkk_oub.rs:18:17\n   |\n18 |     if a < 0 ||\
    \ *a < 0 || *a % (*a) < 0 {\n   |                 ^^\n\nerror[E0614]: type `isize`\
    \ cannot be dereferenced\n  --> /tmp/tmp1zkk_oub.rs:18:27\n   |\n18 |     if a\
    \ < 0 || *a < 0 || *a % (*a) < 0 {\n   |                           ^^\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmp1zkk_oub.rs:18:32\n   |\n\
    18 |     if a < 0 || *a < 0 || *a % (*a) < 0 {\n   |                         \
    \       ^^^^\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a.is_some() && a == a.unwrap() * a.unwrap() * a.unwrap()\n\
    }\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_some` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpsig2yv3r.rs:18:7\n   |\n18 |     a.is_some() && a == a.unwrap()\
    \ * a.unwrap() * a.unwrap()\n   |       ^^^^^^^ method not found in `isize`\n\n\
    error[E0599]: no method named `unwrap` found for type `isize` in the current scope\n\
    \  --> /tmp/tmpsig2yv3r.rs:18:27\n   |\n18 |     a.is_some() && a == a.unwrap()\
    \ * a.unwrap() * a.unwrap()\n   |                           ^^^^^^ method not\
    \ found in `isize`\n\nerror[E0599]: no method named `unwrap` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmpsig2yv3r.rs:18:40\n   |\n18 |     a.is_some()\
    \ && a == a.unwrap() * a.unwrap() * a.unwrap()\n   |                         \
    \               ^^^^^^ method not found in `isize`\n\nerror[E0599]: no method\
    \ named `unwrap` found for type `isize` in the current scope\n  --> /tmp/tmpsig2yv3r.rs:18:53\n\
    \   |\n18 |     a.is_some() && a == a.unwrap() * a.unwrap() * a.unwrap()\n   |\
    \                                                     ^^^^^^ method not found\
    \ in `isize`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    (1..=a).all(|x| x % x == 0)\n}\n\nfn main() {\n    let\
    \ candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpd30kolqn.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a >= 0 && a < 24\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpocthdano.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    // Write your function here\n    return true;\n}\n\nfn\
    \ main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmptvue_5df.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == 1\n        || a == 3\n        || a == 5\n       \
    \ || a == 7\n        || a == 9\n        || a == 11\n        || a == 13\n     \
    \   || a == 15\n        || a == 17\n        || a == 19\n        || a == 21\n \
    \       || a == 23\n        || a == 25\n        || a == 27\n        || a == 29\n\
    \        || a == 31\n        || a == 33\n        || a == 35\n        || a == 37\n\
    \        || a == 39\n        || a == 41\n        || a == 43\n        || a == 45\n\
    \        || a == 47\n        || a == 49\n        || a == 51\n        || a == 53\n\
    \        || a == 55\n        || a == 57\n        || a == 59\n        || a == 61\n\
    \        || a == 63\n        || a == 65\n        || a == 67\n        || a == 69\n\
    \        || a == 71\n        || a == 73\n        || a == 75\n        || a == 77\n\
    \        || a == 79\n        || a == 81\n        || a == 83\n        || a == 85\n\
    \        || a == 87\n        || a == 89\n        || a == 91\n        || a == 93\n\
    \        || a == 95\n        || a == 97\n        || a == 99\n        || a == 101\n\
    \        || a == 103\n        || a == 105\n        || a == 107\n        || a ==\
    \ 109\n        || a == 111\n        || a == 113\n        || a == 115\n       \
    \ || a == 117\n        || a == 119\n        || a == 121\n        || a == 123\n\
    \        || a == 125\n        || a == 127\n        || a == 129\n        || a ==\
    \ 131\n        || a == 133\n        || a == 135\n        || a == 137\n       \
    \ || a == 139\n        || a == 141\n        || a == 143\n        || a == 145\n\
    \        || a == 147\n        || a == 149\n        || a == 151\n        || a ==\
    \ 153\n        || a == 155\n        || a == 157\n        || a == 159\n       \
    \ || a == 161\n        || a == 163\n        || a == 165\n        || a == 167\n\
    \        || a == 169\n        || a == 171\n        || a == 173\n        || a ==\
    \ 175\n        || a == 177\n        || a == 179\n        || a == 181\n       \
    \ || a == 183\n        || a == 185\n        || a == 187\n        || a == 189\n\
    \        || a == 191\n        || a == 193\n        || a == 195\n        || a ==\
    \ 197\n        || a == 199\n\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmprktduek7.rs:125:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a.is_square() && a % a == 0\n}\n\nfn main() {\n    let\
    \ candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_square` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmp4k3ilt0p.rs:18:7\n   |\n18 |     a.is_square()\
    \ && a % a == 0\n   |       ^^^^^^^^^ method not found in `isize`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a ** 3 == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0614]: type `{integer}` cannot be dereferenced\n  --> /tmp/tmphh_9uc_2.rs:18:8\n\
    \   |\n18 |     a ** 3 == a\n   |        ^^^\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    (a^a)^(a^a)^(a^a) == 0\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmps2rtcqlf.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    (1..=3*a).all(|&x| x*x == a)\n}\n\nfn main() {\n    let\
    \ candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpx_u6emy3.rs:18:20\n   |\n\
    18 |     (1..=3*a).all(|&x| x*x == a)\n   |                    ^--\n   |     \
    \               ||\n   |                    |expected due to this\n   |      \
    \              expected `isize`, found reference\n   |                    help:\
    \ did you mean `x`: `&isize`\n   |\n   = note:   expected type `isize`\n     \
    \      found reference `&_`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a % a == a && a * a <= a && (a * a + a) <= a && a * a\
    \ + a >= a\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmppxjfgve5.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    if a >= 64 {\n        true\n    } else {\n        a ==\
    \ ((a*a)*a)\n    }\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0t308s3x.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    cube_digit(a)\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `cube_digit` in this scope\n  --> /tmp/tmpe6igmbee.rs:18:5\n\
    \   |\n18 |     cube_digit(a)\n   |     ^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let cube = a * a + a * a + a * a >= 4;\n    cube && a\
    \ * a * a * a == a && a != 0\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpmwtjiftw.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == 1\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpqsm27bd4.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    (2 * a * a * a) > a\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp778vuq9k.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a >= 0 && a < 27\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpkcp0bx0r.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut v = a;\n    v *= v;\n    v *= v;\n    v *= v;\n\
    \    v != 0\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp13qq8os4.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a != 0 && (a & (a - 1)) == (a - 1)\n}\n\nfn main() {\n\
    \    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpn_azcolb.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a.is_power_of_two() || a % a == 0\n}\n\nfn main() {\n\
    \    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmpi539uncj.rs:18:7\n   |\n18 |     a.is_power_of_two()\
    \ || a % a == 0\n   |       ^^^^^^^^^^^^^^^ method not found in `isize`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    debug_assert!(-1 < a && a < 9, \"iscube expects an integer\
    \ between -1 and 9, inclusive\");\n\n    // We start by checking for squares.\n\
    \    if a * a * a == a && a % 4 == 0 {\n        return true;\n    }\n\n    //\
    \ We then iterate over the numbers 1..9 and check for\n    // the cube.\n    for\
    \ num in 1..9 {\n        if a * num * num == a && a % num == 0 {\n           \
    \ return true;\n        }\n    }\n\n    // If all checks have failed, return false.\n\
    \    false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpgpvh0ee0.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    if a < 1 {\n        return false;\n    }\n    let x =\
    \ a * a * a;\n    if x == 1 {\n        return true;\n    }\n    if x == a * a\
    \ {\n        return true;\n    }\n    if x == a * a * a * a {\n        return\
    \ true;\n    }\n    if x == a * a * a * a * a * a {\n        return true;\n  \
    \  }\n    if x == a * a * a * a * a * a * a * a {\n        return true;\n    }\n\
    \    if x == a * a * a * a * a * a * a * a * a || x == a * a * a * a * a * a *\
    \ a * a * a * a {\n        return true;\n    }\n    if x == a * a * a * a * a\
    \ * a * a * a * a * a * a || x == a * a * a * a * a * a * a * a * a * a * a *\
    \ a || x == a * a * a * a * a * a * a * a * a * a * a * a * a * a * a {\n    \
    \    return true;\n    }\n    if x == a * a * a * a * a * a * a * a * a * a *\
    \ a || x == a * a * a * a * a * a * a * a * a * a * a * a * a * a || x == a *\
    \ a * a * a * a * a * a * a * a * a * a * a * a * a * a || x == a * a * a * a\
    \ * a * a * a * a * a * a * a * a * a * a || x == a * a * a * a * a * a * a *\
    \ a * a * a * a * a * a || x == a * a * a * a * a * a * a * a * a * a * a {\n\
    \        return true;\n    }\n    if x == a * a * a * a * a * a * a * a * a *\
    \ a * a || x == a * a * a * a * a * a * a * a * a * a * a * a * a || x == a *\
    \ a * a * a * a * a * a * a * a * a * a * a || x == a * a * a * a * a * a * a\
    \ * a * a * a || x == a * a * a * a * a * a * a || x == a * a * a * a || x ==\
    \ a * a {\n        return true;\n    }\n    if x == a * a * a * a * a * a || x\
    \ == a * a * a * a || x == a * a {\n        return true;\n    }\n    if x == a\
    \ {\n        return true;\n    }\n    if x == 1 {\n        return true;\n    }\n\
    \    return false;\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpdt2rv8t6.rs:65:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    debug_assert!(a >= -a && a <= a);\n    debug_assert!(a\
    \ != 0);\n    debug_assert!(a != a);\n\n    a % a == 0\n}\n\nfn main() {\n   \
    \ let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''assertion failed: a != a'', /tmp/tmp93bp7y1s.rs:20:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    if a == 0 { true }\n    else {\n        let b = a;\n \
    \       if a == b { true }\n        else if b % a == 0 { true }\n        else\
    \ { false }\n    }\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpngll4ctg.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a % a == 0\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpkqtiho76.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    ((((a * a) * a) * a) < isize::MAX) as bool\n}\n\nfn main()\
    \ {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4p00nw73.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    if a == 1 {\n        return true;\n    }\n    if a ==\
    \ 2 {\n        return true;\n    }\n    if a == 3 {\n        return true;\n  \
    \  }\n    if a == 4 {\n        return true;\n    }\n    if a == 5 {\n        return\
    \ true;\n    }\n    if a == 6 {\n        return true;\n    }\n    if a == 7 {\n\
    \        return true;\n    }\n    if a == 8 {\n        return true;\n    }\n \
    \   if a == 9 {\n        return true;\n    }\n    if a == 10 {\n        return\
    \ true;\n    }\n    if a == 11 {\n        return true;\n    }\n    if a == 12\
    \ {\n        return true;\n    }\n    if a == 13 {\n        return true;\n   \
    \ }\n    if a == 14 {\n        return true;\n    }\n    if a == 15 {\n       \
    \ return true;\n    }\n    if a == 16 {\n        return true;\n    }\n    if a\
    \ == 17 {\n        return true;\n    }\n    if a == 18 {\n        return true;\n\
    \    }\n    if a == 19 {\n        return true;\n    }\n    if a == 20 {\n    \
    \    return true;\n    }\n    if a == 21 {\n        return true;\n    }\n    if\
    \ a == 22 {\n        return true;\n    }\n    if a == 23 {\n        return true;\n\
    \    }\n    if a == 24 {\n        return true;\n    }\n    if a == 25 {\n    \
    \    return true;\n    }\n    if a == 26 {\n        return true;\n    }\n    if\
    \ a == 27 {\n        return true;\n    }\n    if a == 28 {\n        return true;\n\
    \    }\n    if a == 29 {\n        return true;\n    }\n    if a == 30 {\n    \
    \    return true;\n    }\n    if a == 31 {\n        return true;\n    }\n    if\
    \ a == 32 {\n        return true;\n    }\n    if a == 33 {\n        return true;\n\
    \    }\n    if a == 34 {\n        return true;\n    }\n    if a == 35 {\n    \
    \    return true;\n    }\n    if a == 36 {\n        return true;\n    }\n    if\
    \ a == 37 {\n        return true;\n    }\n    if a == 38 {\n        return true;\n\
    \    }\n    if a == 39 {\n        return true;\n    }\n    if a == 40 {\n    \
    \    return true;\n    }\n    if a == 41 {\n        return true;\n    }\n    if\
    \ a == 42 {\n        return true;\n    }\n    if a == 43 {\n        return true;\n\
    \    }\n    if a == 44 {\n        return true;\n    }\n    if a == 45 {\n    \
    \    return true;\n    }\n    if a == 46 {\n        return true;\n    }\n    if\
    \ a == 47 {\n        return true;\n    }\n    if a == 48 {\n        return true;\n\
    \    }\n    if a == 49 {\n        return true;\n    }\n    if a == 50 {\n    \
    \    return true;\n    }\n    if a == 51 {\n        return true;\n    }\n    if\
    \ a == 52 {\n        return true;\n    }\n    if a == 53 {\n        return true;\n\
    \    }\n    if a == 54 {\n        return true;\n    }\n    if a == 55 {\n    \
    \    return true;\n    }\n    if a == 56 {\n        return true;\n    }\n    if\
    \ a == 57 {\n        return true;\n    }\n    if a == 58\n}\n\nfn main() {\n \
    \   let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `}`\n   --> /tmp/tmpe_2_8qgk.rs:190:1\n    |\n\
    189 |     if a == 58\n    |     -- this `if` expression has a condition, but no\
    \ block\n190 | }\n    | ^ expected `{`\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    (a % 2) == 0\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp8x9bf1d9.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a % a == 0\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpkqtiho76.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    if a == 0 { true }\n    else if a == 1 { true }\n    else\
    \ if a == 2 { true }\n    else if a == 3 { true }\n    else if a == 4 { true }\n\
    \    else if a == 5 { true }\n    else if a == 6 { true }\n    else if a == 7\
    \ { true }\n    else if a == 8 { true }\n    else if a == 9 { true }\n    else\
    \ if a == 10 { true }\n    else if a == 11 { true }\n    else if a == 12 { true\
    \ }\n    else if a == 13 { true }\n    else if a == 14 { true }\n    else if a\
    \ == 15 { true }\n    else if a == 16 { true }\n    else if a == 17 { true }\n\
    \    else if a == 18 { true }\n    else if a == 19 { true }\n    else if a ==\
    \ 20 { true }\n    else if a == 21 { true }\n    else if a == 22 { true }\n  \
    \  else if a == 23 { true }\n    else if a == 24 { true }\n    else if a == 25\
    \ { true }\n    else if a == 26 { true }\n    else if a == 27 { true }\n    else\
    \ if a == 28 { true }\n    else if a == 29 { true }\n    else if a == 30 { true\
    \ }\n    else if a == 31 { true }\n    else if a == 32 { true }\n    else if a\
    \ == 33 { true }\n    else if a == 34 { true }\n    else if a == 35 { true }\n\
    \    else if a == 36 { true }\n    else if a == 37 { true }\n    else if a ==\
    \ 38 { true }\n    else if a == 39 { true }\n    else if a == 40 { true }\n  \
    \  else if a == 41 { true }\n    else if a == 42 { true }\n    else if a == 43\
    \ { true }\n    else if a == 44 { true }\n    else if a == 45 { true }\n    else\
    \ if a == 46 { true }\n    else if a == 47 { true }\n    else if a == 48 { true\
    \ }\n    else if a == 49 { true }\n    else if a == 50 { true }\n    else if a\
    \ == 51 { true }\n    else if a == 52 { true }\n    else if a == 53 { true }\n\
    \    else if a == 54 { true }\n    else if a == 55\n}\n\nfn main() {\n    let\
    \ candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `}`\n  --> /tmp/tmpanta0yu7.rs:74:1\n   |\n\
    73 |     else if a == 55\n   |          -- this `if` expression has a condition,\
    \ but no block\n74 | }\n   | ^ expected `{`\n\nerror: aborting due to previous\
    \ error\n\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a != 0\n        && (a - 1) == (a - 1) * (a - 1) * (a -\
    \ 1)\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpyifvl4w1.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    (a % 8 == 0) && !(a % 4 == 0)\n}\n\nfn main() {\n    let\
    \ candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpxf84b2ff.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a % a == 0 && a != 1\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpsu1ft6bq.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976101
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a ** 3 == a && a % 4 == 0\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `{integer}` cannot be dereferenced\n  --> /tmp/tmp2xishwj1.rs:18:8\n\
    \   |\n18 |     a ** 3 == a && a % 4 == 0\n   |        ^^^\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0614`.\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == 0 || a == 1 || a == 4 || a == 9 || a == 16 || a ==\
    \ 25 || a == 36 || a == 49 || a == 64\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpv9q5ksiu.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976101
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a.is_power_of_2()\n        && is_cube_power_of_two(&a)\n\
    }\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_cube_power_of_two` in this scope\n\
    \  --> /tmp/tmp5wld6qw7.rs:19:12\n   |\n19 |         && is_cube_power_of_two(&a)\n\
    \   |            ^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0599]:\
    \ no method named `is_power_of_2` found for type `isize` in the current scope\n\
    \  --> /tmp/tmp5wld6qw7.rs:18:7\n   |\n18 |     a.is_power_of_2()\n   |      \
    \ ^^^^^^^^^^^^^ method not found in `isize`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == a && a * a == a * a\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp_fduvtyz.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976101
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    cube_number(a).is_some()\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `cube_number` in this scope\n  --> /tmp/tmpzve4fb6y.rs:18:5\n\
    \   |\n18 |     cube_number(a).is_some()\n   |     ^^^^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    (a ** 3) % a == 0\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `{integer}` cannot be dereferenced\n  --> /tmp/tmpy3v15214.rs:18:9\n\
    \   |\n18 |     (a ** 3) % a == 0\n   |         ^^^\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0614`.\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    debug_assert!(a >= 0);\n    a != 0 && a / a == a * a\n\
    }\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''assertion failed: a >= 0'', /tmp/tmppcvv_k5n.rs:18:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976101
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    (a*a == a) && (a*a == 2*a) && (a*a == 3)\n}\n\nfn main()\
    \ {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp2oayv_59.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976101
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    (a / 4) * (a / 4) == a\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpra__iaui.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976101
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a % a == 0 && a >= 1 && a <= 8\n}\n\nfn main() {\n   \
    \ let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpawcgglcr.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976101
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a >= 1 && a <= 64 \n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpjte5v8_e.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976101
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    if a == 1 {\n        return true;\n    } else if a ==\
    \ 2 {\n        return false;\n    } else if a == 3 {\n        return true;\n \
    \   } else if a == 4 {\n        return false;\n    } else if a == 5 {\n      \
    \  return true;\n    } else if a == 6 {\n        return false;\n    } else if\
    \ a == 7 {\n        return true;\n    } else if a == 8 {\n        return false;\n\
    \    } else if a == 9 {\n        return true;\n    } else if a == 10 {\n     \
    \   return false;\n    } else if a == 11 {\n        return true;\n    } else if\
    \ a == 12 {\n        return false;\n    } else if a == 13 {\n        return true;\n\
    \    } else if a == 14 {\n        return false;\n    } else if a == 15 {\n   \
    \     return true;\n    } else if a == 16 {\n        return false;\n    } else\
    \ if a == 17 {\n        return true;\n    } else if a == 18 {\n        return\
    \ false;\n    } else if a == 19 {\n        return true;\n    } else if a == 20\
    \ {\n        return false;\n    } else if a == 21 {\n        return true;\n  \
    \  } else if a == 22 {\n        return false;\n    } else if a == 23 {\n     \
    \   return true;\n    } else if a == 24 {\n        return false;\n    } else if\
    \ a == 25 {\n        return true;\n    } else if a == 26 {\n        return false;\n\
    \    } else if a == 27 {\n        return true;\n    } else if a == 28 {\n    \
    \    return false;\n    } else if a == 29 {\n        return true;\n    } else\
    \ if a == 30 {\n        return false;\n    } else if a == 31 {\n        return\
    \ true;\n    } else if a == 32 {\n        return false;\n    } else if a == 33\
    \ {\n        return true;\n    } else if a == 34 {\n        return false;\n  \
    \  } else if a == 35 {\n        return true;\n    } else if a == 36 {\n      \
    \  return false;\n    } else if a == 37 {\n        return true;\n    } else if\
    \ a == 38 {\n        return false;\n    } else if a == 39 {\n        return true;\n\
    \    } else if a == 40 {\n        return false;\n    } else if a == 41 {\n   \
    \     return true;\n    } else if a == 42 {\n        return false;\n    } else\
    \ if a == 43 {\n        return true;\n    } else if a == 44 {\n        return\
    \ false;\n    } else if a == 45 {\n        return true;\n    } else if a == 46\
    \ {\n        return false;\n    } else if a == 47 {\n        return true;\n  \
    \  } else if a == 48 {\n        return false;\n    } else if a == 49 {\n     \
    \   return true;\n    } else if a == 50 {\n        return false;\n    } else if\
    \ a == 51 {\n        return true;\n    } else if a == 52 {\n        return false;\n\
    \    } else if a == 53 {\n        return true;\n    } else if a == 54 {\n    \
    \    return false;\n    } else if a == 55 {\n        return true;\n    } else\
    \ if a == 56 {\n        return false;\n    } else if a == 57 {\n        return\
    \ true;\n    } else if a == 58\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `}`\n   --> /tmp/tmpba6knogf.rs:133:1\n    |\n\
    132 |     } else if a == 58\n    |            -- this `if` expression has a condition,\
    \ but no block\n133 | }\n    | ^ expected `{`\n\nerror: aborting due to previous\
    \ error\n\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    if a == 0 {\n        return true;\n    }\n    let mut\
    \ m = a * a + a * a;\n    let mut r = 1;\n    while m > r {\n        if m % a\
    \ == 0 || m % a == a {\n            return false;\n        }\n        r *= a;\n\
    \    }\n    return true;\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpqlvr38p7.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976101
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    true\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp86jalxby.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976040
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a >= 3 && a < 9\n}\n\nfn main() {\n    let candidate =\
    \ iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n\
    \    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n\
    \    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpym9p8j2y.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976101
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a.is_uint() && a % a == 0\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_uint` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpq_pz106w.rs:18:7\n   |\n18 |     a.is_uint() && a % a ==\
    \ 0\n   |       ^^^^^^^ method not found in `isize`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    if a == 1 {\n        return true;\n    }\n    let mut\
    \ i = 1;\n    let mut c = 1;\n    while i * i < a {\n        if a % i == 0 &&\
    \ a / i != i {\n            c += 1;\n        }\n        i += 1;\n    }\n    if\
    \ c == a * c {\n        return true;\n    }\n    return false;\n}\n\nfn main()\
    \ {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpgwlxzfn0.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976101
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a >= -1 && a <= 18\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpc56yy9co.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976101
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a >= 1 && a <= 63 && a % 2 == 0\n}\n\nfn main() {\n  \
    \  let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpl7c7qiu5.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976101
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    match (a % Cube, a) {\n        (Cube::One, a) => true,\n\
    \        (Cube::Zero, a) => a == 0,\n        (Cube::Multiple(mul), a) => iscube(a\
    \ * mul),\n        _ => false,\n    }\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Cube`\n  --> /tmp/tmp9zfx3efn.rs:19:10\n\
    \   |\n19 |         (Cube::One, a) => true,\n   |          ^^^^ use of undeclared\
    \ type `Cube`\n\nerror[E0433]: failed to resolve: use of undeclared type `Cube`\n\
    \  --> /tmp/tmp9zfx3efn.rs:20:10\n   |\n20 |         (Cube::Zero, a) => a == 0,\n\
    \   |          ^^^^ use of undeclared type `Cube`\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `Cube`\n  --> /tmp/tmp9zfx3efn.rs:21:10\n   |\n21 | \
    \        (Cube::Multiple(mul), a) => iscube(a * mul),\n   |          ^^^^ use\
    \ of undeclared type `Cube`\n\nerror[E0425]: cannot find value `Cube` in this\
    \ scope\n  --> /tmp/tmp9zfx3efn.rs:18:16\n   |\n18 |     match (a % Cube, a) {\n\
    \   |                ^^^^ not found in this scope\n\nerror: aborting due to 4\
    \ previous errors\n\nSome errors have detailed explanations: E0425, E0433.\nFor\
    \ more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    (a**3) == (Cube::new(a))\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Cube`\n  --> /tmp/tmp6drnyc20.rs:18:16\n\
    \   |\n18 |     (a**3) == (Cube::new(a))\n   |                ^^^^ use of undeclared\
    \ type `Cube`\n\nerror[E0614]: type `{integer}` cannot be dereferenced\n  -->\
    \ /tmp/tmp6drnyc20.rs:18:8\n   |\n18 |     (a**3) == (Cube::new(a))\n   |    \
    \    ^^\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0433, E0614.\nFor more information about an error, try `rustc\
    \ --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    (a == 1) || (a == 2) || (a == 3) || (a == 4) || (a ==\
    \ 5) || (a == 6) || (a == 7) \n        || (a == 8) || (a == 9) || (a == 10) ||\
    \ (a == 11) || (a == 12) || (a == 13) \n        || (a == 14) || (a == 15) || (a\
    \ == 16) || (a == 17) || (a == 18) || (a == 19) \n        || (a == 20) || (a ==\
    \ 21) || (a == 22) || (a == 23) || (a == 24) || (a == 25) \n        || (a == 26)\
    \ || (a == 27) || (a == 28) || (a == 29) || (a == 30) || (a == 31)\n}\n\nfn main()\
    \ {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp3zuwgjak.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976101
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == 1 || a % a == 0\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp7hflc7ju.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976101
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a + a >= 3 * a + 2 * a \n        && a + a >= 3 * a + 1\n\
    \        && a + a >= 2 * a + 1\n        && a + a >= 1\n}\n\nfn main() {\n    let\
    \ candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpkbh32f7y.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976101
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a >= 0 && a <= 18 && a == cubed[a]\n}\n\nfn main() {\n\
    \    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `cubed` in this scope\n  --> /tmp/tmpx5lrcate.rs:18:31\n\
    \   |\n18 |     a >= 0 && a <= 18 && a == cubed[a]\n   |                     \
    \          ^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976101
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    if a == 1 {\n        return true;\n    }\n\n    if a ==\
    \ 2 {\n        return true;\n    }\n\n    if a == 3 {\n        return true;\n\
    \    }\n\n    if a == 4 {\n        return true;\n    }\n\n    if a == 5 {\n  \
    \      return true;\n    }\n\n    if a == 6 {\n        return true;\n    }\n\n\
    \    if a == 7 {\n        return true;\n    }\n\n    if a == 8 {\n        return\
    \ true;\n    }\n\n    if a == 9 {\n        return true;\n    }\n\n    if a ==\
    \ 10 {\n        return true;\n    }\n\n    if a == 11 {\n        return true;\n\
    \    }\n\n    if a == 12 {\n        return true;\n    }\n\n    if a == 13 {\n\
    \        return true;\n    }\n\n    if a == 14 {\n        return true;\n    }\n\
    \n    if a == 15 {\n        return true;\n    }\n\n    if a == 16 {\n        return\
    \ true;\n    }\n\n    if a == 17 {\n        return true;\n    }\n\n    if a ==\
    \ 18 {\n        return true;\n    }\n\n    if a == 19 {\n        return true;\n\
    \    }\n\n    if a == 20 {\n        return true;\n    }\n\n    if a == 21 {\n\
    \        return true;\n    }\n\n    if a == 22 {\n        return true;\n    }\n\
    \n    if a == 23 {\n        return true;\n    }\n\n    if a == 24 {\n        return\
    \ true;\n    }\n\n    if a == 25 {\n        return true;\n    }\n\n    if a ==\
    \ 26 {\n        return true;\n    }\n\n    if a == 27 {\n        return true;\n\
    \    }\n\n    if a == 28 {\n        return true;\n    }\n\n    if a == 29 {\n\
    \        return true;\n    }\n\n    if a == 30 {\n        return true;\n    }\n\
    \n    if a == 31 {\n        return true;\n    }\n\n    if a == 32 {\n        return\
    \ true;\n    }\n\n    if a == 33 {\n        return true;\n    }\n\n    if a ==\
    \ 34 {\n        return true;\n    }\n\n    if a == 35 {\n        return true;\n\
    \    }\n\n    if a == 36 {\n        return true;\n    }\n\n    if a == 37 {\n\
    \        return true;\n    }\n\n    if a == 38 {\n        return true;\n    }\n\
    \n    if a == 39 {\n        return true;\n    }\n\n    if a == 40 {\n        return\
    \ true;\n    }\n\n    if a == 41 {\n        return true;\n    }\n\n    if a ==\
    \ 42 {\n        return true;\n    }\n\n    if a == 43 {\n        return true;\n\
    \    }\n\n    if a == 44 {\n        return true;\n    }\n\n    if a == 45 {\n\
    \        return true;\n    }\n\n    if a == 46 {\n        return true;\n    }\n\
    \n    if a == 47 {\n        return true;\n    }\n\n    if a == 48 {\n        return\
    \ true;\n    }\n\n    if a == 49 {\n        return true;\n    }\n\n    if a ==\
    \ 50 {\n        return true;\n    }\n\n    if a == 51 {\n        return true;\n\
    \    }\n\n    if a == 52 {\n        return true;\n    }\n\n    if a == 53 {\n\
    \        return true;\n    }\n\n    if a == 54 {\n        return true;\n    }\n\
    \n    if a == 55 {\n        return true;\n    }\n\n    if a == 56 {\n        return\
    \ true;\n    }\n\n    if a == 57 {\n        return true;\n    }\n\n    if a ==\
    \ 58\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `}`\n   --> /tmp/tmpvfg121_d.rs:247:1\n    |\n\
    246 |     if a == 58\n    |     -- this `if` expression has a condition, but no\
    \ block\n247 | }\n    | ^ expected `{`\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659976101
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a.is_power_of_two() && a.abs() % 4 == 0\n}\n\nfn main()\
    \ {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmpft8h56r5.rs:18:7\n   |\n18 |     a.is_power_of_two()\
    \ && a.abs() % 4 == 0\n   |       ^^^^^^^^^^^^^^^ method not found in `isize`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976101
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    (a % 3) == 0 && (a % 5) == 0\n}\n\nfn main() {\n    let\
    \ candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpl__5pdyq.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == 1\n        || a == 3\n        || a == 5\n       \
    \ || a == 7\n        || a == 9\n        || a == 11\n        || a == 13\n     \
    \   || a == 15\n        || a == 17\n        || a == 19\n}\n\nfn main() {\n   \
    \ let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmppalzr7cl.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976101
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a**3 == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0614]: type `{integer}` cannot be dereferenced\n  --> /tmp/tmpjak3i01y.rs:18:7\n\
    \   |\n18 |     a**3 == a\n   |       ^^\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659976101
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    debug_assert_ne!(a, 0);\n    debug_assert_ne!(a, 1);\n\
    \    debug_assert_ne!(a, 4);\n    debug_assert_ne!(a, 9);\n    debug_assert_ne!(a,\
    \ 16);\n    debug_assert_ne!(a, 25);\n    debug_assert_ne!(a, 36);\n    debug_assert_ne!(a,\
    \ 49);\n    debug_assert_ne!(a, 64);\n    debug_assert_ne!(a, 81);\n    debug_assert_ne!(a,\
    \ 100);\n    debug_assert_ne!(a, 125);\n    debug_assert_ne!(a, 144);\n    debug_assert_ne!(a,\
    \ 169);\n    debug_assert_ne!(a, 196);\n    debug_assert_ne!(a, 225);\n    debug_assert_ne!(a,\
    \ 256);\n    debug_assert_ne!(a, 312);\n    debug_assert_ne!(a, 352);\n    debug_assert_ne!(a,\
    \ 400);\n    debug_assert_ne!(a, 465);\n    debug_assert_ne!(a, 536);\n    debug_assert_ne!(a,\
    \ 602);\n    debug_assert_ne!(a, 676);\n    debug_assert_ne!(a, 740);\n    debug_assert_ne!(a,\
    \ 810);\n    debug_assert_ne!(a, 878);\n    debug_assert_ne!(a, 948);\n    debug_assert_ne!(a,\
    \ 1020);\n    debug_assert_ne!(a, 1080);\n    debug_assert_ne!(a, 1155);\n   \
    \ debug_assert_ne!(a, 1232);\n    debug_assert_ne!(a, 1305);\n    debug_assert_ne!(a,\
    \ 1388);\n    debug_assert_ne!(a, 1470);\n    debug_assert_ne!(a, 1560);\n   \
    \ debug_assert_ne!(a, 1650);\n    debug_assert_ne!(a, 1744);\n    debug_assert_ne!(a,\
    \ 1836);\n    debug_assert_ne!(a, 1928);\n    debug_assert_ne!(a, 2029);\n   \
    \ debug_assert_ne!(a, 2113);\n    debug_assert_ne!(a, 2207);\n    debug_assert_ne!(a,\
    \ 2299);\n    debug_assert_ne!(a, 2373);\n    debug_assert_ne!(a, 2457);\n   \
    \ debug_assert_ne!(a, 2539);\n    debug_assert_ne!(a, 2623);\n    debug_assert_ne!(a,\
    \ 2703);\n    debug_assert_ne!(a, 2797);\n    debug_assert_ne!(a, 2879);\n   \
    \ debug_assert_ne!(a, 2955);\n    debug_assert_ne!(a, 3031);\n    debug_assert_ne!(a,\
    \ 3109);\n    debug_assert_ne!(a, 3185);\n    debug_assert_\n}\n\nfn main() {\n\
    \    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `debug_assert_` in this scope\n  --> /tmp/tmpdkoqww34.rs:73:5\n\
    \   |\n73 |     debug_assert_\n   |     ^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976101
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    if a == 0 {\n        return true;\n    }\n    for i in\
    \ 0..3 {\n        if a % i == 0 {\n            return false;\n        }\n    }\n\
    \    return true;\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmp8_2z5k2i.rs:22:12

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976101
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    (a % 12) == 0 && (a % 16) == 0 && (a % 24) == 0 && (a\
    \ % 36) == 0\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpi49xjyd7.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976101
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    ((((a / 3) % 3) == 0) && a == ((a / 3) * 3))\n}\n\nfn\
    \ main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpdipfpspv.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976101
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    use std::cmp::{Ord, Ordering, PartialOrd, PartialOrdering};\n\
    \    fn is_pow2(a: usize) -> bool {\n        if a < 2 {\n            a == 1\n\
    \        } else {\n            a & (a - 1) == 0\n        }\n    }\n\n    a <=\
    \ 1 || a == 0 || is_pow2(a)\n}\n\nfn main() {\n    let candidate = iscube;\n \
    \   assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n  \
    \  assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n  \
    \  assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0432]: unresolved import `std::cmp::PartialOrdering`\n  --> /tmp/tmpwi7w6rm3.rs:18:47\n\
    \   |\n18 |     use std::cmp::{Ord, Ordering, PartialOrd, PartialOrdering};\n\
    \   |                                               ^^^^^^^^^^^^^^^\n   |    \
    \                                           |\n   |                          \
    \                     no `PartialOrdering` in `cmp`\n   |                    \
    \                           help: a similar name exists in the module: `PartialOrd`\n\
    \nwarning: unused imports: `Ord`, `Ordering`, `PartialOrd`\n  --> /tmp/tmpwi7w6rm3.rs:18:20\n\
    \   |\n18 |     use std::cmp::{Ord, Ordering, PartialOrd, PartialOrdering};\n\
    \   |                    ^^^  ^^^^^^^^  ^^^^^^^^^^\n   |\n   = note: `#[warn(unused_imports)]`\
    \ on by default\n\nwarning: the item `Ord` is imported redundantly\n   --> /tmp/tmpwi7w6rm3.rs:18:20\n\
    \    |\n18  |     use std::cmp::{Ord, Ordering, PartialOrd, PartialOrdering};\n\
    \    |                    ^^^\n\nwarning: the item `PartialOrd` is imported redundantly\n\
    \   --> /tmp/tmpwi7w6rm3.rs:18:35\n    |\n18  |     use std::cmp::{Ord, Ordering,\
    \ PartialOrd, PartialOrdering};\n    |                                   ^^^^^^^^^^\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpwi7w6rm3.rs:27:33\n   |\n27 |\
    \     a <= 1 || a == 0 || is_pow2(a)\n   |                                 ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n27 |     a <= 1 || a ==\
    \ 0 || is_pow2(a.try_into().unwrap())\n   |                                  ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nSome errors\
    \ have detailed explanations: E0308, E0432.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976101
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    debug_assert!((a % 2) == 0);\n    a >= 1 && a <= 180;\n\
    }\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7hc7_0lt.rs:17:24\n   |\n\
    17 | fn iscube(a: isize) -> bool {\n   |    ------              ^^^^ expected\
    \ `bool`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n18 |     debug_assert!((a % 2) == 0);\n19 |\
    \     a >= 1 && a <= 180;\n   |                       - help: remove this semicolon\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976101
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a <= 0\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpzq5nqu7u.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976100
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a >= -3 && a < 6\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpb8rfkxby.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976101
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    (a & 1) == 0 && (a & 3) == 0 && (a & 5) == 0 && (a & 7)\
    \ == 0 && (a & 9) == 0 && (a & 13) == 0 &&\n    (a & 17) == 0 && (a & 19) == 0\
    \ && (a & 23) == 0 && (a & 29) == 0 && (a & 31) == 0 && (a & 37) == 0 &&\n   \
    \ (a & 41) == 0 && (a & 43) == 0 && (a & 47) == 0 && (a & 49) == 0 && (a & 53)\
    \ == 0 && (a & 57) == 0 &&\n    (a & 61) == 0 && (a & 63) == 0 && (a & 67) ==\
    \ 0 && (a & 69) == 0 && (a & 71) == 0 && (a & 73) == 0 &&\n    (a & 79) == 0 &&\
    \ (a & 83) == 0 && (a & 89) == 0 && (a & 97) == 0 && (a & 101) == 0 && (a & 103)\
    \ == 0 &&\n    (a & 107) == 0 && (a & 109) == 0 && (a & 113) == 0 && (a & 127)\
    \ == 0 && (a & 131) == 0 && (a & 193) == 0 &&\n    (a & 197) == 0 && (a & 199)\
    \ == 0 && (a & 201) == 0 && (a & 207) == 0 && (a & 209) == 0 && (a & 211) == 0\
    \ &&\n    (a & 213) == 0 && (a & 217) == 0 && (a & 223) == 0 && (a & 227) == 0\
    \ && (a & 229) == 0 && (a & 231) == 0 &&\n    (a & 233) == 0 && (a & 237) == 0\
    \ && (a & 239) == 0 && (a & 241) == 0 && (a & 243) == 0 && (a & 247) == 0 &&\n\
    \    (a & 251) == 0 && (a & 253) == 0 && (a & 255) == 0 && (a & 257) == 0 && (a\
    \ & 259) == 0 && (a & 261) == 0 &&\n    (a & 263) == 0 && (a & 265) == 0 && (a\
    \ & 267) == 0 && (a & 269) == 0 && (a & 271) == 0 && (a & 273) == 0 &&\n    (a\
    \ & 277) == 0 && (a & 279) == 0 && (a & 281) == 0 && (a & 283) == 0 && (a & 285)\
    \ == 0 && (a & 287) == 0 &&\n    (a & 289) == 0 && (a & 291) == 0 && (a & 293)\
    \ == 0 && (a & 295) == 0 && (a & 297) == 0 && (a & 299) == 0 &&\n    (a & 301)\
    \ == 0 && (a & 30\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmppzu5i6o7.rs:31:23\n\
    \   |\n17 | fn iscube(a: isize) -> bool {\n   |                             -\
    \ closing delimiter possibly meant for this\n...\n31 |     (a & 301) == 0 && (a\
    \ & 30\n   |                       ^ unclosed delimiter\n32 | }\n   | ^ mismatched\
    \ closing delimiter\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppzu5i6o7.rs:31:23\n\
    \   |\n31 |       (a & 301) == 0 && (a & 30\n   |  _______________________^\n\
    32 | | }\n   | |_^ expected `bool`, found `isize`\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976101
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    (a ** 3) % 3 == 0\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `{integer}` cannot be dereferenced\n  --> /tmp/tmpgmo2_2id.rs:18:9\n\
    \   |\n18 |     (a ** 3) % 3 == 0\n   |         ^^^\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0614`.\n"
  stdout: ''
  timestamp: 1659976101
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == 3 || a == 5 || a == 7 || a == 9 ||\n    a == 11 ||\
    \ a == 13 || a == 15 || a == 17 ||\n    a == 19 || a == 21 || a == 23 || a ==\
    \ 25 ||\n    a == 27 || a == 29 || a == 31 || a == 33 ||\n    a == 35 || a ==\
    \ 37 || a == 39 || a == 41 ||\n    a == 43 || a == 45 || a == 47 || a == 49 ||\n\
    \    a == 51 || a == 53 || a == 55 || a == 57 ||\n    a == 59 || a == 61 || a\
    \ == 63 || a == 65 ||\n    a == 67 || a == 69 || a == 71 || a == 73 ||\n    a\
    \ == 75 || a == 77 || a == 79 || a == 81 ||\n    a == 83 || a == 85 || a == 87\
    \ || a == 89 ||\n    a == 91 || a == 93 || a == 95 || a == 97 ||\n    a == 99\
    \ || a == 101 || a == 103 || a == 105 ||\n    a == 107 || a == 109 || a == 111\
    \ || a == 113 ||\n    a == 115 || a == 117 || a == 119 ||\n    a == 121 ||\n \
    \   a == 123 ||\n    a == 125 ||\n    a == 127 ||\n    a == 129\n}\n\nfn main()\
    \ {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpzxphinth.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976101
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    if a == 1 {\n        return true;\n    }\n    if a ==\
    \ 2 {\n        return false;\n    }\n    if a == 9 {\n        return true;\n \
    \   }\n    if a == 64 {\n        return true;\n    }\n    if a > 64 {\n      \
    \  return false;\n    }\n    let mut a = a;\n    loop {\n        let mut b = a;\n\
    \        b /= 9;\n        if b == 1 {\n            return true;\n        }\n \
    \       if a == b {\n            return false;\n        }\n        a = b;\n  \
    \  }\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp639fhqf9.rs:51:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976101
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a >= 360 && a <= 418\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpyympcq9n.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976101
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let a = a as isize;\n    if a == 0 { true } else { a &\
    \ 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 &\
    \ 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 &\
    \ 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 &\
    \ 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 &\
    \ 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 &\
    \ 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 &\
    \ 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 &\
    \ 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 &\
    \ 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 &\
    \ 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 &\
    \ 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 &\
    \ 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 &\
    \ 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 &\
    \ 1 & \n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpcs983xpu.rs:32:3\n\
    \   |\n17 | fn iscube(a: isize) -> bool {\n   |                             -\
    \ unclosed delimiter\n18 |     let a = a as isize;\n19 |     if a == 0 { true\
    \ } else { a & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 &\
    \ 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 &...\n   |                           \
    \  - this delimiter might not be properly closed...\n20 | }\n   | - ...as it matches\
    \ this but it has different indentation\n...\n32 | }\n   |   ^\n\nerror: expected\
    \ expression, found `}`\n  --> /tmp/tmpcs983xpu.rs:20:1\n   |\n20 | }\n   | ^\
    \ expected expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcs983xpu.rs:19:17\n\
    \   |\n19 |       if a == 0 { true } else { a & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1\
    \ & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 &...\n\
    \   |       -           ^^^^ expected `()`, found `bool`\n   |  _____|\n   | |\n\
    20 | | }\n   | |_- expected this to be `()`\n   |\nhelp: you might have meant\
    \ to return this value\n   |\n19 |     if a == 0 { return true; } else { a & 1\
    \ & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1\
    \ & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1\
    \ & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1\
    \ & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1\
    \ & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1\
    \ & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1\
    \ & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1\
    \ & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1\
    \ & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1\
    \ & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1\
    \ & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1\
    \ & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1\
    \ & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 &"
  stdout: ''
  timestamp: 1659976101
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut cube = 1usize;\n    cube = cube * cube * cube\
    \ + a;\n    cube == 0\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1_du_4l1.rs:19:33\n   |\n\
    19 |     cube = cube * cube * cube + a;\n   |                                \
    \ ^ expected `usize`, found `isize`\n\nerror[E0277]: cannot add `isize` to `usize`\n\
    \  --> /tmp/tmp1_du_4l1.rs:19:31\n   |\n19 |     cube = cube * cube * cube + a;\n\
    \   |                               ^ no implementation for `usize + isize`\n\
    \   |\n   = help: the trait `Add<isize>` is not implemented for `usize`\n   =\
    \ help: the following other types implement trait `Add<Rhs>`:\n             <&'a\
    \ f32 as Add<f32>>\n             <&'a f64 as Add<f64>>\n             <&'a i128\
    \ as Add<i128>>\n             <&'a i16 as Add<i16>>\n             <&'a i32 as\
    \ Add<i32>>\n             <&'a i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n\
    \             <&'a isize as Add<isize>>\n           and 48 others\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976101
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == 0 || a == 1\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp7z9kf5q_.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976101
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    // base case\n    if a == 1 {\n        return true;\n\
    \    }\n    // recursive case\n    if a%3 == 0 {\n        return iscube(a/3) ||\
    \ (a%1 == 0 && iscube(a/3));\n    }\n    else {\n        return false;\n    }\n\
    }\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpegodgw6r.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976101
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    match (a, a % 9, (a / 9) % 3, (a / 27) % 5) {\n      \
    \  (3, 3, 5, 5) |\n        (9, 9, 9, 9)   =>  true,\n        (3, 3, 5, 5) |\n\
    \        (3, 9, 9, 5)   =>  false,\n        (9, 9, 9, 5)   |\n        (9, 3, 9,\
    \ 5)   =>  false,\n        (9, 9, 3, 5)   =>  false,\n        _              \
    \ => false,\n    }\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp3r6qby8a.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976101
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a % a == 0 && a % a == 0 && a\n        % a == 0\n}\n\n\
    fn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp5_cxwr3q.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976101
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == a * a * a\n}\n\nfn main() {\n    let candidate =\
    \ iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n\
    \    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n\
    \    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpx43jjhsj.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976101
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a % 3 == 0 && a * a % 3 == 0\n}\n\nfn main() {\n    let\
    \ candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpoyckdhq6.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976101
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut x = a;\n    repeat::<isize>(|y| {\n        x =\
    \ x * x;\n        x == a ? true : false;\n    })\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found keyword\
    \ `true`\n  --> /tmp/tmp_hbtbh8b.rs:21:18\n   |\n21 |         x == a ? true :\
    \ false;\n   |                  ^^^^ expected one of `.`, `;`, `?`, `}`, or an\
    \ operator\n\nerror[E0425]: cannot find function `repeat` in this scope\n  -->\
    \ /tmp/tmp_hbtbh8b.rs:19:5\n   |\n19 |     repeat::<isize>(|y| {\n   |     ^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing one of these items\n\
    \   |\n1  | use std::io::repeat;\n   |\n1  | use std::iter::repeat;\n   |\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976101
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let c = Cube::new(a);\n    if c.is_cube() {\n        return\
    \ true;\n    }\n    false\n}\n\nfn main() {\n    let candidate = iscube;\n   \
    \ assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Cube`\n  --> /tmp/tmpbgmqpr3d.rs:18:13\n\
    \   |\n18 |     let c = Cube::new(a);\n   |             ^^^^ use of undeclared\
    \ type `Cube`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976101
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a * a == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpoy1owmy9.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976101
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let m = &a / 3;\n    m % 3 == 0 || m == 0 || m == 1\n\
    }\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpw4ko_a5c.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976101
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == 0 || a == 180 || a == 360\n}\n\nfn main() {\n   \
    \ let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmph3eltgxh.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976101
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a % a == 0 && a / a % a == a / a / a % a == a / a / a\
    \ / a % a == 0\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  status: SyntaxError
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmpval3zt1_.rs:18:29\n\
    \   |\n18 |     a % a == 0 && a / a % a == a / a / a % a == a / a / a / a % a\
    \ == 0\n   |                             ^^               ^^\n   |\nhelp: split\
    \ the comparison into two\n   |\n18 |     a % a == 0 && a / a % a == a / a / a\
    \ % a && a / a / a % a == a / a / a / a % a == 0\n   |                       \
    \                       ++++++++++++++++\n\nerror: comparison operators cannot\
    \ be chained\n  --> /tmp/tmpval3zt1_.rs:18:46\n   |\n18 |     a % a == 0 && a\
    \ / a % a == a / a / a % a == a / a / a / a % a == 0\n   |                   \
    \                           ^^                   ^^\n   |\nhelp: split the comparison\
    \ into two\n   |\n18 |     a % a == 0 && a / a % a == a / a / a % a == a / a /\
    \ a / a % a && a / a / a / a % a == 0\n   |                                  \
    \                                 ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpval3zt1_.rs:18:49\n   |\n18 |     a % a == 0 && a / a %\
    \ a == a / a / a % a == a / a / a / a % a == 0\n   |                         \
    \                        ^^^^^^^^^^^^^^^^^ expected `bool`, found `isize`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpval3zt1_.rs:18:70\n   |\n18 |  \
    \   a % a == 0 && a / a % a == a / a / a % a == a / a / a / a % a == 0\n   | \
    \                                                                     ^ expected\
    \ `bool`, found integer\n\nerror: aborting due to 4 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976101
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    if a == 1 || a == -a || a == a as isize || a == 1 as isize\
    \ || a == -a as isize || a == -1 as isize {\n        return true;\n    }\n\n \
    \   if a == 0 || a == a as isize || a == 0 as isize || a == -a as isize || a ==\
    \ -1 as isize {\n        return false;\n    }\n\n    if a == -a as isize {\n \
    \       return false;\n    }\n\n    if a < 0 {\n        return false;\n    }\n\
    \n    let mut x = a as isize;\n    for _ in 0..10 {\n        x = x * x;\n    \
    \    if x == a as isize {\n            return true;\n        }\n    }\n\n    return\
    \ false;\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp5fe222a7.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976101
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    if a < 0 {\n        false\n    } else {\n        a ==\
    \ a && a == a * a && a == a * a * a\n    }\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpv0xu95dc.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976101
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    (a * a == a * a * a)\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp7mzln1qc.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976101
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    let mut b = a / 3;\n    if b <= 0 || b > 6 {\n       \
    \ return false;\n    }\n    if a == b * b * b {\n        return true;\n    }\n\
    \    b /= 3;\n    if b <= 0 || b > 6 {\n        return false;\n    }\n    if a\
    \ == b * b * b {\n        return true;\n    }\n    b /= 3;\n    if b <= 0 || b\
    \ > 6 {\n        return false;\n    }\n    if a == b * b * b {\n        return\
    \ true;\n    }\n    return false;\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp_6zgjxsx.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976101
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns true \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a <= 180 && a >= 1\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpwnmicz_r.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976101
