language: rs
name: HumanEval_117_select_words
results:
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    select_words_helper(s.chars(),\
    \ n, vec![])\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `select_words_helper` in this scope\n\
    \  --> /tmp/tmper4ely1j.rs:18:5\n   |\n18 |     select_words_helper(s.chars(),\
    \ n, vec![])\n   |     ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    if s.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut c = vec![String::from(\"\")];\n\
    \    let mut words = vec![];\n    for c in s.chars() {\n        if c == ' ' {\n\
    \            words = words.to_owned();\n            c = String::from(\"\");\n\
    \            continue;\n        }\n        if c.is_ascii() && c.as_bytes()[0]\
    \ != c.as_bytes()[1] {\n            words = words.to_owned();\n            c =\
    \ String::from(\"\");\n            continue;\n        }\n        if c == c.as_bytes()[1]\
    \ {\n            c.truncate(1);\n            words.push(c.to_string());\n    \
    \    } else {\n            c.truncate(0);\n            words.push(c.to_string());\n\
    \        }\n        if n == words.len() {\n            break;\n        }\n   \
    \ }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmq5iutsy.rs:26:17\n   |\n\
    23 |     for c in s.chars() {\n   |         - expected due to the type of this\
    \ binding\n...\n26 |             c = String::from(\"\");\n   |               \
    \  ^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\nerror[E0599]: no\
    \ method named `as_bytes` found for type `char` in the current scope\n  --> /tmp/tmpmq5iutsy.rs:29:30\n\
    \   |\n29 |         if c.is_ascii() && c.as_bytes()[0] != c.as_bytes()[1] {\n\
    \   |                              ^^^^^^^^ method not found in `char`\n\nerror[E0599]:\
    \ no method named `as_bytes` found for type `char` in the current scope\n  -->\
    \ /tmp/tmpmq5iutsy.rs:29:49\n   |\n29 |         if c.is_ascii() && c.as_bytes()[0]\
    \ != c.as_bytes()[1] {\n   |                                                 ^^^^^^^^\
    \ method not found in `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmq5iutsy.rs:31:17\n\
    \   |\n23 |     for c in s.chars() {\n   |         - expected due to the type\
    \ of this binding\n...\n31 |             c = String::from(\"\");\n   |       \
    \          ^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\nerror[E0599]:\
    \ no method named `as_bytes` found for type `char` in the current scope\n  -->\
    \ /tmp/tmpmq5iutsy.rs:34:19\n   |\n34 |         if c == c.as_bytes()[1] {\n  \
    \ |                   ^^^^^^^^ method not found in `char`\n\nerror[E0599]: no\
    \ method named `truncate` found for type `char` in the current scope\n  --> /tmp/tmpmq5iutsy.rs:35:15\n\
    \   |\n35 |             c.truncate(1);\n   |               ^^^^^^^^ method not\
    \ found in `char`\n\nerror[E0599]: no method named `truncate` found for type `char`\
    \ in the current scope\n  --> /tmp/tmpmq5iutsy.rs:38:15\n   |\n38 |          \
    \   c.truncate(0);\n   |               ^^^^^^^^ method not found in `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpmq5iutsy.rs:41:17\n   |\n41 |  \
    \       if n == words.len() {\n   |                 ^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n41 |         if n == words.len().try_into().unwrap"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    \n}\n\n\
    fn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3v79g7v6.rs:17:41\n   |\n\
    17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    // MY CODE\
    \ HERE\n    vec![\"Mary\", \"lamb\"]\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp76nvtlli.rs:19:10\n   |\n\
    19 |     vec![\"Mary\", \"lamb\"]\n   |          ^^^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |          |\n   |          expected struct `String`,\
    \ found `&str`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    // Your\
    \ code here\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptu_480ft.rs:17:41\n   |\n\
    17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result: Vec<String> = Vec::new();\n    if s.is_empty() {\n        result\n \
    \   } else {\n        let mut vowels = vec!['a', 'e', 'i', 'o', 'u'];\n      \
    \  let mut consonants = vec!['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm',\
    \ 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x'];\n        let mut vowels_counter:\
    \ HashMap<usize, usize> = HashMap::new();\n        let mut consonants_counter:\
    \ HashMap<usize, usize> = HashMap::new();\n        let mut letter_counter: HashMap<String,\
    \ usize> = HashMap::new();\n        for letter in s.chars() {\n            vowels_counter.insert(letter,\
    \ 0);\n            consonants_counter.insert(letter, 0);\n            letter_counter.insert(letter,\
    \ 0);\n        }\n        for letter in s.chars() {\n            if let Some(v)\
    \ = vowels.binary_search(&letter) {\n                vowels_counter.entry(v)\n\
    \                    .or_insert(0)\n                    .inc(letter_counter.get(&letter).unwrap_or(0));\n\
    \            }\n            if let Some(c) = consonants.binary_search(&letter)\
    \ {\n                consonants_counter.entry(c)\n                    .or_insert(0)\n\
    \                    .inc(letter_counter.get(&letter).unwrap_or(0));\n       \
    \     }\n        }\n        for v in vowels_counter.keys() {\n            if consonants_counter[v]\
    \ != n {\n                continue;\n            }\n            let letter_with_v\
    \ = s.chars().filter(|c| c == v).count();\n            result.push(String::from(v.to_string()));\n\
    \            if letter_with_v == n {\n                break;\n            }\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashMap` in this scope\n  --> /tmp/tmparojh9au.rs:24:33\n\
    \   |\n24 |         let mut vowels_counter: HashMap<usize, usize> = HashMap::new();\n\
    \   |                                 ^^^^^^^ not found in this scope\n   |\n\
    help: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmparojh9au.rs:24:57\n   |\n24 |         let mut vowels_counter: HashMap<usize,\
    \ usize> = HashMap::new();\n   |                                             \
    \            ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0412]: cannot\
    \ find type `HashMap` in this scope\n  --> /tmp/tmparojh9au.rs:25:37\n   |\n25\
    \ |         let mut consonants_counter: HashMap<usize, usize> = HashMap::new();\n\
    \   |                                     ^^^^^^^ not found in this scope\n  \
    \ |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmparojh9au.rs:25:61\n   |\n25 |         let mut consonants_counter:\
    \ HashMap<usize, usize> = HashMap::new();\n   |                              \
    \                               ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0412]:\
    \ cannot find type `HashMap` in this scope\n  --> /tmp/tmparojh9au.rs:26:33\n\
    \   |\n26 |         let mut letter_counter: HashMap<String, usize> = HashMap::new();\n\
    \   |                                 ^^^^^^^ not found in this scope\n   |\n\
    help: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmparojh9au.rs:26:58\n   |\n26 |         let mut letter_counter: HashMap<String,\
    \ usize> = HashMap::new();\n   |                                             \
    \             ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  |"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    if s.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut words = vec![];\n    let mut counts\
    \ = HashMap::new();\n    let mut i = 0;\n    loop {\n        let mut letter =\
    \ s.chars().nth(i).unwrap();\n        if counts.get(&letter).is_some() {\n   \
    \         i += 1;\n            continue;\n        }\n        let mut found = false;\n\
    \        while !found {\n            found = words.iter().any(|&x| x == &letter);\n\
    \            if found {\n                i += 1;\n                break;\n   \
    \         }\n            words.push((letter, letter));\n        }\n        counts.insert(letter,\
    \ 1);\n        i += 1;\n        if i == n {\n            break;\n        }\n \
    \   }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpnmfsakjg.rs:22:22\n   |\n22 |     let mut counts = HashMap::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0277]:\
    \ can't compare `(char, char)` with `&char`\n  --> /tmp/tmpnmfsakjg.rs:32:45\n\
    \   |\n32 |             found = words.iter().any(|&x| x == &letter);\n   |   \
    \                                          ^^ no implementation for `(char, char)\
    \ == &char`\n   |\n   = help: the trait `PartialEq<&char>` is not implemented\
    \ for `(char, char)`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             ()\n             (A, B, C, D, E, F, G, H, I, J, K, L)\n        \
    \     (B, C, D, E, F, G, H, I, J, K, L)\n             (C, D, E, F, G, H, I, J,\
    \ K, L)\n             (D, E, F, G, H, I, J, K, L)\n             (E, F, G, H, I,\
    \ J, K, L)\n             (F, G, H, I, J, K, L)\n             (G, H, I, J, K, L)\n\
    \           and 5 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnmfsakjg.rs:41:17\n\
    \   |\n41 |         if i == n {\n   |                 ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n41 |         if i == n.try_into().unwrap()\
    \ {\n   |                  ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpnmfsakjg.rs:45:5\n   |\n17 | fn select_words(s: String, n: isize)\
    \ -> Vec<String> {\n   |                                         ----------- expected\
    \ `Vec<String>` because of return type\n...\n45 |     words\n   |     ^^^^^ expected\
    \ struct `String`, found tuple\n   |\n   = note: expected struct `Vec<String>`\n\
    \              found struct `Vec<(char, char)>`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308, E0433.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    if s.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut count = 0;\n    let mut res =\
    \ vec![];\n    let mut s = String::from(s);\n    while s.len() > 0 {\n       \
    \ let mut index = s.find_first_not_ascii_whitespace();\n        if index == s.len()\
    \ {\n            res.push(s);\n            break;\n        }\n        while index\
    \ < s.len() {\n            let char = s[index];\n            if char == ' ' {\n\
    \                index = s.find_first_not_ascii_whitespace();\n              \
    \  if index == s.len() {\n                    res.push(s);\n                 \
    \   break;\n                }\n            }\n            if !consonants::contains(char)\
    \ {\n                index += 1;\n                continue;\n            }\n \
    \           count = count + 1;\n            index = s.find_first_not_ascii_whitespace(index);\n\
    \            if count == n {\n                res.push(s);\n                break;\n\
    \            }\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `consonants`\n\
    \  --> /tmp/tmpfpekhaa9.rs:39:17\n   |\n39 |             if !consonants::contains(char)\
    \ {\n   |                 ^^^^^^^^^^ use of undeclared crate or module `consonants`\n\
    \nerror[E0599]: no method named `find_first_not_ascii_whitespace` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmpfpekhaa9.rs:25:27\n   |\n25 | \
    \        let mut index = s.find_first_not_ascii_whitespace();\n   |          \
    \                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `split_ascii_whitespace`\n\nerror[E0599]: no method\
    \ named `find_first_not_ascii_whitespace` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpfpekhaa9.rs:33:27\n   |\n33 |                 index = s.find_first_not_ascii_whitespace();\n\
    \   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: there is\
    \ an associated function with a similar name: `split_ascii_whitespace`\n\nerror[E0599]:\
    \ no method named `find_first_not_ascii_whitespace` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpfpekhaa9.rs:44:23\n   |\n44 |          \
    \   index = s.find_first_not_ascii_whitespace(index);\n   |                  \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `split_ascii_whitespace`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    // TODO\n\
    \    return vec![];\n}\n\nfn main() {\n    let candidate = select_words;\n   \
    \ assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"little\"]`', /tmp/tmpu14_1vfg.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    assert!(n\
    \ > 0);\n    assert!(s.is_empty() || s.chars().count() == n);\n    vec![\"Mary\"\
    , \"lamb\", \"little\"]\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplr89ix3b.rs:19:50\n   |\n\
    19 |     assert!(s.is_empty() || s.chars().count() == n);\n   |              \
    \                                    ^ expected `usize`, found `isize`\n   |\n\
    help: you can convert an `isize` to a `usize` and panic if the converted value\
    \ doesn't fit\n   |\n19 |     assert!(s.is_empty() || s.chars().count() == n.try_into().unwrap());\n\
    \   |                                                   ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmplr89ix3b.rs:20:10\n   |\n20 |\
    \     vec![\"Mary\", \"lamb\", \"little\"]\n   |          ^^^^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |          |\n   |          expected\
    \ struct `String`, found `&str`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ counts = HashMap::new();\n    for c in s.chars() {\n        counts.entry(c).or_insert(0)\
    \ += 1;\n    }\n    let mut words = Vec::new();\n    for entry in counts.iter()\
    \ {\n        if entry.value() == n {\n            words.push(entry.key());\n \
    \       }\n    }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpazg7rabc.rs:18:22\n   |\n18 |     let mut counts = HashMap::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0067]:\
    \ invalid left-hand side of assignment\n  --> /tmp/tmpazg7rabc.rs:20:38\n   |\n\
    20 |         counts.entry(c).or_insert(0) += 1;\n   |         ----------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0433.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ list = vec![];\n    for i in s.chars() {\n        \n        if i.is_ascii()\
    \ {\n            if i.to_ascii_lowercase().contains(&String::from(\"aeiouy\"))\
    \ {\n                list\n                    .push(i.to_ascii_lowercase().to_lowercase().trim_matches('\
    \ '));\n            }\n        } else {\n            if i.to_lowercase().contains(&String::from(\"\
    aeiouy\")) {\n                list\n                    .push(i.to_lowercase().trim_matches('\
    \ '));\n            }\n        }\n    }\n    if list.len() <= n {\n        list\n\
    \    } else {\n        list.iter().take(n).collect()\n    }\n}\n\nfn main() {\n\
    \    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `contains` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpkb2vseni.rs:22:39\n   |\n22 |             if i.to_ascii_lowercase().contains(&String::from(\"\
    aeiouy\")) {\n   |                                       ^^^^^^^^ method not found\
    \ in `char`\n\nerror[E0599]: no method named `trim_matches` found for struct `ToLowercase`\
    \ in the current scope\n  --> /tmp/tmpkb2vseni.rs:24:65\n   |\n24 |          \
    \           .push(i.to_ascii_lowercase().to_lowercase().trim_matches(' '));\n\
    \   |                                                                 ^^^^^^^^^^^^\
    \ method not found in `ToLowercase`\n\nerror[E0599]: no method named `contains`\
    \ found for struct `ToLowercase` in the current scope\n  --> /tmp/tmpkb2vseni.rs:27:33\n\
    \   |\n27 |             if i.to_lowercase().contains(&String::from(\"aeiouy\"\
    )) {\n   |                                 ^^^^^^^^ method not found in `ToLowercase`\n\
    \nerror[E0599]: no method named `trim_matches` found for struct `ToLowercase`\
    \ in the current scope\n  --> /tmp/tmpkb2vseni.rs:29:44\n   |\n29 |          \
    \           .push(i.to_lowercase().trim_matches(' '));\n   |                 \
    \                           ^^^^^^^^^^^^ method not found in `ToLowercase`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpkb2vseni.rs:33:22\n   |\n33 |  \
    \   if list.len() <= n {\n   |                      ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n33 |     if list.len() <= n.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpkb2vseni.rs:36:26\n   |\n36 |         list.iter().take(n).collect()\n\
    \   |                          ^ expected `usize`, found `isize`\n   |\nhelp:\
    \ you can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n36 |         list.iter().take(n.try_into().unwrap()).collect()\n\
    \   |                           ++++++++++++++++++++\n\nerror[E0277]: a value\
    \ of type `Vec<String>` cannot be built from an iterator over elements of ty"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    // TODO\
    \ \n    if s.is_empty() {\n        return vec![];\n    }\n    let mut s: Vec<String>\
    \ = vec![];\n    for c in s.chars() {\n        if c.is_consonant() {\n       \
    \     s.push(c);\n        }\n        if n == s.len() {\n            return s;\n\
    \        }\n        if n != s.len() && c == s[n - 1] {\n            return vec![];\n\
    \        }\n    }\n    vec![]\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `chars` found for struct `Vec<String>` in\
    \ the current scope\n  --> /tmp/tmp_9bn6uyr.rs:23:16\n   |\n23 |     for c in\
    \ s.chars() {\n   |                ^^^^^ method not found in `Vec<String>`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp_9bn6uyr.rs:27:17\n   |\n27 |  \
    \       if n == s.len() {\n   |                 ^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n27 |         if n == s.len().try_into().unwrap()\
    \ {\n   |                        ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_9bn6uyr.rs:30:17\n   |\n30 |         if n != s.len() &&\
    \ c == s[n - 1] {\n   |                 ^^^^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n30 |         if n != s.len().try_into().unwrap() &&\
    \ c == s[n - 1] {\n   |                        ++++++++++++++++++++\n\nerror[E0277]:\
    \ the type `[String]` cannot be indexed by `isize`\n  --> /tmp/tmp_9bn6uyr.rs:30:33\n\
    \   |\n30 |         if n != s.len() && c == s[n - 1] {\n   |                 \
    \                ^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[String]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<String>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    if s.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut result = Vec::new();\n\n   \
    \ let mut num_consonants = 0;\n    let mut num_vowels = 0;\n\n    for c in s.chars()\
    \ {\n        match c {\n            'a' => num_vowels += 1,\n            'e' =>\
    \ num_vowels += 1,\n            'i' => num_vowels += 1,\n            'o' => num_vowels\
    \ += 1,\n            'u' => num_vowels += 1,\n            _ => num_consonants\
    \ += 1,\n        }\n\n        if num_consonants == n {\n            result.push(String::from(&s[..]));\n\
    \            num_consonants = 0;\n            num_vowels = 0;\n        }\n   \
    \ }\n\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"Mary had a little lamb\", \"Mary had a little lamb\", \"Mary had a little\
    \ lamb\", \"Mary had a little lamb\"]`,\n right: `[\"little\"]`', /tmp/tmpjsuie1e4.rs:49:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    // todo\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5rx3bp8l.rs:17:41\n   |\n\
    17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    match n\
    \ {\n        0 => vec![],\n        _ => {\n            let mut s = s;\n      \
    \      let mut consonants = 0;\n            loop {\n                s = s.remove_prefix(consonants).to_string();\n\
    \                if s.is_empty() {\n                    break;\n             \
    \   }\n                if s.chars().all(|c| c != ' ') {\n                    consonants\
    \ += 1;\n                }\n            }\n            let mut words = vec![];\n\
    \            for c in s.chars() {\n                if c == ' ' {\n           \
    \         continue;\n                }\n                if c != 'n' {\n      \
    \              words.push(c.to_string());\n                }\n            }\n\
    \            words\n        }\n    }\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `remove_prefix` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpcwg2e0l5.rs:24:23\n   |\n24 |          \
    \       s = s.remove_prefix(consonants).to_string();\n   |                   \
    \    ^^^^^^^^^^^^^ method not found in `String`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    match (n,\
    \ s.length) {\n        (0, 0) => Vec::new(),\n        (0, _) => Vec::new(),\n\
    \        (i, _) => select_words(s.trim_right_matches(&[\"a\", \"e\", \"i\", \"\
    o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"][i..]),i).into_iter()\n        \
    \    .filter_map(|&s| s.chars().take_while(|&c| {\n                    c != \"\
    a\" && c != \"e\" && c != \"i\" && c != \"o\" && c != \"u\" && c != \"A\" && c\
    \ != \"E\" && c != \"I\" && c != \"O\" && c != \"U\"\n                }).collect::<Vec<String>>())\n\
    \            .collect::<Vec<String>>(),\n        (_, i) => select_words(s.trim_right_matches(&[\"\
    a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"][i..]),i).into_iter()\n\
    \            .filter_map(|&s| s.chars().take_while(|&c| {\n                  \
    \  c != \"a\" && c != \"e\" && c != \"i\" && c != \"o\" && c != \"u\" && c !=\
    \ \"A\" && c != \"E\" && c != \"I\" && c != \"O\" && c != \"U\"\n            \
    \    }).collect::<Vec<String>>())\n            .collect::<Vec<String>>(),\n  \
    \      (i, _) => {\n            let mut s = s.trim_right_matches(&[\"a\", \"e\"\
    , \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"][i..]);\n           \
    \ let len = s.chars().take_while(|&c| {\n                    c != \"a\" && c !=\
    \ \"e\" && c != \"i\" && c != \"o\" && c != \"u\" && c != \"A\" && c != \"E\"\
    \ && c != \"I\" && c != \"O\" && c != \"U\"\n                }).count();\n   \
    \         select_words(&mut s, i+1).into_iter()\n                .filter_map(|&s|\
    \ s.chars().take_while(|&c| {\n                    c != \"a\" && c != \"e\" &&\
    \ c != \"i\" && c != \"o\" && c != \"u\" && c != \"A\" && c != \"E\" && c != \"\
    I\" && c != \"O\" && c != \"U\"\n                }).collect::<Vec<String>>())\n\
    \                .collect::<Vec<String>>()\n        }\n    }\n}\n\nfn main() {\n\
    \    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0609]: no field `length` on type `String`\n  --> /tmp/tmp414ycczt.rs:18:17\n\
    \   |\n18 |     match (n, s.length) {\n   |                 ^^^^^^ unknown field\n\
    \nwarning: use of deprecated associated function `core::str::<impl str>::trim_right_matches`:\
    \ superseded by `trim_end_matches`\n  --> /tmp/tmp414ycczt.rs:21:34\n   |\n21\
    \ |         (i, _) => select_words(s.trim_right_matches(&[\"a\", \"e\", \"i\"\
    , \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"][i..]),i).into_iter()\n   |\
    \                                  ^^^^^^^^^^^^^^^^^^ help: replace the use of\
    \ the deprecated associated function: `trim_end_matches`\n   |\n   = note: `#[warn(deprecated)]`\
    \ on by default\n\nerror[E0277]: expected a `Fn<(char,)>` closure, found `[&str]`\n\
    \  --> /tmp/tmp414ycczt.rs:21:53\n   |\n21 |         (i, _) => select_words(s.trim_right_matches(&[\"\
    a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"][i..]),i).into_iter()\n\
    \   |                                  ------------------ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected an `Fn<(char,)>` closure, found `[&str]`\n   |                    \
    \              |\n   |                                  required by a bound introduced\
    \ by this call\n   |\n   = help: the trait `Fn<(char,)>` is not implemented for\
    \ `[&str]`\n   = help: the following other types implement trait `Pattern<'a>`:\n\
    \             &'b [char; N]\n             &'b [char]\n             [char; N]\n\
    \   = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&[&str]`\n   = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `&[&str]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp414ycczt.rs:21:32\n\
    \   |\n21 |         (i, _) => select_words(s.trim_right_matches(&[\"a\", \"e\"\
    , \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"][i..]),i).into_iter()\n\
    \   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \              |\n   |                                expected struct `String`,\
    \ found `&str`\n\nerror[E03"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    select_words_aux(s,\
    \ n, true)\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `select_words_aux` in this scope\n \
    \ --> /tmp/tmp8m0hgkx3.rs:18:5\n   |\n18 |     select_words_aux(s, n, true)\n\
    \   |     ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    if s.is_empty()\
    \ {\n        return vec![];\n    }\n    \n    let mut counts = vec![0; 26]; \n\
    \    \n    for c in s.chars() {\n        counts[c as usize - 'a' as usize] +=\
    \ 1;\n    }\n    \n    counts.sort_unstable_by_key(|x| x as isize);\n    \n  \
    \  let mut result = vec![];\n    \n    for c in counts.iter().rev() {\n      \
    \  if c == n {\n            result.push(*s.chars().nth(c as usize - 'a' as usize));\n\
    \        }\n    }\n    \n    result\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmp605aojm8.rs:33:14\n\
    \   |\n33 |         if c == n {\n   |              ^^ no implementation for `&isize\
    \ == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0614]: type `Option<char>` cannot be dereferenced\n\
    \  --> /tmp/tmp605aojm8.rs:34:25\n   |\n34 |             result.push(*s.chars().nth(c\
    \ as usize - 'a' as usize));\n   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0606]: casting `&isize` as `isize` is invalid\n  --> /tmp/tmp605aojm8.rs:28:37\n\
    \   |\n28 |     counts.sort_unstable_by_key(|x| x as isize);\n   |           \
    \                          -^^^^^^^^^\n   |                                  \
    \   |\n   |                                     cannot cast `&isize` as `isize`\n\
    \   |                                     help: dereference the expression: `*x`\n\
    \nerror[E0606]: casting `&isize` as `usize` is invalid\n  --> /tmp/tmp605aojm8.rs:34:40\n\
    \   |\n34 |             result.push(*s.chars().nth(c as usize - 'a' as usize));\n\
    \   |                                        -^^^^^^^^^\n   |                \
    \                        |\n   |                                        cannot\
    \ cast `&isize` as `usize`\n   |                                        help:\
    \ dereference the expression: `*c`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0606, E0614.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    assert_eq!(\n\
    \        s.length(),\n        n.checked_mul(5).unwrap_or(s.len())\n    );\n  \
    \  if s.len() <= n {\n        return vec![s];\n    }\n\n    let mut words = vec![];\n\
    \    let mut pos = 0;\n    let mut i = 0;\n    loop {\n        let word = s[pos..].to_owned();\n\
    \        if word.len() == n {\n            words.push(word);\n        }\n    \
    \    i += 1;\n        if i >= 5 {\n            break;\n        }\n        pos\
    \ = i + 1;\n    }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp2cfxu8lu.rs:19:11\n   |\n19 |         s.length(),\n\
    \   |           ^^^^^^ help: there is an associated function with a similar name:\
    \ `len`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2cfxu8lu.rs:20:36\n \
    \  |\n20 |         n.checked_mul(5).unwrap_or(s.len())\n   |                 \
    \                   ^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n20 |         n.checked_mul(5).unwrap_or(s.len().try_into().unwrap())\n\
    \   |                                           ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2cfxu8lu.rs:22:19\n   |\n22 |     if s.len()\
    \ <= n {\n   |                   ^ expected `usize`, found `isize`\n   |\nhelp:\
    \ you can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n22 |     if s.len() <= n.try_into().unwrap() {\n   |            \
    \        ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2cfxu8lu.rs:31:26\n\
    \   |\n31 |         if word.len() == n {\n   |                          ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n31 |         if word.len()\
    \ == n.try_into().unwrap() {\n   |                           ++++++++++++++++++++\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    if s ==\
    \ \"\" {\n        return vec![];\n    }\n    let mut words = vec![];\n    for\
    \ s in s.chars() {\n        if s.is_vowel() {\n            continue;\n       \
    \ }\n        if n == s.len() {\n            words.push(s);\n            continue;\n\
    \        }\n        let mut cur = s;\n        let mut found = false;\n       \
    \ for c in s.chars() {\n            if c == ' ' {\n                break;\n  \
    \          }\n            if c == cur {\n                found = true;\n     \
    \           break;\n            }\n        }\n        if !found {\n          \
    \  words.push(s);\n        }\n    }\n    words\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpxmshw3qb.rs:23:14\n   |\n23 |         if s.is_vowel() {\n\
    \   |              ^^^^^^^^ method not found in `char`\n\nerror[E0599]: no method\
    \ named `len` found for type `char` in the current scope\n  --> /tmp/tmpxmshw3qb.rs:26:19\n\
    \   |\n26 |         if n == s.len() {\n   |                   ^^^ method not found\
    \ in `char`\n\nerror[E0599]: no method named `chars` found for type `char` in\
    \ the current scope\n  --> /tmp/tmpxmshw3qb.rs:32:20\n   |\n32 |         for c\
    \ in s.chars() {\n   |                    ^^^^^ method not found in `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpxmshw3qb.rs:45:5\n   |\n17 | fn\
    \ select_words(s: String, n: isize) -> Vec<String> {\n   |                   \
    \                      ----------- expected `Vec<String>` because of return type\n\
    ...\n45 |     words\n   |     ^^^^^ expected struct `String`, found `char`\n \
    \  |\n   = note: expected struct `Vec<String>`\n              found struct `Vec<char>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ n = n.to_string();\n    let mut s = s.to_string();\n    let mut count = 0;\n\
    \    let mut vec = Vec::new();\n    while s.len() > 0 {\n        let c = s[0]\
    \ as char;\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\
    \ {\n            count = count + 1;\n        }\n        \n        if count ==\
    \ n.to_string() {\n            vec.push(s.to_string());\n            count = 0;\n\
    \        }\n\n        s = s.to_string().strip_right();\n    }\n\n    vec\n}\n\n\
    fn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp37e24plv.rs:24:12\n\
    \   |\n24 |         if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\
    \ {\n   |            ^                                                       \
    \ ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these\
    \ parentheses\n   |\n24 -         if (c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u') {\n24 +         if c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u' {\n   | \n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `{integer}`\n  --> /tmp/tmp37e24plv.rs:23:17\n   |\n23 |         let c =\
    \ s[0] as char;\n   |                 ^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: can't compare `{integer}` with `String`\n  --> /tmp/tmp37e24plv.rs:28:18\n\
    \   |\n28 |         if count == n.to_string() {\n   |                  ^^ no implementation\
    \ for `{integer} == String`\n   |\n   = help: the trait `PartialEq<String>` is\
    \ not implemented for `{integer}`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0599]: no method named `strip_right`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmp37e24plv.rs:33:27\n\
    \   |\n33 |         s = s.to_string().strip_right();\n   |                   \
    \        ^^^^^^^^^^^ help: there is an associated function with a similar name:\
    \ `trim_right`\n\nerror: aborting due to 3 previous errors; 1 warning emitted\n\
    \nSom"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ v = Vec::new();\n    for i in s.chars() {\n        if i == ' ' {\n         \
    \   continue;\n        }\n        if i.is_ascii() && i.to_ascii_lowercase().chars().count()\
    \ == n {\n            v.push(s.to_string());\n        }\n    }\n    v\n}\n\nfn\
    \ main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `chars` found for type `char` in the current\
    \ scope\n  --> /tmp/tmplzs8cqlk.rs:23:51\n   |\n23 |         if i.is_ascii() &&\
    \ i.to_ascii_lowercase().chars().count() == n {\n   |                        \
    \                           ^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut has_word = false;\n    let mut has_next = false;\n    while index != s.len()\
    \ {\n        if s[index] == ' ' && !has_word {\n            has_next = true;\n\
    \            index += 1;\n        }\n        if has_next {\n            if count\
    \ == n {\n                result.push(&s[index..]);\n            }\n         \
    \   has_word = true;\n            count = 1;\n            has_next = false;\n\
    \            index += 1;\n        } else {\n            count += 1;\n        \
    \    has_word = false;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpoypeszsa.rs:24:12\n\
    \   |\n24 |         if s[index] == ' ' && !has_word {\n   |            ^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpoypeszsa.rs:41:5\n\
    \   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |      \
    \                                   ----------- expected `Vec<String>` because\
    \ of return type\n...\n41 |     result\n   |     ^^^^^^ expected struct `String`,\
    \ found `&str`\n   |\n   = note: expected struct `Vec<String>`\n             \
    \ found struct `Vec<&str>`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    words.iter()\n\
    \        .filter(|&x| x.contains(&s))\n        .filter(|&x| x.count(\"a\" as char)\
    \ == n)\n        .collect()\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `words` in this scope\n  --> /tmp/tmp9i_hda8c.rs:18:5\n\
    \   |\n18 |     words.iter()\n   |     ^^^^^ not found in this scope\n\nerror[E0606]:\
    \ casting `&'static str` as `char` is invalid\n  --> /tmp/tmp9i_hda8c.rs:20:30\n\
    \   |\n20 |         .filter(|&x| x.count(\"a\" as char) == n)\n   |          \
    \                    ^^^^^^^^^^^\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0425, E0606.\nFor more information\
    \ about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = Vec::new();\n\n    for i in s.chars().filter_map(|c| {\n        match\
    \ c {\n            'A'..='Z' => true,\n            'a'..='z' => true,\n      \
    \      '0'..='9' => true,\n            _ => false\n        }\n    }).take(n) {\n\
    \        words.push(String::from(i));\n    }\n\n    words\n}\n\nfn main() {\n\
    \    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpx78o1ops.rs:22:26\n   |\n\
    22 |             'A'..='Z' => true,\n   |                          ^^^^ expected\
    \ enum `Option`, found `bool`\n   |\n   = note: expected enum `Option<_>`\n  \
    \            found type `bool`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n22 |             'A'..='Z' => Some(true),\n   |                       \
    \   +++++    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpx78o1ops.rs:27:13\n\
    \   |\n27 |     }).take(n) {\n   |             ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n27 |     }).take(n.try_into().unwrap()) {\n   |   \
    \           ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    if s ==\
    \ \"\" {\n        return vec![];\n    }\n    let mut vowels: HashSet<String> =\
    \ HashSet::new();\n    for i in s.chars().filter(|c| c !='A' && c !='E' && c !='I'\
    \ && c !='O' && c !='U') {\n        vowels.insert(String::from(\"A\".to_string()));\n\
    \        vowels.insert(String::from(\"E\".to_string()));\n        vowels.insert(String::from(\"\
    I\".to_string()));\n        vowels.insert(String::from(\"O\".to_string()));\n\
    \        vowels.insert(String::from(\"U\".to_string()));\n    }\n    let mut count\
    \ = 1;\n    let mut word: Vec<String> = vec![];\n    for w in s.split_whitespace()\
    \ {\n        if w.len() == n && vowels.iter().all(|vowel| w.contains(vowel)) {\n\
    \            word.push(w);\n            count = count + 1;\n            if count\
    \ == n {\n                break;\n            }\n        }\n    }\n    word\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmp76z9o41k.rs:21:21\n\
    \   |\n21 |     let mut vowels: HashSet<String> = HashSet::new();\n   |      \
    \               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp76z9o41k.rs:21:39\n\
    \   |\n21 |     let mut vowels: HashSet<String> = HashSet::new();\n   |      \
    \                                 ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp76z9o41k.rs:22:37\n\
    \   |\n22 |     for i in s.chars().filter(|c| c !='A' && c !='E' && c !='I' &&\
    \ c !='O' && c !='U') {\n   |                                     ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp76z9o41k.rs:22:48\n\
    \   |\n22 |     for i in s.chars().filter(|c| c !='A' && c !='E' && c !='I' &&\
    \ c !='O' && c !='U') {\n   |                                                ^^\
    \ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp76z9o41k.rs:22:59\n\
    \   |\n22 |     for i in s.chars().filter(|c| c !='A' && c !='E' && c !='I' &&\
    \ c !='O' && c !='U') {\n   |                                                \
    \           ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmp76z9o41k.rs:22:70\n   |\n22 |     for i in s.chars().filter(|c|\
    \ c !='A' && c !='E' && c !='I' && c !='O' && c !='U') {\n   |               \
    \      "
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    if s.is_empty()\
    \ {\n        return Vec::new();\n    }\n    let mut vowels = Vec::new();\n   \
    \ let mut consonants = Vec::new();\n    for ch in s.chars() {\n        match ch\
    \ {\n            'a' | '.' | ',' | ';' | '?' | '!' | '\\'' | '/' | '-' | ':' |\
    \ '_' | '@' | '%' => consonants.push(ch),\n            'a' | 'b' | 'c' | 'd' |\
    \ 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q'\
    \ | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z' => vowels.push(ch),\n\
    \            _ => (),\n        }\n    }\n    match vowels.len() {\n        0 =>\
    \ Vec::new(),\n        1 => consonants.into_iter().filter_map(|x| x.starts_with(*vowels.as_slice()).collect::<Vec<_>>()).collect::<Vec<_>>(),\n\
    \        _ => consonants.into_iter().filter_map(|x| x.contains(*vowels.as_slice())).collect::<Vec<_>>(),\n\
    \    }.sort_by(|x, y| x.cmp(y)).take(n).collect::<Vec<_>>()\n}\n\nfn main() {\n\
    \    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `starts_with` found for type `char` in the\
    \ current scope\n  --> /tmp/tmp3nvl945a.rs:32:54\n   |\n32 |         1 => consonants.into_iter().filter_map(|x|\
    \ x.starts_with(*vowels.as_slice()).collect::<Vec<_>>()).collect::<Vec<_>>(),\n\
    \   |                                                      ^^^^^^^^^^^ method\
    \ not found in `char`\n\nerror[E0599]: no method named `contains` found for type\
    \ `char` in the current scope\n  --> /tmp/tmp3nvl945a.rs:33:54\n   |\n33 |   \
    \      _ => consonants.into_iter().filter_map(|x| x.contains(*vowels.as_slice())).collect::<Vec<_>>(),\n\
    \   |                                                      ^^^^^^^^ method not\
    \ found in `char`\n\nerror[E0599]: `()` is not an iterator\n  --> /tmp/tmp3nvl945a.rs:34:32\n\
    \   |\n34 |     }.sort_by(|x, y| x.cmp(y)).take(n).collect::<Vec<_>>()\n   | \
    \                               ^^^^ `()` is not an iterator\n   |\n   = note:\
    \ the following trait bounds were not satisfied:\n           `(): Iterator`\n\
    \           which is required by `&mut (): Iterator`\n\nerror: aborting due to\
    \ 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    \n}\n\n\
    fn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3v79g7v6.rs:17:41\n   |\n\
    17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    if s.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut words = vec![];\n    let mut position\
    \ = 0;\n    let mut current_pos = 0;\n    while position < s.len() {\n       \
    \ let mut in_word = false;\n        let mut word = \"\";\n        let mut current_letter\
    \ = 0;\n        while current_pos < position {\n            current_letter = s[current_pos];\n\
    \            if current_letter == ' ' {\n                in_word = false;\n  \
    \              break;\n            } else if current_letter == 'i' || current_letter\
    \ == 'u' || \n                    current_letter == 'e' || current_letter == 'y'\
    \ ||\n                    current_letter == 'o' || current_letter == 'a' ||\n\
    \                    current_letter == 'y' || current_letter == 'u' ||\n     \
    \               current_letter == 'e' || current_letter == 'i' ||\n          \
    \          current_letter == 'y' {\n                in_word = false;\n       \
    \         break;\n            } else {\n                in_word = true;\n    \
    \        }\n            current_pos += 1;\n        }\n        if in_word {\n \
    \           words.push(word);\n        }\n        position = current_pos;\n  \
    \  }\n    words.sort_by_key(|w| w.len());\n    words.dedup();\n    words.filter(\
    \ |w| w.len() == n)\n}\n\nfn main() {\n    let candidate = select_words;\n   \
    \ assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpb8o5tgfi.rs:29:30\n\
    \   |\n29 |             current_letter = s[current_pos];\n   |               \
    \               ^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpb8o5tgfi.rs:30:34\n   |\n30 |             if\
    \ current_letter == ' ' {\n   |                                  ^^^ expected\
    \ integer, found `char`\n\nerror[E0277]: can't compare `{integer}` with `char`\n\
    \  --> /tmp/tmpb8o5tgfi.rs:30:31\n   |\n30 |             if current_letter ==\
    \ ' ' {\n   |                               ^^ no implementation for `{integer}\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `{integer}`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb8o5tgfi.rs:33:41\n\
    \   |\n33 |             } else if current_letter == 'i' || current_letter == 'u'\
    \ || \n   |                                         ^^^ expected integer, found\
    \ `char`\n\nerror[E0277]: can't compare `{integer}` with `char`\n  --> /tmp/tmpb8o5tgfi.rs:33:38\n\
    \   |\n33 |             } else if current_letter == 'i' || current_letter == 'u'\
    \ || \n   |                                      ^^ no implementation for `{integer}\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `{integer}`\n   = help: the following other types implement trait `PartialEq<Rh"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words: Vec<String> = vec![];\n    let mut i = 0;\n    while i < s.len() {\n\
    \        if s.chars().filter(|c| {\n            if c == '_' || c == 'A' || c ==\
    \ 'E' || c == 'I' || c == 'O' || c == 'U'\n                || c == 'a' || c ==\
    \ 'e' || c == 'i' || c == 'o' || c == 'u'\n                || c == 'U' || c ==\
    \ 'i' || c == 'e' || c == 'o' || c == 'a'\n                || c == 'u' || c ==\
    \ 'U' || c == 'i' || c == 'e' || c == 'o'\n                || c == 'a'\n     \
    \           || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A'\n    \
    \            || c == 'E' || c == 'I' || c == 'O' || c == 'U' || c == 'U'\n   \
    \             || c == 'O' || c == 'I' || c == 'I'\n                || c == 'a'\
    \ || c == 'e' || c == 'i' || c == 'o' || c == 'u'\n                || c == 'A'\
    \ || c == 'E' || c == 'I' || c == 'O' || c == 'U'\n                || c == 'U'\
    \ || c == 'O' || c == 'I' || c == 'I' || c == 'a'\n                || c == 'e'\
    \ || c == 'i' || c == 'o' || c == 'u' || c == 'A'\n                || c == 'E'\
    \ || c == 'I' || c == 'O' || c == 'U' || c == 'U'\n                || c == 'O'\
    \ || c == 'I' || c == 'I' || c == 'a'\n                || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u' || c == 'A'\n                || c == 'E' || c == 'I'\
    \ || c == 'O' || c == 'U' || c == 'U'\n                || c == 'O' || c == 'I'\
    \ || c == 'I' || c == 'a' || c == 'e'\n                || c == 'i' || c == 'o'\
    \ || c == 'u' || c == 'A' || c == 'E'\n                || c == 'I' || c == 'O'\
    \ || c == 'U' || c == 'U' || c == 'O'\n                || c == 'I' || c == 'I'\n\
    \                || c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'\n\
    \                || c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U'\n\
    \                || c == 'U' || c == 'O' || c == 'I' || c == 'I\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp7tc71mhx.rs:56:3\n\
    \   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |      \
    \                                               - unclosed delimiter\n...\n20\
    \ |     while i < s.len() {\n   |                       - unclosed delimiter\n\
    21 |         if s.chars().filter(|c| {\n   |                            - unclosed\
    \ delimiter\n...\n56 | }\n   |   ^\n\nerror: expected `while`, `for`, `loop` or\
    \ `{` after a label\n  --> /tmp/tmp7tc71mhx.rs:45:1\n   |\n45 | }\n   | ^ expected\
    \ `while`, `for`, `loop` or `{` after a label\n\nerror: expected expression, found\
    \ `}`\n  --> /tmp/tmp7tc71mhx.rs:45:1\n   |\n45 | }\n   | ^ expected expression\n\
    \nerror: expected one of `)`, `,`, `.`, `?`, or an operator, found keyword `fn`\n\
    \  --> /tmp/tmp7tc71mhx.rs:47:1\n   |\n45 | }\n   |  - expected one of `)`, `,`,\
    \ `.`, `?`, or an operator\n46 | \n47 | fn main() {\n   | ^^ unexpected token\n\
    \nerror: expected `{`, found keyword `fn`\n  --> /tmp/tmp7tc71mhx.rs:47:1\n  \
    \ |\n21 |         if s.chars().filter(|c| {\n   |         -- this `if` expression\
    \ has a condition, but no block\n...\n47 | fn main() {\n   | ^^ expected `{`\n\
    \   |\nhelp: try placing this code inside a block\n   |\n47 ~ { fn main() {\n\
    48 |     let candidate = select_words;\n49 |     assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n50 |     assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n51 |     assert_eq!(candidate(String::from(\"simple white space\"), 2),\
    \ Vec::<String>::new());\n52 |     assert_eq!(candidate(String::from(\"Hello world\"\
    ), 4), vec![String::from(\"world\")]);\n ...\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp7tc71mhx.rs:20:5\n   |\n17 |   fn select_words(s: String, n: isize)\
    \ -> Vec<String> {\n   |                                           -----------\
    \ expected `Vec<String>` because of return type\n...\n20 | /     while i < s.len()\
    \ {\n21 | |         if s.chars().filter(|c| {\n22 | |             if c == '_'\
    \ || c == 'A' || c == 'E' || c == 'I"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ v: Vec<String> = Vec::new();\n    v.push((&s[..]).iter().filter(|&c| c == &n).collect::<Vec<_>>());\n\
    \    if s.is_empty() {\n        Vec::new()\n    } else {\n        v.iter().cloned().filter(|x|\
    \ x.chars().any(|&c| c != n)).collect()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for reference `&str` in the\
    \ current scope\n  --> /tmp/tmpm5isj1e6.rs:19:21\n   |\n19 |     v.push((&s[..]).iter().filter(|&c|\
    \ c == &n).collect::<Vec<_>>());\n   |                     ^^^^ method not found\
    \ in `&str`\n   |\nhelp: because of the in-memory representation of `&str`, to\
    \ obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n19\
    \ |     v.push((&s[..]).chars().filter(|&c| c == &n).collect::<Vec<_>>());\n \
    \  |                     ~~~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpm5isj1e6.rs:23:53\n\
    \   |\n23 |         v.iter().cloned().filter(|x| x.chars().any(|&c| c != n)).collect()\n\
    \   |                                                     ^--\n   |          \
    \                                           ||\n   |                         \
    \                            |expected due to this\n   |                     \
    \                                expected `char`, found reference\n   |      \
    \                                               help: did you mean `c`: `&char`\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    \n    for ch in s.chars() {\n        if ch.is_ascii_letter_or_digit()\
    \ || ch.is_ascii_whitespace() || ch.is_ascii_punctuation() {\n            let\
    \ word = s.split_whitespace().collect::<Vec<_>>();\n            if word.len()\
    \ == n {\n                words.push(String::from(word));\n            }\n   \
    \     }\n    }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter_or_digit` found for type\
    \ `char` in the current scope\n  --> /tmp/tmp3trqn39d.rs:21:15\n   |\n21 |   \
    \      if ch.is_ascii_letter_or_digit() || ch.is_ascii_whitespace() || ch.is_ascii_punctuation()\
    \ {\n   |               ^^^^^^^^^^^^^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `is_ascii_digit`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp3trqn39d.rs:23:30\n   |\n23 |             if word.len() == n {\n\
    \   |                              ^ expected `usize`, found `isize`\n   |\nhelp:\
    \ you can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n23 |             if word.len() == n.try_into().unwrap() {\n   | \
    \                              ++++++++++++++++++++\n\nerror[E0277]: the trait\
    \ bound `String: From<Vec<&str>>` is not satisfied\n  --> /tmp/tmp3trqn39d.rs:24:28\n\
    \   |\n24 |                 words.push(String::from(word));\n   |            \
    \                ^^^^^^^^^^^^ the trait `From<Vec<&str>>` is not implemented for\
    \ `String`\n   |\n   = help: the following other types implement trait `From<T>`:\n\
    \             <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    // Your\
    \ code here\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptu_480ft.rs:17:41\n   |\n\
    17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    \n    let\
    \ mut result = Vec::new();\n\n    let mut consonants = vec![\n        String::from(\"\
    BCDFGHJKLMNPQRSTVWXYZ\"),\n        String::from(\"LDFHJLKSMRTYUIVC\"),\n     \
    \   String::from(\"MNPRTWXYZ\"),\n    ];\n\n    if s.is_empty() {\n        return\
    \ result;\n    }\n\n    for i in 0..s.len() {\n        if consonants.contains(&s[i])\
    \ {\n            result.push(s.to_string());\n            consonants.retain(|c|\
    \ !c.contains(&s[i]));\n            if consonants.len() == n {\n             \
    \   break;\n            }\n        }\n    }\n\n    result\n}\n\nfn main() {\n\
    \    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpkbci5_bg.rs:32:33\n\
    \   |\n32 |         if consonants.contains(&s[i]) {\n   |                    \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpkbci5_bg.rs:34:48\n   |\n34 |             consonants.retain(|c|\
    \ !c.contains(&s[i]));\n   |                                                ^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkbci5_bg.rs:35:36\n\
    \   |\n35 |             if consonants.len() == n {\n   |                     \
    \               ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    35 |             if consonants.len() == n.try_into().unwrap() {\n   |        \
    \                             ++++++++++++++++++++\n\nerror: aborting due to 3\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ out = vec![];\n    let mut current_word = \"\";\n    let mut vowels = \"aeiou\"\
    ;\n    \n    for c in s.chars() {\n        if vowels.contains(&c.to_lowercase())\
    \ {\n            if current_word.len() == n {\n                out.push(current_word);\n\
    \                current_word = \"\";\n            }\n            current_word.push_str(&c);\n\
    \        } else {\n            if current_word.len() == n {\n                out.push(current_word);\n\
    \                current_word = \"\";\n            }\n            current_word.push_str(&c);\n\
    \        }\n    }\n    if current_word.len() > 0 {\n        out.push(current_word);\n\
    \    }\n    out\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `ToLowercase`\n \
    \   --> /tmp/tmpvbynb4vo.rs:23:28\n     |\n23   |         if vowels.contains(&c.to_lowercase())\
    \ {\n     |                   -------- ^^^^^^^^^^^^^^^^^ expected an `Fn<(char,)>`\
    \ closure, found `ToLowercase`\n     |                   |\n     |           \
    \        required by a bound introduced by this call\n     |\n     = help: the\
    \ trait `Fn<(char,)>` is not implemented for `ToLowercase`\n     = help: the following\
    \ other types implement trait `Pattern<'a>`:\n               &'b String\n    \
    \           &'b [char; N]\n               &'b [char]\n               &'b str\n\
    \               &'c &'b str\n               [char; N]\n               char\n \
    \              pattern::MultiCharEqPattern<C>\n     = note: required because of\
    \ the requirements on the impl of `FnOnce<(char,)>` for `&ToLowercase`\n     =\
    \ note: required because of the requirements on the impl of `Pattern<'_>` for\
    \ `&ToLowercase`\nnote: required by a bound in `core::str::<impl str>::contains`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpvbynb4vo.rs:24:38\n   |\n24 |\
    \             if current_word.len() == n {\n   |                             \
    \         ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n24 |      \
    \       if current_word.len() == n.try_into().unwrap() {\n   |               \
    \                        ++++++++++++++++++++\n\nerror[E0599]: no method named\
    \ `push_str` found for reference `&str` in the current scope\n  --> /tmp/tmpvbynb4vo.rs:28:26\n\
    \   |\n28 |             current_word.push_str(&c);\n   |                     \
    \     ^^^^^^^^ method not found in `&str`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpvbynb4vo.rs:30:38\n   |\n30 |             if current_word.len()\
    \ == n {\n   |                                      ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n30 |             if current_word.len() ==\
    \ n.try_into().unwrap() {\n   |                        "
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    assert!(s.chars().count()\
    \ == n);\n    \n    // convert String to vector of chars\n    let mut chars =\
    \ s.chars();\n    \n    // count consonants in string\n    let mut cnt = 0;\n\
    \    for c in chars {\n        cnt += is_vowel(c);\n    }\n    \n    // remove\
    \ consonants form string\n    let mut chars = chars.filter(|c|!is_vowel(c));\n\
    \    \n    // slice vector by count of consonants\n    let mut chars = chars.chunks(n);\n\
    \    \n    // flatten vector to a vector\n    let chars: Vec<String> = chars.collect();\n\
    \    \n    // remove any empty strings\n    chars.retain(|s| !s.is_empty());\n\
    \    \n    return chars\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmputc70m1a.rs:26:16\n\
    \   |\n26 |         cnt += is_vowel(c);\n   |                ^^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `is_vowel` in this scope\n\
    \  --> /tmp/tmputc70m1a.rs:30:38\n   |\n30 |     let mut chars = chars.filter(|c|!is_vowel(c));\n\
    \   |                                      ^^^^^^^^ not found in this scope\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmputc70m1a.rs:18:34\n   |\n18 |  \
    \   assert!(s.chars().count() == n);\n   |                                  ^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n18 |     assert!(s.chars().count()\
    \ == n.try_into().unwrap());\n   |                                   ++++++++++++++++++++\n\
    \nerror[E0599]: no method named `chunks` found for struct `Filter` in the current\
    \ scope\n  --> /tmp/tmputc70m1a.rs:33:27\n   |\n33 |     let mut chars = chars.chunks(n);\n\
    \   |                           ^^^^^^ method not found in `Filter<Chars<'_>,\
    \ [closure@/tmp/tmputc70m1a.rs:30:34: 30:49]>`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result: Vec<String> = vec![];\n    let mut current_word = String::from(\"\"\
    );\n    let mut counter: isize = 0;\n    loop {\n        if counter < n && match\
    \ s.chars().next() {\n            Some(c) if c == 'a' ||\n                c ==\
    \ 'e' ||\n                c == 'i' ||\n                c == 'o' ||\n         \
    \       c == 'u' =>\n                current_word.push(c);\n            Some(c)\
    \ if c == ' ' ||\n                c == '\\n' ||\n                c == '\\t' =>\n\
    \                current_word.push(c);\n            _ =>\n        }\n        if\
    \ counter > n {\n            break;\n        }\n        counter = counter + 1;\n\
    \        result.push(current_word);\n    }\n    result\n}\n\nfn main() {\n   \
    \ let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found keyword `if`\n  --> /tmp/tmpnk9t2iw8.rs:29:21\n\
    \   |\n29 |             Some(c) if c == ' ' ||\n   |                     ^^ expected\
    \ identifier, found keyword\n\nerror: expected one of `,`, `.`, `?`, `}`, or an\
    \ operator, found `;`\n  --> /tmp/tmpnk9t2iw8.rs:28:37\n   |\n27 |           \
    \      c == 'u' =>\n   |                          -- while parsing the `match`\
    \ arm starting here\n28 |                 current_word.push(c);\n   |        \
    \                             ^ expected one of `,`, `.`, `?`, `}`, or an operator\n\
    \nerror: expected `{`, found keyword `if`\n  --> /tmp/tmpnk9t2iw8.rs:35:9\n  \
    \ |\n22 |         if counter < n && match s.chars().next() {\n   |         --\
    \ this `if` expression has a condition, but no block\n...\n35 |         if counter\
    \ > n {\n   |         ^^ expected `{`\n   |\nhelp: try placing this code inside\
    \ a block\n   |\n35 ~         { if counter > n {\n36 |             break;\n37\
    \ ~         } }\n   |\n\nwarning: unreachable expression\n  --> /tmp/tmpnk9t2iw8.rs:41:5\n\
    \   |\n21 | /     loop {\n22 | |         if counter < n && match s.chars().next()\
    \ {\n23 | |             Some(c) if c == 'a' ||\n24 | |                 c == 'e'\
    \ ||\n...  |\n39 | |         result.push(current_word);\n40 | |     }\n   | |_____-\
    \ any code following this expression is unreachable\n41 |       result\n   | \
    \      ^^^^^^ unreachable expression\n   |\n   = note: `#[warn(unreachable_code)]`\
    \ on by default\n\nerror: aborting due to 3 previous errors; 1 warning emitted\n\
    \n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ ret = Vec::new();\n    for i in s.chars() {\n        if i.is_consonant() {\n\
    \            if n == 0 {\n                break;\n            } else {\n     \
    \           ret += &i.to_string();\n                n -= 1;\n            }\n \
    \       }\n    }\n    ret\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpejy4ibyl.rs:20:14\n   |\n20 |         if i.is_consonant()\
    \ {\n   |              ^^^^^^^^^^^^ method not found in `char`\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `Vec<_>`\n  --> /tmp/tmpejy4ibyl.rs:24:17\n\
    \   |\n24 |                 ret += &i.to_string();\n   |                 ---^^^^^^^^^^^^^^^^^^\n\
    \   |                 |\n   |                 cannot use `+=` on type `Vec<_>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0368, E0599.\nFor more information about an error, try `rustc --explain E0368`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    if s.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut words: Vec<String> = vec![];\n\
    \    for w in s.splitn(n as usize) {\n        let mut cur_len = 0;\n        for\
    \ c in w {\n            cur_len += c.len_utf8();\n        }\n        if cur_len\
    \ == n {\n            words.push(w);\n        }\n    }\n    words\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 2 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmpv9w6za1t.rs:23:16\n     |\n23   |     for w in s.splitn(n as\
    \ usize) {\n     |                ^^^^^^ ---------- supplied 1 argument\n    \
    \ |                |\n     |                expected 2 arguments\n     |\nnote:\
    \ associated function defined here\n\nerror[E0277]: `&str` is not an iterator\n\
    \  --> /tmp/tmpv9w6za1t.rs:25:18\n   |\n25 |         for c in w {\n   |      \
    \            ^ `&str` is not an iterator; try calling `.chars()` or `.bytes()`\n\
    \   |\n   = help: the trait `Iterator` is not implemented for `&str`\n   = note:\
    \ required because of the requirements on the impl of `IntoIterator` for `&str`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpv9w6za1t.rs:29:24\n   |\n29 |\
    \             words.push(w);\n   |                        ^- help: try using a\
    \ conversion method: `.to_string()`\n   |                        |\n   |     \
    \                   expected struct `String`, found `&str`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0061, E0277,\
    \ E0308.\nFor more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    for (i, char) in s.chars().enumerate() {\n        match\
    \ char {\n            'a' => words.push(i),\n            'e' => words.push(i),\n\
    \            'i' => words.push(i),\n            'o' => words.push(i),\n      \
    \      'u' => words.push(i),\n            _ => (),\n        }\n    }\n    words.sort_unstable();\n\
    \    let mut n = 0;\n    let mut last_char = s.chars().next().unwrap();\n    words.retain(|&word|\
    \ {\n        if n == n {\n            if last_char == word {\n               \
    \ n += 1;\n                true\n            } else {\n                false\n\
    \            }\n        } else {\n            n = 0;\n            false\n    \
    \    }\n    });\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpo4r1yub4.rs:34:29\n   |\n\
    34 |             if last_char == word {\n   |                             ^^^^\
    \ expected `char`, found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo4r1yub4.rs:45:5\n\
    \   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |      \
    \                                   ----------- expected `Vec<String>` because\
    \ of return type\n...\n45 |     words\n   |     ^^^^^ expected struct `String`,\
    \ found `usize`\n   |\n   = note: expected struct `Vec<String>`\n            \
    \  found struct `Vec<usize>`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ vec: Vec<String> = Vec::new();\n    for &s in s.split_whitespace() {\n     \
    \   let len = s.chars().filter(|&c| c.is_consonant()).count();\n        if len\
    \ == n {\n            vec.push(s);\n        }\n    }\n    vec\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n  --> /tmp/tmpgwwe_20b.rs:19:10\n   |\n19 |     for &s in s.split_whitespace()\
    \ {\n   |          ^ doesn't have a size known at compile-time\n   |\n   = help:\
    \ the trait `Sized` is not implemented for `str`\n   = note: all local variables\
    \ must have a statically known size\n   = help: unsized locals are gated as an\
    \ unstable feature\n\nerror[E0599]: no method named `is_consonant` found for type\
    \ `char` in the current scope\n  --> /tmp/tmpgwwe_20b.rs:20:43\n   |\n20 |   \
    \      let len = s.chars().filter(|&c| c.is_consonant()).count();\n   |      \
    \                                     ^^^^^^^^^^^^ method not found in `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpgwwe_20b.rs:21:19\n   |\n21 |\
    \         if len == n {\n   |                   ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n21 |         if len == n.try_into().unwrap() {\n  \
    \ |                    ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpgwwe_20b.rs:22:22\n   |\n22 |             vec.push(s);\n   |  \
    \                    ^- help: try using a conversion method: `.to_string()`\n\
    \   |                      |\n   |                      expected struct `String`,\
    \ found `str`\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    select_words(s,\
    \ n, 0)\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 2 arguments but 3 arguments were supplied\n\
    \  --> /tmp/tmpsqrjp1y3.rs:18:5\n   |\n18 |     select_words(s, n, 0)\n   |  \
    \   ^^^^^^^^^^^^ -  -  - supplied 3 arguments\n   |     |\n   |     expected 2\
    \ arguments\n   |\nnote: function defined here\n  --> /tmp/tmpsqrjp1y3.rs:17:4\n\
    \   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ^^^^^^^^^^^^\
    \ ---------  --------\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    // BEGIN\
    \ Question 4\n    // Declare a function select_words which:\n    // - Takes in\
    \ 2 arguments\n    // - Returns an `Vec<String>` of words\n    // - You are expected\
    \ to use Vec::append.\n    let mut select_words = Vec::new();\n    // BEGIN Question\
    \ 4\n    for i in s.split_whitespace() {\n        // Check if the word contains\
    \ n\n        if i.chars().count() == n {\n            // Append the word to the\
    \ vector\n            select_words.push(String::from(i));\n        }\n    }\n\
    \    // END Question 4\n    select_words\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmps98uy6nc.rs:27:33\n   |\n\
    27 |         if i.chars().count() == n {\n   |                               \
    \  ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to\
    \ a `usize` and panic if the converted value doesn't fit\n   |\n27 |         if\
    \ i.chars().count() == n.try_into().unwrap() {\n   |                         \
    \         ++++++++++++++++++++\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    \n    let mut word_array = s.split_whitespace();\n\
    \    \n    let mut count = 0;\n    \n    for word in word_array {\n        \n\
    \        let mut word_string = word;\n        \n        loop {\n            \n\
    \            if word_string.contains(String::from(\"[aeiouyAEIOUY]\")) == false\
    \ {\n                \n                result.push(word_string.clone());\n   \
    \             \n                break;\n                \n            }\n    \
    \        \n            count += 1;\n            \n            if count == n {\n\
    \                \n                break;\n                \n            }\n \
    \           \n            word_string = word_string.clone();\n            \n \
    \       }\n        \n    }\n    \n    result\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n   \
    \ --> /tmp/tmpmfs0ir_j.rs:30:37\n     |\n30   |             if word_string.contains(String::from(\"\
    [aeiouyAEIOUY]\")) == false {\n     |                            -------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected an implementor of trait `Pattern<'_>`\n     |                     \
    \       |\n     |                            required by a bound introduced by\
    \ this call\n     |\n     = note: the trait bound `String: Pattern<'_>` is not\
    \ satisfied\n     = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `String`\nnote: required by a bound in `core::str::<impl str>::contains`\n\
    help: consider borrowing here\n     |\n30   |             if word_string.contains(&String::from(\"\
    [aeiouyAEIOUY]\")) == false {\n     |                                     +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpmfs0ir_j.rs:52:5\n   |\n17 | fn\
    \ select_words(s: String, n: isize) -> Vec<String> {\n   |                   \
    \                      ----------- expected `Vec<String>` because of return type\n\
    ...\n52 |     result\n   |     ^^^^^^ expected struct `String`, found `&str`\n\
    \   |\n   = note: expected struct `Vec<String>`\n              found struct `Vec<&str>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    if n ==\
    \ 0 {\n        return vec![];\n    }\n    let mut words = vec![];\n    for w in\
    \ s.split_whitespace() {\n        let mut count = 0;\n        for c in w.chars()\
    \ {\n            count += c as usize - 'a' as usize;\n        }\n        if count\
    \ == n {\n            words.push(w);\n        }\n    }\n    words\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk0fgor_k.rs:27:21\n   |\n\
    27 |         if count == n {\n   |                     ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n27 |         if count == n.try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpk0fgor_k.rs:31:5\n   |\n17 | fn select_words(s: String,\
    \ n: isize) -> Vec<String> {\n   |                                         -----------\
    \ expected `Vec<String>` because of return type\n...\n31 |     words\n   |   \
    \  ^^^^^ expected struct `String`, found `&str`\n   |\n   = note: expected struct\
    \ `Vec<String>`\n              found struct `Vec<&str>`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"\
    ];\n    let mut consonants = vec![\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"\
    j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"\
    w\", \"x\", \"y\", \"z\"];\n    let mut last_consonant_in_word: usize = 0;\n \
    \   let mut i = 0;\n    let mut j = 0;\n    while j < s.len() {\n        if s.chars().nth(i).unwrap()\
    \ == 'a' || s.chars().nth(i).unwrap() == 'e' || s.chars().nth(i).unwrap() == 'i'\
    \ || s.chars().nth(i).unwrap() == 'o' || s.chars().nth(i).unwrap() == 'u' {\n\
    \            i += 1;\n            words.insert(s.chars().nth(j).unwrap().to_string(),\
    \ 1);\n            last_consonant_in_word = i;\n        }\n        else if s.chars().nth(i).unwrap()\
    \ == 'b' || s.chars().nth(i).unwrap() == 'c' || s.chars().nth(i).unwrap() == 'd'\
    \ || s.chars().nth(i).unwrap() == 'f' || s.chars().nth(i).unwrap() == 'g' || s.chars().nth(i).unwrap()\
    \ == 'h' || s.chars().nth(i).unwrap() == 'j' || s.chars().nth(i).unwrap() == 'k'\
    \ || s.chars().nth(i).unwrap() == 'l' || s.chars().nth(i).unwrap() == 'm' || s.chars().nth(i).unwrap()\
    \ == 'n' || s.chars().nth(i).unwrap() == 'p' || s.chars().nth(i).unwrap() == 'q'\
    \ || s.chars().nth(i).unwrap() == 'r' || s.chars().nth(i).unwrap() == 's' || s.chars().nth(i).unwrap()\
    \ == 't' || s.chars().nth(i).unwrap() == 'v' || s.chars().nth(i).unwrap() == 'w'\
    \ || s.chars().nth(i).unwrap() == 'x' || s.chars().nth(i).unwrap() == 'y' || s.chars().nth(i).unwrap()\
    \ == 'z' {\n            i += 1;\n            words.insert(s.chars().nth(j).unwrap().to_string(),\
    \ 1);\n            last_consonant_in_word = i;\n        }\n        else {\n  \
    \          if s.chars().nth(i).unwrap() == 'a' || s.chars().nth(i).unwrap() ==\
    \ 'e' || s.chars().nth(i).unwrap() == 'i' || s.chars().nth(i).unwrap() == 'o'\
    \ || s.chars().nth(i).unwrap() == 'u' {\n                last_consonant_in_word\
    \ += 1;\n            }\n            else {\n                last_consonant_in_word\
    \ += 1;\n            }\n            i += \n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpg5ag7dyu.rs:54:3\n\
    \   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |      \
    \                                               - unclosed delimiter\n...\n24\
    \ |     while j < s.len() {\n   |                       - unclosed delimiter\n\
    ...\n35 |         else {\n   |              - this delimiter might not be properly\
    \ closed...\n...\n43 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n54 | }\n   |   ^\n\nerror: expected expression, found `}`\n  --> /tmp/tmpg5ag7dyu.rs:43:1\n\
    \   |\n43 | }\n   | ^ expected expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpg5ag7dyu.rs:27:26\n   |\n27 |             words.insert(s.chars().nth(j).unwrap().to_string(),\
    \ 1);\n   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `usize`, found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg5ag7dyu.rs:32:26\n\
    \   |\n32 |             words.insert(s.chars().nth(j).unwrap().to_string(), 1);\n\
    \   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `usize`, found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg5ag7dyu.rs:24:5\n\
    \   |\n17 |   fn select_words(s: String, n: isize) -> Vec<String> {\n   |    \
    \                                       ----------- expected `Vec<String>` because\
    \ of return type\n...\n24 | /     while j < s.len() {\n25 | |         if s.chars().nth(i).unwrap()\
    \ == 'a' || s.chars().nth(i).unwrap() == 'e' || s.chars().nth(i).unwrap() == 'i'\
    \ || s.chars().nth(i).u...\n26 | |             i += 1;\n27 | |             words.insert(s.chars().nth(j).unwrap().to_string(),\
    \ 1);\n...  |\n53 | |     assert_eq!(candidate(String::from(\"a b c d e f\"),\
    \ 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"\
    f\")]);\n54 | | }\n   | |__^ expected struct `Vec`, found `()`\n   |\n   = note:\
    \ expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 5 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    s.split_whitespace().filter(|&c|\
    \ c.chars().count() <= n).collect()\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprv_eqc64.rs:18:59\n   |\n\
    18 |     s.split_whitespace().filter(|&c| c.chars().count() <= n).collect()\n\
    \   |                                                           ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n18 |     s.split_whitespace().filter(|&c|\
    \ c.chars().count() <= n.try_into().unwrap()).collect()\n   |                \
    \                                            ++++++++++++++++++++\n\nerror[E0277]:\
    \ a value of type `Vec<String>` cannot be built from an iterator over elements\
    \ of type `&str`\n    --> /tmp/tmprv_eqc64.rs:18:62\n     |\n18   |     s.split_whitespace().filter(|&c|\
    \ c.chars().count() <= n).collect()\n     |                                  \
    \                            ^^^^^^^ value of type `Vec<String>` cannot be built\
    \ from `std::iter::Iterator<Item=&str>`\n     |\n     = help: the trait `FromIterator<&str>`\
    \ is not implemented for `Vec<String>`\n     = help: the trait `FromIterator<T>`\
    \ is implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    vec![*select_words(s,\
    \ n, \"\")].iter().cloned().collect()\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 2 arguments but 3 arguments were supplied\n\
    \  --> /tmp/tmp2vefcl5m.rs:18:11\n   |\n18 |     vec![*select_words(s, n, \"\"\
    )].iter().cloned().collect()\n   |           ^^^^^^^^^^^^ -  -  -- supplied 3\
    \ arguments\n   |           |\n   |           expected 2 arguments\n   |\nnote:\
    \ function defined here\n  --> /tmp/tmp2vefcl5m.rs:17:4\n   |\n17 | fn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n   |    ^^^^^^^^^^^^ ---------  --------\n\
    \nerror[E0277]: the size for values of type `[String]` cannot be known at compilation\
    \ time\n   --> /tmp/tmp2vefcl5m.rs:18:5\n    |\n18  |     vec![*select_words(s,\
    \ n, \"\")].iter().cloned().collect()\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized`\
    \ is not implemented for `[String]`\nnote: required by a bound in `slice::<impl\
    \ [T]>::into_vec`\n    = note: this error originates in the macro `vec` (in Nightly\
    \ builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: the size\
    \ for values of type `[String]` cannot be known at compilation time\n  --> /tmp/tmp2vefcl5m.rs:18:5\n\
    \   |\n18 |     vec![*select_words(s, n, \"\")].iter().cloned().collect()\n  \
    \ |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n\
    \   |\n   = help: the trait `Sized` is not implemented for `[String]`\n   = note:\
    \ slice and array elements must have `Sized` type\n   = note: this error originates\
    \ in the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more\
    \ info)\n\nerror[E0599]: no method named `iter` found for struct `Vec` in the\
    \ current scope\n  --> /tmp/tmp2vefcl5m.rs:18:35\n   |\n18 |     vec![*select_words(s,\
    \ n, \"\")].iter().cloned().collect()\n   |                                  \
    \ ^^^^ method not found in `Vec<[String]>`\n\nerror[E0277]: the size for values\
    \ of type `[String]` cannot be known at compilation time\n   --> /tmp/tmp2vefcl5m.rs:18:5\n\
    \    |\n18  |     vec![*select_words(s, n, \"\")].iter().cloned().collect()\n\
    \    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n\
    \    |\n    = hel"
  stdout: ''
  timestamp: 1660010887
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    vec![]\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"little\"]`', /tmp/tmp1sy5pnx1.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ char_counts = String::new();\n    let mut vowels = String::new();\n    let mut\
    \ caps = String::new();\n    let mut upper_case = String::new();\n    let mut\
    \ lower_case = String::new();\n    let mut word_chars = String::new();\n    let\
    \ mut word_counts = Vec::new();\n    let mut word: String = String::new();\n \
    \   for c in s.chars() {\n        let c = c.to_ascii_lowercase();\n        if\
    \ (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            vowels.push(c);\n\
    \        }\n        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'\
    \ || c == 'y' {\n            caps.push(c);\n        }\n        if c == 'a' ||\
    \ c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c ==\
    \ 'I' || c == 'O' || c == 'U' || c == 'Y' {\n            upper_case.push(c);\n\
    \        }\n        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'\
    \ || c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'y' || c\
    \ == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n            lower_case.push(c);\n\
    \        }\n        char_count += 1;\n    }\n    word_chars = upper_case.chars().filter(|c|\
    \ c == c || c == c || c == c || c == c || c == c || c == c || c == c || c == c\
    \ || c == c || c == c || c == c || c == c || c == c || c == c || c == c || c ==\
    \ c || c == c || c == c || c == c || c == c || c == c || c == c || c == c || c\
    \ == c || c == c || c == c || c == c || c == c || c == c || c == c || c == c ||\
    \ c == c || c == c || c == c || c == c || c == c || c == c || c == c || c == c\
    \ || c == c || c == c || c == c || c == c || c == c || c == c || c == c || c ==\
    \ c || c == c || c == c || c == c || c == c || c == c || c == c || c == c || c\
    \ == c || c == c || c == c || c == c || c == c || c == c || c == c || c == c ||\
    \ c == c || c == c || c == c || c == c || c == \n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpf2q4pequ.rs:42:43\n\
    \   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |      \
    \                                               - closing delimiter possibly meant\
    \ for this\n...\n42 |     word_chars = upper_case.chars().filter(|c| c == c ||\
    \ c == c || c == c || c == c || c == c || c == c || c == c || c == c || c == c\
    \ || ...\n   |                                           ^ unclosed delimiter\n\
    43 | }\n   | ^ mismatched closing delimiter\n\nerror: expected expression, found\
    \ `)`\n  --> /tmp/tmpf2q4pequ.rs:43:1\n   |\n43 | }\n   | ^ expected expression\n\
    \nerror[E0425]: cannot find value `char_count` in this scope\n  --> /tmp/tmpf2q4pequ.rs:40:9\n\
    \   |\n40 |         char_count += 1;\n   |         ^^^^^^^^^^ help: a local variable\
    \ with a similar name exists: `char_counts`\n\nwarning: unnecessary parentheses\
    \ around `if` condition\n  --> /tmp/tmpf2q4pequ.rs:28:12\n   |\n28 |         if\
    \ (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n   |         \
    \   ^                                                        ^\n   |\n   = note:\
    \ `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n\
    28 -         if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n\
    28 +         if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n \
    \  | \n\nerror: aborting due to 3 previous errors; 1 warning emitted\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    // TODO:\
    \ Write your code here.\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpn2m2zo5m.rs:17:41\n   |\n\
    17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    // TODO\
    \ - your code goes here\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpq5kz1vhq.rs:17:41\n   |\n\
    17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ counts = Vec::new();\n    let mut words: Vec<String> = Vec::new();\n    let\
    \ mut word = String::from(\"\");\n    for c in s.chars() {\n        if c == '\
    \ ' {\n            if word.is_empty() {\n                continue;\n         \
    \   } else {\n                words.push(word);\n            }\n            word\
    \ = String::from(\"\");\n        } else if c.is_lowercase() && c.is_ascii() &&\
    \ !c.is_uppercase() {\n            let mut n = 1;\n            if let Some(mut\
    \ count) = counts.iter_mut().find(|&(_, count)| count > n) {\n               \
    \ count.0 += 1;\n            } else {\n                counts.push((c, 1));\n\
    \            }\n            word += c;\n        } else {\n            let mut\
    \ count = counts.iter().find(|&(_, count)| count > n);\n            if let Some(mut\
    \ count) = count {\n                count.0 += 1;\n            } else {\n    \
    \            counts.push((c, 1));\n            }\n            word += c;\n   \
    \     }\n    }\n    if word.is_empty() {\n        return Vec::new();\n    }\n\
    \    words.push(word);\n    words.sort_by_key(|word| word);\n    words\n}\n\n\
    fn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgkj8_1vm.rs:31:83\n   |\n\
    31 |             if let Some(mut count) = counts.iter_mut().find(|&(_, count)|\
    \ count > n) {\n   |                                                         \
    \                          ^\n   |                                           \
    \                                        |\n   |                             \
    \                                                      expected `&mut _`, found\
    \ integer\n   |                                                              \
    \                     help: consider mutably borrowing here: `&mut n`\n   |\n\
    \   = note: expected mutable reference `&mut _`\n                           found\
    \ type `{integer}`\n\nerror[E0277]: cannot add-assign `{integer}` to `char`\n\
    \  --> /tmp/tmpgkj8_1vm.rs:32:25\n   |\n32 |                 count.0 += 1;\n \
    \  |                         ^^ no implementation for `char += {integer}`\n  \
    \ |\n   = help: the trait `AddAssign<{integer}>` is not implemented for `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpgkj8_1vm.rs:36:21\n   |\n36 |\
    \             word += c;\n   |                     ^ expected `&str`, found `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpgkj8_1vm.rs:38:70\n   |\n38 |\
    \             let mut count = counts.iter().find(|&(_, count)| count > n);\n \
    \  |                                                                      ^\n\
    \   |                                                                      |\n\
    \   |                                                                      expected\
    \ reference, found `isize`\n   |                                             \
    \                         help: consider borrowing here: `&n`\n   |\n   = note:\
    \ expected reference `&_`\n                   found type `isize`\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `char`\n  --> /tmp/tmpgkj8_1vm.rs:40:17\n\
    \   |\n40 |                 count.0 += 1;\n   |                 -------^^^^^\n\
    \   |                 |\n   |                 cannot use `+=` on type `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpgkj8_1vm.rs:44:2"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    if s.is_empty()\
    \ {\n        return Vec::new();\n    }\n\n    let mut result = vec![];\n    let\
    \ mut count = 0;\n\n    for c in s.chars() {\n        if c.is_vowel() {\n    \
    \        if count == n {\n                result.push(s.sub_string(0, c));\n \
    \               break;\n            }\n            count += 1;\n        } else\
    \ {\n            count = 0;\n        }\n    }\n\n    result\n}\n\nfn main() {\n\
    \    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpnmf7pjuy.rs:26:14\n   |\n26 |         if c.is_vowel() {\n\
    \   |              ^^^^^^^^ method not found in `char`\n\nerror[E0599]: no method\
    \ named `sub_string` found for struct `String` in the current scope\n  --> /tmp/tmpnmf7pjuy.rs:28:31\n\
    \   |\n28 |                 result.push(s.sub_string(0, c));\n   |           \
    \                    ^^^^^^^^^^ method not found in `String`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    match s.len()\
    \ {\n        0 => vec![],\n        _ => s.chars().filter(|&c| c !='a' && c !='e'\
    \ && c !='i' && c !='o' && c !='u' && c !='y' && c != ' ').cloned().collect(),\n\
    \    }.iter().filter(|&c| c as usize == n).cloned().collect()\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<Filter<Chars<'_>, [closure@/tmp/tmp5h9usdmv.rs:20:31:\
    \ 20:110]> as Iterator>::Item == &_`\n    --> /tmp/tmp5h9usdmv.rs:20:112\n   \
    \  |\n20   |         _ => s.chars().filter(|&c| c !='a' && c !='e' && c !='i'\
    \ && c !='o' && c !='u' && c !='y' && c != ' ').cloned().collect(),\n     |  \
    \                                                                            \
    \                                  ^^^^^^ expected reference, found `char`\n \
    \    |\n     = note: expected reference `&_`\n                     found type\
    \ `char`\nnote: required by a bound in `cloned`\n\nerror[E0599]: the method `collect`\
    \ exists for struct `Cloned<Filter<Chars<'_>, [closure@/tmp/tmp5h9usdmv.rs:20:31:\
    \ 20:110]>>`, but its trait bounds were not satisfied\n  --> /tmp/tmp5h9usdmv.rs:20:121\n\
    \   |\n20 |            _ => s.chars().filter(|&c| c !='a' && c !='e' && c !='i'\
    \ && c !='o' && c !='u' && c !='y' && c != ' ').cloned().collect(),\n   |    \
    \                                                                            \
    \                                            ^^^^^^^ method cannot be called on\
    \ `Cloned<Filter<Chars<'_>, [closure@/tmp/tmp5h9usdmv.rs:20:31: 20:110]>>` due\
    \ to unsatisfied trait bounds\n   |\n   = note: the following trait bounds were\
    \ not satisfied:\n           `<Filter<Chars<'_>, [closure@/tmp/tmp5h9usdmv.rs:20:31:\
    \ 20:110]> as Iterator>::Item = &_`\n           which is required by `Cloned<Filter<Chars<'_>,\
    \ [closure@/tmp/tmp5h9usdmv.rs:20:31: 20:110]>>: Iterator`\n           `Cloned<Filter<Chars<'_>,\
    \ [closure@/tmp/tmp5h9usdmv.rs:20:31: 20:110]>>: Iterator`\n           which is\
    \ required by `&mut Cloned<Filter<Chars<'_>, [closure@/tmp/tmp5h9usdmv.rs:20:31:\
    \ 20:110]>>: Iterator`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5h9usdmv.rs:21:40\n\
    \   |\n21 |     }.iter().filter(|&c| c as usize == n).cloned().collect()\n   |\
    \                                        ^ expected `usize`, found `isize`\n \
    \  |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n21 |     }.iter().filter(|&c| c as usize"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    select_words_with_memory(s.to_string(),\
    \ n)\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `select_words_with_memory` in this scope\n\
    \  --> /tmp/tmplkna8sky.rs:18:5\n   |\n18 |     select_words_with_memory(s.to_string(),\
    \ n)\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = Vec::new();\n    if s.is_empty() {\n        return words;\n    }\n\n\
    \    for c in s.chars() {\n        if c.is_ascii() {\n            if c == ' '\
    \ || c == '\\t' {\n                continue;\n            }\n            if c.is_consonant()\
    \ && c.is_uppercase() && c.is_ascii() {\n                words.push(s.split_whitespace().next().unwrap());\n\
    \                if words.len() == n {\n                    words.push(s);\n \
    \               }\n            }\n        }\n    }\n\n    words\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmp4vgxhjrf.rs:28:18\n   |\n28 |             if c.is_consonant()\
    \ && c.is_uppercase() && c.is_ascii() {\n   |                  ^^^^^^^^^^^^ method\
    \ not found in `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4vgxhjrf.rs:29:28\n\
    \   |\n29 |                 words.push(s.split_whitespace().next().unwrap());\n\
    \   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try\
    \ using a conversion method: `.to_string()`\n   |                            |\n\
    \   |                            expected struct `String`, found `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp4vgxhjrf.rs:30:35\n   |\n30 |              \
    \   if words.len() == n {\n   |                                   ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n30 |                 if words.len()\
    \ == n.try_into().unwrap() {\n   |                                    ++++++++++++++++++++\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    if s.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut result = vec![];\n\n    let\
    \ mut current = 0;\n    let mut last = 0;\n    let mut last_is_consonant = false;\n\
    \n    for pos in s.chars().enumerate().map(|(pos, _)| pos)\n    {\n        if\
    \ current == n {\n            if last != 0 {\n                let word = s[last..pos];\n\
    \                result.push(String::from(word));\n            }\n\n         \
    \   last = pos + 1;\n            current = 0;\n        }\n\n        if let Some(next)\
    \ = pos + 1 {\n            current++;\n        }\n\n        if last_is_consonant\
    \ && (current == 0) {\n            current = 1;\n        }\n\n        last_is_consonant\
    \ = current == 1;\n    }\n\n    if current > 0 {\n        let word = s[last..];\n\
    \        result.push(String::from(word));\n    }\n\n    result\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpgnsd5iam.rs:41:20\n\
    \   |\n41 |             current++;\n   |                    ^^ not a valid postfix\
    \ operator\n   |\nhelp: use `+= 1` instead\n   |\n41 |             { let tmp =\
    \ current; current += 1; tmp };\n   |             +++++++++++        ~~~~~~~~~~~~~~~~~~~~~\n\
    41 -             current++;\n41 +             current += 1;\n   | \n\nerror[E0277]:\
    \ the size for values of type `str` cannot be known at compilation time\n  -->\
    \ /tmp/tmpgnsd5iam.rs:32:21\n   |\n32 |                 let word = s[last..pos];\n\
    \   |                     ^^^^ doesn't have a size known at compile-time\n   |\n\
    \   = help: the trait `Sized` is not implemented for `str`\n   = note: all local\
    \ variables must have a statically known size\n   = help: unsized locals are gated\
    \ as an unstable feature\nhelp: consider borrowing here\n   |\n32 |          \
    \       let word = &s[last..pos];\n   |                            +\n\nerror[E0277]:\
    \ the size for values of type `str` cannot be known at compilation time\n   -->\
    \ /tmp/tmpgnsd5iam.rs:33:42\n    |\n33  |                 result.push(String::from(word));\n\
    \    |                             ------------ ^^^^ doesn't have a size known\
    \ at compile-time\n    |                             |\n    |                \
    \             required by a bound introduced by this call\n    |\n    = help:\
    \ the trait `Sized` is not implemented for `str`\nnote: required by a bound in\
    \ `from`\n\nerror[E0277]: the trait bound `String: From<str>` is not satisfied\n\
    \  --> /tmp/tmpgnsd5iam.rs:33:29\n   |\n33 |                 result.push(String::from(word));\n\
    \   |                             ^^^^^^^^^^^^ the trait `From<str>` is not implemented\
    \ for `String`\n   |\n   = help: the following other types implement trait `From<T>`:\n\
    \             <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpgnsd5iam.rs:40:16\n   |\n4"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    if s.is_empty()\
    \ {\n        return Vec::new();\n    }\n    let mut count = 0;\n    let mut s\
    \ = s;\n    let mut words = Vec::new();\n    while s.len() > 0 {\n        let\
    \ mut consonant = false;\n        while let Some(c) = s.chars().next() {\n   \
    \         if c.is_upper() {\n                consonant = false;\n            }\
    \ else if c.is_lower() {\n                consonant = true;\n            } else\
    \ {\n                count = match count {\n                    0 => c,\n    \
    \                1 => c.to_lowercase(),\n                    _ => {\n        \
    \                if count > n {\n                            break;\n        \
    \                } else {\n                            let i = count - 1;\n  \
    \                          let mut c = c.to_lowercase();\n                   \
    \         while i != 0 {\n                                c = &c.chars().next().unwrap().to_lowercase();\n\
    \                                i -= 1;\n                            }\n    \
    \                        c\n                        }\n                    }\n\
    \                };\n                consonant = false;\n            }\n     \
    \   }\n        if consonant == true {\n            words.push(s.clone());\n  \
    \      }\n        s = &s[1..];\n    }\n    words\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_upper` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpuhz700ox.rs:27:18\n   |\n27 |             if c.is_upper()\
    \ {\n   |                  ^^^^^^^^ help: there is an associated function with\
    \ a similar name: `is_uppercase`\n\nerror[E0599]: no method named `is_lower` found\
    \ for type `char` in the current scope\n  --> /tmp/tmpuhz700ox.rs:29:25\n   |\n\
    29 |             } else if c.is_lower() {\n   |                         ^^^^^^^^\
    \ help: there is an associated function with a similar name: `is_lowercase`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpuhz700ox.rs:33:26\n   |\n33 |  \
    \                   0 => c,\n   |                          ^ expected integer,\
    \ found `char`\n\nerror[E0599]: no method named `chars` found for struct `ToLowercase`\
    \ in the current scope\n  --> /tmp/tmpuhz700ox.rs:42:40\n   |\n42 | ...      \
    \             c = &c.chars().next().unwrap().to_lowercase();\n   |           \
    \                   ^^^^^ method not found in `ToLowercase`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpuhz700ox.rs:45:29\n   |\n45 | ...                   c\n\
    \   |                       ^ expected `isize`, found struct `ToLowercase`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpuhz700ox.rs:55:13\n   |\n22 |  \
    \   let mut s = s;\n   |                 - expected due to this value\n...\n55\
    \ |         s = &s[1..];\n   |             ^^^^^^^ expected struct `String`, found\
    \ `&str`\n   |\nhelp: try using a conversion method\n   |\n55 |         s = (&s[1..]).to_string();\n\
    \   |             +       +++++++++++++\n\nerror: aborting due to 6 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    if s.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut letters = s.chars().collect::<Vec<_>>();\n\
    \    letters.sort_by_key(|&x| x.unwrap());\n    letters.reverse();\n\n    let\
    \ mut words = vec![];\n    let mut counter = 0;\n    let mut j = 0;\n    for i\
    \ in 0..=n {\n        for word in letters.iter().take(i - counter).chain(letters.iter().skip(counter\
    \ + i)) {\n            if word.chars().all(|&x| x == i) {\n                words.push(word.to_string());\n\
    \                j += 1;\n            }\n        }\n    }\n    return words;\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp3hy0w6da.rs:23:32\n   |\n23 |     letters.sort_by_key(|&x|\
    \ x.unwrap());\n   |                                ^^^^^^ method not found in\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3hy0w6da.rs:30:41\n\
    \   |\n30 |         for word in letters.iter().take(i - counter).chain(letters.iter().skip(counter\
    \ + i)) {\n   |                                         ^^^^^^^^^^^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n30 |         for word in letters.iter().take((i\
    \ - counter).try_into().unwrap()).chain(letters.iter().skip(counter + i)) {\n\
    \   |                                         +           +++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp3hy0w6da.rs:30:80\n   |\n30 |\
    \         for word in letters.iter().take(i - counter).chain(letters.iter().skip(counter\
    \ + i)) {\n   |                                                              \
    \                  ^^^^^^^^^^^ expected `usize`, found `isize`\n   |\nhelp: you\
    \ can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n30 |         for word in letters.iter().take(i - counter).chain(letters.iter().skip((counter\
    \ + i).try_into().unwrap())) {\n   |                                         \
    \                                       +           +++++++++++++++++++++\n\n\
    error[E0599]: no method named `chars` found for reference `&char` in the current\
    \ scope\n  --> /tmp/tmp3hy0w6da.rs:31:21\n   |\n31 |             if word.chars().all(|&x|\
    \ x == i) {\n   |                     ^^^^^ method not found in `&char`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ vec = vec![];\n\n    for character in s.chars() {\n        if character == '\
    \ ' {\n            vec.push(String::from(\"\"));\n        } else {\n         \
    \   for c in character.chars() {\n                if !c.is_ascii() {\n       \
    \             let mut found = false as bool;\n\n                    for char in\
    \ \"aeiouAEIOU\".chars() {\n                        if char == c {\n         \
    \                   found = true;\n                        }\n               \
    \     }\n                    if found {\n                        vec.push(String::from(c));\n\
    \                    }\n                }\n            }\n        }\n    }\n\n\
    \    if vec.len() == 0 {\n        vec\n    } else {\n        let mut count = 0;\n\
    \        let mut prev = \"\";\n\n        for word in vec.into_iter() {\n     \
    \       if count > n && prev != \"\" && word.contains(prev) {\n              \
    \  vec.remove(0);\n                vec.push(word);\n            }\n          \
    \  prev = word;\n            count += 1;\n        }\n        vec\n    }\n}\n\n\
    fn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `chars` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpnakewa2s.rs:24:32\n   |\n24 |             for c in character.chars()\
    \ {\n   |                                ^^^^^ method not found in `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpnakewa2s.rs:52:20\n   |\n45 |  \
    \       let mut prev = \"\";\n   |                        -- expected due to this\
    \ value\n...\n52 |             prev = word;\n   |                    ^^^^\n  \
    \ |                    |\n   |                    expected `&str`, found struct\
    \ `String`\n   |                    help: consider borrowing here: `&word`\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    if s.is_empty()\
    \ {\n        return vec![];\n    }\n\n    match n {\n        0 => vec![],\n  \
    \      1 => {\n            vec![\"Mary\", \"lamb\"]\n        }\n        2 => {\n\
    \            vec![\n                s.splitn(2, ' ').nth(0).unwrap().to_string().into(),\n\
    \                s.splitn(2, ' ').nth(1).unwrap().to_string().into(),\n      \
    \      ]\n        }\n        3 => {\n            vec![s.splitn(2, ' ').nth(1).unwrap().to_string().into(),\
    \ s.splitn(2, ' ').nth(2).unwrap().to_string().into()]\n        }\n        _ =>\
    \ {\n            vec![s.splitn(2, ' ').nth(1).unwrap().to_string().into(), s.splitn(2,\
    \ ' ').nth(2).unwrap().to_string().into()]\n        }\n    }\n}\n\nfn main() {\n\
    \    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpx77_ny4z.rs:25:18\n   |\n\
    25 |             vec![\"Mary\", \"lamb\"]\n   |                  ^^^^^^- help:\
    \ try using a conversion method: `.to_string()`\n   |                  |\n   |\
    \                  expected struct `String`, found `&str`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ ret = vec![];\n    for i in s.chars() {\n        if i.is_consonant() {\n   \
    \         if i >= n {\n                let mut it = i;\n                while\
    \ it.is_consonant() && it.next().is_consonant() {\n                }\n       \
    \         if it.next().is_consonant() {\n                    ret.push(String::from(s.chars().skip(it.index()).take(it.index()\
    \ - i)));\n                }\n            }\n        }\n    }\n    ret\n}\n\n\
    fn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmp7hmdzqf6.rs:20:14\n   |\n20 |         if i.is_consonant()\
    \ {\n   |              ^^^^^^^^^^^^ method not found in `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp7hmdzqf6.rs:21:21\n   |\n21 |             if\
    \ i >= n {\n   |                     ^ expected `char`, found `isize`\n\nerror[E0599]:\
    \ no method named `is_consonant` found for type `char` in the current scope\n\
    \  --> /tmp/tmp7hmdzqf6.rs:23:26\n   |\n23 |                 while it.is_consonant()\
    \ && it.next().is_consonant() {\n   |                          ^^^^^^^^^^^^ method\
    \ not found in `char`\n\nerror[E0599]: no method named `next` found for type `char`\
    \ in the current scope\n  --> /tmp/tmp7hmdzqf6.rs:23:47\n   |\n23 |          \
    \       while it.is_consonant() && it.next().is_consonant() {\n   |          \
    \                                     ^^^^ method not found in `char`\n\nerror[E0599]:\
    \ no method named `next` found for type `char` in the current scope\n  --> /tmp/tmp7hmdzqf6.rs:25:23\n\
    \   |\n25 |                 if it.next().is_consonant() {\n   |              \
    \         ^^^^ method not found in `char`\n\nerror[E0599]: no method named `index`\
    \ found for type `char` in the current scope\n  --> /tmp/tmp7hmdzqf6.rs:26:61\n\
    \   |\n26 |                     ret.push(String::from(s.chars().skip(it.index()).take(it.index()\
    \ - i)));\n   |                                                             ^^^^^\
    \ method not found in `char`\n\nerror[E0599]: no method named `index` found for\
    \ type `char` in the current scope\n  --> /tmp/tmp7hmdzqf6.rs:26:78\n   |\n26\
    \ |                     ret.push(String::from(s.chars().skip(it.index()).take(it.index()\
    \ - i)));\n   |                                                              \
    \                ^^^^^ method not found in `char`\n\nerror[E0277]: the trait bound\
    \ `String: From<std::iter::Take<Skip<Chars<'_>>>>` is not satisfied\n  --> /tmp/tmp7hmdzqf6.rs:26:30\n\
    \   |\n26 |                     ret.push(String::from(s.chars().skip(it.index()).take(it.index()\
    \ - i)));\n   |                "
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    s.chars()\n\
    \        .filter(|c| c.is_alphabetic())\n        .filter(|c| c.is_whitespace())\n\
    \        .filter(|c| c.is_punctuation())\n        .filter(|c| c.is_alphabetic())\n\
    \        .take(n)\n        .collect()\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_punctuation` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpc7d0nmc8.rs:21:23\n   |\n21 |         .filter(|c|\
    \ c.is_punctuation())\n   |                       ^^^^^^^^^^^^^^ help: there is\
    \ an associated function with a similar name: `is_ascii_punctuation`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpc7d0nmc8.rs:23:15\n   |\n23 |         .take(n)\n\
    \   |               ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    23 |         .take(n.try_into().unwrap())\n   |                ++++++++++++++++++++\n\
    \nerror[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmpc7d0nmc8.rs:24:10\n     |\n24\
    \   |         .collect()\n     |          ^^^^^^^ value of type `Vec<String>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n     |\n     = help:\
    \ the trait `FromIterator<char>` is not implemented for `Vec<String>`\n     =\
    \ help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    \n    let\
    \ mut vec: Vec<String> = Vec::new();\n    \n    let mut prev_consonants = Vec::new();\n\
    \    let mut cur_consonants = Vec::new();\n    \n    for cons in s.chars() {\n\
    \        let char = (cons as u32).to_digit(10);\n        if char > 0 {\n     \
    \       cur_consonants.push(char);\n        }\n        if char < 10 {\n      \
    \      prev_consonants.push(char);\n        }\n    }\n    \n    if cur_consonants.len()\
    \ == n {\n        for cons in cur_consonants.iter() {\n            vec.push(String::from(&prev_consonants[cons\
    \ as usize - 1]));\n        }\n    }\n    \n    vec\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_digit` found for type `u32` in the current\
    \ scope\n  --> /tmp/tmpa5tvtbzy.rs:25:34\n   |\n25 |         let char = (cons\
    \ as u32).to_digit(10);\n   |                                  ^^^^^^^^ method\
    \ not found in `u32`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpa5tvtbzy.rs:34:32\n\
    \   |\n34 |     if cur_consonants.len() == n {\n   |                         \
    \       ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n34 |     if\
    \ cur_consonants.len() == n.try_into().unwrap() {\n   |                      \
    \           ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ counter = 0;\n    \n    let mut words = vec![];\n    for ch in s.chars() {\n\
    \        if ch == ' ' {\n            words.push_back(String::from(\"\"));\n  \
    \          counter += 1;\n            if counter == n {\n                break;\n\
    \            }\n        } else {\n            words.push_back(String::from(&ch));\n\
    \            counter += 1;\n        }\n    }\n    \n    words\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `push_back` found for struct `Vec<_>` in\
    \ the current scope\n  --> /tmp/tmp6zyjskjm.rs:23:19\n   |\n23 |             words.push_back(String::from(\"\
    \"));\n   |                   ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]:\
    \ no method named `push_back` found for struct `Vec<_>` in the current scope\n\
    \  --> /tmp/tmp6zyjskjm.rs:29:19\n   |\n29 |             words.push_back(String::from(&ch));\n\
    \   |                   ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0277]:\
    \ the trait bound `String: From<&char>` is not satisfied\n  --> /tmp/tmp6zyjskjm.rs:29:29\n\
    \   |\n29 |             words.push_back(String::from(&ch));\n   |            \
    \                 ^^^^^^^^^^^^ the trait `From<&char>` is not implemented for\
    \ `String`\n   |\n   = help: the following other types implement trait `From<T>`:\n\
    \             <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    match (n,\
    \ s.chars().count()) {\n        (i, 0) => vec![],\n        (i, _) => {\n     \
    \       let mut s = vec![];\n            let mut counter = 1;\n            while\
    \ counter <= i {\n                let mut index = i;\n                let mut\
    \ count = 0;\n                while (index != 0) && (count < n) {\n          \
    \          if s[index - 1] != s.chars().nth(index - 1) {\n                   \
    \     count = 1;\n                        index--;\n                    } else\
    \ {\n                        count++;\n                    }\n               \
    \ }\n                index -= count;\n                s.push(s.chars().nth(index).unwrap());\n\
    \            }\n            s\n        }\n    }\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmph5y9wd79.rs:29:32\n\
    \   |\n29 |                         index--;\n   |                           \
    \     ^ expected expression\n\nerror: Rust has no postfix increment operator\n\
    \  --> /tmp/tmph5y9wd79.rs:31:30\n   |\n31 |                         count++;\n\
    \   |                              ^^ not a valid postfix operator\n   |\nhelp:\
    \ use `+= 1` instead\n   |\n31 |                         { let tmp = count; count\
    \ += 1; tmp };\n   |                         +++++++++++      ~~~~~~~~~~~~~~~~~~~\n\
    31 -                         count++;\n31 +                         count += 1;\n\
    \   | \n\nerror[E0277]: the type `[_]` cannot be indexed by `isize`\n  --> /tmp/tmph5y9wd79.rs:27:24\n\
    \   |\n27 |                     if s[index - 1] != s.chars().nth(index - 1) {\n\
    \   |                        ^^^^^^^^^^^^ slice indices are of type `usize` or\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<_>`\n\nerror[E0599]: no method named `chars` found for struct `Vec<_>`\
    \ in the current scope\n  --> /tmp/tmph5y9wd79.rs:27:42\n   |\n27 |          \
    \           if s[index - 1] != s.chars().nth(index - 1) {\n   |              \
    \                            ^^^^^ method not found in `Vec<_>`\n\nerror[E0599]:\
    \ no method named `chars` found for struct `Vec<_>` in the current scope\n  -->\
    \ /tmp/tmph5y9wd79.rs:35:26\n   |\n35 |                 s.push(s.chars().nth(index).unwrap());\n\
    \   |                          ^^^^^ method not found in `Vec<_>`\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ s = String::from(\"Mary had a little lamb\");\n    let mut count = 0;\n    let\
    \ mut words = Vec::<String>::new();\n    while s.len() > 0 {\n        let len\
    \ = s.len();\n        let mut current = 0;\n        while current < len {\n  \
    \          if s[current].is_ascii_lowercase() || s[current].is_ascii_uppercase()\
    \ || s[current].is_ascii_space() {\n                current++;\n            }\
    \ else {\n                break;\n            }\n        }\n        count += 1;\n\
    \        if count == n {\n            words = vec![s.trim_start_matches(\"\")];\n\
    \            break;\n        }\n        s = &s[..current];\n    }\n    words\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp90280imh.rs:26:24\n\
    \   |\n26 |                 current++;\n   |                        ^^ not a valid\
    \ postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n26 |               \
    \  { let tmp = current; current += 1; tmp };\n   |                 +++++++++++\
    \        ~~~~~~~~~~~~~~~~~~~~~\n26 -                 current++;\n26 +        \
    \         current += 1;\n   | \n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmp90280imh.rs:25:16\n   |\n25 |             if s[current].is_ascii_lowercase()\
    \ || s[current].is_ascii_uppercase() || s[current].is_ascii_space() {\n   |  \
    \              ^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp90280imh.rs:25:51\n   |\n25 |             if s[current].is_ascii_lowercase()\
    \ || s[current].is_ascii_uppercase() || s[current].is_ascii_space() {\n   |  \
    \                                                 ^^^^^^^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp90280"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ counter = Counter::new();\n    let mut words = Vec::new();\n    for c in s.chars()\
    \ {\n        if c == ' ' {\n            words.clear();\n            break;\n \
    \       }\n        counter[c] += 1;\n    }\n    let max_count = counter.iter().max().unwrap();\n\
    \    let mut word_idx = 0;\n    for word in words.iter_mut() {\n        if *word\
    \ == ' ' {\n            word_idx = 0;\n        }\n        if counter[s.chars().nth(word_idx).unwrap()]\
    \ == n {\n            *word = String::from(s.chars().nth(word_idx).unwrap());\n\
    \            word_idx += 1;\n        }\n    }\n    return words;\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Counter`\n  -->\
    \ /tmp/tmpuef3g4xu.rs:18:23\n   |\n18 |     let mut counter = Counter::new();\n\
    \   |                       ^^^^^^^ use of undeclared type `Counter`\n\nerror[E0277]:\
    \ can't compare `String` with `char`\n  --> /tmp/tmpuef3g4xu.rs:30:18\n   |\n\
    30 |         if *word == ' ' {\n   |                  ^^ no implementation for\
    \ `String == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0277, E0433.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ v = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        let mut j\
    \ = i;\n        while j < s.len() && s[j] != 'a' && s[j] != 'e' && s[j] != 'i'\
    \ && s[j] != 'o' && s[j] != 'u' && s[j] != 'y' && s[j] != 's' {\n            i\
    \ += 1;\n            j += 1\n        }\n        if j == s.len() {\n          \
    \  i += 1;\n            v.push(s.to_string().to_string());\n        } else {\n\
    \            v.push(&s[i .. j]);\n            i += j - i;\n        }\n    }\n\
    \    if v.len() == 0 && n == 1 {\n        vec![]\n    } else if v.len() == 0 &&\
    \ n == 2 {\n        vec![s.to_string().to_string()]\n    } else {\n        v\n\
    \    }\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp7r4vdykl.rs:22:30\n\
    \   |\n22 |         while j < s.len() && s[j] != 'a' && s[j] != 'e' && s[j] !=\
    \ 'i' && s[j] != 'o' && s[j] != 'u' && s[j] != 'y' && s[j] != 's' {\n   |    \
    \                          ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp7r4vdykl.rs:22:45\n\
    \   |\n22 |         while j < s.len() && s[j] != 'a' && s[j] != 'e' && s[j] !=\
    \ 'i' && s[j] != 'o' && s[j] != 'u' && s[j] != 'y' && s[j] != 's' {\n   |    \
    \                                         ^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp7r4vdykl.rs:22:60\n   |\n22 |         while j < s.len() && s[j]\
    \ != 'a' && s[j] != 'e' && s[j] != 'i' && s[j] != 'o' && s[j] != 'u' && s[j] !=\
    \ 'y' && s[j] != 's' {\n   |                                                 \
    \           ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types impl"
  stdout: ''
  timestamp: 1660010887
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    vec![]\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"little\"]`', /tmp/tmp1sy5pnx1.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    if s.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut result = vec![];\n    let mut\
    \ cur_n = n;\n    let mut cur_s = s;\n    let mut cur_pos = 0;\n    \n    while\
    \ cur_pos < cur_s.len() {\n        let mut cur_word = String::new();\n       \
    \ let mut consonants = String::new();\n        \n        for c in cur_s.chars()\
    \ {\n            if c.is_ascii() {\n                consonants += c.to_string();\n\
    \            } else {\n                if consonants.len() == 0 {\n          \
    \          cur_word.push(c.to_string());\n                } else {\n         \
    \           cur_word.push(consonants);\n                    consonants = String::new();\n\
    \                }\n            }\n        }\n        \n        if consonants.len()\
    \ == 0 {\n            cur_word.push(cur_s.chars().next().unwrap().to_string());\n\
    \        } else {\n            cur_word.push(consonants);\n        }\n       \
    \ \n        result.push(cur_word);\n        cur_n -= 1;\n        cur_s += cur_word;\n\
    \        cur_pos += cur_word.len();\n    }\n    result\n}\n\nfn main() {\n   \
    \ let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6j7ragbk.rs:32:31\n   |\n\
    32 |                 consonants += c.to_string();\n   |                      \
    \         ^^^^^^^^^^^^^\n   |                               |\n   |          \
    \                     expected `&str`, found struct `String`\n   |           \
    \                    help: consider borrowing here: `&c.to_string()`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp6j7ragbk.rs:35:35\n   |\n35 |              \
    \       cur_word.push(c.to_string());\n   |                                  \
    \ ^^^^^^^^^^^^^ expected `char`, found struct `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp6j7ragbk.rs:37:35\n   |\n37 |                     cur_word.push(consonants);\n\
    \   |                                   ^^^^^^^^^^ expected `char`, found struct\
    \ `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6j7ragbk.rs:44:27\n\
    \   |\n44 |             cur_word.push(cur_s.chars().next().unwrap().to_string());\n\
    \   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `char`, found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6j7ragbk.rs:46:27\n\
    \   |\n46 |             cur_word.push(consonants);\n   |                     \
    \      ^^^^^^^^^^ expected `char`, found struct `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp6j7ragbk.rs:51:18\n   |\n51 |         cur_s += cur_word;\n\
    \   |                  ^^^^^^^^\n   |                  |\n   |               \
    \   expected `&str`, found struct `String`\n   |                  help: consider\
    \ borrowing here: `&cur_word`\n\nerror: aborting due to 6 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    if n ==\
    \ 0 {\n        vec![]\n    } else if s.is_empty() {\n        vec![]\n    } else\
    \ if n < 0 {\n        vec![]\n    } else {\n        let mut res = vec![];\n  \
    \      for c in s.chars() {\n            if !c.is_consonant() {\n            \
    \    continue;\n            }\n            let mut word: Vec<&str> = vec![];\n\
    \            if c.is_vowel() {\n                for vowel in vec![\n         \
    \           \"a\" as &str,\n                    \"e\" as &str,\n             \
    \       \"i\" as &str,\n                    \"o\" as &str,\n                 \
    \   \"u\" as &str,\n                ] {\n                    if s.contains(&vowel)\
    \ {\n                        word.push(&vowel);\n                    }\n     \
    \           }\n            } else {\n                for consonant in vec![\n\
    \                    \"b\",\n                    \"c\" as &str,\n            \
    \        \"d\" as &str,\n                    \"f\" as &str,\n                \
    \    \"g\" as &str,\n                    \"h\" as &str,\n                    \"\
    j\" as &str,\n                    \"k\" as &str,\n                    \"l\" as\
    \ &str,\n                    \"m\" as &str,\n                    \"n\" as &str,\n\
    \                    \"p\" as &str,\n                    \"q\" as &str,\n    \
    \                \"r\" as &str,\n                    \"s\" as &str,\n        \
    \            \"t\" as &str,\n                    \"v\" as &str,\n            \
    \        \"w\" as &str,\n                    \"x\" as &str,\n                \
    \    \"y\" as &str,\n                    \"z\" as &str,\n                ] {\n\
    \                    if s.contains(&consonant) {\n                        word.push(&consonant);\n\
    \                    }\n                }\n            }\n            if word.len()\
    \ == n {\n                res.push(word);\n            }\n        }\n        res\n\
    \    }\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpuqu180_4.rs:27:19\n   |\n27 |             if !c.is_consonant()\
    \ {\n   |                   ^^^^^^^^^^^^ method not found in `char`\n\nerror[E0599]:\
    \ no method named `is_vowel` found for type `char` in the current scope\n  -->\
    \ /tmp/tmpuqu180_4.rs:31:18\n   |\n31 |             if c.is_vowel() {\n   |  \
    \                ^^^^^^^^ method not found in `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpuqu180_4.rs:72:30\n   |\n72 |             if word.len()\
    \ == n {\n   |                              ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n72 |             if word.len() == n.try_into().unwrap()\
    \ {\n   |                               ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpuqu180_4.rs:76:9\n   |\n17 | fn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n   |                                   \
    \      ----------- expected `Vec<String>` because of return type\n...\n76 |  \
    \       res\n   |         ^^^ expected struct `String`, found struct `Vec`\n \
    \  |\n   = note: expected struct `Vec<String>`\n              found struct `Vec<Vec<&str>>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    match n\
    \ {\n        0 => vec![],\n        _ => s.split(\"\").iter().filter(|word| {\n\
    \            word\n                .chars()\n                .filter(|c| c < 'a'\
    \ || c > 'z')\n                .count() == n\n        }).map(|word| word.to_string()).collect()\n\
    \    }\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `std::str::Split`\
    \ in the current scope\n  --> /tmp/tmp567fhqx8.rs:20:26\n   |\n20 |         _\
    \ => s.split(\"\").iter().filter(|word| {\n   |                          ^^^^\
    \ method not found in `std::str::Split<'_, &str>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n\n    // write your code here\n    let mut s = String::from(s);\n\
    \    if s.is_empty() {\n        result = vec![];\n        return result;\n   \
    \ }\n\n    let mut s = String::from(s);\n    for i in 0..s.len() {\n        if\
    \ s[i] == ' ' {\n            continue;\n        }\n        for j in (i..s.len())\
    \ {\n            let mut chars = vec![];\n            if j == i {\n          \
    \      chars = vec![String::from(s[i])];\n            } else {\n             \
    \   let mut chars = s.chars().take(j - i).collect::<Vec<_>>();\n             \
    \   chars.sort_unstable();\n                for j in chars.iter().cloned() {\n\
    \                    if j.to_lowercase().contains(String::from(\"a..z\")) {\n\
    \                        chars.push((j + String::from(\"a..z\")));\n         \
    \           } else if j.to_lowercase().contains(String::from(\"A..Z\")) {\n  \
    \                      chars.push((j + String::from(\"A..Z\")));\n           \
    \         } else if j.to_lowercase().contains(String::from(\"0..9\")) {\n    \
    \                    chars.push((j + String::from(\"0..9\")));\n             \
    \       } else if j.to_lowercase().contains(String::from(\"1..9\")) {\n      \
    \                  chars.push((j + String::from(\"1..9\")));\n               \
    \     } else if j.to_lowercase().contains(String::from(\"A..Z..a\")) {\n     \
    \                   chars.push((j + String::from(\"A..Z..a\")));\n           \
    \         } else if j.to_lowercase().contains(String::from(\"0..9..a\")) {\n \
    \                       chars.push((j + String::from(\"0..9..a\")));\n       \
    \             } else if j.to_lowercase().contains(String::from(\"1..9..a\")) {\n\
    \                        chars.push((j + String::from(\"1..9..a\")));\n      \
    \              } else if j.to_lowercase().contains(String::from(\"A..Z..z\"))\
    \ {\n                        chars.push((j + String::from(\"A..Z..z\")));\n  \
    \                  } else if j.to_lowercase().contains(String::from(\"0..9..z\"\
    )) {\n                        chars.push((j + String::from(\"0..9..z\")));\n \
    \                   } else if j.to_lowercase().contains(String::from(\"1..9..z\"\
    )) {\n                        chars.push((j + String::from(\"1..9..z\")));\n \
    \                   } else if j.to_lowercase().contains(String::from(\"A..Z..A\"\
    )) {\n                        chars.push((\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpjjayf5rt.rs:73:3\n\
    \   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |      \
    \                                               - unclosed delimiter\n...\n28\
    \ |     for i in 0..s.len() {\n   |                         - unclosed delimiter\n\
    ...\n32 |         for j in (i..s.len()) {\n   |                              \
    \ - unclosed delimiter\n...\n36 |             } else {\n   |                 \
    \   - unclosed delimiter\n...\n39 |                 for j in chars.iter().cloned()\
    \ {\n   |                                                - unclosed delimiter\n\
    ...\n60 |                     } else if j.to_lowercase().contains(String::from(\"\
    A..Z..A\")) {\n   |                                                          \
    \                        - this delimiter might not be properly closed...\n61\
    \ |                         chars.push((\n62 | }\n   | - ...as it matches this\
    \ but it has different indentation\n...\n73 | }\n   |   ^\n\nerror: mismatched\
    \ closing delimiter: `}`\n  --> /tmp/tmpjjayf5rt.rs:61:36\n   |\n17 | fn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n   |                                   \
    \                  - closing delimiter possibly meant for this\n...\n61 |    \
    \                     chars.push((\n   |                                    ^\
    \ unclosed delimiter\n62 | }\n   | ^ mismatched closing delimiter\n\nwarning:\
    \ unnecessary parentheses around `for` iterator expression\n  --> /tmp/tmpjjayf5rt.rs:32:18\n\
    \   |\n32 |         for j in (i..s.len()) {\n   |                  ^         \
    \ ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these\
    \ parentheses\n   |\n32 -         for j in (i..s.len()) {\n32 +         for j\
    \ in i..s.len() {\n   | \n\nwarning: unnecessary parentheses around method argument\n\
    \  --> /tmp/tmpjjayf5rt.rs:41:36\n   |\n41 |                         chars.push((j\
    \ + String::from(\"a..z\")));\n   |                                    ^     \
    \                   ^\n   |\nhelp: remove these parentheses\n   |\n41 -      \
    \                   chars.push((j + String::from(\"a..z\")));\n41 +   "
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    if s.is_empty()\
    \ {\n        vec![]\n    } else {\n        let mut v = vec![];\n        v.push(s.split_whitespace().nth(0).unwrap());\n\
    \        for i in 1..s.len() {\n            if s.chars().nth(i).unwrap().chars().take_while(|x|\
    \ {x == '\\a'; x != ' '}).count() == n {\n                v.push(s.split_whitespace().nth(i).unwrap());\n\
    \            }\n        }\n        v\n    }\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: unknown character escape: `a`\n  --> /tmp/tmpbrdbfao_.rs:24:73\n\
    \   |\n24 |             if s.chars().nth(i).unwrap().chars().take_while(|x| {x\
    \ == '\\a'; x != ' '}).count() == n {\n   |                                  \
    \                                       ^ unknown character escape\n   |\n   =\
    \ help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\n\
    help: if you meant to write a literal backslash (perhaps escaping in a regular\
    \ expression), consider a raw string literal\n   |\n24 |             if s.chars().nth(i).unwrap().chars().take_while(|x|\
    \ {x == r\"\\a\"; x != ' '}).count() == n {\n   |                            \
    \                                           ~~~~~\n\nerror[E0599]: no method named\
    \ `chars` found for type `char` in the current scope\n  --> /tmp/tmpbrdbfao_.rs:24:42\n\
    \   |\n24 |             if s.chars().nth(i).unwrap().chars().take_while(|x| {x\
    \ == '\\a'; x != ' '}).count() == n {\n   |                                  \
    \        ^^^^^ method not found in `char`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpbrdbfao_.rs:28:9\n   |\n17 | fn select_words(s: String, n: isize)\
    \ -> Vec<String> {\n   |                                         ----------- expected\
    \ `Vec<String>` because of return type\n...\n28 |         v\n   |         ^ expected\
    \ struct `String`, found `&str`\n   |\n   = note: expected struct `Vec<String>`\n\
    \              found struct `Vec<&str>`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words: Vec<String> = vec![];\n    for i in s.chars() {\n        let is_vowel\
    \ = is_vowel(i).unwrap();\n        if is_vowel {\n            if words.len() >=\
    \ n {\n                words.push(i);\n                break;\n            }\n\
    \        } else {\n            let consonant = consonant(i);\n            if consonant.is_none()\
    \ {\n                if words.len() >= n {\n                    words.push(i);\n\
    \                }\n            } else {\n                if words.len() >= n\
    \ {\n                    break;\n                }\n                words.push(consonant.unwrap());\n\
    \            }\n        }\n    }\n    words\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmplvha5aq4.rs:20:24\n\
    \   |\n20 |         let is_vowel = is_vowel(i).unwrap();\n   |               \
    \         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `consonant` in this scope\n  --> /tmp/tmplvha5aq4.rs:27:29\n   |\n27 |     \
    \        let consonant = consonant(i);\n   |                             ^^^^^^^^^\
    \ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplvha5aq4.rs:22:31\n\
    \   |\n22 |             if words.len() >= n {\n   |                          \
    \     ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n22 |      \
    \       if words.len() >= n.try_into().unwrap() {\n   |                      \
    \          ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplvha5aq4.rs:23:28\n\
    \   |\n23 |                 words.push(i);\n   |                            ^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \          |\n   |                            expected struct `String`, found\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplvha5aq4.rs:29:35\n\
    \   |\n29 |                 if words.len() >= n {\n   |                      \
    \             ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an\
    \ `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n29\
    \ |                 if words.len() >= n.try_into().unwrap() {\n   |          \
    \                          ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmplvha5aq4.rs:30:32\n   |\n30 |                     words.push(i);\n\
    \   |                                ^- help: try using a conversion method: `.to_string()`\n\
    \   |                                |\n   |                                expected\
    \ struct `String`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplvha5aq4.rs:33:35\n\
    \   |\n33 |                 if words.len() >= n {\n   |                      \
    \             ^ expected `usize`, found `isize`\n   |\nhelp: you can convert a"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ res = Vec::new();\n    let mut w = s.to_string();\n    let mut last = 0;\n \
    \   let mut last_index = -1;\n    let mut found = 0;\n    let mut i = 1;\n   \
    \ while i < w.len() {\n        match &w[last..i] {\n            b\"aeiouyAEIOUY\"\
    \ => {\n                found = 1;\n            }\n            b\"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    \ => {\n                found = 2;\n            }\n            _ => {\n      \
    \          found = -1;\n            }\n        }\n        if found == n {\n  \
    \          res.push(w[last..i]);\n            last_index = i;\n        }\n   \
    \     last = i;\n        i += 1;\n    }\n    if last_index == -1 {\n        res\n\
    \    } else {\n        res\n    }\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp81fy9cyp.rs:26:13\n   |\n\
    25 |         match &w[last..i] {\n   |               ----------- this expression\
    \ has type `&str`\n26 |             b\"aeiouyAEIOUY\" => {\n   |             ^^^^^^^^^^^^^^^\
    \ expected `str`, found array `[u8; 12]`\n   |\n   = note: expected reference\
    \ `&str`\n              found reference `&'static [u8; 12]`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp81fy9cyp.rs:29:13\n   |\n25 |         match &w[last..i]\
    \ {\n   |               ----------- this expression has type `&str`\n...\n29 |\
    \             b\"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\" => {\n   |     \
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found array\
    \ `[u8; 42]`\n   |\n   = note: expected reference `&str`\n              found\
    \ reference `&'static [u8; 42]`\n\nerror[E0277]: the size for values of type `str`\
    \ cannot be known at compilation time\n   --> /tmp/tmp81fy9cyp.rs:37:22\n    |\n\
    37  |             res.push(w[last..i]);\n    |                 ---- ^^^^^^^^^^\
    \ doesn't have a size known at compile-time\n    |                 |\n    |  \
    \               required by a bound introduced by this call\n    |\n    = help:\
    \ the trait `Sized` is not implemented for `str`\nnote: required by a bound in\
    \ `Vec::<T, A>::push`\n\nerror[E0277]: the size for values of type `str` cannot\
    \ be known at compilation time\n   --> /tmp/tmp81fy9cyp.rs:18:19\n    |\n18  |\
    \     let mut res = Vec::new();\n    |                   ^^^^^^^^ doesn't have\
    \ a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented\
    \ for `str`\nnote: required by a bound in `Vec::<T>::new`\n\nerror[E0277]: the\
    \ size for values of type `str` cannot be known at compilation time\n   --> /tmp/tmp81fy9cyp.rs:18:19\n\
    \    |\n18  |     let mut res = Vec::new();\n    |                   ^^^ doesn't\
    \ have a size known at compile-time\n    |\n    = help: the trait `Sized` is not\
    \ implemented for `str`\nnote: required by a bound in `Vec`\n\nerror[E0277]: the\
    \ trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp81fy9cyp.rs:21:26\n\
    \   |\n21 |     let mut last_index = "
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut it = s.chars().enumerate();\n    for i in\
    \ it.filter_map(|(i,c)| {\n        if c != 'a' && c != 'e' && c != 'i' && c !=\
    \ 'o' && c != 'u' {\n            None\n        } else {\n            Some(i.to_string().to_owned())\n\
    \        }\n    }).take(n).collect::<Vec<_>>();\n    for s in it {\n        result.push(s.to_string());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `;`\n  --> /tmp/tmp1xyx0w28.rs:26:35\n   |\n\
    26 |     }).take(n).collect::<Vec<_>>();\n   |                               \
    \    ^ expected `{`\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ list = Vec::new();\n    let mut i = 1;\n    while i <= n {\n        if s.contains(&String::from(\"\
    _\")) {\n            list.push(i);\n        }\n        i += 1;\n    }\n    return\
    \ list\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgi4cj5_3.rs:26:12\n   |\n\
    17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |             \
    \                            ----------- expected `Vec<String>` because of return\
    \ type\n...\n26 |     return list\n   |            ^^^^ expected struct `String`,\
    \ found `isize`\n   |\n   = note: expected struct `Vec<String>`\n            \
    \  found struct `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    if s.is_empty()\
    \ {\n        return vec![];\n    }\n\n    // count vowels in s\n    let mut count\
    \ = HashMap::new();\n    for c in s.chars() {\n        if c.is_vowel() {\n   \
    \         count.insert(c.to_owned(), 1);\n        }\n    }\n\n    // find the\
    \ first k consonants in s in order, where k <= n\n    // and n <= count.len()\
    \ as a precondition\n    let mut indices = Vec::new();\n    for &(k,_) in count.iter().enumerate().take_while(|(_,k)|\
    \ *k > n) {\n        indices.push(i);\n    }\n\n    // build the words from the\
    \ indices\n    let mut words = vec![];\n    for i in indices {\n        let start\
    \ = s.as_bytes()[..i].iter().cloned().collect::<Vec<_>>();\n        let end =\
    \ s.as_bytes()[i + 2..].iter().cloned().collect::<Vec<_>>();\n        words.push(start.join(\"\
    \ \").to_owned().to_string());\n        words.push(end.join(\" \").to_owned().to_string());\n\
    \    }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpo4dwcyzv.rs:23:21\n   |\n23 |     let mut count = HashMap::new();\n\
    \   |                     ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0425]:\
    \ cannot find value `i` in this scope\n  --> /tmp/tmpo4dwcyzv.rs:34:22\n   |\n\
    34 |         indices.push(i);\n   |                      ^ help: a local variable\
    \ with a similar name exists: `k`\n\nerror[E0599]: no method named `is_vowel`\
    \ found for type `char` in the current scope\n  --> /tmp/tmpo4dwcyzv.rs:25:14\n\
    \   |\n25 |         if c.is_vowel() {\n   |              ^^^^^^^^ method not found\
    \ in `char`\n\nerror[E0599]: the method `join` exists for struct `Vec<u8>`, but\
    \ its trait bounds were not satisfied\n  --> /tmp/tmpo4dwcyzv.rs:42:26\n   |\n\
    42 |         words.push(start.join(\" \").to_owned().to_string());\n   |     \
    \                     ^^^^ method cannot be called on `Vec<u8>` due to unsatisfied\
    \ trait bounds\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `[u8]: Join<_>`\n\nerror[E0599]: the method `join` exists for struct\
    \ `Vec<u8>`, but its trait bounds were not satisfied\n  --> /tmp/tmpo4dwcyzv.rs:43:24\n\
    \   |\n43 |         words.push(end.join(\" \").to_owned().to_string());\n   |\
    \                        ^^^^ method cannot be called on `Vec<u8>` due to unsatisfied\
    \ trait bounds\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `[u8]: Join<_>`\n\nerror: aborting due to 5 previous errors\n\nSome\
    \ errors have detailed explanations: E0425, E0433, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ letters = s.chars();\n    let mut result = Vec::new();\n    let mut current:\
    \ Vec<&str> = Vec::new();\n    let mut currentLetter = 0;\n    let mut index =\
    \ 0;\n    let mut found = false;\n    loop {\n        if found {\n           \
    \ result.push(current);\n        }\n        current = Vec::new();\n        for\
    \ letter in letters {\n            let letter = &letter;\n            if let Some(i)\
    \ = current.iter().position(|&b| b == letter) {\n                // if we've already\
    \ found the letter\n                // and we're at the correct index, then move\
    \ on to the next letter\n                if i == index {\n                   \
    \ let mut next = letter;\n                    let mut next = &next[next.len()\
    \ - 1];\n                    if next == 'p' {\n                        current.push(next);\n\
    \                        index += 1;\n                    }\n                }\n\
    \                else {\n                    let mut next = &letter[letter];\n\
    \                    if next == 'p' {\n                        current.push(next);\n\
    \                        index += 1;\n                    }\n                }\n\
    \            } else {\n                // if we've never found the letter yet\n\
    \                // then we need to push our letter onto the current index\n \
    \               current.push(letter);\n                index += 1;\n         \
    \   }\n        }\n        if current.len() == n {\n            found = true;\n\
    \        }\n        letters = letters.next();\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `str` with `char`\n  --> /tmp/tmpmz9zdcfx.rs:31:61\n\
    \   |\n31 |             if let Some(i) = current.iter().position(|&b| b == letter)\
    \ {\n   |                                                             ^^ no implementation\
    \ for `str == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n   = note: required because\
    \ of the requirements on the impl of `PartialEq<&char>` for `&str`\n\nerror[E0599]:\
    \ no method named `len` found for reference `&char` in the current scope\n  -->\
    \ /tmp/tmpmz9zdcfx.rs:36:47\n   |\n36 |                     let mut next = &next[next.len()\
    \ - 1];\n   |                                               ^^^ method not found\
    \ in `&char`\n\nerror[E0277]: can't compare `&str` with `char`\n  --> /tmp/tmpmz9zdcfx.rs:37:29\n\
    \   |\n37 |                     if next == 'p' {\n   |                       \
    \      ^^ no implementation for `&str == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&str`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0608]: cannot index into a value of type `&char`\n\
    \  --> /tmp/tmpmz9zdcfx.rs:43:37\n   |\n43 |                     let mut next\
    \ = &letter[letter];\n   |                     "
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ res = Vec::new();\n    let mut i = 0;\n    while i < s.len() {\n        if s.chars().count(|c|\
    \ c.is_consonant() == n) == n {\n            res.push(&s[i..i + n]);\n       \
    \     i += n;\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpajpkx8qx.rs:21:29\n\
    \   |\n21 |         if s.chars().count(|c| c.is_consonant() == n) == n {\n   |\
    \                             ^ consider giving this closure parameter a type\n\
    \   |\n   = note: type must be known at this point\n\nerror[E0061]: this function\
    \ takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpajpkx8qx.rs:21:22\n\
    \    |\n21  |         if s.chars().count(|c| c.is_consonant() == n) == n {\n \
    \   |                      ^^^^^ ------------------------- supplied 1 argument\n\
    \    |                      |\n    |                      expected 0 arguments\n\
    \    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpajpkx8qx.rs:21:58\n   |\n21 |         if s.chars().count(|c| c.is_consonant()\
    \ == n) == n {\n   |                                                         \
    \ ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to\
    \ a `usize` and panic if the converted value doesn't fit\n   |\n21 |         if\
    \ s.chars().count(|c| c.is_consonant() == n) == n.try_into().unwrap() {\n   |\
    \                                                           ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpajpkx8qx.rs:22:32\n   |\n22 |\
    \             res.push(&s[i..i + n]);\n   |                                ^ expected\
    \ `usize`, found `isize`\n\nerror[E0277]: cannot add `isize` to `usize`\n  -->\
    \ /tmp/tmpajpkx8qx.rs:22:30\n   |\n22 |             res.push(&s[i..i + n]);\n\
    \   |                              ^ no implementation for `usize + isize`\n \
    \  |\n   = help: the trait `Add<isize>` is not implemented for `usize`\n   = help:\
    \ the following other types implement trait `Add<Rhs>`:\n             <&'a f32\
    \ as Add<f32>>\n             <&'a f64 as Add<f64>>\n             <&'a i128 as\
    \ Add<i128>>\n             <&'a i16 as Add<i16>>\n             <&'a i32 as Add<i32>>\n\
    \             <&'a i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n      \
    \       <&'a isize as Add<isize>>\n           and 48 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpajpkx8qx.rs:23:18\n   |\n23 "
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = Vec::new();\n    for &c in s.chars() {\n        if c.is_ascii_letter()\
    \ || c.is_ascii_space() {\n            if c.is_ascii_letter() {\n            \
    \    if n == 1 {\n                    words.insert(String::from(c.to_ascii_lowercase()),\
    \ 0);\n                }\n                if n == 2 {\n                    words.insert(String::from(c.to_ascii_uppercase()),\
    \ 0);\n                }\n                if n == 3 {\n                    words.insert(String::from(c.to_ascii_lowercase()\
    \ + c.to_ascii_uppercase()), 0);\n                }\n            }\n        }\n\
    \    }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcfl9egk6.rs:19:9\n   |\n\
    19 |     for &c in s.chars() {\n   |         ^^    --------- this expression has\
    \ type `Option<char>`\n   |         |\n   |         expected `char`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `c`\n   |\n \
    \  = note:   expected type `char`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpcfl9egk6.rs:23:34\n   |\n23 |              \
    \       words.insert(String::from(c.to_ascii_lowercase()), 0);\n   |         \
    \                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`,\
    \ found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcfl9egk6.rs:26:34\n\
    \   |\n26 |                     words.insert(String::from(c.to_ascii_uppercase()),\
    \ 0);\n   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `usize`, found struct `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpcfl9egk6.rs:29:34\n   |\n29 |                     words.insert(String::from(c.to_ascii_lowercase()\
    \ + c.to_ascii_uppercase()), 0);\n   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `usize`, found struct `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpcfl9egk6.rs:34:5\n   |\n17 | fn select_words(s: String, n: isize)\
    \ -> Vec<String> {\n   |                                         ----------- expected\
    \ `Vec<String>` because of return type\n...\n34 |     words\n   |     ^^^^^ expected\
    \ struct `String`, found integer\n   |\n   = note: expected struct `Vec<String>`\n\
    \              found struct `Vec<{integer}>`\n\nerror: aborting due to 5 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    use std::iter::repeat;\n\
    \    let mut words = vec![];\n\n    if !s.is_empty() {\n        let mut chars\
    \ = s.chars();\n        while !chars.next().is_empty() {\n            let mut\
    \ n = chars.next().unwrap();\n            let mut i = 0;\n            while i\
    \ < n {\n                if chars.next().is_empty() {\n                    i +=\
    \ 1;\n                } else {\n                    break;\n                }\n\
    \            }\n            if i == n {\n                words.push(s.subslice(chars.next().unwrap(),\
    \ chars.next().unwrap() + 1));\n            }\n        }\n    }\n\n    if words.iter().all(|&word|\
    \ word.chars().count() == n) {\n        words\n    } else {\n        words\n \
    \   }\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "warning: unused import: `std::iter::repeat`\n  --> /tmp/tmp9nd8s8bb.rs:18:9\n\
    \   |\n18 |     use std::iter::repeat;\n   |         ^^^^^^^^^^^^^^^^^\n   |\n\
    \   = note: `#[warn(unused_imports)]` on by default\n\nerror[E0599]: no method\
    \ named `is_empty` found for enum `Option` in the current scope\n  --> /tmp/tmp9nd8s8bb.rs:23:29\n\
    \   |\n23 |         while !chars.next().is_empty() {\n   |                   \
    \          ^^^^^^^^ method not found in `Option<char>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp9nd8s8bb.rs:26:23\n   |\n26 |             while i < n {\n\
    \   |                       ^ expected integer, found `char`\n\nerror[E0277]:\
    \ can't compare `{integer}` with `char`\n  --> /tmp/tmp9nd8s8bb.rs:26:21\n   |\n\
    26 |             while i < n {\n   |                     ^ no implementation for\
    \ `{integer} < char` and `{integer} > char`\n   |\n   = help: the trait `PartialOrd<char>`\
    \ is not implemented for `{integer}`\n   = help: the following other types implement\
    \ trait `PartialOrd<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0599]: no method named `is_empty`\
    \ found for enum `Option` in the current scope\n  --> /tmp/tmp9nd8s8bb.rs:27:33\n\
    \   |\n27 |                 if chars.next().is_empty() {\n   |               \
    \                  ^^^^^^^^ method not found in `Option<char>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9nd8s8bb.rs:33:21\n   |\n33 |             if\
    \ i == n {\n   |                     ^ expected integer, found `char`\n\nerror[E0277]:\
    \ can't compare `{integer}` with `char`\n  --> /tmp/tmp9nd8s8bb.rs:33:18\n   |\n\
    33 |             if i == n {\n   |                  ^^ no implementation for `{integer}\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `{integer}`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror["
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    match s.len()\
    \ {\n        0 => vec![],\n        _ => {\n            let mut set = String::from(\"\
    aeiou\");\n            let mut s = s;\n            let mut index = 0;\n      \
    \      while s.len() > index {\n                if s.chars().all(|c| set.contains(&c))\
    \ {\n                    set.insert(0, s.chars().next().unwrap());\n         \
    \       }\n                index += 1;\n            }\n            s.chars().rev().take(n).collect()\n\
    \        }\n    }\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmp9f654opp.rs:25:51\n\
    \     |\n25   |                 if s.chars().all(|c| set.contains(&c)) {\n   \
    \  |                                          -------- ^^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n     |                                          |\n \
    \    |                                          required by a bound introduced\
    \ by this call\n     |\n     = help: the trait `Fn<(char,)>` is not implemented\
    \ for `char`\n     = note: required because of the requirements on the impl of\
    \ `FnOnce<(char,)>` for `&char`\n     = note: required because of the requirements\
    \ on the impl of `Pattern<'_>` for `&char`\nnote: required by a bound in `core::str::<impl\
    \ str>::contains`\nhelp: consider dereferencing here\n     |\n25   |         \
    \        if s.chars().all(|c| set.contains(*&c)) {\n     |                   \
    \                                +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9f654opp.rs:30:34\n\
    \   |\n30 |             s.chars().rev().take(n).collect()\n   |              \
    \                    ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    30 |             s.chars().rev().take(n.try_into().unwrap()).collect()\n   | \
    \                                  ++++++++++++++++++++\n\nerror[E0277]: a value\
    \ of type `Vec<String>` cannot be built from an iterator over elements of type\
    \ `char`\n    --> /tmp/tmp9f654opp.rs:30:37\n     |\n30   |             s.chars().rev().take(n).collect()\n\
    \     |                                     ^^^^^^^ value of type `Vec<String>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n     |\n     = help:\
    \ the trait `FromIterator<char>` is not implemented for `Vec<String>`\n     =\
    \ help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    // BEGIN\
    \ Question 4\n    assert!(n >= 0);\n    \n    let mut result = vec![];\n    \n\
    \    let mut s = String::from(s);\n    \n    while n != 0 {\n        \n      \
    \  let mut current = s.chars();\n        \n        while current.any(|c| c.is_consonant()\
    \ != true) {\n            current.next();\n        }\n        \n        result.push(current.collect());\n\
    \        \n        n-=1;\n        \n        if n == 0 {\n            return result;\n\
    \        }\n    }\n    \n    // END Question 4\n    \n    return vec![];\n}\n\n\
    fn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpsjm2_gsl.rs:29:33\n   |\n29 |         while current.any(|c|\
    \ c.is_consonant() != true) {\n   |                                 ^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    select_words(s,\
    \ n, vec![String::from(\"Hello\")])\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 2 arguments but 3 arguments were supplied\n\
    \  --> /tmp/tmphx4wvtfd.rs:18:5\n   |\n18 |     select_words(s, n, vec![String::from(\"\
    Hello\")])\n   |     ^^^^^^^^^^^^ -  -  --------------------------- supplied 3\
    \ arguments\n   |     |\n   |     expected 2 arguments\n   |\nnote: function defined\
    \ here\n  --> /tmp/tmphx4wvtfd.rs:17:4\n   |\n17 | fn select_words(s: String,\
    \ n: isize) -> Vec<String> {\n   |    ^^^^^^^^^^^^ ---------  --------\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ word = Vec::new();\n    let mut s = String::from(s);\n    s.strip_ascii_whitespace();\n\
    \    while n > 0{\n        for _ in s.chars().skip_while(|x| x == ' ') {\n   \
    \         // We are going to check if the current character is a consonant.\n\
    \            // If it is, we move on to the next character and check if it matches\n\
    \            // a consonant in the string of characters.\n        }\n        word.push(s);\n\
    \        s.clear();\n        n--;\n    }\n    word.push(s);\n    word\n}\n\nfn\
    \ main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmp5bpptrs8.rs:29:12\n\
    \   |\n29 |         n--;\n   |            ^ expected expression\n\nerror[E0599]:\
    \ no method named `strip_ascii_whitespace` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp5bpptrs8.rs:20:7\n   |\n20 |     s.strip_ascii_whitespace();\n\
    \   |       ^^^^^^^^^^^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `split_ascii_whitespace`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmp5bpptrs8.rs:22:45\n   |\n22 |         for _ in s.chars().skip_while(|x|\
    \ x == ' ') {\n   |                                             ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut s = String::from(s);\n    let mut vowels =\
    \ vec!['a', 'e', 'i', 'o', 'u', 'y'];\n    while !s.is_empty() {\n        let\
    \ mut c = s.chars().nth(0).unwrap();\n        if c == ' ' || c == '\\n' {\n  \
    \          if s.len() > n {\n                result.push(s.trim_end());\n    \
    \        }\n            s = String::from(\"\");\n        }\n        else {\n \
    \           if vowels.contains(&c) || c != 'a' && c != 'e' && c != 'i' && c !=\
    \ 'o' && c != 'y' && c != 'w' {\n                result.push(s.trim_end());\n\
    \            }\n            else {\n                s = String::from(\"\");\n\
    \            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_15_dvip.rs:24:26\n   |\n\
    24 |             if s.len() > n {\n   |                          ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n24 |             if s.len() > n.try_into().unwrap()\
    \ {\n   |                           ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_15_dvip.rs:38:5\n   |\n17 | fn select_words(s: String,\
    \ n: isize) -> Vec<String> {\n   |                                         -----------\
    \ expected `Vec<String>` because of return type\n...\n38 |     result\n   |  \
    \   ^^^^^^ expected struct `String`, found `&str`\n   |\n   = note: expected struct\
    \ `Vec<String>`\n              found struct `Vec<&str>`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    if s.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut s = s;\n    let mut n = n as\
    \ isize;\n\n    let mut word_vec: Vec<String> = Vec::new();\n    let mut word_iter:\
    \ Vec<String> = Vec::new();\n    loop {\n        let first_word = s.split_whitespace()[0];\n\
    \        if n == 0 {\n            break;\n        }\n        if n == 1 {\n   \
    \         word_vec.push(first_word);\n            break;\n        }\n\n      \
    \  if word_vec.len() == 1 {\n            word_vec.push(first_word);\n        \
    \    break;\n        }\n\n        for w in s.split_whitespace() {\n          \
    \  if w == first_word {\n                word_vec.push(w);\n                break;\n\
    \            } else {\n                word_iter\n                    .push(w)\n\
    \                    .chain(word_vec)\n                    .cloned()\n       \
    \             .sort();\n            }\n        }\n\n        word_vec.clear();\n\
    \        word_vec.extend(word_iter);\n        n = n - 1;\n    }\n\n    word_vec\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmpt93b_2kc.rs:28:26\n   |\n28 |         let first_word = s.split_whitespace()[0];\n\
    \   |                          ^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpt93b_2kc.rs:44:31\n   |\n44 |                 word_vec.push(w);\n\
    \   |                               ^- help: try using a conversion method: `.to_string()`\n\
    \   |                               |\n   |                               expected\
    \ struct `String`, found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt93b_2kc.rs:48:27\n\
    \   |\n48 |                     .push(w)\n   |                           ^- help:\
    \ try using a conversion method: `.to_string()`\n   |                        \
    \   |\n   |                           expected struct `String`, found `&str`\n\
    \nerror[E0599]: `()` is not an iterator\n  --> /tmp/tmpt93b_2kc.rs:49:22\n   |\n\
    49 |                     .chain(word_vec)\n   |                      ^^^^^ `()`\
    \ is not an iterator\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `(): Iterator`\n           which is required by `&mut (): Iterator`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599, E0608.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    if s.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut v = vec![];\n    for c in s.chars()\
    \ {\n        if c == ' ' {\n            continue;\n        }\n        if c ==\
    \ 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'\n        || c == 'y' ||\
    \ c == '{' || c == '}' || c == '{' || c == '}' || c == ','\n        {\n      \
    \      continue;\n        }\n        if c == ' ' {\n            continue;\n  \
    \      }\n        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'\n\
    \        || c == 'y' || c == '{' || c == '}' || c == '{' || c == '}' || c == ','\n\
    \        {\n            continue;\n        }\n        if c == ' ' {\n        \
    \    continue;\n        }\n        if c.to_ascii_lowercase() == c {\n        \
    \    continue;\n        }\n        if c.to_ascii_uppercase() == c {\n        \
    \    continue;\n        }\n        if c.to_ascii_lowercase().chars().count() >\
    \ n {\n            continue;\n        }\n        if c.to_ascii_uppercase().chars().count()\
    \ > n {\n            continue;\n        }\n        if c == ' ' {\n           \
    \ continue;\n        }\n        v.push(c);\n    }\n    v\n}\n\nfn main() {\n \
    \   let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `chars` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpttcxj_dm.rs:49:35\n   |\n49 |         if c.to_ascii_lowercase().chars().count()\
    \ > n {\n   |                                   ^^^^^ method not found in `char`\n\
    \nerror[E0599]: no method named `chars` found for type `char` in the current scope\n\
    \  --> /tmp/tmpttcxj_dm.rs:52:35\n   |\n52 |         if c.to_ascii_uppercase().chars().count()\
    \ > n {\n   |                                   ^^^^^ method not found in `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpttcxj_dm.rs:60:5\n   |\n17 | fn\
    \ select_words(s: String, n: isize) -> Vec<String> {\n   |                   \
    \                      ----------- expected `Vec<String>` because of return type\n\
    ...\n60 |     v\n   |     ^ expected struct `String`, found `char`\n   |\n   =\
    \ note: expected struct `Vec<String>`\n              found struct `Vec<char>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ ret: Vec<String> = Vec::new();\n    for substr in s.split(|c| !c.is_ascii_alphanumeric())\
    \ {\n        let mut s = substr.to_owned();\n        let mut count = 1;\n    \
    \    while s.is_ascii_alphanumeric() && count < n {\n            count += 1;\n\
    \            s += 1;\n        }\n        if count == n {\n            ret.push(String::from(s));\n\
    \        }\n    }\n    ret\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpwmcjk44_.rs:19:28\n\
    \   |\n19 |     for substr in s.split(|c| !c.is_ascii_alphanumeric()) {\n   |\
    \                            ^ consider giving this closure parameter a type\n\
    \   |\n   = note: type must be known at this point\n\nerror[E0599]: no method\
    \ named `is_ascii_alphanumeric` found for struct `String` in the current scope\n\
    \  --> /tmp/tmpwmcjk44_.rs:22:17\n   |\n22 |         while s.is_ascii_alphanumeric()\
    \ && count < n {\n   |                 ^^^^^^^^^^^^^^^^^^^^^ method not found\
    \ in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwmcjk44_.rs:24:18\n\
    \   |\n24 |             s += 1;\n   |                  ^ expected `&str`, found\
    \ integer\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0282, E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    if s.is_empty()\
    \ {\n        return vec![];\n    }\n    \n    let mut s = s; // Copy\n    let\
    \ mut count = n; // Copy\n    \n    while let Some(word) = s.split_whitespace()\
    \ {\n        if word.len() >= n {\n            count -= word.len();\n        \
    \    if count == 0 {\n                s = s.trim_left_whitespace();\n        \
    \    }\n        }\n    }\n    \n    return s.split_whitespace()\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcpi48rew.rs:25:15\n   |\n\
    25 |     while let Some(word) = s.split_whitespace() {\n   |               ^^^^^^^^^^\
    \   -------------------- this expression has type `SplitWhitespace<'_>`\n   |\
    \               |\n   |               expected struct `SplitWhitespace`, found\
    \ enum `Option`\n   |\n   = note: expected struct `SplitWhitespace<'_>`\n    \
    \            found enum `Option<_>`\n\nerror[E0599]: no method named `trim_left_whitespace`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpcpi48rew.rs:29:23\n\
    \   |\n29 |                 s = s.trim_left_whitespace();\n   |              \
    \         ^^^^^^^^^^^^^^^^^^^^ help: there is an associated function with a similar\
    \ name: `split_whitespace`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcpi48rew.rs:34:12\n\
    \   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |      \
    \                                   ----------- expected `Vec<String>` because\
    \ of return type\n...\n34 |     return s.split_whitespace()\n   |            ^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found struct `SplitWhitespace`\n   |\n   = note: expected\
    \ struct `Vec<String>`\n              found struct `SplitWhitespace<'_>`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = vec![];\n    let mut i = 1;\n    while i <= n {\n        // split string\
    \ into a vec\n        let split_string = s.split_whitespace();\n\n        // count\
    \ number of consonants\n        let mut num_of_consonants = 0;\n        for w\
    \ in split_string {\n            if w == \"a\" || w == \"e\" || w == \"i\" ||\
    \ w == \"o\" || w == \"u\" {\n                num_of_consonants += 1;\n      \
    \      }\n        }\n\n        // if number of consonants is equal to n\n    \
    \    if num_of_consonants == n {\n            result.push(split_string[0]);\n\
    \        }\n\n        // else continue\n        i += 1;\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmptd2c1o_0.rs:34:25\n   |\n34 |             result.push(split_string[0]);\n\
    \   |                         ^^^^^^^^^^^^^^^\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0608`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    match (s.chars(),\
    \ n) {\n        (&[_], 0) => vec![],\n        (&[..], _) => vec![],\n        (&[c,\
    \ ..], n) => {\n            let mut count = 0;\n            let mut vec = Vec::new();\n\
    \            for c in s.chars() {\n                if c != 'a' && c != 'e' &&\
    \ c != 'i' && c != 'o' && c != 'u' && c != 'A' &&\n                    c != 'E'\
    \ && c != 'I' && c != 'O' && c != 'U' &&\n                    c != 'a' && c !=\
    \ 'e' && c != 'i' && c != 'o' && c != 'u' && c != 'A' &&\n                   \
    \ c != 'E' && c != 'I' && c != 'O' && c != 'U' && c != 'a' &&\n              \
    \      c != 'e' && c != 'i' && c != 'o' && c != 'u' && c != 'A' &&\n         \
    \           c != 'E' && c != 'I' && c != 'O' && c != 'U' && c != 'a' &&\n    \
    \                c != 'e' && c != 'i' && c != 'o' && c != 'u' && c != 'A' &&\n\
    \                    c != 'E' && c != 'I' && c != 'O' && c != 'U' && c != 'a'\
    \ &&\n                    c != 'e' && c != 'i' && c != 'o' && c != 'u' && c !=\
    \ 'A' &&\n                    c != 'E' && c != 'I' && c != 'O' && c != 'U' &&\
    \ c != 'a' &&\n                    c != 'e' && c != 'i' && c != 'o' && c != 'u'\
    \ && c != 'A' &&\n                    c != 'E' && c != 'I' && c != 'O' && c !=\
    \ 'U' && c != 'a' &&\n                    c != 'e' && c != 'i' && c != 'o' &&\
    \ c != 'u' && c != 'A' &&\n                    c != 'E' && c != 'I' && c != 'O'\
    \ && c != 'U' && c != 'a' &&\n                    c != 'e' && c != 'i' && c !=\
    \ 'o' && c != 'u' && c != 'A' &&\n                    c != 'E' && c != 'I' &&\
    \ c != 'O' && c != 'U' && c != 'a' &&\n                    c != 'e' && c != 'i'\
    \ && c != 'o' && c != 'u' && c != 'A' &&\n                    c != 'E' && c !=\
    \ 'I' && c != 'O' && c != 'U' && c != 'a' &&\n                    c != 'e' &&\
    \ c != 'i' && c != 'o' && c != 'u' && c != 'A' &&\n                    c != 'E'\
    \ && c != 'I' && c != 'O' && \n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmprc4w4zcv.rs:56:3\n\
    \   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |      \
    \                                               - unclosed delimiter\n18 |   \
    \  match (s.chars(), n) {\n   |                          - unclosed delimiter\n\
    ...\n21 |         (&[c, ..], n) => {\n   |                          - unclosed\
    \ delimiter\n...\n24 |             for c in s.chars() {\n   |                \
    \                - this delimiter might not be properly closed...\n...\n45 | }\n\
    \   | - ...as it matches this but it has different indentation\n...\n56 | }\n\
    \   |   ^\n\nerror: expected expression, found `}`\n  --> /tmp/tmprc4w4zcv.rs:45:1\n\
    \   |\n45 | }\n   | ^ expected expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmprc4w4zcv.rs:19:10\n   |\n18 |     match (s.chars(), n) {\n   |\
    \           -------------- this expression has type `(Chars<'_>, isize)`\n19 |\
    \         (&[_], 0) => vec![],\n   |          ^^^^ expected struct `Chars`, found\
    \ reference\n   |\n   = note: expected struct `Chars<'_>`\n           found reference\
    \ `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprc4w4zcv.rs:20:10\n  \
    \ |\n18 |     match (s.chars(), n) {\n   |           -------------- this expression\
    \ has type `(Chars<'_>, isize)`\n19 |         (&[_], 0) => vec![],\n20 |     \
    \    (&[..], _) => vec![],\n   |          ^^^^^ expected struct `Chars`, found\
    \ reference\n   |\n   = note: expected struct `Chars<'_>`\n           found reference\
    \ `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprc4w4zcv.rs:21:10\n  \
    \ |\n18 |     match (s.chars(), n) {\n   |           -------------- this expression\
    \ has type `(Chars<'_>, isize)`\n...\n21 |         (&[c, ..], n) => {\n   |  \
    \        ^^^^^^^^ expected struct `Chars`, found reference\n   |\n   = note: expected\
    \ struct `Chars<'_>`\n           found reference `&_`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmprc4w4zcv.rs:21:26\n   |\n21 |           (&[c, ..], n) =>\
    \ {\n   |  __________________________^\n22 | |             let mut count = 0;\n\
    23 | |             let mut vec = Vec::new();\n24 | |             for c "
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut words = s.split_whitespace().collect::<Vec<_>>();\n\
    \    let mut counts = HashMap::new();\n    for &w in words {\n        if counts.contains_key(&w)\
    \ {\n            counts.entry(*w).or_insert(0) += 1;\n        }\n        else\
    \ {\n            counts.insert(w.clone(), 1);\n        }\n    }\n    let mut max\
    \ = 0;\n    for pair in counts {\n        if pair.1.cmp(&n) == -1 {\n        \
    \    if max < pair.1 {\n                max = pair.1;\n            }\n       \
    \ }\n    }\n    for pair in counts {\n        if pair.1.cmp(&n) == 1 {\n     \
    \       if max > pair.1 {\n                break;\n            }\n        }\n\
    \        if pair.1.cmp(&max) == 0 {\n            result.push(*pair.key);\n   \
    \     }\n    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpwlfhzy0y.rs:20:22\n   |\n20 |     let mut counts = HashMap::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0277]:\
    \ the size for values of type `str` cannot be known at compilation time\n  -->\
    \ /tmp/tmpwlfhzy0y.rs:21:10\n   |\n21 |     for &w in words {\n   |          ^\
    \ doesn't have a size known at compile-time\n   |\n   = help: the trait `Sized`\
    \ is not implemented for `str`\n   = note: all local variables must have a statically\
    \ known size\n   = help: unsized locals are gated as an unstable feature\n\nerror[E0614]:\
    \ type `str` cannot be dereferenced\n  --> /tmp/tmpwlfhzy0y.rs:23:26\n   |\n23\
    \ |             counts.entry(*w).or_insert(0) += 1;\n   |                    \
    \      ^^\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpwlfhzy0y.rs:23:43\n\
    \   |\n23 |             counts.entry(*w).or_insert(0) += 1;\n   |            \
    \ ----------------------------- ^^\n   |             |\n   |             cannot\
    \ assign to this expression\n\nerror[E0599]: no method named `clone` found for\
    \ type `str` in the current scope\n  --> /tmp/tmpwlfhzy0y.rs:26:29\n   |\n26 |\
    \             counts.insert(w.clone(), 1);\n   |                             ^^^^^\
    \ method not found in `str`\n\nerror: aborting due to 5 previous errors\n\nSome\
    \ errors have detailed explanations: E0067, E0277, E0433, E0599, E0614.\nFor more\
    \ information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    vec![s]\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"Mary had a little lamb\"]`,\n right: `[\"little\"]`', /tmp/tmp_hgpcn0d.rs:23:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010888
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    vec![]\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"little\"]`', /tmp/tmp1sy5pnx1.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = vec![];\n    let mut s = s;\n    while s.len() > n {\n        result.push(s.trim_suffix(1));\n\
    \        s = s.trim_suffix(1);\n    }\n    if s.len() > 0 {\n        result.push(s);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7p9y_rbc.rs:20:21\n   |\n\
    20 |     while s.len() > n {\n   |                     ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n20 |     while s.len() > n.try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0599]: no method\
    \ named `trim_suffix` found for struct `String` in the current scope\n  --> /tmp/tmp7p9y_rbc.rs:21:23\n\
    \   |\n21 |         result.push(s.trim_suffix(1));\n   |                     \
    \  ^^^^^^^^^^^ help: there is an associated function with a similar name: `strip_suffix`\n\
    \nerror[E0599]: no method named `trim_suffix` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp7p9y_rbc.rs:22:15\n   |\n22 |         s = s.trim_suffix(1);\n\
    \   |               ^^^^^^^^^^^ help: there is an associated function with a similar\
    \ name: `strip_suffix`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    match len(s)\
    \ {\n        0 => Vec::new(),\n        _ => s.chars().collect::<Vec<String>>().filter(|c|\
    \ is_consonant(c)).filter(|c| c == ' ').take(n).collect()\n    }\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `len` in this scope\n  --> /tmp/tmpjolhv5nf.rs:18:11\n\
    \   |\n18 |     match len(s) {\n   |           ^^^ not found in this scope\n\n\
    error[E0425]: cannot find function `is_consonant` in this scope\n  --> /tmp/tmpjolhv5nf.rs:20:60\n\
    \   |\n20 |         _ => s.chars().collect::<Vec<String>>().filter(|c| is_consonant(c)).filter(|c|\
    \ c == ' ').take(n).collect()\n   |                                          \
    \                  ^^^^^^^^^^^^ not found in this scope\n\nerror[E0277]: a value\
    \ of type `Vec<String>` cannot be built from an iterator over elements of type\
    \ `char`\n    --> /tmp/tmpjolhv5nf.rs:20:24\n     |\n20   |         _ => s.chars().collect::<Vec<String>>().filter(|c|\
    \ is_consonant(c)).filter(|c| c == ' ').take(n).collect()\n     |            \
    \            ^^^^^^^ value of type `Vec<String>` cannot be built from `std::iter::Iterator<Item=char>`\n\
    \     |\n     = help: the trait `FromIterator<char>` is not implemented for `Vec<String>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0599]: `Vec<String>` is not an iterator\n\
    \   --> /tmp/tmpjolhv5nf.rs:20:49\n    |\n20  |           _ => s.chars().collect::<Vec<String>>().filter(|c|\
    \ is_consonant(c)).filter(|c| c == ' ').take(n).collect()\n    |             \
    \                                      ^^^^^^ `Vec<String>` is not an iterator\n\
    \    |\n    = note: the following trait bounds were not satisfied:\n         \
    \   `Vec<String>: Iterator`\n            which is required by `&mut Vec<String>:\
    \ Iterator`\n            `[String]: Iterator`\n            which is required by\
    \ `&mut [String]: Iterator`\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = Vec::new();\n    let mut chars = s.chars();\n    let mut current_char\
    \ = 0;\n    let mut found_count = 0;\n    while chars.len() > 0 {\n        current_char\
    \ += 1;\n        let next_char = chars.next().unwrap();\n        if next_char\
    \ == ' ' {\n            found_count += 1;\n        }\n        if next_char ==\
    \ c.consonant[n - found_count] {\n            found_count += 1;\n            if\
    \ found_count == n {\n                words.push(String::from(&s[current_char..]));\n\
    \                found_count = 0;\n            }\n        }\n    }\n    words\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `c` in this scope\n  --> /tmp/tmp06nj2yeh.rs:28:25\n\
    \   |\n28 |         if next_char == c.consonant[n - found_count] {\n   |     \
    \                    ^ help: a local variable with a similar name exists: `n`\n\
    \nerror[E0599]: no method named `len` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmp06nj2yeh.rs:22:17\n   |\n22 |     while chars.len() > 0\
    \ {\n   |                 ^^^ method not found in `Chars<'_>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    if s.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut selected_words = vec![];\n\n\
    \    let mut i = 0;\n    while i < s.len() {\n        loop {\n            let\
    \ mut j = i + 1;\n            let mut word = \"\";\n            while j < s.len()\
    \ {\n                if s[j] == s[i]\n                    || (s[j] as u32 as char)\
    \ == (s[i] as u32 as char) {\n                    word += s[j];\n            \
    \        i += 1;\n                    break;\n                } else {\n     \
    \               j += 1;\n                }\n            }\n            if word.length()\
    \ == n {\n                selected_words.push_back(word);\n                i +=\
    \ 1;\n            } else {\n                break;\n            }\n        }\n\
    \    }\n    selected_words\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp99p7pd0k.rs:30:20\n\
    \   |\n30 |                 if s[j] == s[i]\n   |                    ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp99p7pd0k.rs:30:28\n   |\n30 |                 if s[j] == s[i]\n\
    \   |                            ^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp99p7pd0k.rs:31:25\n   |\n31 |                     || (s[j] as u32\
    \ as char) == (s[i] as u32 as char) {\n   |                         ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    s.chars().filter_map(|c|\
    \ {\n        if c.is_alphabetic() {\n            if c == ' ' {\n             \
    \   Some(true)\n            } else {\n                if n <= 0 || c.is_consonant()\
    \ {\n                    Some(false)\n                } else {\n             \
    \       Some(true)\n                }\n            }\n        } else {\n     \
    \       None\n        }\n    }).filter(|c| c.is_some()).collect()\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmp94sj5sjx.rs:23:32\n   |\n23 |                 if\
    \ n <= 0 || c.is_consonant() {\n   |                                ^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror[E0599]: no method named `is_some` found\
    \ for reference `&bool` in the current scope\n  --> /tmp/tmp94sj5sjx.rs:32:21\n\
    \   |\n32 |     }).filter(|c| c.is_some()).collect()\n   |                   \
    \  ^^^^^^^ method not found in `&bool`\n\nerror[E0277]: a value of type `Vec<String>`\
    \ cannot be built from an iterator over elements of type `bool`\n    --> /tmp/tmp94sj5sjx.rs:32:32\n\
    \     |\n32   |     }).filter(|c| c.is_some()).collect()\n     |             \
    \                   ^^^^^^^ value of type `Vec<String>` cannot be built from `std::iter::Iterator<Item=bool>`\n\
    \     |\n     = help: the trait `FromIterator<bool>` is not implemented for `Vec<String>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    select_words(s,\
    \ n, s.chars().count())\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 2 arguments but 3 arguments were supplied\n\
    \  --> /tmp/tmpb8xdulav.rs:18:5\n   |\n18 |     select_words(s, n, s.chars().count())\n\
    \   |     ^^^^^^^^^^^^ -  -  ----------------- supplied 3 arguments\n   |    \
    \ |\n   |     expected 2 arguments\n   |\nnote: function defined here\n  --> /tmp/tmpb8xdulav.rs:17:4\n\
    \   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ^^^^^^^^^^^^\
    \ ---------  --------\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ chars = s;\n    let mut words = Vec::new();\n    loop {\n        let mut found\
    \ = false;\n        for (char, char_len) in chars.chars().enumerate() {\n    \
    \        if char_len > n {\n                chars = chars.chars().skip_while(|&&c|\
    \ *c != char).collect();\n            } else {\n                found = true;\n\
    \                break;\n            }\n        }\n        if found {\n      \
    \      words.push(s);\n        }\n        if chars.is_empty() {\n            break;\n\
    \        }\n    }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz_0et2w9.rs:23:27\n   |\n\
    23 |             if char_len > n {\n   |                           ^ expected\
    \ `char`, found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpz_0et2w9.rs:24:52\n\
    \   |\n24 |                 chars = chars.chars().skip_while(|&&c| *c != char).collect();\n\
    \   |                                                    ^-\n   |            \
    \                                        ||\n   |                            \
    \                        |expected due to this\n   |                         \
    \                           expected `char`, found reference\n   |           \
    \                                         help: you can probably remove the explicit\
    \ borrow: `c`\n   |\n   = note:   expected type `char`\n           found reference\
    \ `&_`\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    \n}\n\n\
    fn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3v79g7v6.rs:17:41\n   |\n\
    17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ s: Vec<String> = vec![];\n    let mut w: Vec<String> = vec![];\n\n    if s.is_empty()\
    \ {\n        return vec![];\n    }\n    if n == 1 {\n        w = vec![s.to_string()];\n\
    \    } else {\n        let mut w: Vec<String> = vec![];\n        for char in s.chars()\
    \ {\n            if !char.vowel() {\n                w.push(s.to_string());\n\
    \            } else {\n                if w.len() >= n {\n                   \
    \ w.pop();\n                } else {\n                    w.push(char.to_string());\n\
    \                }\n            }\n        }\n    }\n    let mut s: Vec<String>\
    \ = vec![];\n    for word in w {\n        match s.iter_mut() {\n            Some(ref\
    \ mut s) => {\n                if s.contains(&word) {\n                    s.push(word);\n\
    \                }\n            }\n            None => {\n                s.push(word);\n\
    \            }\n        }\n    }\n    \n    \n    return s\n}\n\nfn main() {\n\
    \    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `Vec<String>` doesn't implement `std::fmt::Display`\n   -->\
    \ /tmp/tmpmg699yyi.rs:25:20\n    |\n25  |           w = vec![s.to_string()];\n\
    \    |                      ^^^^^^^^^ `Vec<String>` cannot be formatted with the\
    \ default formatter\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Vec<String>: std::fmt::Display`\n            which is required by\
    \ `Vec<String>: ToString`\n            `[String]: std::fmt::Display`\n       \
    \     which is required by `[String]: ToString`\n\nerror[E0599]: no method named\
    \ `chars` found for struct `Vec<String>` in the current scope\n  --> /tmp/tmpmg699yyi.rs:28:23\n\
    \   |\n28 |         for char in s.chars() {\n   |                       ^^^^^\
    \ method not found in `Vec<String>`\n\nerror[E0599]: `Vec<String>` doesn't implement\
    \ `std::fmt::Display`\n   --> /tmp/tmpmg699yyi.rs:30:26\n    |\n30  |        \
    \           w.push(s.to_string());\n    |                            ^^^^^^^^^\
    \ `Vec<String>` cannot be formatted with the default formatter\n    |\n    = note:\
    \ the following trait bounds were not satisfied:\n            `Vec<String>: std::fmt::Display`\n\
    \            which is required by `Vec<String>: ToString`\n            `[String]:\
    \ std::fmt::Display`\n            which is required by `[String]: ToString`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpmg699yyi.rs:32:31\n   |\n32 |  \
    \               if w.len() >= n {\n   |                               ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n32 |                 if\
    \ w.len() >= n.try_into().unwrap() {\n   |                                ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpmg699yyi.rs:43:13\n   |\n42 |\
    \         match s.iter_mut() {\n   |               ------------ this expression\
    \ has type `std::slice::IterMut<'_, String>`\n43 |             Some(ref mut s)\
    \ => {\n   |             ^^^^^^^^^^^^^^^ expected struct `std::slice::IterMut`,\
    \ found enum `Option`\n   |\n   = note: expected struct `std::slice::IterMut<'_,\
    \ String>`\n     "
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    \n}\n\n\
    fn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3v79g7v6.rs:17:41\n   |\n\
    17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    // TODO:\
    \ implement the function\n    return vec![];\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"little\"]`', /tmp/tmpy6xnd_ns.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010888
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    if s.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut s = s;\n\n    let mut words\
    \ = vec![];\n\n    let mut consonants_found = 0;\n\n    while !s.is_empty() {\n\
    \        let c = s.chars().next().unwrap();\n        if c < 'a' || c > 'z' {\n\
    \            break;\n        }\n        let mut found = false;\n        for c\
    \ in s.chars() {\n            if c < 'A' || c > 'Z' {\n                break;\n\
    \            }\n            if c == 'y' || c == 'Y' {\n                continue;\n\
    \            }\n            if c != c.to_ascii_lowercase() {\n               \
    \ break;\n            }\n            found = true;\n        }\n        if !found\
    \ {\n            break;\n        }\n        words.push_back(s);\n        consonants_found++;\n\
    \        s = String::from(\"\");\n    }\n\n    if consonants_found > n {\n   \
    \     return vec![];\n    }\n    words\n}\n\nfn main() {\n    let candidate =\
    \ select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmphfib2ygs.rs:50:25\n\
    \   |\n50 |         consonants_found++;\n   |                         ^^ not a\
    \ valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n50 |         {\
    \ let tmp = consonants_found; consonants_found += 1; tmp };\n   |         +++++++++++\
    \                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n50 -         consonants_found++;\n\
    50 +         consonants_found += 1;\n   | \n\nerror[E0599]: no method named `push_back`\
    \ found for struct `Vec<_>` in the current scope\n  --> /tmp/tmphfib2ygs.rs:49:15\n\
    \   |\n49 |         words.push_back(s);\n   |               ^^^^^^^^^ method not\
    \ found in `Vec<_>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    if s.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut i = 0;\n    let mut len = s.len();\n\
    \    let mut words = vec![];\n\n    while i < len && i < n {\n        if s.chars().any(|c|\
    \ !c.is_vowel()) {\n            i += 1;\n        } else {\n            words.push(s.split_off(i));\n\
    \        }\n    }\n\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpa38i2rjt.rs:26:26\n   |\n\
    26 |     while i < len && i < n {\n   |                          ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n26 |     while i < len && i < n.try_into().unwrap()\
    \ {\n   |                           ++++++++++++++++++++\n\nerror[E0599]: no method\
    \ named `is_vowel` found for type `char` in the current scope\n  --> /tmp/tmpa38i2rjt.rs:27:33\n\
    \   |\n27 |         if s.chars().any(|c| !c.is_vowel()) {\n   |              \
    \                   ^^^^^^^^ method not found in `char`\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ s = s;\n\n    if s.is_empty() {\n        return Vec::new();\n    }\n\n    let\
    \ mut current_word = \"\";\n    let mut count = String::new();\n\n    s.chars().for_each(|c|{\n\
    \        if c == ' ' || c == '\\t' {\n            count = String::from(count.unwrap());\n\
    \            count\n                .chars()\n                .filter(|c| c !=\
    \ '\\n' && c != ' ' && c != '\\t')\n                .count();\n            \n\
    \            current_word = String::from(current_word.unwrap());\n\n         \
    \   if count.len() == n {\n                current_word += c;\n              \
    \  s.clear();\n            } else {\n                current_word += c;\n    \
    \        }\n        } else {\n            current_word += c;\n        }\n    });\n\
    \    \n    if count != String::new() {\n        s.clear();\n        current_word\
    \ += ' ';\n    }\n\n    if current_word.len() != n {\n        return vec![String::from(current_word)];\n\
    \    }\n\n    vec![String::from(current_word)]\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmptputb0ox.rs:29:40\n   |\n29 |             count\
    \ = String::from(count.unwrap());\n   |                                      \
    \  ^^^^^^ method not found in `String`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmptputb0ox.rs:32:31\n   |\n32 |                 .filter(|c|\
    \ c != '\\n' && c != ' ' && c != '\\t')\n   |                               ^^\
    \ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmptputb0ox.rs:32:44\n\
    \   |\n32 |                 .filter(|c| c != '\\n' && c != ' ' && c != '\\t')\n\
    \   |                                            ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmptputb0ox.rs:32:56\n   |\n32\
    \ |                 .filter(|c| c != '\\n' && c != ' ' && c != '\\t')\n   |  \
    \                                                      ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0599]: no method named `unwrap` found for reference `&str` in the current\
    \ scope\n  --> /tmp/tmptputb0ox.rs:35:54\n   |\n35 |             current_word\
    \ = String::from(current_word.unwrap());\n   |                               \
    \                       ^^^^^^ method not found in `&str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmptputb0ox.rs:35:28\n   |\n24 |     let mut current_word\
    \ = \"\";\n   |                            -- expected due to this value\n...\n\
    35 |             current_word = String::from(current_word.unwrap());\n   |   \
    \                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |          \
    \                  |\n   |                         "
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    s.split(\"\
    \ \").filter(|s| s == \"a\"..=(\"z\" + String::from(\"a\")) as &'static str)\n\
    \        .filter(|s| s == \"A\"..=(\"Z\" + String::from(\"A\")) as &'static str)\n\
    \        .filter(|s| s.chars().all(|c| c < 'A' || c > 'Z'))\n        .filter(|s|\
    \ s.chars().count(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'))\n\
    \        .filter(|s| s.chars().count(|c| c == 'b'..=('z' + String::from('b')))\
    \ as &'static str)\n        .filter(|s| s.chars().count(|c| c == 'B'..=('Z' +\
    \ String::from('B'))) as &'static str)\n        .filter(|s| s.chars().count(|c|\
    \ c == 'c' || c == 'd' || c == 'f' || c == 'g' || c == 'h' || c == 'j' || c ==\
    \ 'k' || c == 'l' || c == 'm' || c == 'n' || c == 'p' || c == 'q' || c == 'r'\
    \ || c == 's' || c == 't' || c == 'v' || c == 'w' || c == 'x' || c == 'y' || c\
    \ == 'z'))\n        .filter(|s| s.chars().count(|c| c == 'A'..=('Z' + String::from('A')))\
    \ as &'static str)\n        .filter(|s| s.chars().count(|c| c == 'B'..=('Z' +\
    \ String::from('B'))) as &'static str)\n        .filter(|s| s.chars().count(|c|\
    \ c == 'c' || c == 'd' || c == 'f' || c == 'g' || c == 'h' || c == 'j' || c ==\
    \ 'k' || c == 'l' || c == 'm' || c == 'n' || c == 'p' || c == 'q' || c == 'r'\
    \ || c == 's' || c == 't' || c == 'v' || c == 'w' || c == 'x' || c == 'y' || c\
    \ == 'z'))\n        .filter(|s| s.chars().count(|c| c == 'A'..=('Z' + String::from('A')))\
    \ as &'static str)\n        .filter(|s| s.chars().count(|c| c == 'B'..=('Z' +\
    \ String::from('B'))) as &'static str)\n        .filter(|s| s.chars().count(|c|\
    \ c == 'c' || c == 'd' || c == 'f' || c\n}\n\nfn main() {\n    let candidate =\
    \ select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpsnhqx876.rs:30:36\n\
    \   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |      \
    \                                               - closing delimiter possibly meant\
    \ for this\n...\n30 |         .filter(|s| s.chars().count(|c| c == 'c' || c ==\
    \ 'd' || c == 'f' || c\n   |                                    ^ unclosed delimiter\n\
    31 | }\n   | ^ mismatched closing delimiter\n\nerror[E0277]: can't compare `&str`\
    \ with `str`\n  --> /tmp/tmpsnhqx876.rs:18:31\n   |\n18 |     s.split(\" \").filter(|s|\
    \ s == \"a\"..=(\"z\" + String::from(\"a\")) as &'static str)\n   |          \
    \                     ^^ no implementation for `&str == str`\n   |\n   = help:\
    \ the trait `PartialEq<str>` is not implemented for `&str`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n\
    \             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n   = note: required because of the requirements on the\
    \ impl of `PartialEq<&str>` for `&&str`\n\nerror[E0369]: cannot add `String` to\
    \ `&str`\n  --> /tmp/tmpsnhqx876.rs:18:45\n   |\n18 |     s.split(\" \").filter(|s|\
    \ s == \"a\"..=(\"z\" + String::from(\"a\")) as &'static str)\n   |          \
    \                               --- ^ ----------------- String\n   |         \
    \                                |   |\n   |                                 \
    \        |   `+` cannot be used to concatenate a `&str` with a `String`\n   |\
    \                                         &str\n   |\nhelp: create an owned `String`\
    \ on the left and add a borrow on the right\n   |\n18 |     s.split(\" \").filter(|s|\
    \ s == \"a\"..=(\"z\".to_owned() + &String::from(\"a\")) as &'static str)\n  \
    \ |                                            +++++++++++   +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpsnhqx876.rs:1"
  stdout: ''
  timestamp: 1660010888
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    if s.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut words: Vec<String> = vec![];\n\
    \    let mut cur = String::from(\"\");\n    let mut cnt = 0;\n    let mut in_word\
    \ = false;\n    let mut space_count = String::from(\"\");\n    for &c in &s {\n\
    \        let mut s = c.to_ascii_lowercase();\n        let c = s.chars().count();\n\
    \        if c == n {\n            if in_word {\n                words.push(cur);\n\
    \                cur = String::from(\"\");\n                in_word = false;\n\
    \            }\n            if s.len() < n {\n                cur += s;\n    \
    \        } else {\n                cur = s;\n            }\n            cnt++;\n\
    \        }\n        if c == 1 {\n            if s.len() <= n && c > n {\n    \
    \            cur += s;\n            } else {\n                cur = s;\n     \
    \       }\n        }\n        if c == n {\n            in_word = true;\n     \
    \   }\n        if c > n {\n            if s.len() == n && c > n {\n          \
    \      cur += s;\n                words.push(cur);\n            }\n          \
    \  space_count += s;\n        }\n    }\n    if cnt != n {\n        if in_word\
    \ {\n            words.push(cur);\n        }\n        if space_count.len() > n\
    \ {\n            words.push(space_count.clone());\n        }\n    }\n    words\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpjxe8i5vu.rs:40:16\n\
    \   |\n40 |             cnt++;\n   |                ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n40 |             { let tmp = cnt; cnt +=\
    \ 1; tmp };\n   |             +++++++++++    ~~~~~~~~~~~~~~~~~\n40 -         \
    \    cnt++;\n40 +             cnt += 1;\n   | \n\nerror[E0277]: `&String` is not\
    \ an iterator\n  --> /tmp/tmpjxe8i5vu.rs:26:15\n   |\n26 |     for &c in &s {\n\
    \   |               ^^ `&String` is not an iterator\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `&String`\n   = note: required because of\
    \ the requirements on the impl of `IntoIterator` for `&String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpjxe8i5vu.rs:64:32\n   |\n64 |         if space_count.len()\
    \ > n {\n   |                                ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n64 |         if space_count.len() > n.try_into().unwrap()\
    \ {\n   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    if s.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut letters = String::new();\n \
    \   let mut counts = HashMap::new();\n\n    for c in s.chars() {\n        if let\
    \ Some(count) = counts.get(&c) {\n            counts.entry(c.clone()).or_insert(*count\
    \ + 1);\n        } else {\n            counts.entry(c.clone()).or_insert(1);\n\
    \        }\n    }\n\n    for (key, _) in counts {\n        if counts[key] == n\
    \ {\n            let mut words = vec![];\n            words.extend_from_slice(&s[key..key+key]);\n\
    \            words.extend_from_slice(&s[key..key+key]);\n            words.extend_from_slice(&s[key..key+key]);\n\
    \            return words;\n        }\n    }\n\n    vec![]\n}\n\nfn main() {\n\
    \    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp6eg6q20f.rs:23:22\n   |\n23 |     let mut counts = HashMap::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp6eg6q20f.rs:36:37\n   |\n36 |             words.extend_from_slice(&s[key..key+key]);\n\
    \   |                                     ^^^^^^^^^^^^^^^^ expected slice, found\
    \ `str`\n   |\n   = note: expected reference `&[_]`\n              found reference\
    \ `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6eg6q20f.rs:37:37\n\
    \   |\n37 |             words.extend_from_slice(&s[key..key+key]);\n   |     \
    \                                ^^^^^^^^^^^^^^^^ expected slice, found `str`\n\
    \   |\n   = note: expected reference `&[_]`\n              found reference `&str`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp6eg6q20f.rs:38:37\n   |\n38 |\
    \             words.extend_from_slice(&s[key..key+key]);\n   |               \
    \                      ^^^^^^^^^^^^^^^^ expected slice, found `str`\n   |\n  \
    \ = note: expected reference `&[_]`\n              found reference `&str`\n\n\
    error: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ res = Vec::new();\n    for i in 0..n + 1 {\n        res.push(s.take_nth(i));\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `take_nth` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpcjungvrp.rs:20:20\n   |\n20 |         res.push(s.take_nth(i));\n\
    \   |                    ^^^^^^^^ method not found in `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = vec![];\n    let mut counts = HashMap::new();\n    for c in s.chars()\
    \ {\n        counts.entry(c).or_insert(0)+= 1;\n    }\n    for (i, c) in counts.iter().enumerate()\
    \ {\n        if c >= n {\n            result.push(s.to_string()[i .. i + 1]);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp2_7daw0o.rs:19:22\n   |\n19 |     let mut counts = HashMap::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0067]:\
    \ invalid left-hand side of assignment\n  --> /tmp/tmp2_7daw0o.rs:21:37\n   |\n\
    21 |         counts.entry(c).or_insert(0)+= 1;\n   |         ----------------------------^^\n\
    \   |         |\n   |         cannot assign to this expression\n\nerror[E0277]:\
    \ the size for values of type `str` cannot be known at compilation time\n   -->\
    \ /tmp/tmp2_7daw0o.rs:25:25\n    |\n25  |             result.push(s.to_string()[i\
    \ .. i + 1]);\n    |                    ---- ^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't\
    \ have a size known at compile-time\n    |                    |\n    |       \
    \             required by a bound introduced by this call\n    |\n    = help:\
    \ the trait `Sized` is not implemented for `str`\nnote: required by a bound in\
    \ `Vec::<T, A>::push`\n\nerror[E0277]: the size for values of type `str` cannot\
    \ be known at compilation time\n   --> /tmp/tmp2_7daw0o.rs:18:22\n    |\n18  |\
    \     let mut result = vec![];\n    |                      ^^^^^^ doesn't have\
    \ a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented\
    \ for `str`\nnote: required by a bound in `Vec::<T>::new`\n    = note: this error\
    \ originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace\
    \ for more info)\n\nerror[E0277]: the size for values of type `str` cannot be\
    \ known at compilation time\n   --> /tmp/tmp2_7daw0o.rs:18:22\n    |\n18  |  \
    \   let mut result = vec![];\n    |                      ^^^^^^ doesn't have a\
    \ size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented\
    \ for `str`\nnote: required by a bound in `Vec`\n    = note: this error originates\
    \ in the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more\
    \ info)\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2_7daw0o.rs:28:5\n  \
    \ |\n17 | fn select_words(s: String, n: isize) -> V"
  stdout: ''
  timestamp: 1660010887
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    vec![]\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"little\"]`', /tmp/tmp1sy5pnx1.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ s = s;\n    let mut l = s.len();\n    while l > 0 {\n        let mut ws = vec![];\n\
    \        for _ in 0..n {\n            let mut i = 0;\n            while i != l\
    \ {\n                if s.chars().nth(i).unwrap().is_ascii() {\n             \
    \       break;\n                }\n                i += 1;\n            }\n  \
    \          if i != l {\n                ws.push(croak(\"not enough chars left\"\
    .to_string(), s));\n            }\n        }\n        let mut idx = ws.iter().position(|&x|\
    \ x.is_ascii());\n        if idx == ws.len() {\n            idx = 0;\n       \
    \ }\n        let mut word = ws.drain(..idx);\n        ws.drain(idx, ..);\n   \
    \     ws.push(croak(\"not enough chars left\".to_string(), s));\n        ws.swap(idx,\
    \ ws.len());\n        for &mut c in ws {\n            s.push_str(&c.to_string());\n\
    \        }\n        l -= 1;\n    }\n    if s.len() == 0 {\n        vec![]\n  \
    \  } else {\n        vec![s]\n    }\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `croak` in this scope\n  --> /tmp/tmp9mgc46ii.rs:31:25\n\
    \   |\n31 |                 ws.push(croak(\"not enough chars left\".to_string(),\
    \ s));\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `croak` in this scope\n  --> /tmp/tmp9mgc46ii.rs:40:17\n\
    \   |\n40 |         ws.push(croak(\"not enough chars left\".to_string(), s));\n\
    \   |                 ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp9mgc46ii.rs:36:19\n   |\n34 |         let mut idx = ws.iter().position(|&x|\
    \ x.is_ascii());\n   |                       -------------------------------------\
    \ expected due to this value\n35 |         if idx == ws.len() {\n36 |        \
    \     idx = 0;\n   |                   ^ expected enum `Option`, found integer\n\
    \   |\n   = note: expected enum `Option<usize>`\n              found type `{integer}`\n\
    help: try wrapping the expression in `Some`\n   |\n36 |             idx = Some(0);\n\
    \   |                   +++++ +\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    vec![]\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"little\"]`', /tmp/tmp1sy5pnx1.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ res = Vec::new();\n    let mut word: Option<Vec<String>> = None;\n    for (i,\
    \ ch) in s.chars().enumerate() {\n        if i > n || ch.is_vowel() {\n      \
    \      if let Some(word)  = word {\n                res.push(word.clone());\n\
    \            }\n            word = None;\n        } else {\n            word =\
    \ Some(vec![i]);\n        }\n    }\n    match word {\n        Some(w) => res.push(w),\n\
    \        None => res,\n    }\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpa8ckmulf.rs:21:16\n   |\n\
    21 |         if i > n || ch.is_vowel() {\n   |                ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n21 |         if i > n.try_into().unwrap()\
    \ || ch.is_vowel() {\n   |                 ++++++++++++++++++++\n\nerror[E0599]:\
    \ no method named `is_vowel` found for type `char` in the current scope\n  -->\
    \ /tmp/tmpa8ckmulf.rs:21:24\n   |\n21 |         if i > n || ch.is_vowel() {\n\
    \   |                        ^^^^^^^^ method not found in `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpa8ckmulf.rs:27:30\n   |\n27 |             word\
    \ = Some(vec![i]);\n   |                              ^- help: try using a conversion\
    \ method: `.to_string()`\n   |                              |\n   |          \
    \                    expected struct `String`, found `usize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpa8ckmulf.rs:31:20\n   |\n17 | fn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n   |                                   \
    \      ----------- expected `Vec<String>` because of return type\n...\n31 |  \
    \       Some(w) => res.push(w),\n   |                    ^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<String>`\n \
    \          found unit type `()`\n\nerror: aborting due to 4 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    if s.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut result = vec![];\n\n    let\
    \ mut pos = 0;\n    while pos < s.len() {\n        let mut j = 0;\n        while\
    \ j < n && s[pos].is_ascii_digit() {\n            j += 1\n        };\n       \
    \ if j == n {\n            result.push(s[pos..pos + n - 1]);\n            pos\
    \ += n - 1;\n        } else {\n            pos += j;\n        }\n    }\n\n   \
    \ result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp009s1s5t.rs:27:24\n\
    \   |\n27 |         while j < n && s[pos].is_ascii_digit() {\n   |           \
    \             ^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp009s1s5t.rs:31:38\n\
    \   |\n31 |             result.push(s[pos..pos + n - 1]);\n   |              \
    \                        ^ expected `usize`, found `isize`\n\nerror[E0277]: cannot\
    \ add `isize` to `usize`\n  --> /tmp/tmp009s1s5t.rs:31:36\n   |\n31 |        \
    \     result.push(s[pos..pos + n - 1]);\n   |                                \
    \    ^ no implementation for `usize + isize`\n   |\n   = help: the trait `Add<isize>`\
    \ is not implemented for `usize`\n   = help: the following other types implement\
    \ trait `Add<Rhs>`:\n             <&'a f32 as Add<f32>>\n             <&'a f64\
    \ as Add<f64>>\n             <&'a i128 as Add<i128>>\n             <&'a i16 as\
    \ Add<i16>>\n             <&'a i32 as Add<i32>>\n             <&'a i64 as Add<i64>>\n\
    \             <&'a i8 as Add<i8>>\n             <&'a isize as Add<isize>>\n  \
    \         and 48 others\n\nerror[E0277]: the size for values of type `str` cannot\
    \ be known at compilation time\n   --> /tmp/tmp009s1s5t.rs:31:25\n    |\n31  |\
    \             result.push(s[pos..pos + n - 1]);\n    |                    ----\
    \ ^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n    |       \
    \             |\n    |                    required by a bound introduced by this\
    \ call\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote:\
    \ required by a bound in `Vec::<T, A>::push`\n\nerror[E0277]: the"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    if s.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut count = vec![];\n    let mut has_n\
    \ = false;\n    let mut i = 0;\n    while i <= s.len() {\n        if s[i] == '\
    \ ' || s[i] == '\\t' || s[i] == '\\n' {\n            has_n = false;\n        }\
    \ else {\n            has_n = true;\n        }\n        if has_n && count == n\
    \ {\n            count.push(s.to_string());\n        }\n        i += 1;\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp1ufxznsj.rs:25:12\n\
    \   |\n25 |         if s[i] == ' ' || s[i] == '\\t' || s[i] == '\\n' {\n   | \
    \           ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp1ufxznsj.rs:25:27\n   |\n25 |         if s[i] == ' ' || s[i] ==\
    \ '\\t' || s[i] == '\\n' {\n   |                           ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp1ufxznsj.rs:25:43\n   |\n25 |         if s[i] == ' ' || s[i] ==\
    \ '\\t' || s[i] == '\\n' {\n   |                                           ^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \       "
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ vec = Vec::new();\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ char = s[i];\n        if char.isspace() {\n            i += 1;\n        } else\
    \ if char == ' ' {\n            vec.push(String::from(\"\"));\n            i +=\
    \ 1;\n        } else {\n            let mut count = 0;\n            for c in &s[1..]\
    \ {\n                if c.is_ascii_digit() {\n                    count += 1;\n\
    \                }\n                if c == char {\n                    count\
    \ += 1;\n                }\n            }\n            if count == n {\n     \
    \           vec.push(String::from(&s[1..i].to_string()));\n                i +=\
    \ 1;\n            }\n        }\n    }\n    vec\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp6m4xz7y7.rs:21:20\n\
    \   |\n21 |         let char = s[i];\n   |                    ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: `&str` is not an iterator\n  --> /tmp/tmp6m4xz7y7.rs:29:22\n\
    \   |\n29 |             for c in &s[1..] {\n   |                      ^^^^^^^\
    \ `&str` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   =\
    \ help: the trait `Iterator` is not implemented for `&str`\n   = note: required\
    \ because of the requirements on the impl of `IntoIterator` for `&str`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = vec![];\n    if s.is_empty() {\n        return result;\n    }\n   \
    \ let mut word_count = 1;\n    for c in s.chars() {\n        if c == ' ' {\n \
    \           word_count += 1;\n        }\n        if word_count == n {\n      \
    \      result.push(s.to_string());\n        }\n        if word_count > n {\n \
    \           break;\n        }\n        word_count += 1;\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"Mary had a little lamb\"]`,\n right: `[\"little\"]`', /tmp/tmpgymefwrw.rs:40:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010888
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    // Your\
    \ code here\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptu_480ft.rs:17:41\n   |\n\
    17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    for word in s.split() {\n        if word.chars().filter(|c|\
    \ c.is_ascii_letter()).count() == n {\n            result.push(word);\n      \
    \  }\n    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmpsm1nolsm.rs:19:19\n     |\n19   |     for word in s.split() {\n\
    \     |                   ^^^^^- supplied 0 arguments\n     |                \
    \   |\n     |                   expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror[E0599]: no method named `is_ascii_letter` found\
    \ for reference `&char` in the current scope\n  --> /tmp/tmpsm1nolsm.rs:20:38\n\
    \   |\n20 |         if word.chars().filter(|c| c.is_ascii_letter()).count() ==\
    \ n {\n   |                                      ^^^^^^^^^^^^^^^ help: there is\
    \ an associated function with a similar name: `is_ascii`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpsm1nolsm.rs:20:68\n   |\n20 |         if word.chars().filter(|c|\
    \ c.is_ascii_letter()).count() == n {\n   |                                  \
    \                                  ^ expected `usize`, found `isize`\n   |\nhelp:\
    \ you can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n20 |         if word.chars().filter(|c| c.is_ascii_letter()).count()\
    \ == n.try_into().unwrap() {\n   |                                           \
    \                          ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsm1nolsm.rs:24:5\n   |\n17 | fn select_words(s: String, n: isize)\
    \ -> Vec<String> {\n   |                                         ----------- expected\
    \ `Vec<String>` because of return type\n...\n24 |     result\n   |     ^^^^^^\
    \ expected struct `String`, found `&str`\n   |\n   = note: expected struct `Vec<String>`\n\
    \              found struct `Vec<&str>`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0061, E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ letters = s.chars().collect::<Vec<String>>();\n    let mut positions = Vec::new();\n\
    \    let mut word_string = String::from(\"\");\n    let mut word = String::from(\"\
    \");\n    for letter in letters {\n        if letter != ' ' {\n            word.push(letter);\n\
    \            positions.push(word_string.len() - word.len());\n        }\n    \
    \    word_string += word;\n        word = String::from(\"\");\n    }\n    if word.len()\
    \ != 0 && n != 0 {\n        let mut word_string = String::from(\"\");\n      \
    \  let mut position = word_string.len();\n        for letter in letters {\n  \
    \          if letter == ' ' || letter == '\\n' {\n                let position\
    \ = position + word.len() - word_string.len();\n                if position ==\
    \ positions[positions.len() - 1] {\n                    if position == positions.len()\
    \ - 1 {\n                        word_string += word;\n                    }\n\
    \                    positions.insert(0, position);\n                }\n     \
    \       }\n            word_string += word;\n            word = String::from(\"\
    \");\n        }\n        if word_string.len() == 0 {\n            word_string\
    \ = String::from(\"\");\n            positions = Vec::new();\n        }\n    }\n\
    \    let mut words: Vec<String> = Vec::new();\n    let mut word_strings = word_string.split_whitespace();\n\
    \    let mut word_strings_length = word_strings.length;\n    for word_string in\
    \ word_strings {\n        for position in positions.iter() {\n            if word_string.len()\
    \ == position {\n                words.push(word_string);\n                word_strings_length\
    \ -= 1;\n                positions.retain(|x| *x == position);\n             \
    \   word_strings_length -= 1;\n                break;\n            }\n       \
    \ }\n    }\n    if word_strings_length > 0 {\n        select_words(String::from(word_string),\
    \ n)\n    } else {\n        words\n    }\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmpv1xp7mko.rs:18:33\n     |\n18\
    \   |     let mut letters = s.chars().collect::<Vec<String>>();\n     |      \
    \                           ^^^^^^^ value of type `Vec<String>` cannot be built\
    \ from `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<String>`\n     = help: the trait `FromIterator<T>`\
    \ is implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpv1xp7mko.rs:24:23\n   |\n24 |             word.push(letter);\n\
    \   |                       ^^^^^^ expected `char`, found struct `String`\n\n\
    error[E0277]: can't compare `String` with `char`\n  --> /tmp/tmpv1xp7mko.rs:23:19\n\
    \   |\n23 |         if letter != ' ' {\n   |                   ^^ no implementation\
    \ for `String == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpv1xp7mko.rs:27:24\n   |\n27 |         word_string += word;\n\
    \   |                        ^^^^\n   |                        |\n   |       \
    \                 expected `&str`, found struct `String`\n   |               \
    \         help: consider borrowing here: `&word`\n\nerror[E0277]: can't compare\
    \ `String` with `char`\n  --> /tmp/tmpv1xp7mko.rs:34:23\n   |\n34 |          \
    \   if letter == ' ' || letter == '\\n' {\n   |                       ^^ no implementation\
    \ for `String == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `String`\n   = help: the following other types i"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    for word in s.split_whitespace() {\n        if word.nth_char().is_some()\
    \ && word.nth_char().unwrap() == n {\n            words.push(word);\n        }\n\
    \    }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `nth_char` found for reference `&str` in\
    \ the current scope\n  --> /tmp/tmphy3q6cc2.rs:20:17\n   |\n20 |         if word.nth_char().is_some()\
    \ && word.nth_char().unwrap() == n {\n   |                 ^^^^^^^^ method not\
    \ found in `&str`\n\nerror[E0599]: no method named `nth_char` found for reference\
    \ `&str` in the current scope\n  --> /tmp/tmphy3q6cc2.rs:20:46\n   |\n20 |   \
    \      if word.nth_char().is_some() && word.nth_char().unwrap() == n {\n   | \
    \                                             ^^^^^^^^ method not found in `&str`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmphy3q6cc2.rs:24:5\n   |\n17 | fn\
    \ select_words(s: String, n: isize) -> Vec<String> {\n   |                   \
    \                      ----------- expected `Vec<String>` because of return type\n\
    ...\n24 |     words\n   |     ^^^^^ expected struct `String`, found `&str`\n \
    \  |\n   = note: expected struct `Vec<String>`\n              found struct `Vec<&str>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ chars = s.chars().collect::<Vec<String>>();\n    chars.sort();\n\n    let mut\
    \ res = Vec::new();\n    for c in chars {\n        if c.is_contained_by(&n) &&\
    \ n >= 1 {\n            res.push(c[0]);\n        }\n    }\n\n    res\n}\n\nfn\
    \ main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmp0fjj45h6.rs:18:31\n     |\n18\
    \   |     let mut chars = s.chars().collect::<Vec<String>>();\n     |        \
    \                       ^^^^^^^ value of type `Vec<String>` cannot be built from\
    \ `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<String>`\n     = help: the trait `FromIterator<T>`\
    \ is implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0599]:\
    \ no method named `is_contained_by` found for struct `String` in the current scope\n\
    \  --> /tmp/tmp0fjj45h6.rs:23:14\n   |\n23 |         if c.is_contained_by(&n)\
    \ && n >= 1 {\n   |              ^^^^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `contains`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `{integer}`\n  --> /tmp/tmp0fjj45h6.rs:24:22\n   |\n24\
    \ |             res.push(c[0]);\n   |                      ^^^^ `String` cannot\
    \ be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is\
    \ not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ counts: Vec<usize> = Vec::new();\n    let mut cur_count = 1;\n    for ch in\
    \ s.chars() {\n        if cur_count == n {\n            cur_count = 1;\n     \
    \       counts.push(cur_count);\n        } else if ch == ' ' {\n            cur_count\
    \ = 1;\n        } else {\n            cur_count++;\n        }\n    }\n    let\
    \ mut result: Vec<String> = Vec::new();\n    for num in counts {\n        if num\
    \ > 0 {\n            let mut start = String::new();\n            let mut end =\
    \ String::new();\n            let mut cur_pos = 0;\n            for ch in s.chars()\
    \ {\n                if ch == ' ' {\n                    cur_pos = 0;\n      \
    \              cur_count = 1;\n                } else if cur_pos == num {\n  \
    \                  result.push(start.to_owned());\n                    start.push_str(String::from(\"\
    _\"));\n                    end.push_str(String::from(\"_\"));\n             \
    \       cur_count = 1;\n                } else {\n                    start.push_str(String::from(\"\
    _\"));\n                    end.push_str(String::from(\"_\"));\n             \
    \       cur_count += 1;\n                }\n                cur_pos++;\n     \
    \       }\n            result.push(end);\n        }\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpenwenxfv.rs:27:22\n\
    \   |\n27 |             cur_count++;\n   |                      ^^ not a valid\
    \ postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n27 |             { let\
    \ tmp = cur_count; cur_count += 1; tmp };\n   |             +++++++++++      \
    \    ~~~~~~~~~~~~~~~~~~~~~~~\n27 -             cur_count++;\n27 +            \
    \ cur_count += 1;\n   | \n\nerror: Rust has no postfix increment operator\n  -->\
    \ /tmp/tmpenwenxfv.rs:50:24\n   |\n50 |                 cur_pos++;\n   |     \
    \                   ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n\
    \   |\n50 |                 { let tmp = cur_pos; cur_pos += 1; tmp };\n   |  \
    \               +++++++++++        ~~~~~~~~~~~~~~~~~~~~~\n50 -               \
    \  cur_pos++;\n50 +                 cur_pos += 1;\n   | \n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpenwenxfv.rs:23:25\n   |\n23 |             counts.push(cur_count);\n\
    \   |                         ^^^^^^^^^ expected `usize`, found `isize`\n   |\n\
    help: you can convert an `isize` to a `usize` and panic if the converted value\
    \ doesn't fit\n   |\n23 |             counts.push(cur_count.try_into().unwrap());\n\
    \   |                                  ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpenwenxfv.rs:42:36\n   |\n42 |                     start.push_str(String::from(\"\
    _\"));\n   |                                    ^^^^^^^^^^^^^^^^^\n   |      \
    \                              |\n   |                                    expected\
    \ `&str`, found struct `String`\n   |                                    help:\
    \ consider borrowing here: `&String::from(\"_\")`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpenwenxfv.rs:43:34\n   |\n43 |                     end.push_str(String::from(\"\
    _\"));\n   |                                  ^^^^^^^^^^^^^^^^^\n   |        \
    \                          |\n   |                                  expected `&str`,\
    \ found struct `String`\n   |                                  help: consider\
    \ borrowing here: `&String::from(\"_\")`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpe"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    if s.len()\
    \ < n {\n        return vec![];\n    }\n    let mut res = vec![];\n    for (i,\
    \ w) in s.split_whitespace().iter().enumerate().rev() {\n        if w.len() ==\
    \ n && w.chars().any(|c| c.is_consonant()) {\n            res.insert(i, w);\n\
    \        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzfeg24dl.rs:18:18\n   |\n\
    18 |     if s.len() < n {\n   |                  ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n18 |     if s.len() < n.try_into().unwrap() {\n   |\
    \                   ++++++++++++++++++++\n\nerror[E0599]: no method named `iter`\
    \ found for struct `SplitWhitespace` in the current scope\n  --> /tmp/tmpzfeg24dl.rs:22:40\n\
    \   |\n22 |     for (i, w) in s.split_whitespace().iter().enumerate().rev() {\n\
    \   |                                        ^^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    use regex::Regex;\n\
    \    let mut re = Regex::new(r\"(?:\\w{1})\").unwrap();\n    let mut word: Vec<String>\
    \ = Vec::new();\n    let mut s = s.to_string();\n    for c in s.chars() {\n  \
    \      if let Some(m) = re.captures(c) {\n            if m.len() >= n {\n    \
    \            word.push(m);\n            }\n        }\n    }\n    word\n}\n\nfn\
    \ main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0432]: unresolved import `regex`\n  --> /tmp/tmp95vj_967.rs:18:9\n\
    \   |\n18 |     use regex::Regex;\n   |         ^^^^^ maybe a missing crate `regex`?\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0432`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ n = String::new();\n    n.push_str(&format!(\"{}\", n));\n\n    let mut words\
    \ = vec![];\n\n    match s.chars().take(n) {\n        None => return words,\n\
    \        Some(first_chars) => first_chars.chars().enumerate().for_each(|(i_char,\
    \ _)|{\n            let mut counter = 0;\n            first_chars.chars().enumerate().for_each(|(_,\
    \ char)|{\n                if char == i_char {\n                    counter +=\
    \ 1;\n                }\n            });\n\n            if counter == n {\n  \
    \              words.push(s.split_whitespace().next().unwrap());\n           \
    \ }\n        }),\n    }\n\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwkzjsvmk.rs:23:26\n   |\n\
    23 |     match s.chars().take(n) {\n   |                          ^ expected `usize`,\
    \ found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwkzjsvmk.rs:24:9\n\
    \   |\n23 |     match s.chars().take(n) {\n   |           ----------------- this\
    \ expression has type `std::iter::Take<Chars<'_>>`\n24 |         None => return\
    \ words,\n   |         ^^^^ expected struct `std::iter::Take`, found enum `Option`\n\
    \   |\n   = note: expected struct `std::iter::Take<Chars<'_>>`\n             \
    \   found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwkzjsvmk.rs:25:9\n\
    \   |\n23 |     match s.chars().take(n) {\n   |           ----------------- this\
    \ expression has type `std::iter::Take<Chars<'_>>`\n24 |         None => return\
    \ words,\n25 |         Some(first_chars) => first_chars.chars().enumerate().for_each(|(i_char,\
    \ _)|{\n   |         ^^^^^^^^^^^^^^^^^ expected struct `std::iter::Take`, found\
    \ enum `Option`\n   |\n   = note: expected struct `std::iter::Take<Chars<'_>>`\n\
    \                found enum `Option<_>`\n\nerror[E0277]: can't compare `{integer}`\
    \ with `String`\n  --> /tmp/tmpwkzjsvmk.rs:33:24\n   |\n33 |             if counter\
    \ == n {\n   |                        ^^ no implementation for `{integer} == String`\n\
    \   |\n   = help: the trait `PartialEq<String>` is not implemented for `{integer}`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwkzjsvmk.rs:34:28\n\
    \   |\n34 |                 words.push(s.split_whitespace().next().unwrap());\n\
    \   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try\
    \ using a conversion method: `.to_string()`\n   |                            |\n\
    \   |                            expected struct `String`, found `&str`\n\nerror:\
    \ aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E"
  stdout: ''
  timestamp: 1660010888
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = vec![];\n    for i in s.chars() {\n        if i.is_vowel() {\n    \
    \        continue;\n        }\n        if s.chars().count() < n {\n          \
    \  continue;\n        }\n        result.push(i);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpam18z1d9.rs:20:14\n   |\n20 |         if i.is_vowel() {\n\
    \   |              ^^^^^^^^ method not found in `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpam18z1d9.rs:23:32\n   |\n23 |         if s.chars().count()\
    \ < n {\n   |                                ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |         if s.chars().count() < n.try_into().unwrap()\
    \ {\n   |                                 ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpam18z1d9.rs:28:5\n   |\n17 | fn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n   |                                   \
    \      ----------- expected `Vec<String>` because of return type\n...\n28 |  \
    \   result\n   |     ^^^^^^ expected struct `String`, found `char`\n   |\n   =\
    \ note: expected struct `Vec<String>`\n              found struct `Vec<char>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    vec![]\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"little\"]`', /tmp/tmp1sy5pnx1.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words: Vec<String> = Vec::new();\n    let mut words = s.chars().filter(|x|x.is_alphabetic()\
    \ + x.is_space()).collect();\n    words.retain(|x| n == x.len_utf8());\n    return\
    \ words;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_space` found for reference `&char` in\
    \ the current scope\n  --> /tmp/tmp5_9bhry7.rs:19:63\n   |\n19 |     let mut words\
    \ = s.chars().filter(|x|x.is_alphabetic() + x.is_space()).collect();\n   |   \
    \                                                            ^^^^^^^^ help: there\
    \ is an associated function with a similar name: `is_whitespace`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words: Vec<String> = Vec::new();\n\n    for i in s.chars() {\n        match\
    \ i {\n            char::from(' ') => {}\n            char::from(' ') => {}\n\
    \            char::from(' ') => {}\n            char::from('a') | char::from('e')\
    \ | char::from('i') | char::from('o') | char::from('u') => {\n               \
    \ continue;\n            }\n            char::from('a') | char::from('e') | char::from('i')\
    \ | char::from('o') | char::from('u') => {\n                continue;\n      \
    \      }\n            char::from('a') | char::from('e') | char::from('i') | char::from('o')\
    \ | char::from('u') => {\n                continue;\n            }\n         \
    \   char::from('a') | char::from('e') | char::from('i') | char::from('o') | char::from('u')\
    \ => {\n                continue;\n            }\n            char::from('a')\
    \ | char::from('e') | char::from('i') | char::from('o') | char::from('u') => {\n\
    \                continue;\n            }\n            char::from('a') | char::from('e')\
    \ | char::from('i') | char::from('o') | char::from('u') => {\n               \
    \ continue;\n            }\n            char::from('a') | char::from('e') | char::from('i')\
    \ | char::from('o') | char::from('u') => {\n                continue;\n      \
    \      }\n            char::from('a') | char::from('e') | char::from('i') | char::from('o')\
    \ | char::from('u') => {\n                continue;\n            }\n         \
    \   char::from('a') | char::from('e') | char::from('i') | char::from('o') | char::from('u')\
    \ => {\n                continue;\n            }\n            char::from('a')\
    \ | char::from('e') | char::from('i') | char::from('o') | char::from('u') => {\n\
    \                continue;\n            }\n            char::from('a') | char::from('e')\
    \ | char::from('i') | char::from('o') | char::from('u') => {\n               \
    \ continue;\n            }\n            char::from('a') | char::from('e') | char::from('i')\
    \ | char::from('o') | char::from('\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmp5jgbfrmq.rs:58:96\n\
    \   |\n58 |             char::from('a') | char::from('e') | char::from('i') |\
    \ char::from('o') | char::from('\n   |                                       \
    \                                                         ^\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0762`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    if s.is_empty()\
    \ {\n        return vec![];\n    }\n    \n    let mut words = Vec::new();\n  \
    \  for c& in s.chars() {\n        if (c == '\\'') || (c == '.') {\n          \
    \  words.clear();\n            break;\n        }\n        if c == ' ' {\n    \
    \        if words.len() == 0 {\n                continue;\n            }\n   \
    \         words.push(\"\");\n        }\n        if n == 1 {\n            if words\
    \ == vec![] {\n                continue;\n            }\n            words.push(String::from(c));\n\
    \        } else if c != c.to_ascii_lowercase() {\n            if words == vec![]\
    \ {\n                continue;\n            }\n            words.push(String::from(c));\n\
    \        }\n    }\n    \n    words\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: missing `in` in `for` loop\n  --> /tmp/tmpgsk287hj.rs:23:10\n  \
    \ |\n23 |     for c& in s.chars() {\n   |          ^ help: try adding `in` here\n\
    \nerror: expected expression, found keyword `in`\n  --> /tmp/tmpgsk287hj.rs:23:12\n\
    \   |\n23 |     for c& in s.chars() {\n   |            ^^ expected expression\n\
    \nerror: aborting due to 2 previous errors\n\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    vec![]\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"little\"]`', /tmp/tmp1sy5pnx1.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    if n ==\
    \ 0 {\n        return vec![];\n    }\n\n    let mut v = Vec::with_capacity(s.size());\n\
    \    let mut c = 0;\n    for i in s.chars() {\n        if i.is_consonant() {\n\
    \            c+=1;\n            if c == n {\n                v.push(i.to_string());\n\
    \            }\n        }\n    }\n    \n    if v.len() != 0 {\n        return\
    \ v;\n    }\n    return vec![];\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `size` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmplubhz6cn.rs:22:38\n   |\n22 |     let mut v = Vec::with_capacity(s.size());\n\
    \   |                                      ^^^^ method not found in `String`\n\
    \nerror[E0599]: no method named `is_consonant` found for type `char` in the current\
    \ scope\n  --> /tmp/tmplubhz6cn.rs:25:14\n   |\n25 |         if i.is_consonant()\
    \ {\n   |              ^^^^^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    if s.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut s = s\n        .to_lowercase()\n\
    \        .chars()\n        .collect::<Vec<_>>()\n        .sort();\n\n    // find\
    \ all the words\n    let mut words = vec![];\n    let mut word_count = 0;\n  \
    \  for e in s.iter() {\n        let word = e.to_string();\n        if word_count\
    \ == n {\n            words.push(word);\n        }\n        word_count += 1;\n\
    \    }\n\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n   \
    \ assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for unit type `()` in the current\
    \ scope\n  --> /tmp/tmpzt0eygpo.rs:31:16\n   |\n31 |     for e in s.iter() {\n\
    \   |                ^^^^ method not found in `()`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    vec![\"\"\
    .to_string().into(), s.iter().take(n).collect::<String>()].into_iter().collect()\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpanuzxh_c.rs:18:35\n   |\n18 |     vec![\"\".to_string().into(),\
    \ s.iter().take(n).collect::<String>()].into_iter().collect()\n   |          \
    \                         ^^^^ method not found in `String`\n   |\nhelp: because\
    \ of the in-memory representation of `&str`, to obtain an `Iterator` over each\
    \ of its codepoint use method `chars`\n   |\n18 |     vec![\"\".to_string().into(),\
    \ s.chars().take(n).collect::<String>()].into_iter().collect()\n   |         \
    \                          ~~~~~\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010888
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    if s.is_empty()\
    \ {\n        return Vec::new();\n    }\n    let mut s = s;\n    let mut n = n;\n\
    \    let mut v = Vec::new();\n    loop {\n        if let Some(pos) = s.find('A')\
    \ {\n            v = v.append(&s[..pos]);\n            n = n - 1;\n        }\n\
    \        if n == 0 {\n            break;\n        }\n        s = s.replace('A',\
    \ 'a');\n        if let Some(pos) = s.find('a') {\n            v = v.append(&s[..pos]);\n\
    \            n = n - 1;\n        }\n    }\n    v.into_iter().collect()\n}\n\n\
    fn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1we4fc3k.rs:26:26\n   |\n\
    26 |             v = v.append(&s[..pos]);\n   |                          ^^^^^^^^^\
    \ types differ in mutability\n   |\n   = note: expected mutable reference `&mut\
    \ Vec<_>`\n                      found reference `&str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp1we4fc3k.rs:26:17\n   |\n23 |     let mut v = Vec::new();\n\
    \   |                 ---------- expected due to this value\n...\n26 |       \
    \      v = v.append(&s[..pos]);\n   |                 ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<_>`\n      \
    \     found unit type `()`\nnote: method `append` modifies its receiver in-place\n\
    \  --> /tmp/tmp1we4fc3k.rs:26:19\n   |\n26 |             v = v.append(&s[..pos]);\n\
    \   |                 - ^^^^^^ this call modifies `v` in-place\n   |         \
    \        |\n   |                 you probably want to use this value after calling\
    \ the method...\n   = note: ...instead of the `()` output of method `append`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp1we4fc3k.rs:32:28\n   |\n32 |\
    \         s = s.replace('A', 'a');\n   |                            ^^^ expected\
    \ `&str`, found `char`\n   |\nhelp: if you meant to write a `str` literal, use\
    \ double quotes\n   |\n32 |         s = s.replace('A', \"a\");\n   |         \
    \                   ~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1we4fc3k.rs:34:26\n\
    \   |\n34 |             v = v.append(&s[..pos]);\n   |                       \
    \   ^^^^^^^^^ types differ in mutability\n   |\n   = note: expected mutable reference\
    \ `&mut Vec<_>`\n                      found reference `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp1we4fc3k.rs:34:17\n   |\n23 |     let mut v\
    \ = Vec::new();\n   |                 ---------- expected due to this value\n\
    ...\n34 |             v = v.append(&s[..pos]);\n   |                 ^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<_>`\n\
    \           found unit type `()`\nnote: method `append` modifies its receiver\
    \ in-place\n  --> /tmp/tmp1we4fc3k.rs:34:19\n   |\n34 |   "
  stdout: ''
  timestamp: 1660010888
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words: Vec<String> = vec![];\n    let mut s: Vec<String> = s.split_whitespace();\n\
    \    let mut counts: Vec<isize> = vec![];\n    let mut j = 0;\n    for word in\
    \ s.iter().rev() {\n        counts.push(0);\n        for c in word.chars() {\n\
    \            counts[j] += c;\n            if counts[j] == n {\n              \
    \  words.push(word.to_string());\n                break;\n            }\n    \
    \        j += 1;\n        }\n    }\n    words\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5qpf7pvd.rs:19:30\n   |\n\
    19 |     let mut s: Vec<String> = s.split_whitespace();\n   |                -----------\
    \   ^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found struct `SplitWhitespace`\n\
    \   |                |\n   |                expected due to this\n   |\n   = note:\
    \ expected struct `Vec<String>`\n              found struct `SplitWhitespace<'_>`\n\
    \nerror[E0277]: cannot add-assign `char` to `isize`\n  --> /tmp/tmp5qpf7pvd.rs:25:23\n\
    \   |\n25 |             counts[j] += c;\n   |                       ^^ no implementation\
    \ for `isize += char`\n   |\n   = help: the trait `AddAssign<char>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `AddAssign<Rhs>`:\n\
    \             <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n    \
    \         <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n        \
    \     <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n         \
    \    <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and\
    \ 20 others\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010888
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ s: Vec<String> = vec![];\n    if s.is_empty() { return s; }\n    \n    let mut\
    \ counter: usize = 0;\n    let mut idx: usize = s.len();\n    while counter <\
    \ n {\n        if s[idx] == ' ' {\n            idx--;\n        } else {\n    \
    \        s[idx].to_ascii_lowercase().chars().filter(|c| *c != 'z').cloned().collect::<Vec<_>>().iter().cloned().find(|c|\
    \ *c != 'c').unwrap().collect();\n            idx++;\n        }\n        counter\
    \ = counter + 1;\n    }\n    s.iter().cloned().find(|c| *c != 'c').unwrap().collect();\n\
    \    s\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmp_fn19gji.rs:25:18\n\
    \   |\n25 |             idx--;\n   |                  ^ expected expression\n\n\
    error: Rust has no postfix increment operator\n  --> /tmp/tmp_fn19gji.rs:28:16\n\
    \   |\n28 |             idx++;\n   |                ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n28 |             { let tmp = idx; idx +=\
    \ 1; tmp };\n   |             +++++++++++    ~~~~~~~~~~~~~~~~~\n28 -         \
    \    idx++;\n28 +             idx += 1;\n   | \n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp_fn19gji.rs:23:21\n   |\n23 |     while counter < n {\n   |   \
    \                  ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    23 |     while counter < n.try_into().unwrap() {\n   |                      ++++++++++++++++++++\n\
    \nerror[E0277]: can't compare `String` with `char`\n  --> /tmp/tmp_fn19gji.rs:24:19\n\
    \   |\n24 |         if s[idx] == ' ' {\n   |                   ^^ no implementation\
    \ for `String == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0271]: type mismatch\
    \ resolving `<Filter<Chars<'_>, [closure@/tmp/tmp_fn19gji.rs:27:56: 27:69]> as\
    \ Iterator>::Item == &_`\n    --> /tmp/tmp_fn19gji.rs:27:71\n     |\n27   | ...\
    \   s[idx].to_ascii_lowercase().chars().filter(|c| *c != 'z').cloned().collect::<Vec<_>>().iter().cloned().find(|c|\
    \ *c != 'c').unwrap()...\n     |                                             \
    \                    ^^^^^^ expected reference, found `char`\n     |\n     = note:\
    \ expected reference `&_`\n                "
  stdout: ''
  timestamp: 1660010888
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    s.split_whitespace().filter(|word|\
    \ {\n        word.chars().take(n).all(|c| c.is_ascii_uppercase())\n    }).collect::<Vec<String>>()\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxbx4jthi.rs:19:27\n   |\n\
    19 |         word.chars().take(n).all(|c| c.is_ascii_uppercase())\n   |      \
    \                     ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    19 |         word.chars().take(n.try_into().unwrap()).all(|c| c.is_ascii_uppercase())\n\
    \   |                            ++++++++++++++++++++\n\nerror[E0277]: a value\
    \ of type `Vec<String>` cannot be built from an iterator over elements of type\
    \ `&str`\n    --> /tmp/tmpxbx4jthi.rs:20:8\n     |\n20   |     }).collect::<Vec<String>>()\n\
    \     |        ^^^^^^^ value of type `Vec<String>` cannot be built from `std::iter::Iterator<Item=&str>`\n\
    \     |\n     = help: the trait `FromIterator<&str>` is not implemented for `Vec<String>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010888
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut cnt = 0;\n    for c in s.chars() {\n        if\
    \ c == ' ' {\n            if cnt > n {\n                break;\n            }\n\
    \            cnt = 0;\n        } else {\n            cnt += 1;\n        }\n  \
    \      if cnt == n {\n            words.push(String::from(c));\n        }\n  \
    \  }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"y\", \"t\"]`,\n right: `[\"little\"]`', /tmp/tmplgr7d2oy.rs:38:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010888
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ ret: Vec<String> = Vec::new();\n    if s.len() == 0 {\n        return ret;\n\
    \    }\n    \n    let mut first_consonant = false;\n    let mut last_consonant\
    \ = false;\n    \n    for i in 0..s.len() {\n        if s.chars().nth(i).unwrap()\
    \ == 'a' {\n            first_consonant = true;\n            last_consonant =\
    \ false;\n        }\n        if s.chars().nth(i).unwrap() == 'e' {\n         \
    \   first_consonant = false;\n            last_consonant = true;\n        }\n\
    \        if s.chars().nth(i).unwrap() == 'i' {\n            first_consonant =\
    \ false;\n            last_consonant = false;\n        }\n        if s.chars().nth(i).unwrap()\
    \ == 'o' {\n            first_consonant = false;\n            last_consonant =\
    \ false;\n        }\n        if s.chars().nth(i).unwrap() == 'u' {\n         \
    \   first_consonant = false;\n            last_consonant = false;\n        }\n\
    \        if s.chars().nth(i).unwrap() == 'y' {\n            first_consonant =\
    \ false;\n            last_consonant = false;\n        }\n        if s.chars().nth(i).unwrap()\
    \ == 'w' {\n            first_consonant = true;\n            last_consonant =\
    \ false;\n        }\n        if s.chars().nth(i).unwrap() == 's' {\n         \
    \   first_consonant = false;\n            last_consonant = false;\n        }\n\
    \        if s.chars().nth(i).unwrap() == 't' {\n            first_consonant =\
    \ false;\n            last_consonant = false;\n        }\n        if s.chars().nth(i).unwrap()\
    \ == 'd' {\n            first_consonant = false;\n            last_consonant =\
    \ false;\n        }\n        if s.chars().nth(i).unwrap() == 'b' {\n         \
    \   first_consonant = false;\n            last_consonant = false;\n        }\n\
    \        if s.chars().nth(i).unwrap() == 'm' {\n            first_consonant =\
    \ false;\n            last_consonant = false;\n        }\n        if s.chars().nth(i).unwrap()\
    \ == 'l' {\n            first_consonant = false;\n            last_consonant =\
    \ false;\n        }\n        if s.chars().nth(i).unwrap() == 'f' {\n         \
    \   first_consonant = false;\n            last_consonant = false;\n        }\n\
    \        if s.chars().nth(i).unwrap() == 'p' {\n            first_consonant =\
    \ false;\n            last_consonant = false;\n        }\n        if s.chars().nth(i\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpqt2noota.rs:99:3\n\
    \   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |      \
    \                                               - unclosed delimiter\n...\n26\
    \ |     for i in 0..s.len() {\n   |                         - this delimiter might\
    \ not be properly closed...\n...\n88 | }\n   | - ...as it matches this but it\
    \ has different indentation\n...\n99 | }\n   |   ^\n\nerror: mismatched closing\
    \ delimiter: `}`\n  --> /tmp/tmpqt2noota.rs:87:25\n   |\n17 | fn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n   |                                   \
    \                  - closing delimiter possibly meant for this\n...\n87 |    \
    \     if s.chars().nth(i\n   |                         ^ unclosed delimiter\n\
    88 | }\n   | ^ mismatched closing delimiter\n\nerror: expected `{`, found `}`\n\
    \  --> /tmp/tmpqt2noota.rs:88:1\n   |\n87 |         if s.chars().nth(i\n   | \
    \        -- this `if` expression has a condition, but no block\n88 | }\n   | ^\
    \ expected `{`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqt2noota.rs:17:41\n\
    \   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    if s.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut words = vec![];\n\n    for i\
    \ in 0..s.len() {\n        let mut j = 0;\n        while j < i {\n           \
    \ if s[i] == s[j] {\n                j += 1;\n                continue;\n    \
    \        }\n\n            if j == i {\n                words.push(s.to_string());\n\
    \                break;\n            }\n\n            if s[i] == s[j..i + 1].iter().filter(|&x|\
    \ x.is_ascii()).count() == n {\n                words.push(s.to_string());\n \
    \               break;\n            }\n\n            j += 1;\n        }\n    }\n\
    \n    words\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmp9r0idklg.rs:37:21\n\
    \   |\n37 |             if s[i] == s[j..i + 1].iter().filter(|&x| x.is_ascii()).count()\
    \ == n {\n   |                     ^^                                        \
    \              ^^\n   |\nhelp: split the comparison into two\n   |\n37 |     \
    \        if s[i] == s[j..i + 1].iter().filter(|&x| x.is_ascii()).count() && s[j..i\
    \ + 1].iter().filter(|&x| x.is_ascii()).count() == n {\n   |                 \
    \                                                            +++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp9r0idklg.rs:27:16\n\
    \   |\n27 |             if s[i] == s[j] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp9r0idklg.rs:27:24\n   |\n27 |             if s[i] == s[j] {\n \
    \  |                        ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp9r0idklg.rs:37:16\n\
    \   |\n37 |             "
  stdout: ''
  timestamp: 1660010888
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    vec.select_words(s,\
    \ n)\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0423]: expected value, found macro `vec`\n  --> /tmp/tmpqrb25vtf.rs:18:5\n\
    \   |\n18 |     vec.select_words(s, n)\n   |     ^^^ not a value\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0423`.\n"
  stdout: ''
  timestamp: 1660010888
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    if s.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut i = 1;\n    let mut words: Vec<String>\
    \ = vec![];\n    let mut current = &s[0];\n    let mut vowel = vec![\"a\", \"\
    e\", \"i\", \"o\", \"u\"];\n    while i < n {\n        for vowel in vowel {\n\
    \            if current == vowel {\n                i += 1;\n                current\
    \ = &s[i];\n                words.push(current);\n                break;\n   \
    \         }\n        }\n    }\n\n    words\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpkus3q8h4.rs:24:24\n   |\n24 |     let mut current = &s[0];\n   |   \
    \                     ^^^^ `String` cannot be indexed by `{integer}`\n   |\n \
    \  = help: the trait `Index<{integer}>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpkus3q8h4.rs:30:28\n   |\n30 |                 current = &s[i];\n\
    \   |                            ^^^^ `String` cannot be indexed by `isize`\n\
    \   |\n   = help: the trait `Index<isize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkus3q8h4.rs:31:28\n\
    \   |\n31 |                 words.push(current);\n   |                       \
    \     ^^^^^^^- help: try using a conversion method: `.to_string()`\n   |     \
    \                       |\n   |                            expected struct `String`,\
    \ found reference\n   |\n   = note: expected struct `String`\n           found\
    \ reference `&_`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010888
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words: Vec<String> = vec![];\n    let mut num_consonants = 0;\n    let mut i:\
    \ usize = 0;\n\n    // Go through each letter of the word and increase the consonants\
    \ counter\n    // if the letter isn't a consonant.\n    while i < s.len() {\n\
    \        if s[i] == ' ' || s[i] == '\\t' || s[i] == '\\n' {\n            // Don't\
    \ count spaces, tabs, or new lines as consonants\n            i += 1;\n      \
    \  } else {\n            // Increase the consonants counter by one\n         \
    \   num_consonants += 1;\n            i += 1;\n        }\n    }\n\n    if num_consonants\
    \ == n {\n        // If the number of consonants in the word matches the desired\
    \ number, append \n        // that word into the vector of words.\n        words.push(s);\n\
    \    }\n\n    // If the word is longer than the desired number of consonants,\
    \ append the first word\n    // that satisfies the conditions.\n    if words.len()\
    \ > n {\n        words.push(words[0]);\n    }\n\n    return words;\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp4k55noec.rs:25:12\n\
    \   |\n25 |         if s[i] == ' ' || s[i] == '\\t' || s[i] == '\\n' {\n   | \
    \           ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp4k55noec.rs:25:27\n   |\n25 |         if s[i] == ' ' || s[i] ==\
    \ '\\t' || s[i] == '\\n' {\n   |                           ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp4k55noec.rs:25:43\n   |\n25 |         if s[i] == ' ' || s[i] ==\
    \ '\\t' || s[i] == '\\n' {\n   |                                           ^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \       "
  stdout: ''
  timestamp: 1660010888
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    if s.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut count = 0;\n    let mut words:\
    \ Vec<String> = vec![];\n    let mut next_word: String;\n    for &c in s.chars()\
    \ {\n        if c.is_vowel() {\n            count++;\n        } else {\n     \
    \       words.push(String::from(next_word));\n            count = 0;\n       \
    \     next_word = String::new();\n        }\n\n        if count == n {\n     \
    \       words.push(String::from(next_word));\n            count = 0;\n       \
    \     next_word = String::new();\n        }\n        \n        next_word += c;\n\
    \    }\n\n    words.push(String::from(next_word));\n\n    words\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpp5b1t_vi.rs:27:18\n\
    \   |\n27 |             count++;\n   |                  ^^ not a valid postfix\
    \ operator\n   |\nhelp: use `+= 1` instead\n   |\n27 |             { let tmp =\
    \ count; count += 1; tmp };\n   |             +++++++++++      ~~~~~~~~~~~~~~~~~~~\n\
    27 -             count++;\n27 +             count += 1;\n   | \n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpp5b1t_vi.rs:25:9\n   |\n25 |     for &c in s.chars()\
    \ {\n   |         ^^    --------- this expression has type `Option<char>`\n  \
    \ |         |\n   |         expected `char`, found reference\n   |         help:\
    \ you can probably remove the explicit borrow: `c`\n   |\n   = note:   expected\
    \ type `char`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010888
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    match n\
    \ {\n        0 => vec![],\n        _ => {\n            if s.is_empty() {\n   \
    \             return vec![];\n            }\n            let mut vowels: Vec<&str>\
    \ = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n            let mut consonants:\
    \ Vec<&str> = vec![\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"\
    l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"\
    y\", \"z\"];\n\n            for c in &s.chars() {\n                if consonants.contains(&c.to_lowercase())\
    \ {\n                    consonants.push(&c.to_lowercase());\n               \
    \ }\n                if vowels.contains(&c.to_lowercase()) {\n               \
    \     vowels.push(&c.to_lowercase());\n                }\n            }\n    \
    \        let mut words: Vec<String> = vec![];\n            for vowel in &vowels\
    \ {\n                for (i, w) in s.split_whitespace().iter().enumerate() {\n\
    \                    if w.contains(vowel) {\n                        words.push(s.split_whitespace()[i\
    \ as usize + 1]);\n                    }\n                }\n            }\n \
    \           words.sort_unstable();\n            words\n        }\n    }\n}\n\n\
    fn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&Chars<'_>` is not an iterator\n  --> /tmp/tmpjnab3es7.rs:27:22\n\
    \   |\n27 |             for c in &s.chars() {\n   |                      -^^^^^^^^^\n\
    \   |                      |\n   |                      `&Chars<'_>` is not an\
    \ iterator\n   |                      help: consider removing the leading `&`-reference\n\
    \   |\n   = help: the trait `Iterator` is not implemented for `&Chars<'_>`\n \
    \  = note: `Iterator` is implemented for `&mut std::str::Chars<'_>`, but not for\
    \ `&std::str::Chars<'_>`\n   = note: required because of the requirements on the\
    \ impl of `IntoIterator` for `&Chars<'_>`\n\nerror[E0599]: no method named `iter`\
    \ found for struct `SplitWhitespace` in the current scope\n  --> /tmp/tmpjnab3es7.rs:37:52\n\
    \   |\n37 |                 for (i, w) in s.split_whitespace().iter().enumerate()\
    \ {\n   |                                                    ^^^^ method not found\
    \ in `SplitWhitespace<'_>`\n\nerror[E0608]: cannot index into a value of type\
    \ `SplitWhitespace<'_>`\n  --> /tmp/tmpjnab3es7.rs:39:36\n   |\n39 |         \
    \                words.push(s.split_whitespace()[i as usize + 1]);\n   |     \
    \                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599, E0608.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660010888
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    match s\
    \ {\n        \"\" => Vec::new(),\n        s => s.chars().filter(|c| c == 'A' ||\
    \ c == 'a' || c == 'E' || c == 'e' || c == 'I' || c == 'i' || c == 'O' || c ==\
    \ 'o' || c == 'U' || c == 'u').collect(),\n    }.iter().filter(|&c| *c == *c &&\
    \ c != ' ').take(n).collect()\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj80a0_ti.rs:19:9\n   |\n\
    18 |     match s {\n   |           - this expression has type `String`\n19 | \
    \        \"\" => Vec::new(),\n   |         ^^ expected struct `String`, found\
    \ `&str`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpj80a0_ti.rs:20:37\n\
    \   |\n20 | ...   s => s.chars().filter(|c| c == 'A' || c == 'a' || c == 'E' ||\
    \ c == 'e' || c == 'I' || c == 'i' || c == 'O' || c == 'o' || c == 'U' ...\n \
    \  |                                   ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpj80a0_ti.rs:20:49\n   |\n20 | ...\
    \   s => s.chars().filter(|c| c == 'A' || c == 'a' || c == 'E' || c == 'e' ||\
    \ c == 'I' || c == 'i' || c == 'O' || c == 'o' || c == 'U' ...\n   |         \
    \                                      ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpj80a0_ti.rs:20:61\n   |\n20 | ...\
    \   s => s.chars().filter(|c| c == 'A' || c == 'a' || c == 'E' || c == 'e' ||\
    \ c == 'I' || c == 'i' || c == 'O' || c == 'o' || c == 'U' ...\n   |         \
    \                                                  ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmpj80a0_ti.rs:20:73\n   |\n20\
    \ | ...   s => s.chars().filter(|c| c == 'A' || c == 'a' || c == 'E' || c == 'e'\
    \ || c == 'I' || c == 'i' || c == 'O' || c == 'o' || c == 'U' ...\n   |      \
    \                                                                 ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `Partia"
  stdout: ''
  timestamp: 1660010888
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = Vec::new();\n    let mut consonants = String::new();\n    for char in\
    \ s.chars() {\n        if char == char::from_u32(97).unwrap() {\n            consonants.clear();\n\
    \            words.push(String::new());\n        }\n        else if char == char::from_u32(103).unwrap()\
    \ {\n            if !consonants.is_empty() {\n                words.push(consonants);\n\
    \            }\n            consonants.clear();\n            words.push(String::new());\n\
    \        }\n        else if char == char::from_u32(116).unwrap() {\n         \
    \   if !consonants.is_empty() {\n                words.push(consonants);\n   \
    \         }\n            consonants.clear();\n            words.push(String::new());\n\
    \        }\n        else if char == char::from_u32(32).unwrap() {\n          \
    \  consonants.push(char);\n        }\n        else {\n            consonants.push(char);\n\
    \        }\n    }\n    let mut len = 1;\n    while words[len].len() < n {\n  \
    \      len += 1;\n    }\n    words.truncate(len);\n    words\n}\n\nfn main() {\n\
    \    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvp9429z4.rs:47:30\n   |\n\
    47 |     while words[len].len() < n {\n   |                              ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n47 |     while words[len].len()\
    \ < n.try_into().unwrap() {\n   |                               ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010888
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    s.chars().take(n).collect()\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2c1jxxlj.rs:18:20\n   |\n\
    18 |     s.chars().take(n).collect()\n   |                    ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n18 |     s.chars().take(n.try_into().unwrap()).collect()\n\
    \   |                     ++++++++++++++++++++\n\nerror[E0277]: a value of type\
    \ `Vec<String>` cannot be built from an iterator over elements of type `char`\n\
    \    --> /tmp/tmp2c1jxxlj.rs:18:23\n     |\n18   |     s.chars().take(n).collect()\n\
    \     |                       ^^^^^^^ value of type `Vec<String>` cannot be built\
    \ from `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<String>`\n     = help: the trait `FromIterator<T>`\
    \ is implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010888
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    s.split_whitespace().filter(|w|\
    \ w.chars().take(n).count(|c| *c >= 97 + *c <= 122)).collect()\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmpymc2if06.rs:18:68\n\
    \   |\n18 |     s.split_whitespace().filter(|w| w.chars().take(n).count(|c| *c\
    \ >= 97 + *c <= 122)).collect()\n   |                                        \
    \                            ^^         ^^\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpymc2if06.rs:18:52\n   |\n18 |     s.split_whitespace().filter(|w|\
    \ w.chars().take(n).count(|c| *c >= 97 + *c <= 122)).collect()\n   |         \
    \                                           ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n18 |     s.split_whitespace().filter(|w| w.chars().take(n.try_into().unwrap()).count(|c|\
    \ *c >= 97 + *c <= 122)).collect()\n   |                                     \
    \                ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpymc2if06.rs:18:82\n   |\n18 |     s.split_whitespace().filter(|w| w.chars().take(n).count(|c|\
    \ *c >= 97 + *c <= 122)).collect()\n   |                                     \
    \                                             ^^^ expected `bool`, found integer\n\
    \nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmpymc2if06.rs:18:55\n    |\n18  |     s.split_whitespace().filter(|w|\
    \ w.chars().take(n).count(|c| *c >= 97 + *c <= 122)).collect()\n    |        \
    \                                               ^^^^^ ------------------------\
    \ supplied 1 argument\n    |                                                 \
    \      |\n    |                                                       expected\
    \ 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpymc2if06.rs:18:37\n   |\n18 |     s.split_whitespace().filter(|w|\
    \ w.chars().take(n).count(|c| *c >= 97 + *c <= 122)).collect()\n   |         \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `bool`, found `usize`\n\nerror[E0277]: a value of type `Vec<String>`\
    \ cannot be built from an iterator over elements of type `&str`\n    -->"
  stdout: ''
  timestamp: 1660010888
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    select_words(s,\
    \ n, \"\")\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 2 arguments but 3 arguments were supplied\n\
    \  --> /tmp/tmpxqsdppmj.rs:18:5\n   |\n18 |     select_words(s, n, \"\")\n   |\
    \     ^^^^^^^^^^^^ -  -  -- supplied 3 arguments\n   |     |\n   |     expected\
    \ 2 arguments\n   |\nnote: function defined here\n  --> /tmp/tmpxqsdppmj.rs:17:4\n\
    \   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ^^^^^^^^^^^^\
    \ ---------  --------\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660010888
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    if s.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut vowel = vec![String::from(\"\
    A\"), String::from(\"E\"), String::from(\"I\"), String::from(\"O\"), String::from(\"\
    U\")];\n    for i in 0..vowel.len() {\n        vowel.swap(i + 1, i + 1);\n   \
    \ }\n\n    let mut s = s;\n    \n    vowel.sort_unstable();\n    let mut i = 0;\n\
    \    while i < s.len() {\n        if s.chars().all(|c| c == vowel[i]) {\n    \
    \        i += 1;\n        } else if s.len() > i {\n            s.swap(i, s.len()\
    \ - 1);\n            i += 1;\n        } else {\n            break;\n        }\n\
    \    }\n\n    s.chars().enumerate().filter(|(_, c)| c <= n).collect::<Vec<_>>()\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpboos_kru.rs:32:35\n   |\n\
    32 |         if s.chars().all(|c| c == vowel[i]) {\n   |                     \
    \              ^^^^^^^^ expected `char`, found struct `String`\n\nerror[E0599]:\
    \ no method named `swap` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpboos_kru.rs:35:15\n   |\n35 |             s.swap(i, s.len() - 1);\n\
    \   |               ^^^^ method not found in `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpboos_kru.rs:42:48\n   |\n42 |     s.chars().enumerate().filter(|(_,\
    \ c)| c <= n).collect::<Vec<_>>()\n   |                                      \
    \          ^ expected `&char`, found `isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpboos_kru.rs:42:5\n   |\n17 | fn select_words(s: String, n: isize)\
    \ -> Vec<String> {\n   |                                         ----------- expected\
    \ `Vec<String>` because of return type\n...\n42 |     s.chars().enumerate().filter(|(_,\
    \ c)| c <= n).collect::<Vec<_>>()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found tuple\n   |\n   = note: expected struct `Vec<String>`\n\
    \              found struct `Vec<(usize, char)>`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010888
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ count = 0;\n    let mut result = vec![];\n    for word in s.split_whitespace()\
    \ {\n        if word.naturals() == n {\n            result.push(word);\n     \
    \       count += 1;\n        }\n    }\n    if count == 0 {\n        return vec![];\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `naturals` found for reference `&str` in\
    \ the current scope\n  --> /tmp/tmpuls3qgly.rs:21:17\n   |\n21 |         if word.naturals()\
    \ == n {\n   |                 ^^^^^^^^ method not found in `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpuls3qgly.rs:29:5\n   |\n17 | fn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n   |                                   \
    \      ----------- expected `Vec<String>` because of return type\n...\n29 |  \
    \   result\n   |     ^^^^^^ expected struct `String`, found `&str`\n   |\n   =\
    \ note: expected struct `Vec<String>`\n              found struct `Vec<&str>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010888
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = vec![];\n    let mut last_index = s.len();\n    while last_index >\
    \ 0 {\n        let mut cur_start = last_index;\n        let mut cur_end = last_index;\n\
    \        let mut found = false;\n        for ch in s.chars() {\n            if\
    \ ch.is_whitespace() {\n                break;\n            }\n            match\
    \ ch {\n                ' ' => continue,\n                '\\a' => found,\n  \
    \              '\\b' => found,\n                '\\c' => found,\n            \
    \    '\\d' => found,\n                '\\e' => found,\n                '\\f' =>\
    \ found,\n                '\\n' => found,\n                '\\r' => found,\n \
    \               '\\t' => found,\n                '\\v' => found,\n           \
    \     '\\'' => found,\n                '\\\"' => found,\n                '\\\\\
    ' => found,\n                '\\0' => found,\n                _ => cur_end = last_index\
    \ - 1,\n            }\n            found = true;\n        }\n        if found\
    \ {\n            cur_start += 1;\n            cur_end += 1;\n        }\n     \
    \   if cur_start == cur_end {\n            break;\n        }\n        let word\
    \ = &s[cur_start..cur_end];\n        if n == word.len() {\n            result.push(word);\n\
    \        }\n        last_index = cur_end;\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: unknown character escape: `a`\n  --> /tmp/tmp7q8y18d1.rs:30:19\n\
    \   |\n30 |                 '\\a' => found,\n   |                   ^ unknown\
    \ character escape\n   |\n   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\n\
    help: if you meant to write a literal backslash (perhaps escaping in a regular\
    \ expression), consider a raw string literal\n   |\n30 |                 r\"\\\
    a\" => found,\n   |                 ~~~~~\n\nerror: unknown character escape:\
    \ `b`\n  --> /tmp/tmp7q8y18d1.rs:31:19\n   |\n31 |                 '\\b' => found,\n\
    \   |                   ^ unknown character escape\n   |\n   = help: for more\
    \ information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\n\
    help: if you meant to write a literal backslash (perhaps escaping in a regular\
    \ expression), consider a raw string literal\n   |\n31 |                 r\"\\\
    b\" => found,\n   |                 ~~~~~\n\nerror: unknown character escape:\
    \ `c`\n  --> /tmp/tmp7q8y18d1.rs:32:19\n   |\n32 |                 '\\c' => found,\n\
    \   |                   ^ unknown character escape\n   |\n   = help: for more\
    \ information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\n\
    help: if you meant to write a literal backslash (perhaps escaping in a regular\
    \ expression), consider a raw string literal\n   |\n32 |                 r\"\\\
    c\" => found,\n   |                 ~~~~~\n\nerror: unknown character escape:\
    \ `d`\n  --> /tmp/tmp7q8y18d1.rs:33:19\n   |\n33 |                 '\\d' => found,\n\
    \   |                   ^ unknown character escape\n   |\n   = help: for more\
    \ information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\n\
    help: if you meant to write a literal backslash (perhaps escaping in a regular\
    \ expression), consider a raw string literal\n   |\n33 |                 r\"\\\
    d\" => found,\n   |                 ~~~~~\n\nerror: unknown character escape:\
    \ `e`\n  --> /tmp/tmp7q8y18d1.rs:34:19\n   |\n34 |                 '\\e' => found,\n\
    \   |                   ^ unknown character escape\n   |\n   = help: for more\
    \ information, vi"
  stdout: ''
  timestamp: 1660010888
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    if s.is_empty() {\n        return result;\n    }\n\
    \    let mut index = s.rfind(\" \", n).unwrap();\n    while index != s.rfind(\"\
    \ \", n).unwrap().cmp(n) {\n        if s[index] == ' ' {\n            if index\
    \ < s.len() - 1 {\n                index += 1;\n            }\n        } else\
    \ {\n            result.push(s.split_whitespace()[index]);\n        }\n      \
    \  index = s.rfind(\" \", n).unwrap();\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpy8axwxo8.rs:22:23\n     |\n22   |     let mut index = s.rfind(\"\
    \ \", n).unwrap();\n     |                       ^^^^^ ---  - supplied 2 arguments\n\
    \     |                       |\n     |                       expected 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror[E0061]: this function\
    \ takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpy8axwxo8.rs:23:22\n\
    \     |\n23   |     while index != s.rfind(\" \", n).unwrap().cmp(n) {\n     |\
    \                      ^^^^^ ---  - supplied 2 arguments\n     |             \
    \         |\n     |                      expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpy8axwxo8.rs:23:49\n\
    \   |\n23 |     while index != s.rfind(\" \", n).unwrap().cmp(n) {\n   |     \
    \                                            ^ expected `&usize`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpy8axwxo8.rs:23:20\n   |\n23 |\
    \     while index != s.rfind(\" \", n).unwrap().cmp(n) {\n   |               \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found enum `std::cmp::Ordering`\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpy8axwxo8.rs:24:12\n\
    \   |\n24 |         if s[index] == ' ' {\n   |            ^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmpy8axwxo8.rs:29:25\n   |\n29 |             result.push(s.split_whitespace()[index]);\n\
    \   |                         ^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660010888
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    select_words(s,\
    \ n, true)\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 2 arguments but 3 arguments were supplied\n\
    \  --> /tmp/tmp2vpiy950.rs:18:5\n   |\n18 |     select_words(s, n, true)\n   |\
    \     ^^^^^^^^^^^^ -  -  ---- supplied 3 arguments\n   |     |\n   |     expected\
    \ 2 arguments\n   |\nnote: function defined here\n  --> /tmp/tmp2vpiy950.rs:17:4\n\
    \   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ^^^^^^^^^^^^\
    \ ---------  --------\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660010888
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    // Your\
    \ code here\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptu_480ft.rs:17:41\n   |\n\
    17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    \n}\n\n\
    fn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3v79g7v6.rs:17:41\n   |\n\
    17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    \n    //\
    \ Your code here\n    // return vec![];\n    \n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8syg2r2x.rs:17:41\n   |\n\
    17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010888
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = Vec::new();\n    let mut i = 0;\n\n    while i < s.len() {\n       \
    \ words.push(s.substr(i, i + n));\n        i += n;\n    }\n\n    if words.is_empty()\
    \ {\n        words\n    }\n    else {\n        words\n    }\n}\n\nfn main() {\n\
    \    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `substr` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp1nefhdwh.rs:22:22\n   |\n22 |         words.push(s.substr(i,\
    \ i + n));\n   |                      ^^^^^^ method not found in `String`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp1nefhdwh.rs:22:36\n   |\n22 |  \
    \       words.push(s.substr(i, i + n));\n   |                                \
    \    ^ expected `usize`, found `isize`\n\nerror[E0277]: cannot add `isize` to\
    \ `usize`\n  --> /tmp/tmp1nefhdwh.rs:22:34\n   |\n22 |         words.push(s.substr(i,\
    \ i + n));\n   |                                  ^ no implementation for `usize\
    \ + isize`\n   |\n   = help: the trait `Add<isize>` is not implemented for `usize`\n\
    \   = help: the following other types implement trait `Add<Rhs>`:\n          \
    \   <&'a f32 as Add<f32>>\n             <&'a f64 as Add<f64>>\n             <&'a\
    \ i128 as Add<i128>>\n             <&'a i16 as Add<i16>>\n             <&'a i32\
    \ as Add<i32>>\n             <&'a i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n\
    \             <&'a isize as Add<isize>>\n           and 48 others\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp1nefhdwh.rs:23:14\n   |\n23 |         i += n;\n\
    \   |              ^ expected `usize`, found `isize`\n\nerror[E0277]: cannot add-assign\
    \ `isize` to `usize`\n  --> /tmp/tmp1nefhdwh.rs:23:11\n   |\n23 |         i +=\
    \ n;\n   |           ^^ no implementation for `usize += isize`\n   |\n   = help:\
    \ the trait `AddAssign<isize>` is not implemented for `usize`\n   = help: the\
    \ following other types implement trait `AddAssign<Rhs>`:\n             <f32 as\
    \ AddAssign<&f32>>\n             <f32 as AddAssign>\n             <f64 as AddAssign<&f64>>\n\
    \             <f64 as AddAssign>\n             <i128 as AddAssign<&i128>>\n  \
    \           <i128 as AddAssign>\n             <i16 as AddAssign<&i16>>\n     \
    \        <i16 as AddAssign>\n           and 20 others\n\nerror: aborting due to\
    \ 5 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010888
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ v = Vec::new();\n    let mut s = String::from(s);\n    while n >= 0 {\n    \
    \    if s.chars().any(|c| c.is_consonant()) {\n            v.push(s);\n      \
    \      s.clear();\n        } else {\n            n -= 1;\n        }\n    }\n \
    \   v.push(s)\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmp3g2g3fqd.rs:21:32\n   |\n21 |         if s.chars().any(|c|\
    \ c.is_consonant()) {\n   |                                ^^^^^^^^^^^^ method\
    \ not found in `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3g2g3fqd.rs:28:5\n\
    \   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |      \
    \                                   ----------- expected `Vec<String>` because\
    \ of return type\n...\n28 |     v.push(s)\n   |     ^^^^^^^^^ expected struct\
    \ `Vec`, found `()`\n   |\n   = note: expected struct `Vec<String>`\n        \
    \   found unit type `()`\nnote: method `push` modifies its receiver in-place\n\
    \  --> /tmp/tmp3g2g3fqd.rs:28:7\n   |\n28 |     v.push(s)\n   |     - ^^^^ this\
    \ call modifies `v` in-place\n   |     |\n   |     you probably want to use this\
    \ value after calling the method...\n   = note: ...instead of the `()` output\
    \ of method `push`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010888
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ ans = vec![];\n    let mut buffer = s.chars();\n    let mut i = n;\n    let\
    \ mut c: usize = 0;\n    while i < buffer.len() {\n        c = buffer[i];\n  \
    \      if c == ' ' {\n            i += 1;\n            continue;\n        }\n\
    \        if c < 'a' || c > 'z' {\n            i += 1;\n            continue;\n\
    \        }\n        if c == c.to_ascii_lowercase() {\n            let index =\
    \ buffer.iter().position(|&c| c == c);\n            ans.push(String::from(buffer.clone()));\n\
    \            i += index - 1;\n            continue;\n        }\n        if c ==\
    \ 'o' {\n            ans.push(String::from(buffer.clone()));\n            i +=\
    \ 1;\n            continue;\n        }\n        if c == 'e' {\n            ans.push(String::from(buffer.clone()));\n\
    \            i += 1;\n            continue;\n        }\n        if c == 'y' {\n\
    \            ans.push(String::from(buffer.clone()));\n            i += 1;\n  \
    \          continue;\n        }\n        i += 1;\n    }\n    ans\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmppfmkzto4.rs:22:22\n   |\n22 |     while i < buffer.len()\
    \ {\n   |                      ^^^ method not found in `Chars<'_>`\n\nerror[E0608]:\
    \ cannot index into a value of type `Chars<'_>`\n  --> /tmp/tmppfmkzto4.rs:23:13\n\
    \   |\n23 |         c = buffer[i];\n   |             ^^^^^^^^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmppfmkzto4.rs:24:17\n   |\n24 |         if c ==\
    \ ' ' {\n   |                 ^^^ expected `usize`, found `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmppfmkzto4.rs:28:16\n   |\n28 |         if c <\
    \ 'a' || c > 'z' {\n   |                ^^^ expected `usize`, found `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmppfmkzto4.rs:28:27\n   |\n28 |  \
    \       if c < 'a' || c > 'z' {\n   |                           ^^^ expected `usize`,\
    \ found `char`\n\nerror[E0599]: no method named `to_ascii_lowercase` found for\
    \ type `usize` in the current scope\n  --> /tmp/tmppfmkzto4.rs:32:19\n   |\n32\
    \ |         if c == c.to_ascii_lowercase() {\n   |                   ^^^^^^^^^^^^^^^^^^\
    \ method not found in `usize`\n\nerror[E0599]: no method named `iter` found for\
    \ struct `Chars` in the current scope\n  --> /tmp/tmppfmkzto4.rs:33:32\n   |\n\
    33 |             let index = buffer.iter().position(|&c| c == c);\n   |      \
    \                          ^^^^ private field, not a method\n\nerror[E0277]: the\
    \ trait bound `String: From<Chars<'_>>` is not satisfied\n  --> /tmp/tmppfmkzto4.rs:34:22\n\
    \   |\n34 |             ans.push(String::from(buffer.clone()));\n   |        \
    \              ^^^^^^^^^^^^ the trait `From<Chars<'_>>` is not implemented for\
    \ `String`\n   |\n   = help: the following other types implement trait `From<T>`:\n\
    \             <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmppfmkzto4.rs:38:17\n   |\n38 |\
    \         if c == 'o' {\n   |                 ^^"
  stdout: ''
  timestamp: 1660010888
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    // TODO\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc61yr745.rs:17:41\n   |\n\
    17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010888
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    select_words_helper(s,\
    \ n, 0)\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `select_words_helper` in this scope\n\
    \  --> /tmp/tmpngcjio7u.rs:18:5\n   |\n18 |     select_words_helper(s, n, 0)\n\
    \   |     ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660010888
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    fn helper(str:\
    \ &str, cnt: isize) -> Vec<String> {\n        if cnt == 0 {\n            return\
    \ vec![];\n        }\n        let mut res = vec![];\n        let mut s = str;\n\
    \        let mut i = 0;\n        while s.len() >= cnt + i {\n            let cur\
    \ = s.chars().nth(i + 1).unwrap();\n            if cur == 'a' || cur == 'e' ||\
    \ cur == 'i' || cur == 'o' || cur == 'u' {\n                res.push(s.to_string());\n\
    \                i += 1;\n            } else {\n                break;\n     \
    \       }\n        }\n        res\n    }\n    helper(&s, n)\n}\n\nfn main() {\n\
    \    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp29wrrmjm.rs:25:26\n   |\n\
    25 |         while s.len() >= cnt + i {\n   |                          ^^^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n25 |         while\
    \ s.len() >= (cnt + i).try_into().unwrap() {\n   |                          +\
    \       +++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp29wrrmjm.rs:26:37\n\
    \   |\n26 |             let cur = s.chars().nth(i + 1).unwrap();\n   |       \
    \                              ^^^^^ expected `usize`, found `isize`\n   |\nhelp:\
    \ you can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n26 |             let cur = s.chars().nth((i + 1).try_into().unwrap()).unwrap();\n\
    \   |                                     +     +++++++++++++++++++++\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010888
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = vec![];\n    let mut vowels = \"aeiouAEIOU\";\n    let mut vowel_count\
    \ = vowels.chars().count(|c| *c == c);\n    let mut consonants = \"bcdfghjklmnpqrstvwxyz\"\
    ;\n    let mut consonant_count = consonants.chars().count(|c| *c == c);\n    let\
    \ mut total_count = vowel_count + consonant_count;\n    while total_count < n\
    \ && s.len() > 0 {\n        let mut start = s.find_first_not_of(vowels);\n   \
    \     let mut end = s.find_last_not_of(vowels);\n        let mut word: String\
    \ = s.split_off(&vowels, start, end).to_owned();\n        if word.chars().count(|c|\
    \ c == c) == n {\n            result.push(String::from(word));\n        }\n  \
    \      total_count += word.chars().count(|c| c == c);\n        if total_count\
    \ == n {\n            break;\n        }\n        start = end;\n        end +=\
    \ vowels.chars().count(|c| *c == c);\n        word = s.split_off(&consonants,\
    \ start, end).to_owned();\n        total_count += word.chars().count(|c| c ==\
    \ c);\n        if total_count == n {\n            break;\n        }\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmphq4_d3cs.rs:20:49\n\
    \   |\n20 |     let mut vowel_count = vowels.chars().count(|c| *c == c);\n   |\
    \                                                 ^ consider giving this closure\
    \ parameter a type\n   |\n   = note: type must be known at this point\n\nerror[E0061]:\
    \ this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmphq4_d3cs.rs:20:42\n\
    \    |\n20  |     let mut vowel_count = vowels.chars().count(|c| *c == c);\n \
    \   |                                          ^^^^^ ----------- supplied 1 argument\n\
    \    |                                          |\n    |                     \
    \                     expected 0 arguments\n    |\nnote: associated function defined\
    \ here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmphq4_d3cs.rs:22:50\n    |\n22  |     let mut consonant_count =\
    \ consonants.chars().count(|c| *c == c);\n    |                              \
    \                    ^^^^^ ----------- supplied 1 argument\n    |            \
    \                                      |\n    |                              \
    \                    expected 0 arguments\n    |\nnote: associated function defined\
    \ here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphq4_d3cs.rs:24:25\n  \
    \ |\n24 |     while total_count < n && s.len() > 0 {\n   |                   \
    \      ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n24 |     while\
    \ total_count < n.try_into().unwrap() && s.len() > 0 {\n   |                 \
    \         ++++++++++++++++++++\n\nerror[E0599]: no method named `find_first_not_of`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmphq4_d3cs.rs:25:27\n\
    \   |\n25 |         let mut start = s.find_first_not_of(vowels);\n   |       \
    \                    ^^^^^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `find_last_not_of` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmphq4_d3cs.rs:26:25\n   |\n26 |         let mut end = s.find_last_not_of(vowels);\n\
    \   |     "
  stdout: ''
  timestamp: 1660010888
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    select_words_helper(s,\
    \ n, 0)\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `select_words_helper` in this scope\n\
    \  --> /tmp/tmpngcjio7u.rs:18:5\n   |\n18 |     select_words_helper(s, n, 0)\n\
    \   |     ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660010888
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut iter = s.char_indices();\n    let mut i = 0;\n\
    \    let mut j = 0;\n    let mut current_string = \"\";\n    while i < s.len()\
    \ {\n        let mut next_i = i;\n        while next_i < s.len() {\n         \
    \   if iter.get_mut(next_i).unwrap().1 == n {\n                current_string\
    \ += iter.get_mut(next_i).unwrap().0;\n                i += 1;\n            }\n\
    \            next_i += 1;\n        }\n        words.insert(j, current_string);\n\
    \        j += 1;\n        current_string = \"\";\n        i = next_i;\n    }\n\
    \    words\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `get_mut` found for struct `CharIndices`\
    \ in the current scope\n   --> /tmp/tmp55eljoxn.rs:26:21\n    |\n26  |       \
    \      if iter.get_mut(next_i).unwrap().1 == n {\n    |                     ^^^^^^^\
    \ method not found in `CharIndices<'_>`\n    |\nhelp: consider wrapping the receiver\
    \ expression with the appropriate type\n    |\n26  |             if Pin::new(&mut\
    \ iter).get_mut(next_i).unwrap().1 == n {\n    |                +++++++++++++\
    \     +\n\nerror[E0599]: no method named `get_mut` found for struct `CharIndices`\
    \ in the current scope\n   --> /tmp/tmp55eljoxn.rs:27:40\n    |\n27  |       \
    \          current_string += iter.get_mut(next_i).unwrap().0;\n    |         \
    \                               ^^^^^^^ method not found in `CharIndices<'_>`\n\
    \    |\nhelp: consider wrapping the receiver expression with the appropriate type\n\
    \    |\n27  |                 current_string += Pin::new(&mut iter).get_mut(next_i).unwrap().0;\n\
    \    |                                   +++++++++++++     +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp55eljoxn.rs:37:5\n   |\n17 | fn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n   |                                   \
    \      ----------- expected `Vec<String>` because of return type\n...\n37 |  \
    \   words\n   |     ^^^^^ expected struct `String`, found `&str`\n   |\n   = note:\
    \ expected struct `Vec<String>`\n              found struct `Vec<&str>`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010888
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    select_words(s,\
    \ n, s.chars())\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 2 arguments but 3 arguments were supplied\n\
    \  --> /tmp/tmpcvziow7o.rs:18:5\n   |\n18 |     select_words(s, n, s.chars())\n\
    \   |     ^^^^^^^^^^^^ -  -  --------- supplied 3 arguments\n   |     |\n   |\
    \     expected 2 arguments\n   |\nnote: function defined here\n  --> /tmp/tmpcvziow7o.rs:17:4\n\
    \   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ^^^^^^^^^^^^\
    \ ---------  --------\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660010888
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    if s.len()\
    \ == 0 {\n        return vec![];\n    }\n    let mut v: Vec<String> = vec![];\n\
    \    let mut prev_char = 'a';\n    let mut cur_char = 'a';\n    let mut cur_word\
    \ = 0;\n    let mut idx = 0;\n    let mut cur_len = 0;\n    let mut max_len =\
    \ s.len();\n    let mut cur_len = 0;\n    let mut i = 0;\n    loop {\n       \
    \ i += 1;\n        if n == cur_len {\n            // cur_word == cur_len\n   \
    \         cur_word += 1;\n            cur_len = 0;\n            idx += 1;\n  \
    \          if idx == max_len {\n                break;\n            }\n      \
    \  }\n\n        if i == max_len {\n            // cur_word == max_len\n      \
    \      v.push(s.split_whitespace()[cur_word]);\n            cur_word = 0;\n  \
    \          cur_len = 0;\n            idx = 0;\n        }\n\n        let cur_char\
    \ = s.chars().nth(i).unwrap();\n        if cur_char == prev_char {\n         \
    \   cur_len += 1;\n        } else {\n            cur_word = 0;\n            cur_len\
    \ = 0;\n            idx = 0;\n        }\n        prev_char = cur_char;\n    }\n\
    \    v\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmpzf_agjnc.rs:44:20\n   |\n44 |             v.push(s.split_whitespace()[cur_word]);\n\
    \   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0608`.\n"
  stdout: ''
  timestamp: 1660010888
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    select_words_helper(s,\
    \ n, vec![], 0)\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `select_words_helper` in this scope\n\
    \  --> /tmp/tmpis75_bdx.rs:18:5\n   |\n18 |     select_words_helper(s, n, vec![],\
    \ 0)\n   |     ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660010888
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    if n ==\
    \ 0 {\n        vec![]\n    } else {\n        let mut vec = Vec::new();\n     \
    \   for ch in s.chars() {\n            if ch.is_ascii_letter() || ch.is_whitespace()\
    \ {\n                let mut matched = false;\n                for sub in &mut\
    \ vec {\n                    if sub.contains(ch) {\n                        matched\
    \ = true;\n                        break;\n                    }\n           \
    \     }\n                if matched == false {\n                    vec.push(String::from(ch));\n\
    \                }\n            }\n        }\n        vec\n    }\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for type `char` in\
    \ the current scope\n  --> /tmp/tmp8hetjdvg.rs:23:19\n   |\n23 |             if\
    \ ch.is_ascii_letter() || ch.is_whitespace() {\n   |                   ^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `is_ascii`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010888
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ counts = s.chars().filter(|&c| c != ' ');\n    let mut result = Vec::new();\n\
    \    counts = counts[..counts.len() - n + 1];\n    for i in counts {\n       \
    \ match s.chars().any(|c| c == i) {\n            true => {\n                result.push(s.sub(i,\
    \ i + n));\n            }\n            false => {\n                break;\n  \
    \          }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `Filter` in the current\
    \ scope\n  --> /tmp/tmptm0pikx4.rs:20:30\n   |\n20 |     counts = counts[..counts.len()\
    \ - n + 1];\n   |                              ^^^ method not found in `Filter<Chars<'_>,\
    \ [closure@/tmp/tmptm0pikx4.rs:18:39: 18:52]>`\n\nerror[E0608]: cannot index into\
    \ a value of type `Filter<Chars<'_>, [closure@/tmp/tmptm0pikx4.rs:18:39: 18:52]>`\n\
    \  --> /tmp/tmptm0pikx4.rs:20:14\n   |\n20 |     counts = counts[..counts.len()\
    \ - n + 1];\n   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]:\
    \ no method named `sub` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmptm0pikx4.rs:24:31\n   |\n24 |                 result.push(s.sub(i, i\
    \ + n));\n   |                               ^^^ method not found in `String`\n\
    \nerror[E0369]: cannot add `isize` to `char`\n  --> /tmp/tmptm0pikx4.rs:24:40\n\
    \   |\n24 |                 result.push(s.sub(i, i + n));\n   |              \
    \                        - ^ - isize\n   |                                   \
    \   |\n   |                                      char\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0369, E0599, E0608.\n\
    For more information about an error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660010888
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ s = s;\n    if s.is_empty() {\n        return Vec::new();\n    }\n\n    let\
    \ mut res = Vec::with_capacity(s.len());\n    for i in s.chars().filter(|x| x.is_consonant()\
    \ && x.len() == n && x.is_ascii()) {\n        res.push(s.to_string());\n    }\n\
    \n    return res;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpi0anhqs1.rs:24:37\n   |\n24 |     for i\
    \ in s.chars().filter(|x| x.is_consonant() && x.len() == n && x.is_ascii()) {\n\
    \   |                                     ^^^^^^^^^^^^ method not found in `&char`\n\
    \nerror[E0599]: no method named `len` found for reference `&char` in the current\
    \ scope\n  --> /tmp/tmpi0anhqs1.rs:24:57\n   |\n24 |     for i in s.chars().filter(|x|\
    \ x.is_consonant() && x.len() == n && x.is_ascii()) {\n   |                  \
    \                                       ^^^ method not found in `&char`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010888
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::with_capacity(n);\n    let mut prev_len = 0;\n    for word in\
    \ s.split() {\n        if word.len() == prev_len {\n            result.push(word);\n\
    \            prev_len += 1;\n        }\n        else {\n            if prev_len\
    \ == n {\n                break;\n            }\n            prev_len = 0;\n \
    \       }\n    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk65_wat5.rs:18:41\n   |\n\
    18 |     let mut result = Vec::with_capacity(n);\n   |                       \
    \                  ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    18 |     let mut result = Vec::with_capacity(n.try_into().unwrap());\n   |   \
    \                                       ++++++++++++++++++++\n\nerror[E0061]:\
    \ this function takes 1 argument but 0 arguments were supplied\n    --> /tmp/tmpk65_wat5.rs:20:19\n\
    \     |\n20   |     for word in s.split() {\n     |                   ^^^^^- supplied\
    \ 0 arguments\n     |                   |\n     |                   expected 1\
    \ argument\n     |\nnote: associated function defined here\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpk65_wat5.rs:26:28\n   |\n26 |             if prev_len ==\
    \ n {\n   |                            ^ expected `usize`, found `isize`\n   |\n\
    help: you can convert an `isize` to a `usize` and panic if the converted value\
    \ doesn't fit\n   |\n26 |             if prev_len == n.try_into().unwrap() {\n\
    \   |                             ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpk65_wat5.rs:32:5\n   |\n17 | fn select_words(s: String,\
    \ n: isize) -> Vec<String> {\n   |                                         -----------\
    \ expected `Vec<String>` because of return type\n...\n32 |     result\n   |  \
    \   ^^^^^^ expected struct `String`, found `&str`\n   |\n   = note: expected struct\
    \ `Vec<String>`\n              found struct `Vec<&str>`\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0061, E0308.\n\
    For more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660010888
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    s.split_whitespace().filter(|c|\
    \ c.is_ascii_letter()).collect::<Vec<_>>()\n    .iter().filter(|c| c.chars().count()\
    \ >= n).collect::<Vec<_>>()\n    .iter().cloned().collect()\n}\n\nfn main() {\n\
    \    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&&str`\
    \ in the current scope\n  --> /tmp/tmp_5z2hocr.rs:18:39\n   |\n18 |     s.split_whitespace().filter(|c|\
    \ c.is_ascii_letter()).collect::<Vec<_>>()\n   |                             \
    \          ^^^^^^^^^^^^^^^ help: there is an associated function with a similar\
    \ name: `is_ascii`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_5z2hocr.rs:19:45\n\
    \   |\n19 |     .iter().filter(|c| c.chars().count() >= n).collect::<Vec<_>>()\n\
    \   |                                             ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n19 |     .iter().filter(|c| c.chars().count() >= n.try_into().unwrap()).collect::<Vec<_>>()\n\
    \   |                                              ++++++++++++++++++++\n\nerror[E0277]:\
    \ a value of type `Vec<String>` cannot be built from an iterator over elements\
    \ of type `&&str`\n    --> /tmp/tmp_5z2hocr.rs:20:22\n     |\n20   |     .iter().cloned().collect()\n\
    \     |                      ^^^^^^^ value of type `Vec<String>` cannot be built\
    \ from `std::iter::Iterator<Item=&&str>`\n     |\n     = help: the trait `FromIterator<&&str>`\
    \ is not implemented for `Vec<String>`\n     = help: the trait `FromIterator<T>`\
    \ is implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660010888
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ counts = HashMap::new();\n\n    for c in s.chars() {\n        if c == ' ' {\n\
    \            continue;\n        }\n        if let Some(i) = counts.get(&c) {\n\
    \            counts.entry(i as usize).or_insert(0) += 1;\n        } else {\n \
    \           counts.insert(c as usize, 1);\n        }\n    }\n\n    let mut words:\
    \ Vec<String> = Vec::new();\n\n    for (i, c) in counts {\n        if i == n {\n\
    \            words.push(s.chars().filter(|&c| c == ' ').collect::<String>());\n\
    \            break;\n        }\n    }\n\n    words\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpedaxpi3i.rs:18:22\n   |\n18 |     let mut counts = HashMap::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0067]:\
    \ invalid left-hand side of assignment\n  --> /tmp/tmpedaxpi3i.rs:25:51\n   |\n\
    25 |             counts.entry(i as usize).or_insert(0) += 1;\n   |           \
    \  ------------------------------------- ^^\n   |             |\n   |        \
    \     cannot assign to this expression\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0067, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1660010888
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    match (s.len(),\
    \ n) {\n        (0, 0) => Vec::new(),\n        (_, 0) => vec![],\n        (s,\
    \ 0) => vec![s],\n        (s, Some(_)) => vec![s],\n        (_, n) => {\n    \
    \        let mut result = vec![];\n            let mut current_index = 0;\n  \
    \          while current_index < s.len() {\n                let start = current_index;\n\
    \                while start < s.len() && s[start] == ' ' {\n                \
    \    start += 1;\n                }\n                let word_end = (start + n)\
    \ - 1;\n                if word_end > start {\n                    result.push(&s[start..word_end]);\n\
    \                }\n                current_index = word_end + 1;\n          \
    \  }\n            result\n        }\n    }\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp22oqqsxr.rs:22:13\n   |\n\
    18 |     match (s.len(), n) {\n   |           ------------ this expression has\
    \ type `(usize, isize)`\n...\n22 |         (s, Some(_)) => vec![s],\n   |    \
    \         ^^^^^^^ expected `isize`, found enum `Option`\n   |\n   = note: expected\
    \ type `isize`\n              found enum `Option<_>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp22oqqsxr.rs:21:24\n   |\n21 |         (s, 0) => vec![s],\n\
    \   |                        ^- help: try using a conversion method: `.to_string()`\n\
    \   |                        |\n   |                        expected struct `String`,\
    \ found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp22oqqsxr.rs:22:30\n\
    \   |\n22 |         (s, Some(_)) => vec![s],\n   |                           \
    \   ^- help: try using a conversion method: `.to_string()`\n   |             \
    \                 |\n   |                              expected struct `String`,\
    \ found `usize`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp22oqqsxr.rs:28:42\n   |\n28 |                 while start < s.len()\
    \ && s[start] == ' ' {\n   |                                          ^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp22oqqsxr.rs:31:41\n\
    \   |\n31 |                 let word_end = (start + n) - 1;\n   |            \
    \                             ^ expected `usize`, found `isize`\n\nerror[E0277]:\
    \ cannot add `isize` to `usize`\n  --> /tmp/tmp22oqqsxr.rs:31:39\n   |\n31 | \
    \                let word_end = (start + n) - 1;\n   |                       \
    \                ^ n"
  stdout: ''
  timestamp: 1660010888
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    \n}\n\n\
    fn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3v79g7v6.rs:17:41\n   |\n\
    17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    if s.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut words: Vec<String> = vec![];\n\
    \    let mut current = String::from(\"\");\n    let mut next: String = String::from(\"\
    \");\n    while current != s {\n        next = current.clone();\n        next.chars().for_each(|c|{\n\
    \            if c.is_consonant() {\n                let mut n = next.char_indices().next().unwrap().0;\n\
    \                n = n % n.len();\n                if n == n {\n             \
    \       let mut idx = next.char_indices().next().unwrap().0;\n               \
    \     let mut len = next.char_indices().next().unwrap().0;\n                 \
    \   let mut rem = len;\n                    let mut word = String::from(\"\");\n\
    \                    while rem > 0 {\n                        let mut s = String::from(next[..]);\n\
    \                        s = s.trim_start_matches('A' - 'a');\n              \
    \          s = s.trim_end_matches('Z' - 'a');\n                        s.chars().for_each(|c|{\n\
    \                            if c.is_consonant() {\n                         \
    \       word.push(c);\n                            }\n                       \
    \ });\n                        let mut idx2 = word.char_indices().next().unwrap().0;\n\
    \                        let mut len2 = word.char_indices().next().unwrap().0;\n\
    \                        let mut rem2 = len2;\n                        while rem2\
    \ > 0 {\n                            let mut s2 = String::from(word[..]);\n  \
    \                          s2 = s2.trim_start_matches('A' - 'a');\n          \
    \                  s2 = s2.trim_end_matches('Z' - 'a');\n                    \
    \        s2.chars().for_each(|c|{\n                                if c.is_consonant()\
    \ {\n                                    next.push_str(&c);\n                \
    \                }\n                            });\n                        \
    \    let mut idx3 = s2.char_indices().next().unwrap().0;\n                   \
    \         let mut len3 = s2.char_indices().next().unwrap().0;\n              \
    \              let mut rem3 = len3;\n                            while rem3 >\
    \ 0 {\n                                let mut s3 = String::from(next[..]);\n\
    \                                s3 = s3.trim_start_matches('A' - 'a');\n    \
    \                            s3 = s3.trim_end_matches('Z' - 'a');\n          \
    \                      s3.chars().for_each(|c|{\n                            \
    \        if c.is_consonant() {\n                                        next.push_str(&c);\n\
    \                                    }\n                                });\n\
    \                                let mut idx4 = s3.char_indices().next().unwrap().0;\n\
    \                                let mut len4 = s3.char_indices().next().unwrap().0;\n\
    \                                let mut rem4 = len4;\n                      \
    \          while rem4 > 0 {\n                                    let mut s4 =\
    \ String::\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp8flefdnw.rs:84:3\n\
    \   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |      \
    \                                               - unclosed delimiter\n...\n24\
    \ |     while current != s {\n   |                        - unclosed delimiter\n\
    25 |         next = current.clone();\n26 |         next.chars().for_each(|c|{\n\
    \   |                              -   - unclosed delimiter\n   |            \
    \                  |\n   |                              unclosed delimiter\n27\
    \ |             if c.is_consonant() {\n   |                                 -\
    \ unclosed delimiter\n...\n30 |                 if n == n {\n   |            \
    \               - unclosed delimiter\n...\n35 |                     while rem\
    \ > 0 {\n   |                                   - unclosed delimiter\n...\n47\
    \ |                         while rem2 > 0 {\n   |                           \
    \             - unclosed delimiter\n...\n59 |                             while\
    \ rem3 > 0 {\n   |                                            - unclosed delimiter\n\
    ...\n71 |                                 while rem4 > 0 {\n   |             \
    \                                   - this delimiter might not be properly closed...\n\
    72 |                                     let mut s4 = String::\n73 | }\n   | -\
    \ ...as it matches this but it has different indentation\n...\n84 | }\n   |  \
    \ ^\n\nerror: expected identifier, found `}`\n  --> /tmp/tmp8flefdnw.rs:73:1\n\
    \   |\n73 | }\n   | ^ expected identifier\n\nerror[E0599]: no method named `is_consonant`\
    \ found for type `char` in the current scope\n  --> /tmp/tmp8flefdnw.rs:27:18\n\
    \   |\n27 |             if c.is_consonant() {\n   |                  ^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror[E0599]: no method named `len` found for\
    \ type `usize` in the current scope\n  --> /tmp/tmp8flefdnw.rs:29:27\n   |\n29\
    \ |                 n = n % n.len();\n   |                           ^^^ method\
    \ not found in `usize`\n\nerror[E0277]: the size for values of type `str` cannot\
    \ be known at compilation time\n   --> /tmp/tmp8flefdnw.rs:36:50\n    |\n"
  stdout: ''
  timestamp: 1660010888
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ res = Vec::new();\n    let mut word = String::from(s);\n    let mut i = 0;\n\
    \    while i < word.len() {\n        if word.chars().any(|c| c.is_consonant()\
    \ == true) {\n            i += 1;\n        } else {\n            res.push(word.clone());\n\
    \            i += 1;\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpz3hihkfd.rs:22:35\n   |\n22 |         if word.chars().any(|c|\
    \ c.is_consonant() == true) {\n   |                                   ^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010888
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    \n}\n\n\
    fn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3v79g7v6.rs:17:41\n   |\n\
    17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    if s.is_empty()\
    \ {\n        return vec![];\n    }\n    \n    let mut counts = HashMap::new();\n\
    \    for (i, &c) in s.chars().enumerate() {\n        if c == ' ' || c == '\\n'\
    \ || c == '\\t' {\n            counts.insert(i, 0);\n        }\n        if c ==\
    \ ' ' && n == 2 && counts.contains(&i + 1) {\n            counts.remove(&i + 1);\n\
    \        }\n    }\n    let mut vec: Vec<String> = vec![];\n    for (i, &c) in\
    \ s.chars().enumerate() {\n        if c == ' ' || c == '\\n' || c == '\\t' {\n\
    \            vec.push(String::from(&s.chars()[i .. i].collect()));\n        }\n\
    \        if c == ' ' && n == 2 && counts.contains(&i + 1) {\n            vec.push(String::from(&s.chars()[i\
    \ .. i].collect()));\n        }\n    }\n    vec\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpx0f6ggax.rs:22:22\n   |\n22 |     let mut counts = HashMap::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpx0f6ggax.rs:23:13\n   |\n23 |     for (i, &c)\
    \ in s.chars().enumerate() {\n   |             ^^     --------------------- this\
    \ expression has type `Option<(usize, char)>`\n   |             |\n   |      \
    \       expected `char`, found reference\n   |             help: you can probably\
    \ remove the explicit borrow: `c`\n   |\n   = note:   expected type `char`\n \
    \          found reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpx0f6ggax.rs:32:13\n\
    \   |\n32 |     for (i, &c) in s.chars().enumerate() {\n   |             ^^  \
    \   --------------------- this expression has type `Option<(usize, char)>`\n \
    \  |             |\n   |             expected `char`, found reference\n   |  \
    \           help: you can probably remove the explicit borrow: `c`\n   |\n   =\
    \ note:   expected type `char`\n           found reference `&_`\n\nerror[E0608]:\
    \ cannot index into a value of type `Chars<'_>`\n  --> /tmp/tmpx0f6ggax.rs:34:36\n\
    \   |\n34 |             vec.push(String::from(&s.chars()[i .. i].collect()));\n\
    \   |                                    ^^^^^^^^^^^^^^^^^\n\nerror[E0608]: cannot\
    \ index into a value of type `Chars<'_>`\n  --> /tmp/tmpx0f6ggax.rs:37:36\n  \
    \ |\n37 |             vec.push(String::from(&s.chars()[i .. i].collect()));\n\
    \   |                                    ^^^^^^^^^^^^^^^^^\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0308, E0433,\
    \ E0608.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010888
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    \n}\n\n\
    fn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3v79g7v6.rs:17:41\n   |\n\
    17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010887
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ s = String::from(s);\n    let mut vec = Vec::new();\n    while s.len() > n {\n\
    \        let mut word = s;\n        while word.contains(\"consonant\") {\n   \
    \         let mut word_start = word.find(' ');\n            while word_start >\
    \ 0 && word.chars().nth(word_start).unwrap() == '-' {\n                word_start\
    \ -= 1;\n            }\n            let mut word_end = word.find(' ', word_start\
    \ + 1);\n            while word_end > 0 && word.chars().nth(word_end).unwrap()\
    \ == '-' {\n                word_end -= 1;\n            }\n            let mut\
    \ word_length = word_end as usize - word_start as usize;\n            while word_length\
    \ > 0 && word.chars().nth(word_start+word_length).unwrap() == '-' {\n        \
    \        word_length -= 1;\n            }\n            word.truncate(word_start);\n\
    \            word.truncate(word_start + word_length);\n        }\n        vec.push(word);\n\
    \    }\n    vec\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjwim2j8u.rs:20:21\n   |\n\
    20 |     while s.len() > n {\n   |                     ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n20 |     while s.len() > n.try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpjwim2j8u.rs:24:32\n   |\n24 |             while word_start\
    \ > 0 && word.chars().nth(word_start).unwrap() == '-' {\n   |                \
    \                ^ expected enum `Option`, found integer\n   |\n   = note: expected\
    \ enum `Option<usize>`\n              found type `{integer}`\nhelp: try wrapping\
    \ the expression in `Some`\n   |\n24 |             while word_start > Some(0)\
    \ && word.chars().nth(word_start).unwrap() == '-' {\n   |                    \
    \            +++++ +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjwim2j8u.rs:24:54\n\
    \   |\n24 |             while word_start > 0 && word.chars().nth(word_start).unwrap()\
    \ == '-' {\n   |                                                      ^^^^^^^^^^\
    \ expected `usize`, found enum `Option`\n   |\n   = note: expected type `usize`\n\
    \              found enum `Option<usize>`\n\nerror[E0368]: binary assignment operation\
    \ `-=` cannot be applied to type `Option<usize>`\n  --> /tmp/tmpjwim2j8u.rs:25:17\n\
    \   |\n25 |                 word_start -= 1;\n   |                 ----------^^^^^\n\
    \   |                 |\n   |                 cannot use `-=` on type `Option<usize>`\n\
    \nerror[E0369]: cannot add `{integer}` to `Option<usize>`\n  --> /tmp/tmpjwim2j8u.rs:27:58\n\
    \   |\n27 |             let mut word_end = word.find(' ', word_start + 1);\n \
    \  |                                               ---------- ^ - {integer}\n\
    \   |                                               |\n   |                  \
    \                             Option<usize>\n\nerror[E0061]: this function takes\
    \ 1 argument but 2 arguments were supplied\n    --> /tmp/tmpjwim2j8u.rs:27:37\n\
    \     |\n27   |             let mut word_end = word.find(' ', word_start + 1);\n\
    \     |              "
  stdout: ''
  timestamp: 1660010888
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    match s.len()\
    \ {\n        0 => vec![],\n        _ => {\n            let mut words = vec![];\n\
    \            let mut i = 0;\n            for x in s.chars() {\n              \
    \  let mut found = false;\n                while i < words.len() && words[i].len()\
    \ < n {\n                    if x == words[i].as_ref() {\n                   \
    \     found = true;\n                        break;\n                    }\n \
    \                   i += 1;\n                }\n                if found {\n \
    \                   i += 1;\n                    continue;\n                }\n\
    \                words.push(x);\n            }\n            words\n        }\n\
    \    }\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Vec<T>`\n  --> /tmp/tmpujjz2nz_.rs:25:42\n\
    \   |\n21 |             let mut words = vec![];\n   |                 ---------\
    \ consider giving `words` the explicit type `Vec<T>`, with the type parameters\
    \ specified\n...\n25 |                 while i < words.len() && words[i].len()\
    \ < n {\n   |                                          ^^^^^^^^ cannot infer type\n\
    \   |\n   = note: type must be known at this point\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1660010888
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    select_words_helper(s.as_ref(),\
    \ n)\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `select_words_helper` in this scope\n\
    \  --> /tmp/tmp1k4ti16c.rs:18:5\n   |\n18 |     select_words_helper(s.as_ref(),\
    \ n)\n   |     ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660010888
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    if n ==\
    \ 0 {\n        vec![]\n    }\n    else {\n        let mut list = vec![];\n   \
    \     let mut index = s.char_indices().enumerate().collect::<Vec<_>>();\n    \
    \    for (i, char) in index {\n            if char.1.is_ascii() && char.2.is_ascii()\
    \ && char.1.unwrap() == char.2.unwrap() && char.1.unwrap() % 3 == n {\n      \
    \          list.push((i, char.1.unwrap()));\n            }\n        }\n      \
    \  list\n    }\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0609]: no field `2` on type `(usize, char)`\n  --> /tmp/tmpdn9m3_cv.rs:25:42\n\
    \   |\n25 |             if char.1.is_ascii() && char.2.is_ascii() && char.1.unwrap()\
    \ == char.2.unwrap() && char.1.unwrap() % 3 == n {\n   |                     \
    \                     ^\n\nerror[E0599]: no method named `unwrap` found for type\
    \ `char` in the current scope\n  --> /tmp/tmpdn9m3_cv.rs:25:65\n   |\n25 |   \
    \          if char.1.is_ascii() && char.2.is_ascii() && char.1.unwrap() == char.2.unwrap()\
    \ && char.1.unwrap() % 3 == n {\n   |                                        \
    \                         ^^^^^^ method not found in `char`\n\nerror[E0609]: no\
    \ field `2` on type `(usize, char)`\n  --> /tmp/tmpdn9m3_cv.rs:25:82\n   |\n25\
    \ |             if char.1.is_ascii() && char.2.is_ascii() && char.1.unwrap() ==\
    \ char.2.unwrap() && char.1.unwrap() % 3 == n {\n   |                        \
    \                                                          ^\n\nerror[E0599]:\
    \ no method named `unwrap` found for type `char` in the current scope\n  --> /tmp/tmpdn9m3_cv.rs:25:103\n\
    \   |\n25 |             if char.1.is_ascii() && char.2.is_ascii() && char.1.unwrap()\
    \ == char.2.unwrap() && char.1.unwrap() % 3 == n {\n   |                     \
    \                                                                            \
    \      ^^^^^^ method not found in `char`\n\nerror[E0599]: no method named `unwrap`\
    \ found for type `char` in the current scope\n  --> /tmp/tmpdn9m3_cv.rs:26:38\n\
    \   |\n26 |                 list.push((i, char.1.unwrap()));\n   |           \
    \                           ^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0599, E0609.\n\
    For more information about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010888
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    // TODO\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc61yr745.rs:17:41\n   |\n\
    17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010888
