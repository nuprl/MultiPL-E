language: rs
name: HumanEval_74_total_match
results:
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut result = vec![\"\".to_string(); lst1.len()];\n    for i in 0..lst1.len()\
    \ {\n        if lst1[i] < lst2[i] {\n            result.push(lst1[i]);\n     \
    \   } else {\n            result.push(lst2[i]);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmphhqp_avr.rs:19:25\n\
    \   |\n19 |             result.push(lst1[i]);\n   |                         ^^^^^^^\
    \ move occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmphhqp_avr.rs:21:25\n\
    \   |\n21 |             result.push(lst2[i]);\n   |                         ^^^^^^^\
    \ move occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0507`.\n"
  stdout: ''
  timestamp: 1659976547
- exit_code: 101
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut l1 = lst1.len();\n    let mut l2 = lst2.len();\n    while l1 > 0\
    \ || l2 > 0 {\n        if l1 > 0 {\n            l1 -= 1;\n        } else {\n \
    \           l2 -= 1;\n        }\n        if l1 == 0 && l2 == 0 {\n           \
    \ return lst1;\n        }\n    }\n    vec![]\n}\n\nfn main() {\n    let candidate\
    \ = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"hi\", \"admin\"]`,\n right: `[\"hi\", \"hi\"]`', /tmp/tmp3xq92xp8.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == 0 || lst2.len() == 0 {\n        return vec![];\n    }\n\n\
    \    if lst1.len() == lst2.len() {\n        let mut result = vec![];\n\n     \
    \   for value in lst1 {\n            if lst2.iter().any(|&value2| value2 == &value)\
    \ {\n                result.push(value);\n            }\n        }\n\n       \
    \ return result;\n    }\n\n    if lst1.len() < lst2.len() {\n        let mut result\
    \ = vec![];\n\n        for value in lst1 {\n            if lst2.iter().any(|&value2|\
    \ value2 == &value) {\n                result.push(value);\n            }\n  \
    \      }\n\n        return result;\n    }\n\n    let mut result = vec![];\n\n\
    \    for value in lst1 {\n        if lst2.iter().any(|&value2| value2 == &value)\
    \ {\n            result.push(value);\n        }\n    }\n\n    return result;\n\
    }\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `String` with `&String`\n  --> /tmp/tmps8j0bbih.rs:24:49\n\
    \   |\n24 |             if lst2.iter().any(|&value2| value2 == &value) {\n   |\
    \                                                 ^^ no implementation for `String\
    \ == &String`\n   |\n   = help: the trait `PartialEq<&String>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `String` with `&String`\n  --> /tmp/tmps8j0bbih.rs:36:49\n   |\n36 |       \
    \      if lst2.iter().any(|&value2| value2 == &value) {\n   |                \
    \                                 ^^ no implementation for `String == &String`\n\
    \   |\n   = help: the trait `PartialEq<&String>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `String` with `&String`\n  --> /tmp/tmps8j0bbih.rs:47:45\n   |\n47 |       \
    \  if lst2.iter().any(|&value2| value2 == &value) {\n   |                    \
    \                         ^^ no implementation for `String == &String`\n   |\n\
    \   = help: the trait `PartialEq<&String>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `PartialEq<Rhs>`:\n     \
    \        <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>"
  stdout: ''
  timestamp: 1659976547
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1\n    }\n\n    if lst1.len()\
    \ < lst2.len() {\n        let mut m = Vec::new();\n        for i in 0..lst1.len()\
    \ {\n            if lst1[i] < lst2[i] {\n                m.append(lst1[i]);\n\
    \            }\n        }\n        return m;\n    }\n\n    let mut m = Vec::new();\n\
    \    for i in 0..lst2.len() {\n        if lst2[i] < lst1[i] {\n            m.append(lst2[i]);\n\
    \        }\n    }\n    return m;\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp617ckx5k.rs:24:26\n   |\n\
    24 |                 m.append(lst1[i]);\n   |                          ^^^^^^^\
    \ expected `&mut Vec<_>`, found struct `String`\n   |\n   = note: expected mutable\
    \ reference `&mut Vec<_>`\n                         found struct `String`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp617ckx5k.rs:33:22\n   |\n33 |  \
    \           m.append(lst2[i]);\n   |                      ^^^^^^^ expected `&mut\
    \ Vec<_>`, found struct `String`\n   |\n   = note: expected mutable reference\
    \ `&mut Vec<_>`\n                         found struct `String`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976547
- exit_code: 101
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut total_count = vec![];\n    for i in 0..lst1.len() {\n        let\
    \ mut cur_count = 0;\n        for j in 0..lst2.len() {\n            if lst1[i]\
    \ == lst2[j] {\n                cur_count += 1;\n                break;\n    \
    \        }\n        }\n        total_count.push(cur_count);\n    }\n    if lst1.len()\
    \ == total_count.len() && lst2.len() == total_count.len() {\n        lst1\n  \
    \  } else {\n        lst2\n    }\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"hi\", \"admin\"]`,\n right: `[\"hi\", \"hi\"]`', /tmp/tmp8vk5ebbp.rs:37:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    lst1.iter().zip(lst2.iter()).filter(|pair| {\n        pair.0\n          \
    \  .chars()\n            .all(|c| pair.1\n                .chars()\n         \
    \       .all(|c| c < pair.0))\n    }).cloned().collect()\n}\n\nfn main() {\n \
    \   let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp88m587h4.rs:21:30\n   |\n\
    21 |                 .all(|c| c < pair.0))\n   |                             \
    \ ^^^^^^ expected `char`, found `&String`\n\nerror[E0271]: type mismatch resolving\
    \ `<Filter<Zip<std::slice::Iter<'_, String>, std::slice::Iter<'_, String>>, [closure@/tmp/tmp88m587h4.rs:16:41:\
    \ 22:6]> as Iterator>::Item == &_`\n    --> /tmp/tmp88m587h4.rs:22:8\n     |\n\
    22   |     }).cloned().collect()\n     |        ^^^^^^ expected reference, found\
    \ tuple\n     |\n     = note: expected reference `&_`\n                    found\
    \ tuple `(&String, &String)`\nnote: required by a bound in `cloned`\n\nerror[E0599]:\
    \ the method `collect` exists for struct `Cloned<Filter<Zip<std::slice::Iter<'_,\
    \ String>, std::slice::Iter<'_, String>>, [closure@/tmp/tmp88m587h4.rs:16:41:\
    \ 22:6]>>`, but its trait bounds were not satisfied\n  --> /tmp/tmp88m587h4.rs:22:17\n\
    \   |\n22 |        }).cloned().collect()\n   |                    ^^^^^^^ method\
    \ cannot be called on `Cloned<Filter<Zip<std::slice::Iter<'_, String>, std::slice::Iter<'_,\
    \ String>>, [closure@/tmp/tmp88m587h4.rs:16:41: 22:6]>>` due to unsatisfied trait\
    \ bounds\n   |\n   = note: the following trait bounds were not satisfied:\n  \
    \         `<Filter<Zip<std::slice::Iter<'_, String>, std::slice::Iter<'_, String>>,\
    \ [closure@/tmp/tmp88m587h4.rs:16:41: 22:6]> as Iterator>::Item = &_`\n      \
    \     which is required by `Cloned<Filter<Zip<std::slice::Iter<'_, String>, std::slice::Iter<'_,\
    \ String>>, [closure@/tmp/tmp88m587h4.rs:16:41: 22:6]>>: Iterator`\n         \
    \  `Cloned<Filter<Zip<std::slice::Iter<'_, String>, std::slice::Iter<'_, String>>,\
    \ [closure@/tmp/tmp88m587h4.rs:16:41: 22:6]>>: Iterator`\n           which is\
    \ required by `&mut Cloned<Filter<Zip<std::slice::Iter<'_, String>, std::slice::Iter<'_,\
    \ String>>, [closure@/tmp/tmp88m587h4.rs:16:41: 22:6]>>: Iterator`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0271, E0308,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659976547
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1\n    }\n    lst1\n   \
    \     .iter()\n        .zip(lst2.iter())\n        .filter(|&(a, _)| a <= b)\n\
    \        .map(|(a, b)| b.to_string())\n        .collect()\n}\n\nfn main() {\n\
    \    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `b` in this scope\n  --> /tmp/tmpxydx87fb.rs:22:32\n\
    \   |\n22 |         .filter(|&(a, _)| a <= b)\n   |                          \
    \      ^ help: a local variable with a similar name exists: `a`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976547
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut total_len: usize = 0;\n    for (i, v1) in lst1.iter().zip(lst1.iter().cloned()).skip(1)\
    \ {\n        let (other_i, other_v1) = lst2.iter().skip(i).peekable().nth(1).unwrap();\n\
    \        if v1 != other_v1 {\n            break;\n        }\n        total_len\
    \ += 1;\n    }\n    if total_len == lst1.len() {\n        lst1\n    } else {\n\
    \        vec![String::from(\"\")]\n    }\n}\n\nfn main() {\n    let candidate\
    \ = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd_dq0vc6.rs:18:52\n   |\n\
    18 |         let (other_i, other_v1) = lst2.iter().skip(i).peekable().nth(1).unwrap();\n\
    \   |                                                    ^ expected `usize`, found\
    \ `&String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpd_dq0vc6.rs:18:13\n\
    \   |\n18 |         let (other_i, other_v1) = lst2.iter().skip(i).peekable().nth(1).unwrap();\n\
    \   |             ^^^^^^^^^^^^^^^^^^^   ----------------------------------------------\
    \ this expression has type `&String`\n   |             |\n   |             expected\
    \ struct `String`, found tuple\n   |\n   = note: expected struct `String`\n  \
    \             found tuple `(_, _)`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976547
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut result: Vec<String> = Vec::new();\n    for (a, b) in lst1.iter().zip(lst2.iter())\
    \ {\n        if a < b {\n            result.append(a);\n        } else {\n   \
    \         result.append(b);\n        }\n    }\n    if result.len() == lst1.len()\
    \ {\n        lst1\n    } else {\n        result\n    }\n}\n\nfn main() {\n   \
    \ let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqoulfmse.rs:19:27\n   |\n\
    19 |             result.append(a);\n   |                           ^ types differ\
    \ in mutability\n   |\n   = note: expected mutable reference `&mut Vec<String>`\n\
    \                      found reference `&String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpqoulfmse.rs:21:27\n   |\n21 |             result.append(b);\n \
    \  |                           ^ types differ in mutability\n   |\n   = note:\
    \ expected mutable reference `&mut Vec<String>`\n                      found reference\
    \ `&String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976547
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    match lst1.len() {\n        0 => vec![],\n        1 => vec![lst1[0]],\n \
    \       2 => vec![lst1[0], lst1[1]],\n        3 => vec![lst1[0], lst1[1], lst1[2]],\n\
    \        4 => vec![lst1[0], lst1[1], lst1[2], lst1[3]],\n        5 => vec![lst1[0],\
    \ lst1[1], lst1[2], lst1[3], lst1[4]],\n        _ => {\n            let mut res\
    \ = vec![];\n            for elt in lst1 {\n                if elt.len() > lst2.len()\
    \ {\n                    let mut i = 0;\n                    let mut j = 0;\n\
    \                    while j < lst2.len() && i < elt.len() {\n               \
    \         if lst2[j] < elt[i] {\n                            i += 1;\n       \
    \                 } else {\n                            j += 1;\n            \
    \            }\n                    }\n                    if i < lst2.len() {\n\
    \                        res.push(elt.to_string());\n                    }\n \
    \               }\n            }\n            res\n        }\n    }\n}\n\nfn main()\
    \ {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp6adks1ym.rs:30:38\n\
    \   |\n30 |                         if lst2[j] < elt[i] {\n   |              \
    \                        ^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976547
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut i = 0;\n    while i < lst1.len() {\n        if lst1[i].len() < lst2[i].len()\
    \ {\n            i += 1;\n            continue;\n        }\n        if lst1[i].len()\
    \ > lst2[i].len() {\n            return vec![lst1[i]];\n        }\n        i +=\
    \ 1;\n    }\n    lst1\n}\n\nfn main() {\n    let candidate = total_match;\n  \
    \  assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpfp4logaq.rs:23:25\n\
    \   |\n23 |             return vec![lst1[i]];\n   |                         ^^^^^^^\
    \ move occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0507`.\n"
  stdout: ''
  timestamp: 1659976547
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == 0 || lst2.len() == 0 {\n        return vec![];\n    }\n\
    \    let mut total_lst = vec![];\n    for elem in lst1 {\n        for elem2 in\
    \ lst2 {\n            if elem < elem2 {\n                total_lst.push(elem);\n\
    \                break;\n            }\n        }\n    }\n    total_lst\n}\n\n\
    fn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmp_bnebiq0.rs:21:22\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n21  |  \
    \       for elem2 in lst2 {\n    |                      ^^^^ `lst2` moved due\
    \ to this implicit call to `.into_iter()`, in previous iteration of loop\n   \
    \ |\nnote: this function takes ownership of the receiver `self`, which moves `lst2`\n\
    help: consider iterating over a slice of the `Vec<String>`'s content to avoid\
    \ moving into the `for` loop\n    |\n21  |         for elem2 in &lst2 {\n    |\
    \                      +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976547
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut total_len = vec![0; lst1.len()];\n    for x in lst1 {\n        if\
    \ x < lst2 {\n            total_len[lst1.iter().position(|y| y < x).unwrap()]\
    \ += 1;\n        }\n    }\n    total_len.iter().filter(|&x| x > 0).collect()\n\
    }\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgd1wynu7.rs:18:16\n   |\n\
    18 |         if x < lst2 {\n   |                ^^^^ expected struct `String`,\
    \ found struct `Vec`\n   |\n   = note: expected struct `String`\n            \
    \  found struct `Vec<String>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgd1wynu7.rs:19:52\n\
    \   |\n19 |             total_len[lst1.iter().position(|y| y < x).unwrap()] +=\
    \ 1;\n   |                                                    ^\n   |        \
    \                                            |\n   |                         \
    \                           expected `&String`, found struct `String`\n   |  \
    \                                                  help: consider borrowing here:\
    \ `&x`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgd1wynu7.rs:22:38\n  \
    \ |\n22 |     total_len.iter().filter(|&x| x > 0).collect()\n   |            \
    \                          ^\n   |                                      |\n  \
    \ |                                      expected reference, found integer\n \
    \  |                                      help: consider borrowing here: `&0`\n\
    \   |\n   = note: expected reference `&_`\n                   found type `{integer}`\n\
    \nerror[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&{integer}`\n    --> /tmp/tmpgd1wynu7.rs:22:41\n    \
    \ |\n22   |     total_len.iter().filter(|&x| x > 0).collect()\n     |        \
    \                                 ^^^^^^^ value of type `Vec<String>` cannot be\
    \ built from `std::iter::Iterator<Item=&{integer}>`\n     |\n     = help: the\
    \ trait `FromIterator<&{integer}>` is not implemented for `Vec<String>`\n    \
    \ = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976547
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        lst1\n    } else {\n        lst1.iter().map(|&a|\
    \ {\n            lst2.iter().filter(|&b| a.contains(&b)).count().min(&a.len()\
    \ as i32).map(|c| a.replace(c, \"\"))\n        })\n            .fold(Vec::new(),\
    \ |mut c, (mut a, b)| {\n                let mut newa = c.clone();\n         \
    \       newa.extend(b.iter().cloned());\n                c.extend(b.iter().filter(|&b|\
    \ newa.contains(&b)).map(|b| b.replace(b, \"\")));\n                c\n      \
    \      })\n            .iter().map(|a| a.collect::<String>())\n            .collect()\n\
    \    }\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `String`\n    -->\
    \ /tmp/tmpz48rn0mr.rs:20:48\n     |\n20   |             lst2.iter().filter(|&b|\
    \ a.contains(&b)).count().min(&a.len() as i32).map(|c| a.replace(c, \"\"))\n \
    \    |                                       -------- ^^\n     |             \
    \                          |        |\n     |                                \
    \       |        expected an `Fn<(char,)>` closure, found `String`\n     |   \
    \                                    |        help: consider dereferencing here:\
    \ `&*b`\n     |                                       required by a bound introduced\
    \ by this call\n     |\n     = help: the trait `Fn<(char,)>` is not implemented\
    \ for `String`\n     = note: required because of the requirements on the impl\
    \ of `FnOnce<(char,)>` for `&String`\n     = note: required because of the requirements\
    \ on the impl of `Pattern<'_>` for `&&String`\nnote: required by a bound in `core::str::<impl\
    \ str>::contains`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpz48rn0mr.rs:20:65\n\
    \   |\n20 |             lst2.iter().filter(|&b| a.contains(&b)).count().min(&a.len()\
    \ as i32).map(|c| a.replace(c, \"\"))\n   |                                  \
    \                               ^^^^^^^^^^^^^^^ expected `usize`, found `i32`\n\
    \   |\nhelp: you can convert an `i32` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |             lst2.iter().filter(|&b| a.contains(&b)).count().min((&a.len()\
    \ as i32).try_into().unwrap()).map(|c| a.replace(c, \"\"))\n   |             \
    \                                                    +               +++++++++++++++++++++\n\
    \nerror[E0599]: `usize` is not an iterator\n  --> /tmp/tmpz48rn0mr.rs:20:82\n\
    \   |\n20 |             lst2.iter().filter(|&b| a.contains(&b)).count().min(&a.len()\
    \ as i32).map(|c| a.replace(c, \"\"))\n   |                                  \
    \                                                ^^^ `usize` is not an iterator\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `usize:\
    \ Iterator`\n           which is required by `&mut usize: Iterator`\n\nerror[E"
  stdout: ''
  timestamp: 1659976547
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut total_chars = String::new();\n    for &s in &lst1 {\n        total_chars.push_str(&s.chars().count());\n\
    \    }\n    for &s in &lst2 {\n        total_chars.push_str(&s.chars().count());\n\
    \    }\n    if total_chars == String::new() {\n        lst1\n    } else {\n  \
    \      if lst1.len() > lst2.len() {\n            lst1\n        } else {\n    \
    \        lst2\n        }\n    }\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw2cexhrk.rs:18:30\n   |\n\
    18 |         total_chars.push_str(&s.chars().count());\n   |                 \
    \             ^^^^^^^^^^^^^^^^^^ expected `str`, found `usize`\n   |\n   = note:\
    \ expected reference `&str`\n              found reference `&usize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpw2cexhrk.rs:21:30\n   |\n21 |         total_chars.push_str(&s.chars().count());\n\
    \   |                              ^^^^^^^^^^^^^^^^^^ expected `str`, found `usize`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&usize`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976547
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    lst1.iter().zip(lst2.iter()).filter(|&(x1, x2)| x1.len() < x2.len()).map(|&(x1,\
    \ x2)| x1).collect()\n}\n\nfn main() {\n    let candidate = total_match;\n   \
    \ assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpazjnd1rs.rs:16:79\n   |\n\
    16 |     lst1.iter().zip(lst2.iter()).filter(|&(x1, x2)| x1.len() < x2.len()).map(|&(x1,\
    \ x2)| x1).collect()\n   |                                                   \
    \                            ^^^^^^^^-\n   |                                 \
    \                                              |       |\n   |               \
    \                                                                |       expected\
    \ due to this\n   |                                                          \
    \                     expected tuple, found reference\n   |\n   = note:  expected\
    \ tuple `(&String, &String)`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976547
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    lst1.iter()\n        .map(|s| s.chars().count())\n        .take_while(|n|\
    \ n <= lst2.iter().map(|s| s.chars().count()).sum())\n        .collect()\n}\n\n\
    fn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `&usize: Sum<usize>` is not satisfied\n \
    \   --> /tmp/tmpebg62cp8.rs:18:69\n     |\n18   |         .take_while(|n| n <=\
    \ lst2.iter().map(|s| s.chars().count()).sum())\n     |                      \
    \                                               ^^^ the trait `Sum<usize>` is\
    \ not implemented for `&usize`\n     |\n     = help: the following other types\
    \ implement trait `Sum<A>`:\n               <f32 as Sum<&'a f32>>\n          \
    \     <f32 as Sum>\n               <f64 as Sum<&'a f64>>\n               <f64\
    \ as Sum>\n               <i128 as Sum<&'a i128>>\n               <i128 as Sum>\n\
    \               <i16 as Sum<&'a i16>>\n               <i16 as Sum>\n         \
    \    and 20 others\nnote: required by a bound in `std::iter::Iterator::sum`\n\n\
    error[E0277]: a value of type `Vec<String>` cannot be built from an iterator over\
    \ elements of type `usize`\n    --> /tmp/tmpebg62cp8.rs:19:10\n     |\n19   |\
    \         .collect()\n     |          ^^^^^^^ value of type `Vec<String>` cannot\
    \ be built from `std::iter::Iterator<Item=usize>`\n     |\n     = help: the trait\
    \ `FromIterator<usize>` is not implemented for `Vec<String>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976547
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut res: Vec<String> = Vec::new();\n    for el1 in lst1 {\n        let\
    \ mut found = false;\n        for el2 in lst2 {\n            if el1 == el2 {\n\
    \                found = true;\n            }\n        }\n        if found {\n\
    \            el1.push_str(\"1\");\n        } else {\n            el1.push_str(\"\
    0\");\n            res.push(el1);\n        }\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmpa46kg3s_.rs:19:20\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n19  |  \
    \       for el2 in lst2 {\n    |                    ^^^^ `lst2` moved due to this\
    \ implicit call to `.into_iter()`, in previous iteration of loop\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `lst2`\nhelp:\
    \ consider iterating over a slice of the `Vec<String>`'s content to avoid moving\
    \ into the `for` loop\n    |\n19  |         for el2 in &lst2 {\n    |        \
    \            +\n\nerror[E0596]: cannot borrow `el1` as mutable, as it is not declared\
    \ as mutable\n  --> /tmp/tmpa46kg3s_.rs:25:13\n   |\n17 |     for el1 in lst1\
    \ {\n   |         --- help: consider changing this to be mutable: `mut el1`\n\
    ...\n25 |             el1.push_str(\"1\");\n   |             ^^^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror[E0596]: cannot borrow `el1` as mutable, as\
    \ it is not declared as mutable\n  --> /tmp/tmpa46kg3s_.rs:27:13\n   |\n17 | \
    \    for el1 in lst1 {\n   |         --- help: consider changing this to be mutable:\
    \ `mut el1`\n...\n27 |             el1.push_str(\"0\");\n   |             ^^^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0382, E0596.\nFor more information about\
    \ an error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976547
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    lst1.iter().zip(lst2.iter()).fold(\n        (&[]) as Vec<String>,\n     \
    \   |(acc, (elem1, elem2))| {\n            if elem1 < elem2 {\n              \
    \  acc.push(elem1);\n            } else {\n                acc.push(elem2);\n\
    \            }\n            acc\n        },\n    )\n}\n\nfn main() {\n    let\
    \ candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0593]: closure is expected to take 2 distinct arguments, but it\
    \ takes a single 2-tuple as argument\n  --> /tmp/tmpio0m2vl5.rs:16:34\n   |\n\
    16 |     lst1.iter().zip(lst2.iter()).fold(\n   |                            \
    \      ^^^^ expected closure that takes 2 distinct arguments\n17 |         (&[])\
    \ as Vec<String>,\n18 |         |(acc, (elem1, elem2))| {\n   |         -----------------------\
    \ takes a single 2-tuple as argument\n   |\nhelp: change the closure to take multiple\
    \ arguments instead of a single tuple\n   |\n18 |         |acc, (elem1, elem2)|\
    \ {\n   |         ~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0593`.\n"
  stdout: ''
  timestamp: 1659976547
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut res = vec![];\n    for (l, r) in lst1.iter().zip(lst2.iter()) {\n\
    \        if l.len() < r.len() {\n            res.extend(l);\n        } else {\n\
    \            res.append(r);\n        }\n    }\n    res\n}\n\nfn main() {\n   \
    \ let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpyr7tvp41.rs:19:24\n\
    \    |\n19  |             res.extend(l);\n    |                 ------ ^ `&String`\
    \ is not an iterator\n    |                 |\n    |                 required\
    \ by a bound introduced by this call\n    |\n    = help: the trait `Iterator`\
    \ is not implemented for `&String`\n    = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `&String`\nnote: required by a bound in `extend`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpyr7tvp41.rs:21:24\n   |\n21 |\
    \             res.append(r);\n   |                        ^ types differ in mutability\n\
    \   |\n   = note: expected mutable reference `&mut Vec<_>`\n                 \
    \     found reference `&String`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976547
- exit_code: 101
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    for i in\
    \ 0..lst1.len() {\n        let first_string_len = lst1[i].chars().count();\n \
    \       let second_string_len = lst2[i].chars().count();\n        if first_string_len\
    \ < second_string_len {\n            return lst1;\n        }\n    }\n    return\
    \ lst2;\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"hi\", \"admin\"]`,\n right: `[\"hi\", \"hi\"]`', /tmp/tmpawdliqoc.rs:32:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == 0 || lst2.len() == 0 {\n        return vec![];\n    }\n\
    \    let mut result = lst1.clone();\n    let mut char_count = lst1\n        .iter()\n\
    \        .map(|x| x.chars().count())\n        .sum();\n    let mut j = 0;\n  \
    \  for v in lst2 {\n        if char_count  > v.chars().count() {\n           \
    \ j = i;\n            break;\n        }\n        char_count -= v.chars().count();\n\
    \        i += 1;\n    }\n    result[j..].into_iter().collect()\n}\n\nfn main()\
    \ {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmp8sfhbgtx.rs:27:17\n\
    \   |\n27 |             j = i;\n   |                 ^ help: a local variable\
    \ with a similar name exists: `j`\n\nerror[E0425]: cannot find value `i` in this\
    \ scope\n  --> /tmp/tmp8sfhbgtx.rs:31:9\n   |\n31 |         i += 1;\n   |    \
    \     ^ help: a local variable with a similar name exists: `j`\n\nerror[E0277]:\
    \ a value of type `Vec<String>` cannot be built from an iterator over elements\
    \ of type `&String`\n    --> /tmp/tmp8sfhbgtx.rs:33:29\n     |\n33   |     result[j..].into_iter().collect()\n\
    \     |                             ^^^^^^^ value of type `Vec<String>` cannot\
    \ be built from `std::iter::Iterator<Item=&String>`\n     |\n     = help: the\
    \ trait `FromIterator<&String>` is not implemented for `Vec<String>`\n     = help:\
    \ the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a\
    \ bound in `collect`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0425.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976547
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    use std::cmp::Ordering;\n    if lst1.len() == lst2.len() {\n        return\
    \ lst1;\n    }\n    let mut m = vec![String::from('0'); lst2.len()];\n    for\
    \ i in 0..lst1.len() {\n        let mut pos = vec![String::from('0'); lst2.len()];\n\
    \        for j in 0..lst2.len() {\n            if lst1[i].contains(&lst2[j]) {\n\
    \                pos[j] = pos\n                    .iter()\n                 \
    \   .find(|&x| x.to_ascii_lowercase() < lst2[j].to_ascii_lowercase())\n      \
    \              .unwrap_or(&String::from('0'));\n            } else {\n       \
    \         pos[j] = &String::from('0');\n            }\n        }\n        for\
    \ i in 0..lst2.len() {\n            m[i] += pos[i].to_ascii_lowercase();\n   \
    \     }\n    }\n    let mut m = vec![String::from('0'); lst2.len()];\n    for\
    \ i in 0..lst2.len() {\n        m[i] += &String::from('0');\n    }\n    for i\
    \ in 0..lst1.len() {\n        m[m.len()].to_ascii_lowercase()\n            .find(|&x|\
    \ lst1[i].contains(&x))\n            .unwrap_or(&String::from('0'))\n        \
    \    [i..]\n            .join()\n    }\n    m\n}\n\nfn main() {\n    let candidate\
    \ = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "warning: unused import: `std::cmp::Ordering`\n  --> /tmp/tmpde3z22ux.rs:16:9\n\
    \   |\n16 |     use std::cmp::Ordering;\n   |         ^^^^^^^^^^^^^^^^^^\n   |\n\
    \   = note: `#[warn(unused_imports)]` on by default\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpde3z22ux.rs:25:26\n   |\n25 |                   pos[j]\
    \ = pos\n   |  _________________------___^\n   | |                 |\n   | | \
    \                expected due to the type of this binding\n26 | |            \
    \         .iter()\n27 | |                     .find(|&x| x.to_ascii_lowercase()\
    \ < lst2[j].to_ascii_lowercase())\n28 | |                     .unwrap_or(&String::from('0'));\n\
    \   | |                                                  ^- help: try using a\
    \ conversion method: `.to_string()`\n   | |__________________________________________________|\n\
    \   |                                                    expected struct `String`,\
    \ found `&String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpde3z22ux.rs:30:26\n\
    \   |\n30 |                 pos[j] = &String::from('0');\n   |               \
    \  ------   ^^^^^^^^^^^^^^^^^^ expected struct `String`, found `&String`\n   |\
    \                 |\n   |                 expected due to the type of this binding\n\
    \   |\nhelp: consider removing the borrow\n   |\n30 -                 pos[j] =\
    \ &String::from('0');\n30 +                 pos[j] = String::from('0');\n   |\
    \ \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpde3z22ux.rs:34:21\n   |\n\
    34 |             m[i] += pos[i].to_ascii_lowercase();\n   |                  \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |                     |\n   |            \
    \         expected `&str`, found struct `String`\n   |                     help:\
    \ consider borrowing here: `&pos[i].to_ascii_lowercase()`\n\nerror[E0631]: type\
    \ mismatch in closure arguments\n    --> /tmp/tmpde3z22ux.rs:43:14\n     |\n43\
    \   |             .find(|&x| lst1[i].contains(&x))\n     |              ^^^^ -------------------------\
    \ found signature of `fn(&_) -> _`\n     |              |\n     |            \
    \  expected signature of `fn(char) -> _`\n     |\n     = note: required because\
    \ of the requirements o"
  stdout: ''
  timestamp: 1659976547
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == 0 || lst2.len() == 0 {\n        return vec![];\n    }\n\
    \    if lst1.len() == lst2.len() {\n        let mut result = vec![];\n       \
    \ for (i, val) in lst1.iter().enumerate() {\n            if val.len() < lst2.nth(i).len()\
    \ {\n                result.push(val);\n            }\n        }\n        return\
    \ result;\n    }\n    match lst1.binary_search(&lst2.last().unwrap()) {\n    \
    \    Ok(i) => vec![lst1.get(i).clone(), lst2.last().unwrap().clone()],\n     \
    \   Err(i) => vec![lst1.get(i).clone(), lst2.last().unwrap().clone()]\n    }\n\
    }\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `nth` found for struct `Vec<String>` in the\
    \ current scope\n  --> /tmp/tmpfjmbr612.rs:22:33\n   |\n22 |             if val.len()\
    \ < lst2.nth(i).len() {\n   |                                 ^^^ method not found\
    \ in `Vec<String>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfjmbr612.rs:26:16\n\
    \   |\n15 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |                                                         -----------\
    \ expected `Vec<String>` because of return type\n...\n26 |         return result;\n\
    \   |                ^^^^^^ expected struct `String`, found `&String`\n   |\n\
    \   = note: expected struct `Vec<String>`\n              found struct `Vec<&String>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpfjmbr612.rs:29:23\n   |\n29 |\
    \         Ok(i) => vec![lst1.get(i).clone(), lst2.last().unwrap().clone()],\n\
    \   |                       ^^^^^^^^^^^^^^^^^^^ expected struct `String`, found\
    \ enum `Option`\n   |\n   = note: expected struct `String`\n                found\
    \ enum `Option<&String>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfjmbr612.rs:30:24\n\
    \   |\n30 |         Err(i) => vec![lst1.get(i).clone(), lst2.last().unwrap().clone()]\n\
    \   |                        ^^^^^^^^^^^^^^^^^^^ expected struct `String`, found\
    \ enum `Option`\n   |\n   = note: expected struct `String`\n                found\
    \ enum `Option<&String>`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976547
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_length\
    \ = 0;\n    for el in lst1 {\n        total_length += el.length();\n    }\n  \
    \  for el in lst2 {\n        total_length += el.length();\n    }\n    if total_length\
    \ < lst1.len() {\n        return lst1;\n    }\n    lst1\n}\n\nfn main() {\n  \
    \  let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpbvaafo_r.rs:21:28\n   |\n21 |         total_length\
    \ += el.length();\n   |                            ^^^^^^ help: there is an associated\
    \ function with a similar name: `len`\n\nerror[E0599]: no method named `length`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpbvaafo_r.rs:24:28\n\
    \   |\n24 |         total_length += el.length();\n   |                       \
    \     ^^^^^^ help: there is an associated function with a similar name: `len`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976547
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1\n    }\n    if lst1.len()\
    \ > lst2.len() {\n        lst1.reverse();\n    }\n    if lst2.len() > lst1.len()\
    \ {\n        lst2.reverse();\n    }\n    if lst1.len() == lst2.len() {\n     \
    \   return vec![lst1[0], lst1[1]];\n    }\n    \n    let mut vec1 = vec![String::new();\
    \ lst1.len()];\n    let mut vec2 = vec![String::new(); lst2.len()];\n    \n  \
    \  for i in 0..lst1.len() {\n        vec1[i] = lst1[i];\n    }\n    for i in 0..lst2.len()\
    \ {\n        vec2[i] = lst2[i];\n    }\n    for i in 0..vec1.len() {\n       \
    \ if vec1[i].len() < vec2[i].len() {\n            vec1.swap(i, i + 1);\n     \
    \   }\n        if vec2[i].len() < vec1[i].len() {\n            vec2.swap(i, i\
    \ + 1);\n        }\n        if vec1[i].len() == vec2[i].len() {\n            vec1.swap(i,\
    \ i + 1);\n        }\n    }\n    for i in 0..vec1.len() {\n        if vec1[i].len()\
    \ > vec2[i].len() {\n            vec1.swap(i, i + 1);\n        }\n        if vec2[i].len()\
    \ > vec1[i].len() {\n            vec2.swap(i, i + 1);\n        }\n        if vec1[i].len()\
    \ == vec2[i].len() {\n            vec1.swap(i, i + 1);\n        }\n    }\n   \
    \ for i in 0..vec1.len() {\n        if vec1[i].len() > vec2[i].len() {\n     \
    \       vec1.swap(i, i + 1);\n        }\n        if vec2[i].len() > vec1[i].len()\
    \ {\n            vec2.swap(i, i + 1);\n        }\n        if vec1[i].len() ==\
    \ vec2[i].len() {\n            vec1.swap(i, i + 1);\n        }\n    }\n    for\
    \ i in 0..vec1.len() {\n        if vec1[i].len() > vec2[i].len() {\n         \
    \   vec1.swap(i, i + 1);\n        }\n        if vec2[i].len() > vec1[i].len()\
    \ {\n            vec2.swap(i, i + 1);\n        }\n        if vec1[i].len() ==\
    \ vec2[i].len() {\n            vec1.swap(i, i + 1);\n        }\n    }\n    for\
    \ i in 0..vec1.len() {\n        if vec1[i].len() < vec2[i].len() {\n         \
    \   vec1.swap(i, i + 1);\n        }\n        if vec2[i].len() < vec1[i].len()\
    \ {\n            vec2.swap(i, i + 1);\n        }\n        if vec1[i].len() ==\
    \ vec2[i].\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp_unya3nv.rs:103:3\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                                                   \
    \  - unclosed delimiter\n...\n82  |     for i in 0..vec1.len() {\n    |      \
    \                      - this delimiter might not be properly closed...\n...\n\
    90  | }\n    | - ...as it matches this but it has different indentation\n...\n\
    103 | }\n    |   ^\n\nerror: unexpected token: `}`\n  --> /tmp/tmp_unya3nv.rs:90:1\n\
    \   |\n90 | }\n   | ^\n\nerror: expected `{`, found `}`\n  --> /tmp/tmp_unya3nv.rs:90:1\n\
    \   |\n89 |         if vec1[i].len() == vec2[i].\n   |         -- this `if` expression\
    \ has a condition, but no block\n90 | }\n   | ^ expected `{`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_unya3nv.rs:15:57\n   |\n15 | fn total_match(lst1:\
    \ Vec<String>, lst2: Vec<String>) -> Vec<String> {\n   |    -----------      \
    \                                    ^^^^^^^^^^^ expected struct `Vec`, found\
    \ `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or\
    \ `return` expression\n   |\n   = note: expected struct `Vec<String>`\n      \
    \     found unit type `()`\n\nerror: aborting due to 4 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976547
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n\n    let mut\
    \ match_vec: Vec<String> = Vec::new();\n    let mut length = 1;\n    for elem\
    \ in &lst2 {\n        if elem == &lst1[0] {\n            length += 1;\n      \
    \  } else {\n            if length >= lst1.len() {\n                break;\n \
    \           }\n            match_vec.push(elem);\n            length += 1;\n \
    \       }\n    }\n\n    match_vec\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpg6pcaqwo.rs:29:28\n   |\n\
    29 |             match_vec.push(elem);\n   |                            ^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \          |\n   |                            expected struct `String`, found\
    \ `&String`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976547
- exit_code: 101
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    // TODO: Implement me\n    lst1\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"hi\", \"admin\"]`,\n right: `[\"hi\", \"hi\"]`', /tmp/tmplkk2g0k2.rs:23:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 101
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        lst1\n    } else {\n        if lst1.len()\
    \ < lst2.len() {\n            lst2\n        } else {\n            lst1\n     \
    \   }\n    }\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"hi\", \"admin\"]`,\n right: `[\"hi\", \"hi\"]`', /tmp/tmpzh9ods5z.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 101
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    for i in\
    \ 0..lst1.len() {\n        if lst1[i] < lst2[i] {\n            return lst1;\n\
    \        }\n    }\n    return lst2;\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"hi\", \"admin\"]`,\n right: `[\"hi\", \"hi\"]`', /tmp/tmpspjy2am1.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut total_length = 0;\n    for &item in lst1 {\n        total_length\
    \ += item.len();\n    }\n    for &item in lst2 {\n        total_length += item.len();\n\
    \    }\n    if total_length == 0 {\n        return lst1;\n    }\n    if total_length\
    \ == lst1.len() {\n        return lst1;\n    }\n    if total_length == lst2.len()\
    \ {\n        return lst2;\n    }\n    lst1.iter().zip(lst2.iter()).filter(|&(a,\
    \ b)| *a < *b).collect()\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw5qtok9b.rs:17:9\n   |\n\
    17 |     for &item in lst1 {\n   |         ^^^^^    ---- this expression has type\
    \ `Option<String>`\n   |         |\n   |         expected struct `String`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `item`\n\
    \   |\n   = note: expected struct `String`\n           found reference `&_`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpw5qtok9b.rs:20:9\n   |\n20 |   \
    \  for &item in lst2 {\n   |         ^^^^^    ---- this expression has type `Option<String>`\n\
    \   |         |\n   |         expected struct `String`, found reference\n   |\
    \         help: you can probably remove the explicit borrow: `item`\n   |\n  \
    \ = note: expected struct `String`\n           found reference `&_`\n\nerror[E0277]:\
    \ a value of type `Vec<String>` cannot be built from an iterator over elements\
    \ of type `(&String, &String)`\n    --> /tmp/tmpw5qtok9b.rs:32:60\n     |\n32\
    \   |     lst1.iter().zip(lst2.iter()).filter(|&(a, b)| *a < *b).collect()\n \
    \    |                                                            ^^^^^^^ value\
    \ of type `Vec<String>` cannot be built from `std::iter::Iterator<Item=(&String,\
    \ &String)>`\n     |\n     = help: the trait `FromIterator<(&String, &String)>`\
    \ is not implemented for `Vec<String>`\n     = help: the trait `FromIterator<T>`\
    \ is implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976547
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut result:\
    \ Vec<String> = vec![String::from(\"\")];\n    for v in lst1 {\n        if lst2.iter().all(|s|\
    \ v == s) {\n            result.push(v);\n        }\n    }\n    result.sort();\n\
    \    result\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `String` with `&String`\n  --> /tmp/tmp5e_05pyg.rs:21:34\n\
    \   |\n21 |         if lst2.iter().all(|s| v == s) {\n   |                   \
    \               ^^ no implementation for `String == &String`\n   |\n   = help:\
    \ the trait `PartialEq<&String>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `PartialEq<Rhs>`:\n             <&'a str\
    \ as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n     \
    \        <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976547
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1\n    }\n    if lst1.len()\
    \ > lst2.len() {\n        lst1.reverse();\n        lst2.reverse();\n    }\n  \
    \  for &el in lst1 { \n        for &el2 in lst2 {\n            if el > el2 {\n\
    \                break;\n            }\n        }\n    }\n    lst1\n}\n\nfn main()\
    \ {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpum7qgl9g.rs:23:9\n   |\n\
    23 |     for &el in lst1 { \n   |         ^^^    ---- this expression has type\
    \ `Option<String>`\n   |         |\n   |         expected struct `String`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `el`\n\
    \   |\n   = note: expected struct `String`\n           found reference `&_`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpum7qgl9g.rs:24:13\n   |\n24 |  \
    \       for &el2 in lst2 {\n   |             ^^^^    ---- this expression has\
    \ type `Option<String>`\n   |             |\n   |             expected struct\
    \ `String`, found reference\n   |             help: you can probably remove the\
    \ explicit borrow: `el2`\n   |\n   = note: expected struct `String`\n        \
    \   found reference `&_`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976547
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut len = vec![0; lst1.len()];\n    for l in 0..lst1.len() {\n      \
    \  len[l] += lst1[l].len();\n    }\n    for l in 0..lst2.len() {\n        len[l]\
    \ += lst2[l].len();\n    }\n    for i in 0..len.iter().filter(|&x| *x < len.iter().max()).len()\
    \ {\n        lst1.push(nl!(&lst1[i]));\n    }\n    lst1\n}\n\nfn main() {\n  \
    \  let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error: cannot find macro `nl` in this scope\n  --> /tmp/tmptj05euza.rs:24:19\n\
    \   |\n24 |         lst1.push(nl!(&lst1[i]));\n   |                   ^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmptj05euza.rs:23:45\n   |\n23 |     for i in 0..len.iter().filter(|&x|\
    \ *x < len.iter().max()).len() {\n   |                                       \
    \      ^^^^^^^^^^^^^^^^ expected `usize`, found enum `Option`\n   |\n   = note:\
    \ expected type `usize`\n              found enum `Option<&usize>`\n\nerror[E0599]:\
    \ no method named `len` found for struct `Filter` in the current scope\n  -->\
    \ /tmp/tmptj05euza.rs:23:63\n   |\n23 |     for i in 0..len.iter().filter(|&x|\
    \ *x < len.iter().max()).len() {\n   |                                       \
    \                        ^^^ method not found in `Filter<std::slice::Iter<'_,\
    \ usize>, [closure@/tmp/tmptj05euza.rs:23:35: 23:61]>`\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976547
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut vec = Vec::<String>::new();\n    vec.push(String::from(\"\"));\n\
    \    let mut cnt = 0;\n    for s in lst1 {\n        let mut s = s.to_string();\n\
    \        s.push(' ');\n        for c in s.chars() {\n            vec.push(c);\n\
    \            cnt += 1;\n        }\n        vec.push(cnt);\n        vec.push(cnt);\n\
    \        cnt = 1;\n    }\n    for s in lst2 {\n        let mut s = s.to_string();\n\
    \        s.push(' ');\n        for c in s.chars() {\n            vec.push(c);\n\
    \            cnt += 1;\n        }\n        vec.push(cnt);\n        vec.push(cnt);\n\
    \        cnt = 1;\n    }\n    vec\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzeksps2a.rs:23:22\n   |\n\
    23 |             vec.push(c);\n   |                      ^- help: try using a\
    \ conversion method: `.to_string()`\n   |                      |\n   |       \
    \               expected struct `String`, found `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpzeksps2a.rs:26:18\n   |\n26 |         vec.push(cnt);\n\
    \   |                  ^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                  |\n   |                  expected struct `String`, found\
    \ integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzeksps2a.rs:27:18\n\
    \   |\n27 |         vec.push(cnt);\n   |                  ^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |                  |\n   |         \
    \         expected struct `String`, found integer\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpzeksps2a.rs:34:22\n   |\n34 |             vec.push(c);\n\
    \   |                      ^- help: try using a conversion method: `.to_string()`\n\
    \   |                      |\n   |                      expected struct `String`,\
    \ found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzeksps2a.rs:37:18\n\
    \   |\n37 |         vec.push(cnt);\n   |                  ^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |                  |\n   |         \
    \         expected struct `String`, found integer\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpzeksps2a.rs:38:18\n   |\n38 |         vec.push(cnt);\n\
    \   |                  ^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                  |\n   |                  expected struct `String`, found\
    \ integer\n\nerror: aborting due to 6 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976547
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    // if lists have different length, return empty vec\n    if lst1.len() !=\
    \ lst2.len() {\n        return vec![];\n    }\n    // if lists have same length,\
    \ return the first list\n    if lst1.len() == lst2.len() {\n        return vec![lst1.first()];\n\
    \    }\n\n    // iterate through both lists, calculate the total length for each\
    \ \n    // and create a map of total length to each of the lists, \n    // then\
    \ iterate through the map and keep the key value pairs whose value is less than\
    \ the other\n    let mut total_lengths = vec![String::new(); lst1.len()];\n  \
    \  let mut result_map = HashMap::new();\n    for (i, &elt) in lst1.iter().zip(lst2.iter())\
    \ {\n        total_lengths[i] = elt.len();\n        result_map.insert(elt.len(),\
    \ elt);\n    }\n\n    for (i, length) in total_lengths.iter().enumerate() {\n\
    \        if result_map.contains_key(&length) {\n            result_map.remove(&length);\n\
    \        }\n    }\n    result_map.iter().cloned().collect()\n}\n\nfn main() {\n\
    \    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpmi0kxgi_.rs:29:26\n   |\n29 |     let mut result_map = HashMap::new();\n\
    \   |                          ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpmi0kxgi_.rs:22:21\n   |\n22 |         return\
    \ vec![lst1.first()];\n   |                     ^^^^^^^^^^^^ expected struct `String`,\
    \ found enum `Option`\n   |\n   = note: expected struct `String`\n           \
    \     found enum `Option<&String>`\n\nerror[E0277]: the type `[String]` cannot\
    \ be indexed by `&String`\n  --> /tmp/tmpmi0kxgi_.rs:31:9\n   |\n31 |        \
    \ total_lengths[i] = elt.len();\n   |         ^^^^^^^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[String]>`\
    \ is not implemented for `&String`\n   = note: required because of the requirements\
    \ on the impl of `Index<&String>` for `Vec<String>`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0433.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976547
- exit_code: 101
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    // Calculate the total char length of both strings\n    let char_length_total:\
    \ usize = lst1.iter().map(|x| x.len()).sum();\n    let char_length_other: usize\
    \ = lst2.iter().map(|x| x.len()).sum();\n\n    // If the two vectors have the\
    \ same number of chars, return the first.\n    if char_length_total == char_length_other\
    \ {\n        return lst1;\n    }\n\n    let mut matched = vec![\"\".to_string();\
    \ char_length_total];\n\n    for i in 0..char_length_total {\n        if lst1[i]\
    \ == \"\" {\n            continue;\n        }\n\n        for j in 0..char_length_other\
    \ {\n            if lst2[j] == \"\" {\n                continue;\n           \
    \ }\n\n            if i != j && &lst1[i] == &lst2[j] {\n                matched[i]\
    \ += &lst1[i];\n                break;\n            }\n        }\n    }\n\n  \
    \  matched\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 2 but the
    index is 2'', /tmp/tmppkecb6hq.rs:33:16

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut count = 0;\n    lst1.iter().filter_map(|s| {\n        count += s.chars().filter(|c|\
    \ *c >= '0').count() + s.chars().filter(|c| *c >= 'a').count() + s.chars().filter(|c|\
    \ *c >= 'A').count();\n        Ok(s)\n    }).filter(|s| {\n        count >= lst2.len()\
    \ && count <= lst2.len()\n    }).cloned().collect()\n}\n\nfn main() {\n    let\
    \ candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_0kqqyxk.rs:19:9\n   |\n\
    19 |         Ok(s)\n   |         ^^^^^ expected enum `Option`, found enum `Result`\n\
    \   |\n   = note: expected enum `Option<_>`\n              found enum `Result<&String,\
    \ _>`\nhelp: try wrapping the expression in `Some`\n   |\n19 |         Some(Ok(s))\n\
    \   |         +++++     +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976547
- exit_code: 101
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    \n    let\
    \ mut i = 0;\n    let mut j = 0;\n    loop {\n        if lst1[i] == \"\" {\n \
    \           i += 1;\n            if i == lst1.len() {\n                break;\n\
    \            }\n        } else {\n            if lst1[j] != \"\" {\n         \
    \       break;\n            }\n            i += 1;\n        }\n        j += 1;\n\
    \        if j == lst2.len() {\n            break;\n        }\n    }\n    return\
    \ lst1;\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"hi\", \"admin\"]`,\n right: `[\"hi\", \"hi\"]`', /tmp/tmpzb5l29gg.rs:45:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut total_length = 0;\n    let mut matched_strings = Vec::new();\n  \
    \  for element in lst1.iter().chain(lst2.iter()) {\n        if element.len() >\
    \ total_length {\n            total_length = element.len();\n            matched_strings.push(element);\n\
    \        }\n    }\n    if total_length == 0 {\n        vec![]\n    } else {\n\
    \        matched_strings\n    }\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5v9qo9as.rs:27:9\n   |\n\
    15 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n \
    \  |                                                         ----------- expected\
    \ `Vec<String>` because of return type\n...\n27 |         matched_strings\n  \
    \ |         ^^^^^^^^^^^^^^^ expected struct `String`, found `&String`\n   |\n\
    \   = note: expected struct `Vec<String>`\n              found struct `Vec<&String>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976547
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    vec![lst1[0]] if lst1.len() == lst2.len();\n    lst1.iter().zip(lst2.iter()).filter(|(a,\
    \ b)| {\n        a.len() < b.len()\n    }).map(|(a, b)| a).collect()\n}\n\nfn\
    \ main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found keyword\
    \ `if`\n  --> /tmp/tmp8czl8mqc.rs:16:19\n   |\n16 |     vec![lst1[0]] if lst1.len()\
    \ == lst2.len();\n   |                   ^^ expected one of `.`, `;`, `?`, `}`,\
    \ or an operator\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659976547
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut counter\
    \ = 0;\n    let mut max = 0;\n    let mut res = vec![];\n    for x in lst1 {\n\
    \        for y in lst2 {\n            if x.chars().count() <= y.chars().count()\
    \ {\n                counter += x.chars().count();\n                max = counter;\n\
    \                res.push(x);\n                break;\n            }\n       \
    \ }\n    }\n    if max == 0 {\n        return res;\n    }\n    for x in lst1 {\n\
    \        for y in lst2 {\n            if x.chars().count() == y.chars().count()\
    \ {\n                counter += x.chars().count();\n                max = counter;\n\
    \                res.push(x);\n                break;\n            }\n       \
    \ }\n    }\n    if max == 0 {\n        return res;\n    }\n    for x in lst1 {\n\
    \        for y in lst2 {\n            if x.chars().count() < y.chars().count()\
    \ {\n                counter += x.chars().count();\n                max = counter;\n\
    \                res.push(x);\n                break;\n            }\n       \
    \ }\n    }\n    if max == 0 {\n        return res;\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmp1b6gw24a.rs:23:18\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n23  |  \
    \       for y in lst2 {\n    |                  ^^^^ `lst2` moved due to this\
    \ implicit call to `.into_iter()`, in previous iteration of loop\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `lst2`\nhelp:\
    \ consider iterating over a slice of the `Vec<String>`'s content to avoid moving\
    \ into the `for` loop\n    |\n23  |         for y in &lst2 {\n    |          \
    \        +\n\nerror[E0382]: use of moved value: `lst1`\n  --> /tmp/tmp1b6gw24a.rs:35:14\n\
    \   |\n15 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |                ---- move occurs because `lst1` has type `Vec<String>`,\
    \ which does not implement the `Copy` trait\n...\n22 |     for x in lst1 {\n \
    \  |              ---- `lst1` moved due to this implicit call to `.into_iter()`\n\
    ...\n35 |     for x in lst1 {\n   |              ^^^^ value used here after move\n\
    \   |\nhelp: consider iterating over a slice of the `Vec<String>`'s content to\
    \ avoid moving into the `for` loop\n   |\n22 |     for x in &lst1 {\n   |    \
    \          +\n\nerror[E0382]: use of moved value: `lst2`\n  --> /tmp/tmp1b6gw24a.rs:36:18\n\
    \   |\n15 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n23 |   \
    \      for y in lst2 {\n   |                  ---- `lst2` moved due to this implicit\
    \ call to `.into_iter()`, in previous iteration of loop\n...\n36 |         for\
    \ y in lst2 {\n   |                  ^^^^ `lst2` moved due to this implicit call\
    \ to `.into_iter()`, in previous iteration of loop\n   |\nhelp: consider iterating\
    \ over a slice of the `Vec<String>`'s content to avoid moving into the `for` loop\n\
    \   |\n23 |         for y in &lst2 {"
  stdout: ''
  timestamp: 1659976547
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    use std::cmp::Ordering;\n    let lst1 = lst1.into_iter().cloned();\n    let\
    \ lst2 = lst2.into_iter().cloned();\n    if lst1.len() == lst2.len() {\n     \
    \   return lst1;\n    }\n    let mut result = vec![\"\".into(), \"\".into()];\n\
    \    for s in lst1.zip(lst2) {\n        if s.1 < s.2 {\n            result.0 =\
    \ (result.0.clone() + s.1.to_string()).into();\n            result.1 = (result.1.clone()\
    \ + s.2.to_string()).into();\n        } else {\n            result.0 = (result.0.clone()\
    \ + s.2.to_string()).into();\n            result.1 = (result.1.clone() + s.1.to_string()).into();\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "warning: unused import: `std::cmp::Ordering`\n  --> /tmp/tmp1fadkj8f.rs:16:9\n\
    \   |\n16 |     use std::cmp::Ordering;\n   |         ^^^^^^^^^^^^^^^^^^\n   |\n\
    \   = note: `#[warn(unused_imports)]` on by default\n\nerror[E0271]: type mismatch\
    \ resolving `<std::vec::IntoIter<String> as Iterator>::Item == &_`\n    --> /tmp/tmp1fadkj8f.rs:17:33\n\
    \     |\n17   |     let lst1 = lst1.into_iter().cloned();\n     |            \
    \                     ^^^^^^ expected reference, found struct `String`\n     |\n\
    \     = note: expected reference `&_`\n                   found struct `String`\n\
    note: required by a bound in `cloned`\n\nerror[E0271]: type mismatch resolving\
    \ `<std::vec::IntoIter<String> as Iterator>::Item == &_`\n    --> /tmp/tmp1fadkj8f.rs:18:33\n\
    \     |\n18   |     let lst2 = lst2.into_iter().cloned();\n     |            \
    \                     ^^^^^^ expected reference, found struct `String`\n     |\n\
    \     = note: expected reference `&_`\n                   found struct `String`\n\
    note: required by a bound in `cloned`\n\nerror[E0599]: the method `len` exists\
    \ for struct `Cloned<std::vec::IntoIter<String>>`, but its trait bounds were not\
    \ satisfied\n  --> /tmp/tmp1fadkj8f.rs:19:13\n   |\n19 |       if lst1.len() ==\
    \ lst2.len() {\n   |               ^^^ method cannot be called on `Cloned<std::vec::IntoIter<String>>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `<std::vec::IntoIter<String> as Iterator>::Item\
    \ = &_`\n           which is required by `Cloned<std::vec::IntoIter<String>>:\
    \ ExactSizeIterator`\n\nerror[E0599]: the method `len` exists for struct `Cloned<std::vec::IntoIter<String>>`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmp1fadkj8f.rs:19:27\n \
    \  |\n19 |       if lst1.len() == lst2.len() {\n   |                         \
    \    ^^^ method cannot be called on `Cloned<std::vec::IntoIter<String>>` due to\
    \ unsatisfied trait bounds\n   |\n   = note: the following trait bounds were not\
    \ satisfied:\n           `<std::vec::IntoIter<String> as Iterator>::Item = &_`\n\
    \           which is required by `Cloned<std::vec"
  stdout: ''
  timestamp: 1659976547
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        lst1\n    } else {\n        lst1.iter().filter(|x|\
    \ lst2.iter().any(|y| x.chars().any(|z| z.cmp(y) == -1)).collect::<Vec<_>>()\n\
    \    }\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmp7dwwtc4o.rs:19:27\n\
    \   |\n18 |     } else {\n   |            - closing delimiter possibly meant for\
    \ this\n19 |         lst1.iter().filter(|x| lst2.iter().any(|y| x.chars().any(|z|\
    \ z.cmp(y) == -1)).collect::<Vec<_>>()\n   |                           ^ unclosed\
    \ delimiter\n20 |     }\n   |     ^ mismatched closing delimiter\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp7dwwtc4o.rs:19:76\n   |\n19 |         lst1.iter().filter(|x|\
    \ lst2.iter().any(|y| x.chars().any(|z| z.cmp(y) == -1)).collect::<Vec<_>>()\n\
    \   |                                                                        \
    \    ^ expected `char`, found struct `String`\n   |\n   = note: expected reference\
    \ `&char`\n              found reference `&String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp7dwwtc4o.rs:19:82\n   |\n19 |         lst1.iter().filter(|x|\
    \ lst2.iter().any(|y| x.chars().any(|z| z.cmp(y) == -1)).collect::<Vec<_>>()\n\
    \   |                                                                        \
    \          ^^ expected enum `std::cmp::Ordering`, found integer\n\nerror[E0599]:\
    \ `bool` is not an iterator\n  --> /tmp/tmp7dwwtc4o.rs:19:87\n   |\n19 |     \
    \    lst1.iter().filter(|x| lst2.iter().any(|y| x.chars().any(|z| z.cmp(y) ==\
    \ -1)).collect::<Vec<_>>()\n   |                                             \
    \                                          ^^^^^^^ `bool` is not an iterator\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `bool:\
    \ Iterator`\n           which is required by `&mut bool: Iterator`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp7dwwtc4o.rs:19:9\n   |\n15 |   fn total_match(lst1:\
    \ Vec<String>, lst2: Vec<String>) -> Vec<String> {\n   |                     \
    \                                      ----------- expected `Vec<String>` because\
    \ of return type\n...\n19 | /         lst1.iter().filter(|x| lst2.iter().any(|y|\
    \ x.chars().any(|z| z.cmp(y) == -1)).collect::<Vec<_>>()\n20 | |     }\n   | |_____^\
    \ expected struct `Vec`, found struct `Filter`\n   |\n   = note: expected struct\
    \ `Vec<String>`\n              fo"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    lst1\n        .iter()\n        .zip(lst2.iter())\n        .filter(|(a, b)|\
    \ {\n            match (a, b) {\n                (String::new(), _) => true,\n\
    \                (_, String::new()) => true,\n                _ => false,\n  \
    \          }\n        })\n        .map(|(a, b)| b.to_string().len() as u32 + a.to_string().len()\
    \ as u32)\n        .filter(|b| b > 0)\n        .collect()\n}\n\nfn main() {\n\
    \    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0164]: expected tuple struct or tuple variant, found associated\
    \ function `String::new`\n  --> /tmp/tmpqag2excv.rs:21:18\n   |\n21 |        \
    \         (String::new(), _) => true,\n   |                  ^^^^^^^^^^^^^ `fn`\
    \ calls are not allowed in patterns\n   |\n   = help: for more information, visit\
    \ https://doc.rust-lang.org/book/ch18-00-patterns.html\n\nerror[E0164]: expected\
    \ tuple struct or tuple variant, found associated function `String::new`\n  -->\
    \ /tmp/tmpqag2excv.rs:22:21\n   |\n22 |                 (_, String::new()) =>\
    \ true,\n   |                     ^^^^^^^^^^^^^ `fn` calls are not allowed in\
    \ patterns\n   |\n   = help: for more information, visit https://doc.rust-lang.org/book/ch18-00-patterns.html\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpqag2excv.rs:27:25\n   |\n27 |\
    \         .filter(|b| b > 0)\n   |                         ^\n   |           \
    \              |\n   |                         expected `&u32`, found integer\n\
    \   |                         help: consider borrowing here: `&0`\n\nerror[E0277]:\
    \ a value of type `Vec<String>` cannot be built from an iterator over elements\
    \ of type `u32`\n    --> /tmp/tmpqag2excv.rs:28:10\n     |\n28   |         .collect()\n\
    \     |          ^^^^^^^ value of type `Vec<String>` cannot be built from `std::iter::Iterator<Item=u32>`\n\
    \     |\n     = help: the trait `FromIterator<u32>` is not implemented for `Vec<String>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0164, E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0164`.\n"
  stdout: ''
  timestamp: 1659976547
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut i\
    \ = 0;\n    while i < lst1.len() && i < lst2.len() {\n        if lst1[i] == lst2[i]\
    \ {\n            i += 1;\n        } else {\n            break;\n        }\n  \
    \  }\n    lst1[i..]\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcsgm8gva.rs:27:5\n   |\n\
    15 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n \
    \  |                                                         ----------- expected\
    \ `Vec<String>` because of return type\n...\n27 |     lst1[i..]\n   |     ^^^^^^^^^-\
    \ help: try using a conversion method: `.to_vec()`\n   |     |\n   |     expected\
    \ struct `Vec`, found slice\n   |\n   = note: expected struct `Vec<String>`\n\
    \               found slice `[String]`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976547
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    lst1.len() if lst1.len() == 0 || lst2.len() == 0 || lst1.len() < lst2.len()\
    \ {\n        lst1\n    } else {\n        lst2.iter().fold(Vec::new(), |mut acc,\
    \ &str| {\n            acc.extend_from_slice(str.chars().filter(|c| c < acc.len()).count());\n\
    \            acc\n        })\n    }\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found keyword\
    \ `if`\n  --> /tmp/tmp5u6y71p1.rs:16:16\n   |\n16 |     lst1.len() if lst1.len()\
    \ == 0 || lst2.len() == 0 || lst1.len() < lst2.len() {\n   |                ^^\
    \ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: aborting due to\
    \ previous error\n\n"
  stdout: ''
  timestamp: 1659976547
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut ans\
    \ = Vec::new();\n    for &a in &lst1 {\n        for &b in &lst2 {\n          \
    \  if a > b {\n                ans.push(b);\n                break;\n        \
    \    }\n        }\n    }\n    return ans;\n}\n\nfn main() {\n    let candidate\
    \ = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0507]: cannot move out of a shared reference\n  --> /tmp/tmpv5uobigm.rs:20:15\n\
    \   |\n20 |     for &a in &lst1 {\n   |         --    ^^^^^\n   |         ||\n\
    \   |         |data moved here\n   |         |move occurs because `a` has type\
    \ `String`, which does not implement the `Copy` trait\n   |         help: consider\
    \ removing the `&`: `a`\n\nerror[E0507]: cannot move out of a shared reference\n\
    \  --> /tmp/tmpv5uobigm.rs:21:19\n   |\n21 |         for &b in &lst2 {\n   | \
    \            --    ^^^^^\n   |             ||\n   |             |data moved here\n\
    \   |             |move occurs because `b` has type `String`, which does not implement\
    \ the `Copy` trait\n   |             help: consider removing the `&`: `b`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0507`.\n"
  stdout: ''
  timestamp: 1659976547
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    // If lst1 and lst2 have the same number of chars\n    if lst1.len() == lst2.len()\
    \ {\n        let mut total_len = 0usize;\n        for i in 0..lst1.len() {\n \
    \           total_len += lst1[i].chars().filter(|c| *c < lst2[i]).count();\n \
    \       }\n        \n        if total_len == lst1.len() {\n            return\
    \ lst1;\n        }\n    }\n    \n    // If lst1 and lst2 don't have the same number\
    \ of chars\n    for i in 0..lst1.len() {\n        if total_match(&lst1[i..], &lst2[i..])\
    \ == lst1[i..] {\n            return lst1;\n        }\n    }\n\n    vec![String::from(\"\
    ERROR\")]\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplvtrz866.rs:20:58\n   |\n\
    20 |             total_len += lst1[i].chars().filter(|c| *c < lst2[i]).count();\n\
    \   |                                                          ^^^^^^^ expected\
    \ `char`, found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplvtrz866.rs:30:24\n\
    \   |\n30 |         if total_match(&lst1[i..], &lst2[i..]) == lst1[i..] {\n  \
    \ |                        ^^^^^^^^^^ expected struct `Vec`, found `&[String]`\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found reference `&[String]`\n\
    help: try using a conversion method\n   |\n30 |         if total_match((&lst1[i..]).to_vec(),\
    \ &lst2[i..]) == lst1[i..] {\n   |                        +          ++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmplvtrz866.rs:30:36\n   |\n30 |\
    \         if total_match(&lst1[i..], &lst2[i..]) == lst1[i..] {\n   |        \
    \                            ^^^^^^^^^^ expected struct `Vec`, found `&[String]`\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found reference `&[String]`\n\
    help: try using a conversion method\n   |\n30 |         if total_match(&lst1[i..],\
    \ (&lst2[i..]).to_vec()) == lst1[i..] {\n   |                                \
    \    +          ++++++++++\n\nerror: aborting due to 3 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut count = 0;\n    for el in lst1 {\n        if el < lst2 {\n      \
    \      count += 1;\n        }\n    }\n    if count == lst1.len() {\n        return\
    \ lst1\n    } else {\n        return Vec::new()\n    }\n}\n\nfn main() {\n   \
    \ let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd0vawk9_.rs:18:17\n   |\n\
    18 |         if el < lst2 {\n   |                 ^^^^ expected struct `String`,\
    \ found struct `Vec`\n   |\n   = note: expected struct `String`\n            \
    \  found struct `Vec<String>`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut lst_out = vec![];\n    lst1.iter().cloned().for_each(|str1|{\n  \
    \      lst2.iter().cloned().for_each(|str2|{\n            if str1.chars().count()\
    \ > str2.chars().count() {\n                lst_out.push(str1);\n            }\
    \ else {\n                lst_out.push(str2);\n            }\n        });\n  \
    \  });\n    lst_out\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0507]: cannot move out of `str1`, a captured variable in an `FnMut`\
    \ closure\n  --> /tmp/tmpbxf25yso.rs:20:30\n   |\n17 |       lst1.iter().cloned().for_each(|str1|{\n\
    \   |                                      ---- captured outer variable\n18 |\
    \           lst2.iter().cloned().for_each(|str2|{\n   |  _______________________________________-\n\
    19 | |             if str1.chars().count() > str2.chars().count() {\n20 | |  \
    \               lst_out.push(str1);\n   | |                              ^^^^\
    \ move occurs because `str1` has type `String`, which does not implement the `Copy`\
    \ trait\n21 | |             } else {\n22 | |                 lst_out.push(str2);\n\
    23 | |             }\n24 | |         });\n   | |_________- captured by this `FnMut`\
    \ closure\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0507`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    lst1.iter()\n        .zip(lst2.iter())\n        .filter(|(ele1, ele2)| ele1.len()\
    \ < ele2.len())\n        .map(|(ele1, ele2)| ele1)\n        .collect()\n}\n\n\
    fn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&String`\n    --> /tmp/tmpfp9pu3gw.rs:20:10\n     |\n\
    20   |         .collect()\n     |          ^^^^^^^ value of type `Vec<String>`\
    \ cannot be built from `std::iter::Iterator<Item=&String>`\n     |\n     = help:\
    \ the trait `FromIterator<&String>` is not implemented for `Vec<String>`\n   \
    \  = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976547
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut res = Vec::new();\n    for word in lst1 {\n        if lst2.contains(&word)\
    \ {\n            res.push(word);\n        } else {\n            break;\n     \
    \   }\n    }\n    if res.is_empty() {\n        lst1;\n    }\n    else {\n    \
    \    res\n    }\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0wc76f15.rs:24:23\n   |\n\
    24 |       if res.is_empty() {\n   |  _______________________^\n25 | |       \
    \  lst1;\n   | |             - help: remove this semicolon\n26 | |     }\n   |\
    \ |_____^ expected struct `Vec`, found `()`\n   |\n   = note: expected struct\
    \ `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976547
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut lst_lens\
    \ = Vec::new();\n    for s in lst2 {\n        if !lst_lens.contains(&s.len())\
    \ {\n            lst_lens.push(s.len());\n        }\n    }\n    let mut min_len\
    \ = lst_lens.iter().min().unwrap();\n    let mut result = Vec::new();\n    for\
    \ s in lst1 {\n        if s.len() >= min_len {\n            result.push(s);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5ui2o5zf.rs:28:23\n   |\n\
    28 |         if s.len() >= min_len {\n   |                       ^^^^^^^ expected\
    \ `usize`, found `&usize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    28 |         if s.len() >= *min_len {\n   |                       +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976547
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == 0 && lst2.len() == 0 {\n        return vec![];\n    }\n\
    \    if lst1.len() > 0 && lst2.len() > 0 {\n        if total_matches(&lst1[0],\
    \ &lst2[0]) == lst1.len() {\n            return lst1;\n        } else {\n    \
    \        return vec![];\n        }\n    }\n    if lst1.len() == 0 && lst2.len()\
    \ > 0 {\n        return vec![];\n    }\n    if lst1.len() > 0 && lst2.len() ==\
    \ 0 {\n        return vec![];\n    }\n    if total_matches(&lst1[0], &lst2[0])\
    \ == lst1.len() {\n        return lst1;\n    } else {\n        return vec![];\n\
    \    }\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `total_matches` in this scope\n  -->\
    \ /tmp/tmp1l3_o1x4.rs:20:12\n   |\n20 |         if total_matches(&lst1[0], &lst2[0])\
    \ == lst1.len() {\n   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `total_matches` in this scope\n  --> /tmp/tmp1l3_o1x4.rs:32:8\n\
    \   |\n32 |     if total_matches(&lst1[0], &lst2[0]) == lst1.len() {\n   |   \
    \     ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let len = lst1.len();\n    if len == 0 {\n        return lst1;\n    }\n \
    \   if len == lst2.len() {\n        return lst1;\n    }\n    let mut res = vec![String::from(\"\
    hi\")];\n    for i in 0..len {\n        if lst1[i].len() < lst2[i].len() {\n \
    \           res.insert(i + 1, lst1[i]);\n        }\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpo4xoff2g.rs:26:31\n\
    \   |\n26 |             res.insert(i + 1, lst1[i]);\n   |                    \
    \           ^^^^^^^ move occurs because value has type `String`, which does not\
    \ implement the `Copy` trait\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0507`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    if lst1.len()\
    \ > lst2.len() {\n        lst1.reverse();\n        lst2.reverse();\n    }\n  \
    \  let mut total_match_vec: Vec<String> = vec![];\n    for (i, s) in lst1.iter().enumerate()\
    \ {\n        let s_new = lst2.iter().filter(|x| x.len() > i).count();\n      \
    \  if s_new == 1 {\n            total_match_vec.push(s);\n        }\n    }\n \
    \   total_match_vec\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk3uksn7v.rs:27:34\n   |\n\
    27 |             total_match_vec.push(s);\n   |                              \
    \    ^- help: try using a conversion method: `.to_string()`\n   |            \
    \                      |\n   |                                  expected struct\
    \ `String`, found `&String`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    match lst1.len() {\n        0 => lst2,\n        _ => match lst2.len() {\n\
    \            0 => lst1,\n            _ => let mut sum: Vec<String> = vec![];\n\
    \            for s in lst1 {\n                for t in lst2 {\n              \
    \      if s == t {\n                        sum.push(s);\n                   \
    \ }\n                }\n            }\n            sum.sort_unstable();\n    \
    \        sum\n        },\n    }\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `@` or `|`, found `:`\n  --> /tmp/tmpbvy3zl93.rs:20:29\n\
    \   |\n20 |             _ => let mut sum: Vec<String> = vec![];\n   |        \
    \                     ^\n   |                             |\n   |            \
    \                 expected one of `@` or `|`\n   |                           \
    \  help: maybe write a path separator here: `::`\n\nerror: expected one of `=`\
    \ or `@`, found `<`\n  --> /tmp/tmpbvy3zl93.rs:20:34\n   |\n20 |             _\
    \ => let mut sum: Vec<String> = vec![];\n   |               --               \
    \  ^ expected one of `=` or `@`\n   |               |\n   |               while\
    \ parsing the `match` arm starting here\n\nerror: aborting due to 2 previous errors\n\
    \n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut result = vec![];\n    let len1 = lst1.len();\n    let len2 = lst2.len();\n\
    \    if len1 == len2 {\n        for i in 0..len1 {\n            if lst1[i] < lst2[i]\
    \ {\n                result.push(lst1[i]);\n            }\n        }\n    } else\
    \ if len1 < len2 {\n        for i in 0..len2 {\n            if lst2[i] < lst1[i]\
    \ {\n                result.push(lst2[i]);\n            }\n        }\n    } else\
    \ {\n        for i in 0..len1 {\n            if lst1[i] < lst2[i] {\n        \
    \        result.push(lst1[i]);\n            }\n        }\n        for i in 0..len2\
    \ {\n            if lst2[i] < lst1[i] {\n                result.push(lst2[i]);\n\
    \            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmp770n49g7.rs:22:29\n\
    \   |\n22 |                 result.push(lst1[i]);\n   |                      \
    \       ^^^^^^^ move occurs because value has type `String`, which does not implement\
    \ the `Copy` trait\n\nerror[E0507]: cannot move out of index of `Vec<String>`\n\
    \  --> /tmp/tmp770n49g7.rs:28:29\n   |\n28 |                 result.push(lst2[i]);\n\
    \   |                             ^^^^^^^ move occurs because value has type `String`,\
    \ which does not implement the `Copy` trait\n\nerror[E0507]: cannot move out of\
    \ index of `Vec<String>`\n  --> /tmp/tmp770n49g7.rs:34:29\n   |\n34 |        \
    \         result.push(lst1[i]);\n   |                             ^^^^^^^ move\
    \ occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmp770n49g7.rs:39:29\n\
    \   |\n39 |                 result.push(lst2[i]);\n   |                      \
    \       ^^^^^^^ move occurs because value has type `String`, which does not implement\
    \ the `Copy` trait\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0507`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == 0 || lst2.len() == 0 {\n        return vec![];\n    }\n\n\
    \    if lst1.len() < lst2.len() {\n        return lst1;\n    }\n\n    if lst1.len()\
    \ > lst2.len() {\n        return lst2;\n    }\n\n    if lst1.is_empty() || lst2.is_empty()\
    \ {\n        return vec![];\n    }\n\n    lst1.iter().filter(|&s| s.chars().count()\
    \ < lst2.iter().filter(|&s| s.chars().count()).count()).cloned().collect()\n}\n\
    \nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1yjvbfqf.rs:32:73\n   |\n\
    32 |     lst1.iter().filter(|&s| s.chars().count() < lst2.iter().filter(|&s| s.chars().count()).count()).cloned().collect()\n\
    \   |                                                                        \
    \ ^^^^^^^^^^^^^^^^^ expected `bool`, found `usize`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 101
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    lst1.into_iter().filter(|e| lst2.contains(&e)).collect()\n}\n\nfn main()\
    \ {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"hi\"]`,\n right: `[\"hi\", \"hi\"]`', /tmp/tmpxhbbl2r6.rs:22:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut total = 0;\n    for i in 0..lst1.len() {\n        let i1 = lst1[i];\n\
    \        let i2 = lst2[i];\n        if i1 == i2 {\n            total += 1;\n \
    \       }\n    }\n    lst1[total ..].clone()\n}\n\nfn main() {\n    let candidate\
    \ = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `clone` found for slice `[String]` in the\
    \ current scope\n  --> /tmp/tmpbwd9osyb.rs:24:20\n   |\n24 |     lst1[total ..].clone()\n\
    \   |                    ^^^^^ method not found in `[String]`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut result = vec![];\n    let num_1 = lst1.len();\n    let num_2 = lst2.len();\n\
    \    if num_1 > num_2 {\n        result = lst1;\n    } else {\n        result\
    \ = lst2;\n    }\n    \n    // if both vectors have the same length, return the\
    \ first vector\n    if lst1.len() == lst2.len() {\n        lst1\n    }\n    else\
    \ {\n        result\n    }\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "warning: value assigned to `result` is never read\n  --> /tmp/tmpmu88jp2u.rs:16:13\n\
    \   |\n16 |     let mut result = vec![];\n   |             ^^^^^^\n   |\n   =\
    \ note: `#[warn(unused_assignments)]` on by default\n   = help: maybe it is overwritten\
    \ before being read?\n\nerror[E0382]: borrow of moved value: `lst1`\n  --> /tmp/tmpmu88jp2u.rs:26:8\n\
    \   |\n15 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |                ---- move occurs because `lst1` has type `Vec<String>`,\
    \ which does not implement the `Copy` trait\n...\n20 |         result = lst1;\n\
    \   |                  ---- value moved here\n...\n26 |     if lst1.len() == lst2.len()\
    \ {\n   |        ^^^^^^^^^^ value borrowed here after move\n\nerror[E0382]: borrow\
    \ of moved value: `lst2`\n  --> /tmp/tmpmu88jp2u.rs:26:22\n   |\n15 | fn total_match(lst1:\
    \ Vec<String>, lst2: Vec<String>) -> Vec<String> {\n   |                     \
    \              ---- move occurs because `lst2` has type `Vec<String>`, which does\
    \ not implement the `Copy` trait\n...\n22 |         result = lst2;\n   |     \
    \             ---- value moved here\n...\n26 |     if lst1.len() == lst2.len()\
    \ {\n   |                      ^^^^^^^^^^ value borrowed here after move\n\nerror:\
    \ aborting due to 2 previous errors; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    // Get the total length of the strings.\n    let len = lst1.iter().map(|s|\
    \ s.chars().count()).reduce(|a,b| a+b);\n    // If the total length is equal to\
    \ the length of either vector,\n    // then the vector has same number of chars.\n\
    \    if len == lst1.len() || len == lst2.len() {\n        return lst1;\n    }\n\
    \    let mut len2 = lst2.iter().map(|s| s.chars().count()).reduce(|a,b| a+b);\n\
    \    if len2 < len {\n        len2 = len;\n    }\n    if len2 < len {\n      \
    \  return lst1;\n    }\n    return lst2;\n}\n\nfn main() {\n    let candidate\
    \ = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqv4m6law.rs:20:15\n   |\n\
    20 |     if len == lst1.len() || len == lst2.len() {\n   |               ^^^^^^^^^^\
    \ expected enum `Option`, found `usize`\n   |\n   = note: expected enum `Option<usize>`\n\
    \              found type `usize`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n20 |     if len == Some(lst1.len()) || len == lst2.len() {\n   |      \
    \         +++++          +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqv4m6law.rs:20:36\n\
    \   |\n20 |     if len == lst1.len() || len == lst2.len() {\n   |            \
    \                        ^^^^^^^^^^ expected enum `Option`, found `usize`\n  \
    \ |\n   = note: expected enum `Option<usize>`\n              found type `usize`\n\
    help: try wrapping the expression in `Some`\n   |\n20 |     if len == lst1.len()\
    \ || len == Some(lst2.len()) {\n   |                                    +++++\
    \          +\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        if lst1.is_empty() {\n           \
    \ vec![]\n        }\n        if lst2.is_empty() {\n            vec![]\n      \
    \  }\n        lst1\n    } else {\n        lst1\n    }\n}\n\nfn main() {\n    let\
    \ candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplyueylfp.rs:18:13\n   |\n\
    17 | /         if lst1.is_empty() {\n18 | |             vec![]\n   | |       \
    \      ^^^^^^ expected `()`, found struct `Vec`\n19 | |         }\n   | |_________-\
    \ expected this to be `()`\n   |\n   = note: expected unit type `()`\n       \
    \          found struct `Vec<_>`\n   = note: this error originates in the macro\
    \ `vec` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp:\
    \ consider using a semicolon here\n   |\n19 |         };\n   |          +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmplyueylfp.rs:21:13\n   |\n20 | /\
    \         if lst2.is_empty() {\n21 | |             vec![]\n   | |            \
    \ ^^^^^^ expected `()`, found struct `Vec`\n22 | |         }\n   | |_________-\
    \ expected this to be `()`\n   |\n   = note: expected unit type `()`\n       \
    \          found struct `Vec<_>`\n   = note: this error originates in the macro\
    \ `vec` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp:\
    \ consider using a semicolon here\n   |\n22 |         };\n   |          +\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    match lst1.len() {\n        0 => lst2,\n        1 => lst1,\n        _ =>\
    \ {\n            let mut new_list = vec![String::from(\"0\".to_string())];\n \
    \           for x in lst1 {\n                if lst2.iter().any(|&y| x.cmp(y).is_less_eq(&0))\
    \ {\n                    new_list.push(x);\n                }\n            }\n\
    \            new_list\n        }\n    }\n}\n\nfn main() {\n    let candidate =\
    \ total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp95c_zsj_.rs:22:47\n   |\n\
    22 |                 if lst2.iter().any(|&y| x.cmp(y).is_less_eq(&0)) {\n   |\
    \                                               ^\n   |                      \
    \                         |\n   |                                            \
    \   expected `&String`, found struct `String`\n   |                          \
    \                     help: consider borrowing here: `&y`\n\nerror[E0599]: no\
    \ method named `is_less_eq` found for enum `std::cmp::Ordering` in the current\
    \ scope\n  --> /tmp/tmp95c_zsj_.rs:22:50\n   |\n22 |                 if lst2.iter().any(|&y|\
    \ x.cmp(y).is_less_eq(&0)) {\n   |                                           \
    \       ^^^^^^^^^^ help: there is an associated function with a similar name:\
    \ `is_eq`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == 0 || lst2.len() == 0 {\n        return vec![];\n    }\n\
    \    if lst1.len() == 1 && lst2.len() == 1 {\n        if lst1[0] >= lst2[0] {\n\
    \            return vec![lst1[0]];\n        } else {\n            return vec![lst2[0]];\n\
    \        }\n    }\n    if lst1.len() > lst2.len() {\n        return total_match(\n\
    \            vec![lst1[0]],\n            vec![String::from(\"\")]\n          \
    \      .into_iter()\n                .take(lst2.len() - lst1.len())\n        \
    \        .collect(),\n        );\n    }\n    if lst2.len() > lst1.len() {\n  \
    \      return total_match(\n            vec![String::from(\"\")],\n          \
    \  vec![lst2[0]]\n                .into_iter()\n                .take(lst1.len()\
    \ - lst2.len())\n                .collect(),\n        );\n    }\n    let mut total_matches\
    \ = vec![String::from(\"\")]\n        .into_iter()\n        .take(lst1.len() +\
    \ lst2.len() - 2)\n        .collect();\n    for i in 1..lst1.len() {\n       \
    \ total_matches[0] = total_matches[0].chars().collect();\n        if lst1[i] >\
    \ lst2[i] {\n            total_matches[i - 1] = total_matches[i - 1].chars().collect();\n\
    \        }\n    }\n    total_matches[0] = total_matches[0].chars().collect();\n\
    \    total_matches[total_matches.len() - 1] = total_matches[total_matches.len()\
    \ - 1].chars().collect();\n    total_matches\n}\n\nfn main() {\n    let candidate\
    \ = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpucl2d2ae.rs:49:9\n\
    \   |\n44 |     let mut total_matches = vec![String::from(\"\")]\n   |       \
    \  ----------------- consider giving `total_matches` a type\n...\n49 |       \
    \  total_matches[0] = total_matches[0].chars().collect();\n   |         ^^^^^^^^^^^^^\
    \ cannot infer type\n   |\n   = note: type must be known at this point\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == 0 && lst2.len() == 0 {\n        return vec![];\n    }\n\
    \    let mut result: Vec<String> = vec![];\n    for i in 0..lst1.len() {\n   \
    \     let j: usize = lst1.len();\n        let mut cnt = 0;\n        while j >\
    \ i {\n            cnt += lst1[j].len();\n            j -= 1;\n        }\n   \
    \     if cnt == lst2[i].len() {\n            result.append(&lst1[i]);\n      \
    \  }\n    }\n    if lst1.len() == 0 {\n        return result;\n    }\n    let\
    \ mut result: Vec<String> = vec![];\n    for i in 0..lst2.len() {\n        let\
    \ j: usize = lst2.len();\n        let mut cnt = 0;\n        while j > i {\n  \
    \          cnt += lst2[j].len();\n            j -= 1;\n        }\n        if cnt\
    \ == lst1[i].len() {\n            result.append(&lst2[i]);\n        }\n    }\n\
    \    result.sort_by_key(|x| x.to_lowercase());\n    result\n}\n\nfn main() {\n\
    \    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_7_3hfku.rs:28:27\n   |\n\
    28 |             result.append(&lst1[i]);\n   |                           ^^^^^^^^\
    \ types differ in mutability\n   |\n   = note: expected mutable reference `&mut\
    \ Vec<String>`\n                      found reference `&String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_7_3hfku.rs:43:27\n   |\n43 |             result.append(&lst2[i]);\n\
    \   |                           ^^^^^^^^ types differ in mutability\n   |\n  \
    \ = note: expected mutable reference `&mut Vec<String>`\n                    \
    \  found reference `&String`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut nchars = 0;\n    for s in lst1 {\n        if lst2.iter().all(|s|\
    \ s == s) {\n            nchars += s.len();\n        }\n    }\n    if nchars <\
    \ lst1.len() {\n        return lst1\n    } else {\n        return lst2\n    }\n\
    }\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `lst1`\n   --> /tmp/tmp20n1dmke.rs:22:17\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                ---- move occurs because `lst1` has type `Vec<String>`,\
    \ which does not implement the `Copy` trait\n16  |     let mut nchars = 0;\n17\
    \  |     for s in lst1 {\n    |              ---- `lst1` moved due to this implicit\
    \ call to `.into_iter()`\n...\n22  |     if nchars < lst1.len() {\n    |     \
    \            ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `lst1`\nhelp: consider iterating\
    \ over a slice of the `Vec<String>`'s content to avoid moving into the `for` loop\n\
    \    |\n17  |     for s in &lst1 {\n    |              +\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        lst1\n    } else {\n        let mut\
    \ result = vec![];\n        for val in lst2 {\n            if val in lst1 {\n\
    \                result.push(val);\n            }\n        }\n        result\n\
    \    }\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found keyword `in`\n  --> /tmp/tmpby4k2ioh.rs:21:20\n\
    \   |\n21 |             if val in lst1 {\n   |             --     ^^ expected\
    \ `{`\n   |             |\n   |             this `if` expression has a condition,\
    \ but no block\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == 0 && lst2.len() == 0 {\n        vec![]\n    } else {\n \
    \       let mut total_match = 0;\n        for i in 0..(lst1.len()) {\n       \
    \     total_match += if lst1[i] < lst2[i] { 1 } else { 0 };\n        }\n     \
    \   total_match += lst1.len();\n        total_match += lst2.len();\n        vec![String::from_str(&(lst1[total_match\
    \ - lst2.len()]).to_string())]\n    }\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no function or associated item named `from_str` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmpjfc4fzal.rs:25:22\n   |\n\
    25 |         vec![String::from_str(&(lst1[total_match - lst2.len()]).to_string())]\n\
    \   |                      ^^^^^^^^ function or associated item not found in `String`\n\
    \   |\n   = help: items from traits can only be used if the trait is in scope\n\
    help: the following trait is implemented but not in scope; perhaps add a `use`\
    \ for it:\n   |\n1  | use std::str::FromStr;\n   |\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 101
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1\n    }\n    if lst1.len()\
    \ > lst2.len() {\n        total_match(lst2, lst1)\n    } else {\n        total_match(lst1,\
    \ lst2)\n    }\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"hi\", \"admin\"]`,\n right: `[\"hi\", \"hi\"]`', /tmp/tmphbodvzok.rs:29:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut total_match = vec![];\n    for el in lst1 {\n        let pos = lst2.iter().position(|s|\
    \ s < el);\n        if pos == -1 { total_match.push(el); }\n        else { total_match.push(lst2[pos]);\
    \ }\n    }\n    total_match\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp97ioqmt5.rs:18:48\n   |\n\
    18 |         let pos = lst2.iter().position(|s| s < el);\n   |               \
    \                                 ^^\n   |                                   \
    \             |\n   |                                                expected\
    \ `&String`, found struct `String`\n   |                                     \
    \           help: consider borrowing here: `&el`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp97ioqmt5.rs:19:19\n   |\n19 |         if pos == -1 { total_match.push(el);\
    \ }\n   |                   ^^ expected enum `Option`, found integer\n   |\n \
    \  = note: expected enum `Option<usize>`\n              found type `{integer}`\n\
    help: try wrapping the expression in `Some`\n   |\n19 |         if pos == Some(-1)\
    \ { total_match.push(el); }\n   |                   +++++  +\n\nerror[E0277]:\
    \ the type `[String]` cannot be indexed by `Option<usize>`\n  --> /tmp/tmp97ioqmt5.rs:20:33\n\
    \   |\n20 |         else { total_match.push(lst2[pos]); }\n   |              \
    \                   ^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[String]>` is not implemented for `Option<usize>`\n\
    \   = note: required because of the requirements on the impl of `Index<Option<usize>>`\
    \ for `Vec<String>`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    vec![\n        lst1.iter().filter(|x| x.chars().count() < lst2.iter().filter(|y|\
    \ y.chars().count() > 0).count()).collect(),\n        lst2.iter().filter(|x| x.chars().count()\
    \ < lst1.iter().filter(|y| y.chars().count() > 0).count()).collect(),\n      \
    \  vec![]\n    ]\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `String` cannot be built from an iterator\
    \ over elements of type `&String`\n    --> /tmp/tmp_bts4wlr.rs:17:107\n     |\n\
    17   |         lst1.iter().filter(|x| x.chars().count() < lst2.iter().filter(|y|\
    \ y.chars().count() > 0).count()).collect(),\n     |                         \
    \                                                                            \
    \      ^^^^^^^ value of type `String` cannot be built from `std::iter::Iterator<Item=&String>`\n\
    \     |\n     = help: the trait `FromIterator<&String>` is not implemented for\
    \ `String`\n     = help: the following other types implement trait `FromIterator<A>`:\n\
    \               <String as FromIterator<&'a char>>\n               <String as\
    \ FromIterator<&'a str>>\n               <String as FromIterator<Box<str>>>\n\
    \               <String as FromIterator<Cow<'a, str>>>\n               <String\
    \ as FromIterator<String>>\n               <String as FromIterator<char>>\nnote:\
    \ required by a bound in `collect`\n\nerror[E0277]: a value of type `String` cannot\
    \ be built from an iterator over elements of type `&String`\n    --> /tmp/tmp_bts4wlr.rs:18:107\n\
    \     |\n18   |         lst2.iter().filter(|x| x.chars().count() < lst1.iter().filter(|y|\
    \ y.chars().count() > 0).count()).collect(),\n     |                         \
    \                                                                            \
    \      ^^^^^^^ value of type `String` cannot be built from `std::iter::Iterator<Item=&String>`\n\
    \     |\n     = help: the trait `FromIterator<&String>` is not implemented for\
    \ `String`\n     = help: the following other types implement trait `FromIterator<A>`:\n\
    \               <String as FromIterator<&'a char>>\n               <String as\
    \ FromIterator<&'a str>>\n               <String as FromIterator<Box<str>>>\n\
    \               <String as FromIterator<Cow<'a, str>>>\n               <String\
    \ as FromIterator<String>>\n               <String as FromIterator<char>>\nnote:\
    \ required by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_bts4wlr.rs:19:9\n\
    \   |\n19 |         vec![]\n   |         ^^^^^^ expec"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    if lst1.len()\
    \ > lst2.len() {\n        let tmp = lst1;\n        lst1 = lst2;\n        lst2\
    \ = tmp;\n    }\n    for i in 0..lst1.len() {\n        if lst1.get(i) < lst2.get(i)\
    \ {\n            lst1.swap(i, lst1.len());\n            break;\n        }\n  \
    \  }\n    lst1\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `lst1`\n  --> /tmp/tmpxo4qb52v.rs:21:9\n\
    \   |\n15 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |                ---- help: consider making this binding mutable: `mut\
    \ lst1`\n...\n21 |         lst1 = lst2;\n   |         ^^^^ cannot assign to immutable\
    \ argument\n\nerror[E0384]: cannot assign to immutable argument `lst2`\n  -->\
    \ /tmp/tmpxo4qb52v.rs:22:9\n   |\n15 | fn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n   |                                   ---- help:\
    \ consider making this binding mutable: `mut lst2`\n...\n22 |         lst2 = tmp;\n\
    \   |         ^^^^ cannot assign to immutable argument\n\nerror[E0596]: cannot\
    \ borrow `lst1` as mutable, as it is not declared as mutable\n  --> /tmp/tmpxo4qb52v.rs:26:13\n\
    \   |\n15 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |                ---- help: consider changing this to be mutable: `mut\
    \ lst1`\n...\n26 |             lst1.swap(i, lst1.len());\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror[E0502]: cannot borrow `lst1` as immutable\
    \ because it is also borrowed as mutable\n  --> /tmp/tmpxo4qb52v.rs:26:26\n  \
    \ |\n26 |             lst1.swap(i, lst1.len());\n   |             -------------^^^^^^^^^^-\n\
    \   |             |    |       |\n   |             |    |       immutable borrow\
    \ occurs here\n   |             |    mutable borrow later used by call\n   | \
    \            mutable borrow occurs here\n   |\nhelp: try adding a local storing\
    \ this argument...\n  --> /tmp/tmpxo4qb52v.rs:26:26\n   |\n26 |             lst1.swap(i,\
    \ lst1.len());\n   |                          ^^^^^^^^^^\nhelp: ...and then using\
    \ that local as the argument to this call\n  --> /tmp/tmpxo4qb52v.rs:26:13\n \
    \  |\n26 |             lst1.swap(i, lst1.len());\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0384, E0502, E0596.\nFor more information about an error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut result\
    \ = vec![];\n    let mut it = lst1.iter().cloned().collect::<Vec<_>>();\n    let\
    \ mut jt = lst2.iter().cloned().collect::<Vec<_>>();\n    while it.len() != 0\
    \ && jt.len() != 0 {\n        if *it.len() < *jt.len() {\n            jt.next();\n\
    \        } else {\n            it.next();\n        }\n    }\n    result.extend(it.take(jt.len()));\n\
    \    result\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `usize` cannot be dereferenced\n  --> /tmp/tmpxjsjf_jh.rs:23:12\n\
    \   |\n23 |         if *it.len() < *jt.len() {\n   |            ^^^^^^^^^\n\n\
    error[E0614]: type `usize` cannot be dereferenced\n  --> /tmp/tmpxjsjf_jh.rs:23:24\n\
    \   |\n23 |         if *it.len() < *jt.len() {\n   |                        ^^^^^^^^^\n\
    \nerror[E0599]: no method named `next` found for struct `Vec<String>` in the current\
    \ scope\n  --> /tmp/tmpxjsjf_jh.rs:24:16\n   |\n24 |             jt.next();\n\
    \   |                ^^^^ method not found in `Vec<String>`\n\nerror[E0599]: no\
    \ method named `next` found for struct `Vec<String>` in the current scope\n  -->\
    \ /tmp/tmpxjsjf_jh.rs:26:16\n   |\n26 |             it.next();\n   |         \
    \       ^^^^ method not found in `Vec<String>`\n\nerror[E0599]: `Vec<String>`\
    \ is not an iterator\n   --> /tmp/tmpxjsjf_jh.rs:29:22\n    |\n29  |       result.extend(it.take(jt.len()));\n\
    \    |                        ^^^^ `Vec<String>` is not an iterator\n    |\n \
    \   = note: the following trait bounds were not satisfied:\n            `Vec<String>:\
    \ Iterator`\n            which is required by `&mut Vec<String>: Iterator`\n \
    \           `[String]: Iterator`\n            which is required by `&mut [String]:\
    \ Iterator`\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed\
    \ explanations: E0599, E0614.\nFor more information about an error, try `rustc\
    \ --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    \n    let\
    \ mut min_len = vec![String::new(), String::new(), String::new(), String::new()];\n\
    \    for idx in 0..3 {\n        let len = if idx == 0 { lst1.len(} else { lst2.len()\
    \ };\n        min_len[idx] = String::new();\n        min_len[idx].push_str(&lst1[idx..len].join(\"\
    \"));\n    }\n    min_len[2] = if min_len[0].len() == min_len[1].len() {\n   \
    \     String::from(\"\") + min_len[0]\n    } else {\n        String::from(\"\"\
    ) + min_len[0] + min_len[1]\n    };\n    \n    for idx in 3..4 {\n        let\
    \ len = if idx == 3 { lst1.len(} else { lst2.len() };\n        min_len[idx] =\
    \ String::new();\n        min_len[idx].push_str(&lst2[idx..len].join(\"\"));\n\
    \    }\n    \n    let mut min_len1 = min_len[3];\n    min_len1 = if min_len1.len()\
    \ == min_len[2].len() {\n        String::from(\"\") + min_len1\n    } else {\n\
    \        String::from(\"\") + min_len1 + min_len[2]\n    };\n    \n    let mut\
    \ min_len2 = min_len[0];\n    min_len2 = if min_len2.len() == min_len[1].len()\
    \ {\n        String::from(\"\") + min_len2\n    } else {\n        String::from(\"\
    \") + min_len2 + min_len[1]\n    };\n    \n    if min_len1 == min_len2 {\n   \
    \     min_len1.clone()\n    } else {\n        min_len2.clone()\n    }\n}\n\nfn\
    \ main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpzl_eu5q_.rs:22:41\n\
    \   |\n22 |         let len = if idx == 0 { lst1.len(} else { lst2.len() };\n\
    \   |                               -         ^^ mismatched closing delimiter\n\
    \   |                               |         |\n   |                        \
    \       |         unclosed delimiter\n   |                               closing\
    \ delimiter possibly meant for this\n\nerror: mismatched closing delimiter: `}`\n\
    \  --> /tmp/tmpzl_eu5q_.rs:33:41\n   |\n33 |         let len = if idx == 3 { lst1.len(}\
    \ else { lst2.len() };\n   |                               -         ^^ mismatched\
    \ closing delimiter\n   |                               |         |\n   |    \
    \                           |         unclosed delimiter\n   |               \
    \                closing delimiter possibly meant for this\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpzl_eu5q_.rs:27:28\n   |\n27 |         String::from(\"\"\
    ) + min_len[0]\n   |                            ^^^^^^^^^^\n   |             \
    \               |\n   |                            expected `&str`, found struct\
    \ `String`\n   |                            help: consider borrowing here: `&min_len[0]`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpzl_eu5q_.rs:29:28\n   |\n29 |\
    \         String::from(\"\") + min_len[0] + min_len[1]\n   |                 \
    \           ^^^^^^^^^^\n   |                            |\n   |              \
    \              expected `&str`, found struct `String`\n   |                  \
    \          help: consider borrowing here: `&min_len[0]`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpzl_eu5q_.rs:29:41\n   |\n29 |         String::from(\"\"\
    ) + min_len[0] + min_len[1]\n   |                                         ^^^^^^^^^^\n\
    \   |                                         |\n   |                        \
    \                 expected `&str`, found struct `String`\n   |               \
    \                          help: consider borrowing here: `&min_len[1]`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpzl_eu5q_.rs:40:28\n   |\n40 |         String::from(\"\
    \") + min_len1\n   |                    "
  stdout: ''
  timestamp: 1659976548
- exit_code: 101
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut total_match: Vec<String> = Vec::new();\n    let mut total = 0;\n\
    \    for element in lst1 {\n        if element == lst2[0] {\n            total\
    \ += 1;\n        } else {\n            total -= 1;\n        }\n        if total\
    \ == 0 {\n            total_match.push(element);\n        }\n    }\n    total_match\n\
    }\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"admin\"]`,\n right: `[\"hi\", \"hi\"]`', /tmp/tmp3mo9qaqh.rs:34:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut vec_sum: Vec<String> = vec![];\n    let mut total_counts: usize =\
    \ 0;\n    for val in lst1 {\n        total_counts += val.chars().count();\n  \
    \      if total_counts > lst2.len() {\n            break;\n        }\n       \
    \ let res = lst2.iter().filter(|&val2| val.chars().count() > val2.chars().count()).collect::<Vec<String>>();\n\
    \        if res.len() > 0 {\n            vec_sum.push(res.into_iter().last());\n\
    \        } else {\n            vec_sum.push(val);\n        }\n    }\n    vec_sum\n\
    }\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&String`\n    --> /tmp/tmpwyu14q6k.rs:23:90\n     |\n\
    23   |         let res = lst2.iter().filter(|&val2| val.chars().count() > val2.chars().count()).collect::<Vec<String>>();\n\
    \     |                                                                      \
    \                    ^^^^^^^ value of type `Vec<String>` cannot be built from\
    \ `std::iter::Iterator<Item=&String>`\n     |\n     = help: the trait `FromIterator<&String>`\
    \ is not implemented for `Vec<String>`\n     = help: the trait `FromIterator<T>`\
    \ is implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpwyu14q6k.rs:25:26\n   |\n25 |             vec_sum.push(res.into_iter().last());\n\
    \   |                          ^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found enum `Option`\n   |\n   = note: expected struct `String`\n           \
    \     found enum `Option<String>`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut total = 0;\n    for &s in lst1 {\n        if !lst2.contains(&s) {\n\
    \            total += s.len();\n        }\n    }\n    lst1.iter().take(lst1.len()\
    \ - total).collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2z1lms4j.rs:17:9\n   |\n\
    17 |     for &s in lst1 {\n   |         ^^    ---- this expression has type `Option<String>`\n\
    \   |         |\n   |         expected struct `String`, found reference\n   |\
    \         help: you can probably remove the explicit borrow: `s`\n   |\n   = note:\
    \ expected struct `String`\n           found reference `&_`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2z1lms4j.rs:22:5\n   |\n15 | fn total_match(lst1: Vec<String>,\
    \ lst2: Vec<String>) -> Vec<String> {\n   |                                  \
    \                       ----------- expected `Vec<String>` because of return type\n\
    ...\n22 |     lst1.iter().take(lst1.len() - total).collect::<Vec<_>>()\n   | \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `String`, found `&String`\n   |\n   = note: expected struct `Vec<String>`\n\
    \              found struct `Vec<&String>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 101
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1\n    }\n    if lst1.len()\
    \ > lst2.len() {\n        return lst2\n    }\n    lst2\n}\n\nfn main() {\n   \
    \ let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"hi\", \"admin\"]`,\n right: `[\"hi\", \"hi\"]`', /tmp/tmpxdg10pv9.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    lst1.iter().filter(|x| lst2.iter().any(|y| y.contains(x))).collect()\n}\n\
    \nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `String`\n    -->\
    \ /tmp/tmp2afwwbvw.rs:16:59\n     |\n16   |     lst1.iter().filter(|x| lst2.iter().any(|y|\
    \ y.contains(x))).collect()\n     |                                          \
    \        -------- ^ expected an `Fn<(char,)>` closure, found `String`\n     |\
    \                                                  |\n     |                 \
    \                                 required by a bound introduced by this call\n\
    \     |\n     = help: the trait `Fn<(char,)>` is not implemented for `String`\n\
    \     = help: the following other types implement trait `Pattern<'a>`:\n     \
    \          &'b String\n               &'b str\n               &'c &'b str\n  \
    \   = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&String`\n     = note: required because of the requirements on the impl\
    \ of `Pattern<'_>` for `&&String`\nnote: required by a bound in `core::str::<impl\
    \ str>::contains`\n\nerror[E0277]: a value of type `Vec<String>` cannot be built\
    \ from an iterator over elements of type `&String`\n    --> /tmp/tmp2afwwbvw.rs:16:64\n\
    \     |\n16   |     lst1.iter().filter(|x| lst2.iter().any(|y| y.contains(x))).collect()\n\
    \     |                                                                ^^^^^^^\
    \ value of type `Vec<String>` cannot be built from `std::iter::Iterator<Item=&String>`\n\
    \     |\n     = help: the trait `FromIterator<&String>` is not implemented for\
    \ `Vec<String>`\n     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\n\
    note: required by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        lst1\n    } else {\n        lst1.iter().zip(lst2.iter()).filter(|&(a,\
    \ _)| a < &b).collect::<Vec<_>>()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `b` in this scope\n  --> /tmp/tmp30t7sf4j.rs:19:60\n\
    \   |\n19 |         lst1.iter().zip(lst2.iter()).filter(|&(a, _)| a < &b).collect::<Vec<_>>()\n\
    \   |                                                            ^ help: a local\
    \ variable with a similar name exists: `a`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp30t7sf4j.rs:19:9\n   |\n15 | fn total_match(lst1: Vec<String>,\
    \ lst2: Vec<String>) -> Vec<String> {\n   |                                  \
    \                       ----------- expected `Vec<String>` because of return type\n\
    ...\n19 |         lst1.iter().zip(lst2.iter()).filter(|&(a, _)| a < &b).collect::<Vec<_>>()\n\
    \   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found tuple\n   |\n   = note: expected struct `Vec<String>`\n\
    \              found struct `Vec<(&String, &String)>`\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    lst1.iter().take(lst2.len()).count(|x| x < lst2.iter().cloned().take(lst1.len()).count())\n\
    }\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmp8887bjff.rs:16:34\n    |\n16  |     lst1.iter().take(lst2.len()).count(|x|\
    \ x < lst2.iter().cloned().take(lst1.len()).count())\n    |                  \
    \                ^^^^^ ----------------------------------------------------- supplied\
    \ 1 argument\n    |                                  |\n    |                \
    \                  expected 0 arguments\n    |\nnote: associated function defined\
    \ here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8887bjff.rs:16:5\n   |\n\
    15 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n \
    \  |                                                         ----------- expected\
    \ `Vec<String>` because of return type\n16 |     lst1.iter().take(lst2.len()).count(|x|\
    \ x < lst2.iter().cloned().take(lst1.len()).count())\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found `usize`\n   |\n   = note: expected struct `Vec<String>`\n\
    \                found type `usize`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0061, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_matches\
    \ = vec![String::from(\"hi\")];\n    let mut total_match_chars_count = lst1.len();\n\
    \    for str1 in lst1 {\n        for str2 in lst2 {\n            if str1.len()\
    \ < str2.len() {\n                if str1.chars().count() > total_match_chars_count\
    \ {\n                    total_match_chars_count = str1.chars().count();\n   \
    \             }\n            }\n        }\n    }\n    total_matches.push(String::from(\"\
    hi\"));\n    for str1 in lst1 {\n        if str1.chars().count() == total_match_chars_count\
    \ {\n            total_matches.push(str1);\n        }\n    }\n    total_matches\n\
    }\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmpjdpk_ygo.rs:22:21\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n22  |  \
    \       for str2 in lst2 {\n    |                     ^^^^ `lst2` moved due to\
    \ this implicit call to `.into_iter()`, in previous iteration of loop\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `lst2`\n\
    help: consider iterating over a slice of the `Vec<String>`'s content to avoid\
    \ moving into the `for` loop\n    |\n22  |         for str2 in &lst2 {\n    |\
    \                     +\n\nerror[E0382]: use of moved value: `lst1`\n  --> /tmp/tmpjdpk_ygo.rs:31:17\n\
    \   |\n15 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |                ---- move occurs because `lst1` has type `Vec<String>`,\
    \ which does not implement the `Copy` trait\n...\n21 |     for str1 in lst1 {\n\
    \   |                 ---- `lst1` moved due to this implicit call to `.into_iter()`\n\
    ...\n31 |     for str1 in lst1 {\n   |                 ^^^^ value used here after\
    \ move\n   |\nhelp: consider iterating over a slice of the `Vec<String>`'s content\
    \ to avoid moving into the `for` loop\n   |\n21 |     for str1 in &lst1 {\n  \
    \ |                 +\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == 0 || lst2.len() == 0 {\n        return vec![];\n    }\n\n\
    \    let mut total_chars: usize = 0;\n    for v in lst1 {\n        if v.chars().filter(|&c|\
    \ c < '0').count() > 0 {\n            return vec![];\n        }\n        total_chars\
    \ += v.chars().filter(|&c| c < '0').count();\n    }\n    for v in lst2 {\n   \
    \     if v.chars().filter(|&c| c < '0').count() > 0 {\n            return vec![];\n\
    \        }\n        total_chars += v.chars().filter(|&c| c < '0').count();\n \
    \   }\n\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n   \
    \ if total_chars == lst2.len() {\n        return lst2;\n    }\n\n    let mut result\
    \ = vec![];\n    for v in lst1 {\n        if v.chars().filter(|&c| c < '0').count()\
    \ > 0 {\n            return vec![];\n        }\n        result.push(v);\n    }\n\
    \    for v in lst2 {\n        if v.chars().filter(|&c| c < '0').count() > 0 {\n\
    \            return vec![];\n        }\n        result.push(v);\n    }\n\n   \
    \ result\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `lst1`\n   --> /tmp/tmp1olvs976.rs:34:23\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                ---- move occurs because `lst1` has type `Vec<String>`,\
    \ which does not implement the `Copy` trait\n...\n21  |     for v in lst1 {\n\
    \    |              ---- `lst1` moved due to this implicit call to `.into_iter()`\n\
    ...\n34  |     if total_chars == lst1.len() {\n    |                       ^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `lst1`\nhelp: consider iterating over a slice\
    \ of the `Vec<String>`'s content to avoid moving into the `for` loop\n    |\n\
    21  |     for v in &lst1 {\n    |              +\n\nerror[E0382]: borrow of moved\
    \ value: `lst2`\n  --> /tmp/tmp1olvs976.rs:37:23\n   |\n15 | fn total_match(lst1:\
    \ Vec<String>, lst2: Vec<String>) -> Vec<String> {\n   |                     \
    \              ---- move occurs because `lst2` has type `Vec<String>`, which does\
    \ not implement the `Copy` trait\n...\n27 |     for v in lst2 {\n   |        \
    \      ---- `lst2` moved due to this implicit call to `.into_iter()`\n...\n37\
    \ |     if total_chars == lst2.len() {\n   |                       ^^^^^^^^^^\
    \ value borrowed here after move\n   |\nhelp: consider iterating over a slice\
    \ of the `Vec<String>`'s content to avoid moving into the `for` loop\n   |\n27\
    \ |     for v in &lst2 {\n   |              +\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    match lst1.len() {\n        0 => vec![],\n        x => match lst2.len() {\n\
    \            0 => vec![lst1[0]],\n            x => if x < x {\n              \
    \  lst1\n            } else {\n                let mut i = 0;\n              \
    \  let mut s = lst1[i];\n                let mut j = lst2.len() - 1;\n       \
    \         while i <= j {\n                    if lst1[i] == lst2[j] {\n      \
    \                  i += 1;\n                        j -= 1;\n                \
    \    } else {\n                        break;\n                    }\n       \
    \         }\n                vec![s]\n            }\n        }\n    }\n}\n\nfn\
    \ main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `x`\n  --> /tmp/tmpz9exr2xl.rs:18:9\n   |\n18\
    \ |         x => match lst2.len() {\n   |         ^ help: if this is intentional,\
    \ prefix it with an underscore: `_x`\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n\nwarning: variable does not need to be mutable\n  --> /tmp/tmpz9exr2xl.rs:24:21\n\
    \   |\n24 |                 let mut s = lst1[i];\n   |                     ----^\n\
    \   |                     |\n   |                     help: remove this `mut`\n\
    \   |\n   = note: `#[warn(unused_mut)]` on by default\n\nerror[E0507]: cannot\
    \ move out of index of `Vec<String>`\n  --> /tmp/tmpz9exr2xl.rs:19:23\n   |\n\
    19 |             0 => vec![lst1[0]],\n   |                       ^^^^^^^ move\
    \ occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpz9exr2xl.rs:24:29\n\
    \   |\n24 |                 let mut s = lst1[i];\n   |                       \
    \      ^^^^^^^\n   |                             |\n   |                     \
    \        move occurs because value has type `String`, which does not implement\
    \ the `Copy` trait\n   |                             help: consider borrowing\
    \ here: `&lst1[i]`\n\nerror: aborting due to 2 previous errors; 2 warnings emitted\n\
    \nFor more information about this error, try `rustc --explain E0507`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        lst1\n    }\n    else {\n        let\
    \ mut sum = 0;\n        for i in 0..lst1.len() {\n            if lst1[i] < lst2[i]\
    \ {\n                sum += 1;\n            }\n        }\n        lst1.iter().take(sum).collect()\n\
    \    }\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&String`\n    --> /tmp/tmpb7v8f6y7.rs:26:31\n     |\n\
    26   |         lst1.iter().take(sum).collect()\n     |                       \
    \        ^^^^^^^ value of type `Vec<String>` cannot be built from `std::iter::Iterator<Item=&String>`\n\
    \     |\n     = help: the trait `FromIterator<&String>` is not implemented for\
    \ `Vec<String>`\n     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\n\
    note: required by a bound in `collect`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1\n    } else {\n      \
    \  let mut a = lst1.len();\n        let mut b = lst2.len();\n        let mut result:\
    \ Vec<String> = vec![];\n        let mut counter = 0;\n        while b > 0 ||\
    \ counter < a {\n            while counter < a && a[counter] < lst1[counter] {\n\
    \                counter += 1;\n            }\n            while counter < b &&\
    \ lst1[counter] > lst2[counter] {\n                counter += 1;\n           \
    \ }\n            if counter < a {\n                result.append(lst1[counter]);\n\
    \                a -= 1;\n            } else {\n                result.append(lst2[counter]);\n\
    \                b -= 1;\n            }\n        }\n        return result;\n \
    \   }\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0608]: cannot index into a value of type `usize`\n  --> /tmp/tmpex2nfs_f.rs:24:34\n\
    \   |\n24 |             while counter < a && a[counter] < lst1[counter] {\n  \
    \ |                                  ^^^^^^^^^^\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpex2nfs_f.rs:31:31\n   |\n31 |                 result.append(lst1[counter]);\n\
    \   |                               ^^^^^^^^^^^^^ expected `&mut Vec<String>`,\
    \ found struct `String`\n   |\n   = note: expected mutable reference `&mut Vec<String>`\n\
    \                         found struct `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpex2nfs_f.rs:34:31\n   |\n34 |                 result.append(lst2[counter]);\n\
    \   |                               ^^^^^^^^^^^^^ expected `&mut Vec<String>`,\
    \ found struct `String`\n   |\n   = note: expected mutable reference `&mut Vec<String>`\n\
    \                         found struct `String`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut mux = Vec::new();\n    for i in 0..lst1.len() {\n        if lst1[i]\
    \ < lst2[i] {\n            mux.push(lst1[i]);\n        }\n    }\n    mux\n}\n\n\
    fn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmper3sis8q.rs:19:22\n\
    \   |\n19 |             mux.push(lst1[i]);\n   |                      ^^^^^^^\
    \ move occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0507`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 101
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        lst1\n    }\n    else {\n        lst2\n\
    \    }\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"hi\", \"admin\"]`,\n right: `[\"hi\", \"hi\"]`', /tmp/tmp08wf_e63.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut min_length\
    \ = vec![String::from(\"\")];\n    for s in lst1 {\n        let mut min_str_len\
    \ = s.chars().filter(|c| c < '0').filter(|c| c >= '0').count();\n        let mut\
    \ min_str_len2 = s.chars().filter(|c| c < 'a').filter(|c| c >= 'a').count();\n\
    \        let mut min_str_len3 = s.chars().filter(|c| c < 'A').filter(|c| c >=\
    \ 'A').count();\n        min_length[0] = min_length[0]\n            .max_by_key(|i|\
    \ *i as usize + min_str_len as usize + min_str_len2 as usize + min_str_len3 as\
    \ usize + 1);\n    }\n\n    for s in lst2 {\n        let mut min_str_len = s.chars().filter(|c|\
    \ c < '0').filter(|c| c >= '0').count();\n        let mut min_str_len2 = s.chars().filter(|c|\
    \ c < 'a').filter(|c| c >= 'a').count();\n        let mut min_str_len3 = s.chars().filter(|c|\
    \ c < 'A').filter(|c| c >= 'A').count();\n        min_length[0] = min_length[0]\n\
    \            .max_by_key(|i| *i as usize + min_str_len as usize + min_str_len2\
    \ as usize + min_str_len3 as usize + 1);\n    }\n\n    for s in min_length {\n\
    \        let mut max_str_len = s.chars().filter(|c| c < '0').filter(|c| c >= '0').count();\n\
    \        let mut max_str_len2 = s.chars().filter(|c| c < 'a').filter(|c| c >=\
    \ 'a').count();\n        let mut max_str_len3 = s.chars().filter(|c| c < 'A').filter(|c|\
    \ c >= 'A').count();\n        max_str_len += max_str_len2;\n        max_str_len\
    \ += max_str_len3;\n        if max_str_len == 0 {\n            max_str_len = 1;\n\
    \        }\n    }\n\n    min_length.iter().take(lst1.len()).cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplbc7qk2m.rs:21:56\n   |\n\
    21 |         let mut min_str_len = s.chars().filter(|c| c < '0').filter(|c| c\
    \ >= '0').count();\n   |                                                     \
    \   ^^^\n   |                                                        |\n   | \
    \                                                       expected `&char`, found\
    \ `char`\n   |                                                        help: consider\
    \ borrowing here: `&'0'`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplbc7qk2m.rs:21:77\n\
    \   |\n21 |         let mut min_str_len = s.chars().filter(|c| c < '0').filter(|c|\
    \ c >= '0').count();\n   |                                                   \
    \                          ^^^\n   |                                         \
    \                                    |\n   |                                 \
    \                                            expected `&char`, found `char`\n\
    \   |                                                                        \
    \     help: consider borrowing here: `&'0'`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmplbc7qk2m.rs:22:57\n   |\n22 |         let mut min_str_len2 = s.chars().filter(|c|\
    \ c < 'a').filter(|c| c >= 'a').count();\n   |                               \
    \                          ^^^\n   |                                         \
    \                |\n   |                                                     \
    \    expected `&char`, found `char`\n   |                                    \
    \                     help: consider borrowing here: `&'a'`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmplbc7qk2m.rs:22:78\n   |\n22 |         let mut min_str_len2\
    \ = s.chars().filter(|c| c < 'a').filter(|c| c >= 'a').count();\n   |        \
    \                                                                      ^^^\n \
    \  |                                                                         \
    \     |\n   |                                                                \
    \              expected `&char`, found `char`\n   |                          \
    \                                             "
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut total: usize = 0;\n    for el1 in lst1 {\n        let mut found =\
    \ false;\n        for el2 in lst2 {\n            if el1 == el2 {\n           \
    \     found = true;\n                break;\n            }\n        }\n      \
    \  if !found {\n            total += 1;\n        }\n    }\n    lst1.iter().filter(|&el|\
    \ el == &lst1[0]).cloned()\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc5db5vtz.rs:29:5\n   |\n\
    15 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n \
    \  |                                                         ----------- expected\
    \ `Vec<String>` because of return type\n...\n29 |     lst1.iter().filter(|&el|\
    \ el == &lst1[0]).cloned()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found struct `Cloned`\n   |\n   = note: expected struct\
    \ `Vec<String>`\n              found struct `Cloned<Filter<std::slice::Iter<'_,\
    \ String>, [closure@/tmp/tmpc5db5vtz.rs:29:24: 29:44]>>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == 0 && lst2.len() == 0 {\n        return vec![];\n    }\n\
    \    if lst1.len() == 0 {\n        return vec![*lst2];\n    }\n    if lst2.len()\
    \ == 0 {\n        return vec![*lst1];\n    }\n    let mut total_match = 0;\n \
    \   for (i, s) in lst1.iter().enumerate() {\n        if i < lst2.len() {\n   \
    \         let v = &lst2[i];\n            if *s == *v {\n                total_match\
    \ += 1;\n            }\n        }\n    }\n    if lst1.len() > total_match {\n\
    \        return vec![*lst1];\n    }\n    if lst2.len() > total_match {\n     \
    \   return vec![*lst2];\n    }\n    if lst1.len() == total_match && lst2.len()\
    \ == total_match {\n        return vec![*lst1];\n    }\n    vec![*lst1]\n}\n\n\
    fn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb0xh93qu.rs:20:21\n   |\n\
    20 |         return vec![*lst2];\n   |                     ^^^^^ expected struct\
    \ `String`, found slice\n   |\n   = note: expected struct `String`\n         \
    \      found slice `[String]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb0xh93qu.rs:23:21\n\
    \   |\n23 |         return vec![*lst1];\n   |                     ^^^^^ expected\
    \ struct `String`, found slice\n   |\n   = note: expected struct `String`\n  \
    \             found slice `[String]`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpb0xh93qu.rs:35:21\n   |\n35 |         return vec![*lst1];\n   |    \
    \                 ^^^^^ expected struct `String`, found slice\n   |\n   = note:\
    \ expected struct `String`\n               found slice `[String]`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpb0xh93qu.rs:38:21\n   |\n38 |         return\
    \ vec![*lst2];\n   |                     ^^^^^ expected struct `String`, found\
    \ slice\n   |\n   = note: expected struct `String`\n               found slice\
    \ `[String]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb0xh93qu.rs:41:21\n\
    \   |\n41 |         return vec![*lst1];\n   |                     ^^^^^ expected\
    \ struct `String`, found slice\n   |\n   = note: expected struct `String`\n  \
    \             found slice `[String]`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpb0xh93qu.rs:43:10\n   |\n43 |     vec![*lst1]\n   |          ^^^^^ expected\
    \ struct `String`, found slice\n   |\n   = note: expected struct `String`\n  \
    \             found slice `[String]`\n\nerror: aborting due to 6 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut total_match: Vec<String> = Vec::new();\n    if lst1.len() == lst2.len()\
    \ {\n        for i in 0..lst1.len() {\n            let len = lst1[i].len() + lst2[i].len();\n\
    \            if len < lst2.len() {\n                total_match.push(lst1[i]);\n\
    \            }\n        }\n    }\n    total_match\n}\n\nfn main() {\n    let candidate\
    \ = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpkzsp6ht2.rs:21:34\n\
    \   |\n21 |                 total_match.push(lst1[i]);\n   |                 \
    \                 ^^^^^^^ move occurs because value has type `String`, which does\
    \ not implement the `Copy` trait\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0507`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() != lst2.len() {\n        return vec![];\n    }\n    if lst1.len()\
    \ == 0 {\n        return vec![];\n    }\n    \n    let mut sum = 0;\n    for x\
    \ in lst1 {\n        for y in lst2 {\n            sum += x.chars().filter(|c|\
    \ c <= y).count();\n        }\n    }\n    if sum == lst1.len() {\n        return\
    \ lst1;\n    }\n    vec![String::from_str(&(lst1[0].to_string())[sum..])]\n}\n\
    \nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmph8aun5ba.rs:26:46\n   |\n\
    26 |             sum += x.chars().filter(|c| c <= y).count();\n   |          \
    \                                    ^ expected `&char`, found struct `String`\n\
    \nerror[E0599]: no function or associated item named `from_str` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmph8aun5ba.rs:32:18\n   |\n32 | \
    \    vec![String::from_str(&(lst1[0].to_string())[sum..])]\n   |             \
    \     ^^^^^^^^ function or associated item not found in `String`\n   |\n   = help:\
    \ items from traits can only be used if the trait is in scope\nhelp: the following\
    \ trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1\
    \  | use std::str::FromStr;\n   |\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut lst = Vec::new();\n    lst1.iter().for_each(|s| {\n        if let\
    \ Some(match) = lst2.iter().find(|s| s <= s) {\n            lst.push(match);\n\
    \        } else {\n            lst.push(s);\n        }\n    });\n    lst\n}\n\n\
    fn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found keyword `match`\n  --> /tmp/tmpo973mzkx.rs:18:21\n\
    \   |\n18 |         if let Some(match) = lst2.iter().find(|s| s <= s) {\n   |\
    \                     ^^^^^ expected identifier, found keyword\n   |\nhelp: escape\
    \ `match` to use it as an identifier\n   |\n18 |         if let Some(r#match)\
    \ = lst2.iter().find(|s| s <= s) {\n   |                     ++\n\nerror: expected\
    \ expression, found `)`\n  --> /tmp/tmpo973mzkx.rs:19:27\n   |\n19 |         \
    \    lst.push(match);\n   |                      -----^ expected expression\n\
    \   |                      |\n   |                      while parsing this `match`\
    \ expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo973mzkx.rs:24:5\n\
    \   |\n15 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |                                                         -----------\
    \ expected `Vec<String>` because of return type\n...\n24 |     lst\n   |     ^^^\
    \ expected struct `String`, found `&String`\n   |\n   = note: expected struct\
    \ `Vec<String>`\n              found struct `Vec<&String>`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1\n    }\n\n    let mut\
    \ res = vec![];\n    for i in 0..lst1.len() {\n        if lst1[i] < lst2[i] {\n\
    \            res = res.push(lst1[i]);\n        }\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdz4677w3.rs:23:19\n   |\n\
    20 |     let mut res = vec![];\n   |                   ------ expected due to\
    \ this value\n...\n23 |             res = res.push(lst1[i]);\n   |           \
    \        ^^^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\n   = note:\
    \ expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    match lst1.len() {\n        0 => lst2,\n        _ => total_match(lst1, total_match_iter(lst2,\
    \ lst1))\n    }\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `total_match_iter` in this scope\n \
    \ --> /tmp/tmpbypmprwm.rs:18:32\n   |\n18 |         _ => total_match(lst1, total_match_iter(lst2,\
    \ lst1))\n   |                                ^^^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 101
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        lst1\n    } else {\n        lst2\n\
    \    }\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"hi\", \"admin\"]`,\n right: `[\"hi\", \"hi\"]`', /tmp/tmp5fohhy0d.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == 0 && lst2.len() == 0 {\n        return Vec::new();\n   \
    \ }\n    if lst1.len() == 0 {\n        return lst2;\n    }\n    if lst2.len()\
    \ == 0 {\n        return lst1;\n    }\n\n    let mut total_len = 0;\n    for el1\
    \ in lst1 {\n        for el2 in lst2 {\n            if el1.len() < el2.len() {\n\
    \                total_len += el1.len();\n            } else if el1.len() > el2.len()\
    \ {\n                total_len += el2.len();\n            }\n        }\n    }\n\
    \    if total_len == lst1.len() {\n        return lst1;\n    } else if total_len\
    \ == lst2.len() {\n        return lst2;\n    }\n    lst1.iter().zip(lst2.iter()).fold(\n\
    \        vec![],\n        |mut acc, (el1, el2)| {\n            if el1.len() <\
    \ el2.len() {\n                acc.push(el1);\n            } else if el1.len()\
    \ > el2.len() {\n                acc.push(el2);\n            }\n            acc\n\
    \        },\n    )\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4llar7fm.rs:45:26\n   |\n\
    45 |                 acc.push(el1);\n   |                          ^^^- help:\
    \ try using a conversion method: `.to_string()`\n   |                        \
    \  |\n   |                          expected struct `String`, found `&String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp4llar7fm.rs:47:26\n   |\n47 |\
    \                 acc.push(el2);\n   |                          ^^^- help: try\
    \ using a conversion method: `.to_string()`\n   |                          |\n\
    \   |                          expected struct `String`, found `&String`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        lst1\n    } else {\n        lst2.iter().enumerate().filter(|(i,\
    \ item)| {\n            lst1[i].len() <= item.len() as i64\n        }).map(|(i,\
    \ item)| {\n            lst1[i]\n        }).collect()\n    }\n}\n\nfn main() {\n\
    \    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[String]` cannot be indexed by `&usize`\n  -->\
    \ /tmp/tmpafuea59q.rs:20:13\n   |\n20 |             lst1[i].len() <= item.len()\
    \ as i64\n   |             ^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[String]>` is not implemented\
    \ for `&usize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<&usize>`\
    \ for `Vec<String>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut res = vec![];\n    let mut cnt = 0;\n    for el1 in lst1 {\n    \
    \    if el1.len() > cnt {\n            for el2 in lst2 {\n                if el2\
    \ == el1 {\n                    res.push(el1);\n                    cnt += el1.len();\n\
    \                    break;\n                }\n            }\n        }\n   \
    \ }\n    if cnt == lst1.len() {\n        res\n    } else if cnt == 0 {\n     \
    \   vec![String::from(\"__EMPTY__\")]\n    } else {\n        vec![String::from(\"\
    __TOO_LARGE__\")]\n    }\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmpxlntwer9.rs:20:24\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n20  |  \
    \           for el2 in lst2 {\n    |                        ^^^^ `lst2` moved\
    \ due to this implicit call to `.into_iter()`, in previous iteration of loop\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `lst2`\nhelp: consider iterating over a slice of the `Vec<String>`'s content\
    \ to avoid moving into the `for` loop\n    |\n20  |             for el2 in &lst2\
    \ {\n    |                        +\n\nerror[E0382]: borrow of moved value: `el1`\n\
    \  --> /tmp/tmpxlntwer9.rs:23:28\n   |\n18 |     for el1 in lst1 {\n   |     \
    \    --- move occurs because `el1` has type `String`, which does not implement\
    \ the `Copy` trait\n...\n22 |                     res.push(el1);\n   |       \
    \                       --- value moved here\n23 |                     cnt +=\
    \ el1.len();\n   |                            ^^^^^^^^^ value borrowed here after\
    \ move\n\nerror[E0382]: borrow of moved value: `lst1`\n  --> /tmp/tmpxlntwer9.rs:29:15\n\
    \   |\n15 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |                ---- move occurs because `lst1` has type `Vec<String>`,\
    \ which does not implement the `Copy` trait\n...\n18 |     for el1 in lst1 {\n\
    \   |                ---- `lst1` moved due to this implicit call to `.into_iter()`\n\
    ...\n29 |     if cnt == lst1.len() {\n   |               ^^^^^^^^^^ value borrowed\
    \ here after move\n   |\nhelp: consider iterating over a slice of the `Vec<String>`'s\
    \ content to avoid moving into the `for` loop\n   |\n18 |     for el1 in &lst1\
    \ {\n   |                +\n\nerror: aborting due to 3 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut total_len = vec![0; lst2.len()];\n    for i in 0..lst1.len() {\n\
    \        total_len[i] = lst1[i].len();\n    }\n    for i in 0..lst2.len() {\n\
    \        total_len += lst2[i].chars().take(total_len[i]).count();\n    }\n   \
    \ for i in 0..total_len.len() {\n        if total_len[i] < lst1.len() {\n    \
    \        total_len[i] = lst1.len();\n        }\n    }\n    if total_len.len()\
    \ != lst1.len() {\n        total_len = total_len.iter().cloned().collect();\n\
    \    }\n    total_len\n}\n\nfn main() {\n    let candidate = total_match;\n  \
    \  assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `Vec<usize>`\n  --> /tmp/tmp9emoc00j.rs:21:9\n   |\n21 |         total_len +=\
    \ lst2[i].chars().take(total_len[i]).count();\n   |         ---------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |         |\n   |         cannot use `+=` on type `Vec<usize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9emoc00j.rs:31:5\n   |\n15 | fn total_match(lst1:\
    \ Vec<String>, lst2: Vec<String>) -> Vec<String> {\n   |                     \
    \                                    ----------- expected `Vec<String>` because\
    \ of return type\n...\n31 |     total_len\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `usize`\n   |\n   = note: expected struct `Vec<String>`\n  \
    \            found struct `Vec<usize>`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0368.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut ret:\
    \ Vec<String> = vec![];\n    for i in 0..lst1.len() {\n        if lst2[i] > lst1[i]\
    \ {\n            return ret;\n        }\n    }\n    ret.push(lst1.clone());\n\
    \    ret.push(lst2.clone());\n    ret\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0rruuix_.rs:25:14\n   |\n\
    25 |     ret.push(lst1.clone());\n   |              ^^^^^^^^^^^^ expected struct\
    \ `String`, found struct `Vec`\n   |\n   = note: expected struct `String`\n  \
    \            found struct `Vec<String>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp0rruuix_.rs:26:14\n   |\n26 |     ret.push(lst2.clone());\n   |    \
    \          ^^^^^^^^^^^^ expected struct `String`, found struct `Vec`\n   |\n \
    \  = note: expected struct `String`\n              found struct `Vec<String>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() != lst2.len() {\n        return vec![];\n    }\n    \n    if\
    \ lst1.is_empty() && lst2.is_empty() {\n        return vec![];\n    }\n    \n\
    \    let mut total_len: usize = 0;\n    for i in 0..lst1.len() {\n        let\
    \ s1 = lst1[i];\n        let s2 = lst2[i];\n        total_len = total_len + s1.len();\n\
    \        total_len = total_len + s2.len();\n    }\n    let mut total_len = total_len\
    \ as usize;\n    \n    for i in 0..lst1.len() {\n        if let Some(s1) = lst1.get(i)\
    \ {\n            if let Some(s2) = lst2.get(i) {\n                let len1 = s1.len();\n\
    \                let len2 = s2.len();\n                if len1 > total_len {\n\
    \                    total_len = len1;\n                }\n                if\
    \ len2 > total_len {\n                    total_len = len2;\n                }\n\
    \            }\n        }\n    }\n    \n    if total_len == lst1.len() {\n   \
    \     return vec![];\n    }\n    \n    match lst2.len() {\n        0 => vec![],\n\
    \        _ => {\n            let mut lst3 = vec![];\n            for i in 0..total_len\
    \ {\n                let s3 = String::from(\"\");\n                let s1 = String::from(\"\
    \");\n                let len3 = i as usize;\n                if let Some(s1)\
    \ = lst1.get(len3 - 1) {\n                    if let Some(s2) = lst2.get(len3\
    \ - 1) {\n                        s3 = s1 + s2;\n                    }\n     \
    \           }\n                if let Some(s2) = lst2.get(len3) {\n          \
    \          s3 = s1 + s2;\n                }\n                lst3.push(s3);\n\
    \            }\n            return lst3;\n        }\n    }\n}\n\nfn main() {\n\
    \    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot add `&String` to `&String`\n  --> /tmp/tmpibigtsxl.rs:62:33\n\
    \   |\n62 |                         s3 = s1 + s2;\n   |                      \
    \        -- ^ -- &String\n   |                              |  |\n   |       \
    \                       |  `+` cannot be used to concatenate two `&str` strings\n\
    \   |                              &String\n   |\n   = note: string concatenation\
    \ requires an owned `String` on the left\nhelp: create an owned `String` from\
    \ a string reference\n   |\n62 |                         s3 = s1.to_owned() +\
    \ s2;\n   |                                +++++++++++\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0369`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    lst1.iter().zip(lst2.iter()).filter(|(vec1,\
    \ vec2)| vec1.len() < vec2.len()).collect::<Vec<_>>()\n}\n\nfn main() {\n    let\
    \ candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptap9l3ik.rs:19:5\n   |\n\
    15 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n \
    \  |                                                         ----------- expected\
    \ `Vec<String>` because of return type\n...\n19 |     lst1.iter().zip(lst2.iter()).filter(|(vec1,\
    \ vec2)| vec1.len() < vec2.len()).collect::<Vec<_>>()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found tuple\n   |\n   = note: expected struct `Vec<String>`\n\
    \              found struct `Vec<(&String, &String)>`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return vec![lst1[0]];\n    }\n   \
    \ let mut count = 0;\n    for (index, val) in lst1.iter().zip(lst2.iter()).enumerate().rev()\
    \ {\n        if val > lst2[index] {\n            count += 1;\n        }\n    }\n\
    \    vec![lst1[count - 1]]\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppybtazfu.rs:21:18\n   |\n\
    21 |         if val > lst2[index] {\n   |                  ^^^^^^^^^^^ expected\
    \ tuple, found struct `String`\n   |\n   = note: expected tuple `(&String, &String)`\n\
    \             found struct `String`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut total_matcher = Vec::new();\n    let mut i = 0;\n    while i < lst1.len()\
    \ {\n        let mut j = 0;\n        while j < lst2.len() {\n            if lst1[i].len()\
    \ < lst2[j].len() {\n                break;\n            }\n            if lst1[i].len()\
    \ > lst2[j].len() {\n                j += 1;\n            } else {\n         \
    \       i += 1;\n            }\n        }\n        total_matcher.push(lst1[i]);\n\
    \        i += 1;\n    }\n    total_matcher\n}\n\nfn main() {\n    let candidate\
    \ = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmp8se11ioe.rs:30:28\n\
    \   |\n30 |         total_matcher.push(lst1[i]);\n   |                       \
    \     ^^^^^^^ move occurs because value has type `String`, which does not implement\
    \ the `Copy` trait\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0507`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1\n    }\n    if lst1.len()\
    \ < lst2.len() {\n        let mut res = Vec::new();\n        for value in lst1\
    \ {\n            if lst2.iter().any(|&v| v == value) {\n                continue;\n\
    \            }\n            res.push(value);\n        }\n        return res;\n\
    \    }\n    let mut res = Vec::new();\n    for value in lst2 {\n        if lst1.iter().any(|&v|\
    \ v == value) {\n            continue;\n        }\n        res.push(value);\n\
    \    }\n    return res;\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0507]: cannot move out of a shared reference\n  --> /tmp/tmpz9b39jw6.rs:22:33\n\
    \   |\n22 |             if lst2.iter().any(|&v| v == value) {\n   |          \
    \                       ^-\n   |                                 ||\n   |    \
    \                             |data moved here\n   |                         \
    \        |move occurs because `v` has type `String`, which does not implement\
    \ the `Copy` trait\n   |                                 help: consider removing\
    \ the `&`: `v`\n\nerror[E0507]: cannot move out of a shared reference\n  --> /tmp/tmpz9b39jw6.rs:31:29\n\
    \   |\n31 |         if lst1.iter().any(|&v| v == value) {\n   |              \
    \               ^-\n   |                             ||\n   |                \
    \             |data moved here\n   |                             |move occurs\
    \ because `v` has type `String`, which does not implement the `Copy` trait\n \
    \  |                             help: consider removing the `&`: `v`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0507`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    match lst1.len() {\n        0 => lst2,\n        1 => lst1,\n        2 =>\
    \ if lst1[0] == lst2[0] {\n            vec![lst1[0]]\n        } else {\n     \
    \       vec![lst1[0]]\n        },\n        3 if lst1[0] == lst2[0] && lst1[1]\
    \ != lst2[1] => vec![lst1[0]],\n        4 if lst1[0] == lst2[0] && lst1[1] !=\
    \ lst2[1] && lst1[2] != lst2[2] => vec![lst1[0]],\n        5 => if lst1[0] ==\
    \ lst2[0] && lst1[1] != lst2[1] && lst1[2] != lst2[2] && lst1[3] != lst2[3] {\n\
    \            vec![lst1[0]]\n        } else if lst1[0] == lst2[0] && lst1[1] !=\
    \ lst2[1] && lst1[2] != lst2[2] {\n            vec![lst1[0], lst1[1]]\n      \
    \  } else if lst1[0] == lst2[0] && lst1[1] != lst2[1] {\n            vec![lst1[0],\
    \ lst1[1], lst1[2]]\n        } else if lst1[0] == lst2[0] && lst1[2] != lst2[2]\
    \ {\n            vec![lst1[0], lst1[1], lst1[2]]\n        } else if lst1[0] !=\
    \ lst2[0] {\n            vec![lst1[0], lst1[1], lst1[2], lst1[3]]\n        } else\
    \ if lst1[0] != lst2[0] && lst1[1] != lst2[1] && lst1[2] != lst2[2] {\n      \
    \      vec![lst1[0], lst1[1], lst1[2]]\n        } else {\n            vec![lst1[0],\
    \ lst1[1], lst1[2], lst1[3]]\n        }\n    }\n}\n\nfn main() {\n    let candidate\
    \ = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0004]: non-exhaustive patterns: `_` not covered\n  --> /tmp/tmpydm9r5z5.rs:16:11\n\
    \   |\n16 |     match lst1.len() {\n   |           ^^^^^^^^^^ pattern `_` not\
    \ covered\n   |\n   = note: the matched value is of type `usize`\n   = note: `usize`\
    \ does not have a fixed maximum value, so a wildcard `_` is necessary to match\
    \ exhaustively\nhelp: ensure that all possible cases are being handled by adding\
    \ a match arm with a wildcard pattern or an explicit pattern as shown\n   |\n\
    40 ~         },\n41 +         _ => todo!()\n   |\n\nerror[E0507]: cannot move\
    \ out of index of `Vec<String>`\n  --> /tmp/tmpydm9r5z5.rs:20:18\n   |\n20 | \
    \            vec![lst1[0]]\n   |                  ^^^^^^^ move occurs because\
    \ value has type `String`, which does not implement the `Copy` trait\n\nerror[E0507]:\
    \ cannot move out of index of `Vec<String>`\n  --> /tmp/tmpydm9r5z5.rs:22:18\n\
    \   |\n22 |             vec![lst1[0]]\n   |                  ^^^^^^^ move occurs\
    \ because value has type `String`, which does not implement the `Copy` trait\n\
    \nerror[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpydm9r5z5.rs:24:63\n\
    \   |\n24 |         3 if lst1[0] == lst2[0] && lst1[1] != lst2[1] => vec![lst1[0]],\n\
    \   |                                                               ^^^^^^^ move\
    \ occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpydm9r5z5.rs:25:85\n\
    \   |\n25 |         4 if lst1[0] == lst2[0] && lst1[1] != lst2[1] && lst1[2] !=\
    \ lst2[2] => vec![lst1[0]],\n   |                                            \
    \                                         ^^^^^^^ move occurs because value has\
    \ type `String`, which does not implement the `Copy` trait\n\nerror[E0507]: cannot\
    \ move out of index of `Vec<String>`\n  --> /tmp/tmpydm9r5z5.rs:27:18\n   |\n\
    27 |             vec![lst1[0]]\n   |                  ^^^^^^^ move occurs because\
    \ value has type `String`, which does not implement the `Copy` trait\n\nerror[E0507]:\
    \ cannot move out of index of `Vec<String>`\n  --> /tmp/tmpydm9r5z5.rs:29:18\n\
    \   |\n2"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        for (a, b) in lst1.iter().zip(lst2.iter())\
    \ {\n            if a.len() < b.len() {\n                lst1\n            } else\
    \ {\n                lst2\n            }\n        }\n    } else {\n        lst1\n\
    \    }\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpddjh3488.rs:19:17\n   |\n\
    18 | /             if a.len() < b.len() {\n19 | |                 lst1\n   | |\
    \                 ^^^^ expected `()`, found struct `Vec`\n20 | |             }\
    \ else {\n21 | |                 lst2\n22 | |             }\n   | |_____________-\
    \ expected this to be `()`\n   |\n   = note: expected unit type `()`\n       \
    \          found struct `Vec<String>`\nhelp: you might have meant to return this\
    \ value\n   |\n19 |                 return lst1;\n   |                 ++++++\
    \     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpddjh3488.rs:21:17\n \
    \  |\n18 | /             if a.len() < b.len() {\n19 | |                 lst1\n\
    20 | |             } else {\n21 | |                 lst2\n   | |             \
    \    ^^^^ expected `()`, found struct `Vec`\n22 | |             }\n   | |_____________-\
    \ expected this to be `()`\n   |\n   = note: expected unit type `()`\n       \
    \          found struct `Vec<String>`\nhelp: you might have meant to return this\
    \ value\n   |\n21 |                 return lst2;\n   |                 ++++++\
    \     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpddjh3488.rs:17:9\n  \
    \ |\n15 |   fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |                                                           -----------\
    \ expected `Vec<String>` because of return type\n16 |       if lst1.len() == lst2.len()\
    \ {\n17 | /         for (a, b) in lst1.iter().zip(lst2.iter()) {\n18 | |     \
    \        if a.len() < b.len() {\n19 | |                 lst1\n20 | |         \
    \    } else {\n21 | |                 lst2\n22 | |             }\n23 | |     \
    \    }\n   | |_________^ expected struct `Vec`, found `()`\n   |\n   = note: expected\
    \ struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due\
    \ to 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        for (i, el1) in lst1.iter().zip(lst2.iter()).cloned().zip(&mut\
    \ [0]).map(|(a,b)| {\n            (b as usize) - (a as usize)\n        }).take(lst1.len()).enumerate()\
    \ {\n            if *el1 <= *el2 {\n                lst2.swap(lst1, i);\n    \
    \        }\n        }\n        lst2\n    } else {\n        lst1\n    }\n}\n\n\
    fn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `el2` in this scope\n  --> /tmp/tmpp53svhr0.rs:20:25\n\
    \   |\n20 |             if *el1 <= *el2 {\n   |                         ^^^ help:\
    \ a local variable with a similar name exists: `el1`\n\nerror[E0271]: type mismatch\
    \ resolving `<Zip<std::slice::Iter<'_, String>, std::slice::Iter<'_, String>>\
    \ as Iterator>::Item == &_`\n    --> /tmp/tmpp53svhr0.rs:17:54\n     |\n17   |\
    \         for (i, el1) in lst1.iter().zip(lst2.iter()).cloned().zip(&mut [0]).map(|(a,b)|\
    \ {\n     |                                                      ^^^^^^ expected\
    \ reference, found tuple\n     |\n     = note: expected reference `&_`\n     \
    \               found tuple `(&String, &String)`\nnote: required by a bound in\
    \ `cloned`\n\nerror[E0599]: the method `zip` exists for struct `Cloned<Zip<std::slice::Iter<'_,\
    \ String>, std::slice::Iter<'_, String>>>`, but its trait bounds were not satisfied\n\
    \  --> /tmp/tmpp53svhr0.rs:17:63\n   |\n17 |            for (i, el1) in lst1.iter().zip(lst2.iter()).cloned().zip(&mut\
    \ [0]).map(|(a,b)| {\n   |                                                   \
    \               ^^^ method cannot be called on `Cloned<Zip<std::slice::Iter<'_,\
    \ String>, std::slice::Iter<'_, String>>>` due to unsatisfied trait bounds\n \
    \  |\n   = note: the following trait bounds were not satisfied:\n           `<Zip<std::slice::Iter<'_,\
    \ String>, std::slice::Iter<'_, String>> as Iterator>::Item = &_`\n          \
    \ which is required by `Cloned<Zip<std::slice::Iter<'_, String>, std::slice::Iter<'_,\
    \ String>>>: Iterator`\n           `Cloned<Zip<std::slice::Iter<'_, String>, std::slice::Iter<'_,\
    \ String>>>: Iterator`\n           which is required by `&mut Cloned<Zip<std::slice::Iter<'_,\
    \ String>, std::slice::Iter<'_, String>>>: Iterator`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpp53svhr0.rs:21:27\n   |\n21 |                 lst2.swap(lst1,\
    \ i);\n   |                           ^^^^ expected `usize`, found struct `Vec`\n\
    \   |\n   = note: expected type `usize`\n            found struct `Vec<String>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detaile"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut result = vec![];\n    let mut i = 1;\n    for elem in lst1 {\n  \
    \      if i > lst2.len() {\n            return vec![elem];\n        }\n      \
    \  if elem.len() > lst2[i].len() {\n            i += 1;\n            continue;\n\
    \        }\n        for _ in 0..elem.len() {\n            if lst2[i].starts_with(elem)\
    \ {\n                i += 1;\n            }\n        }\n    }\n    result.push(elem);\n\
    \    result\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `elem` in this scope\n  --> /tmp/tmpx7pr2j1d.rs:32:17\n\
    \   |\n32 |     result.push(elem);\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n\
    \    --> /tmp/tmpx7pr2j1d.rs:27:36\n     |\n27   |             if lst2[i].starts_with(elem)\
    \ {\n     |                        ----------- ^^^^ expected an implementor of\
    \ trait `Pattern<'_>`\n     |                        |\n     |               \
    \         required by a bound introduced by this call\n     |\n     = note: the\
    \ trait bound `String: Pattern<'_>` is not satisfied\n     = note: required because\
    \ of the requirements on the impl of `Pattern<'_>` for `String`\nnote: required\
    \ by a bound in `core::str::<impl str>::starts_with`\nhelp: consider borrowing\
    \ here\n     |\n27   |             if lst2[i].starts_with(&elem) {\n     |   \
    \                                 +\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        lst1\n    } else {\n        let mut\
    \ res: Vec<String> = vec![];\n        for i in 0..lst1.len() {\n            if\
    \ !lst2.iter().any(|&s| s == lst1[i]) {\n                res.push(lst1[i]);\n\
    \            }\n        }\n        res\n    }\n}\n\nfn main() {\n    let candidate\
    \ = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0507]: cannot move out of a shared reference\n  --> /tmp/tmpnpj5_q5t.rs:21:34\n\
    \   |\n21 |             if !lst2.iter().any(|&s| s == lst1[i]) {\n   |       \
    \                           ^-\n   |                                  ||\n   |\
    \                                  |data moved here\n   |                    \
    \              |move occurs because `s` has type `String`, which does not implement\
    \ the `Copy` trait\n   |                                  help: consider removing\
    \ the `&`: `s`\n\nerror[E0507]: cannot move out of index of `Vec<String>`\n  -->\
    \ /tmp/tmpnpj5_q5t.rs:22:26\n   |\n22 |                 res.push(lst1[i]);\n \
    \  |                          ^^^^^^^ move occurs because value has type `String`,\
    \ which does not implement the `Copy` trait\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0507`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    lst2.iter().filter_map(|str| {\n        match lst1.iter().count(|x| x <=\
    \ str) {\n            0 => true,\n            _ => false,\n        }\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmp_zrgdc2u.rs:17:27\n    |\n17  |         match lst1.iter().count(|x|\
    \ x <= str) {\n    |                           ^^^^^ ------------ supplied 1 argument\n\
    \    |                           |\n    |                           expected 0\
    \ arguments\n    |\nnote: associated function defined here\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_zrgdc2u.rs:18:18\n   |\n18 |             0 => true,\n\
    \   |                  ^^^^ expected enum `Option`, found `bool`\n   |\n   = note:\
    \ expected enum `Option<_>`\n              found type `bool`\nhelp: try wrapping\
    \ the expression in `Some`\n   |\n18 |             0 => Some(true),\n   |    \
    \              +++++    +\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0061, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut len1 = lst1.len();\n    let mut len2 = lst2.len();\n\n    if len1\
    \ == len2 {\n        return lst1;\n    }\n\n    if len1 > len2 {\n        len2\
    \ += len1 - len2;\n    }\n    let mut vec1 = vec![String::default(); len1];\n\
    \    let mut vec2 = vec![String::default(); len2];\n    for i in (0..len1).rev()\
    \ {\n        vec1.push((lst1[i])[..]);\n    }\n    for i in (0..len2).rev() {\n\
    \        vec2.push((lst2[i])[..]);\n    }\n    for i in (0..(len1 + len2)).rev()\
    \ {\n        if vec1[i] == vec2[i] {\n            continue;\n        }\n     \
    \   let mut j = (i + len1) % len2;\n        vec1.swap(i, j);\n    }\n    vec1\n\
    }\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprgei_t4h.rs:29:19\n   |\n\
    29 |         vec1.push((lst1[i])[..]);\n   |                   ^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \ |\n   |                   expected struct `String`, found `str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmprgei_t4h.rs:32:19\n   |\n32 |         vec2.push((lst2[i])[..]);\n\
    \   |                   ^^^^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                   |\n   |                   expected struct `String`, found\
    \ `str`\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() != lst2.len() { return vec![] }\n    let mut lst = vec![];\n\
    \    for i in 0..lst1.len() {\n        if lst1[i] < lst2[i] {\n            lst.append(lst1[i]);\n\
    \        }\n    }\n    return lst\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4i2w4vkg.rs:20:24\n   |\n\
    20 |             lst.append(lst1[i]);\n   |                        ^^^^^^^ expected\
    \ `&mut Vec<_>`, found struct `String`\n   |\n   = note: expected mutable reference\
    \ `&mut Vec<_>`\n                         found struct `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return vec![lst1[0]]\n    }\n    vec![lst1[0]]\
    \ if lst2.len() > 0 && lst1.len() > 0 && total_match(lst1, lst1.iter().rev()).len()\
    \ < total_match(lst2, lst2.iter().rev()).len();\n    vec![lst2[0]] if lst1.len()\
    \ > 0 && lst2.len() > 0 && total_match(lst1, lst1.iter().rev()).len() < total_match(lst2,\
    \ lst2.iter().rev()).len();\n    vec![lst1[0]] if lst1.len() == lst2.len() &&\
    \ lst1.len() <= lst2.len();\n    vec![lst2[0]] if lst1.len() == lst2.len() &&\
    \ lst1.len() <= lst2.len();\n    if lst1.len() > lst2.len() {\n        vec![lst1[0],\
    \ lst2[0]] if total_match(lst1.iter().rev(), lst2.iter().rev()).len() < lst1.len();\n\
    \    }\n    if lst2.len() > lst1.len() {\n        vec![lst2[0], lst1[0]] if total_match(lst1.iter().rev(),\
    \ lst2.iter().rev()).len() < lst2.len();\n    }\n    if lst1.len() == lst2.len()\
    \ {\n        vec![lst1[0]]\n    }\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found keyword\
    \ `if`\n  --> /tmp/tmp0kn4f82j.rs:19:19\n   |\n19 |     vec![lst1[0]] if lst2.len()\
    \ > 0 && lst1.len() > 0 && total_match(lst1, lst1.iter().rev()).len() < total_match(lst2,\
    \ lst2.iter().rev()...\n   |                   ^^ expected one of `.`, `;`, `?`,\
    \ `}`, or an operator\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut total_chars = 0;\n    for x in lst1 {\n        total_chars += x.length();\n\
    \    }\n    for x in lst2 {\n        total_chars += x.length();\n    }\n    if\
    \ total_chars == lst1.len() {\n        return lst1;\n    }\n    if total_chars\
    \ == lst2.len() {\n        return lst2;\n    }\n    let mut lst3 = Vec::new();\n\
    \    for x in lst1 {\n        if x.chars().count() > total_chars {\n         \
    \   lst3.push(x);\n        }\n    }\n    for x in lst2 {\n        if x.chars().count()\
    \ > total_chars {\n            lst3.push(x);\n        }\n    }\n    lst3\n}\n\n\
    fn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpqndikeg7.rs:18:26\n   |\n18 |         total_chars\
    \ += x.length();\n   |                          ^^^^^^ help: there is an associated\
    \ function with a similar name: `len`\n\nerror[E0599]: no method named `length`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpqndikeg7.rs:21:26\n\
    \   |\n21 |         total_chars += x.length();\n   |                         \
    \ ^^^^^^ help: there is an associated function with a similar name: `len`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    \n    let\
    \ mut m = vec![];\n    \n    for i in 0..lst1.len() {\n        let j = i;\n  \
    \      \n        while j != lst1.len() {\n            if lst1[j] < lst1[j+i] {\n\
    \                break;\n            }\n            j += i;\n        }\n     \
    \   \n        m.push(lst1[i]);\n        i += j - i;\n    }\n    \n    m\n}\n\n\
    fn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "warning: value assigned to `i` is never read\n  --> /tmp/tmpsywxjb6s.rs:33:9\n\
    \   |\n33 |         i += j - i;\n   |         ^\n   |\n   = note: `#[warn(unused_assignments)]`\
    \ on by default\n   = help: maybe it is overwritten before being read?\n\nerror[E0384]:\
    \ cannot assign twice to immutable variable `j`\n  --> /tmp/tmpsywxjb6s.rs:29:13\n\
    \   |\n23 |         let j = i;\n   |             -\n   |             |\n   | \
    \            first assignment to `j`\n   |             help: consider making this\
    \ binding mutable: `mut j`\n...\n29 |             j += i;\n   |             ^^^^^^\
    \ cannot assign twice to immutable variable\n\nerror[E0507]: cannot move out of\
    \ index of `Vec<String>`\n  --> /tmp/tmpsywxjb6s.rs:32:16\n   |\n32 |        \
    \ m.push(lst1[i]);\n   |                ^^^^^^^ move occurs because value has\
    \ type `String`, which does not implement the `Copy` trait\n\nerror[E0384]: cannot\
    \ assign twice to immutable variable `i`\n  --> /tmp/tmpsywxjb6s.rs:33:9\n   |\n\
    22 |     for i in 0..lst1.len() {\n   |         -\n   |         |\n   |      \
    \   first assignment to `i`\n   |         help: consider making this binding mutable:\
    \ `mut i`\n...\n33 |         i += j - i;\n   |         ^^^^^^^^^^ cannot assign\
    \ twice to immutable variable\n\nerror: aborting due to 3 previous errors; 1 warning\
    \ emitted\n\nSome errors have detailed explanations: E0384, E0507.\nFor more information\
    \ about an error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1\n    } else {\n      \
    \  let mut cnt = 0;\n        let mut cnt2 = 0;\n        let mut res = vec![];\n\
    \        for s in lst1 {\n            for s2 in lst2 {\n                if s <\
    \ s2 {\n                    cnt += 1;\n                    cnt2 += 1;\n      \
    \          }\n            }\n        }\n        if cnt == cnt2 {\n           \
    \ return res\n        } else {\n            return vec![]\n        }\n    }\n\
    }\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpsi84_zr2.rs:21:13\n\
    \   |\n21 |         let mut res = vec![];\n   |             ----^^^\n   |    \
    \         |\n   |             help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `lst2`\n   --> /tmp/tmpsi84_zr2.rs:23:23\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n23  |  \
    \           for s2 in lst2 {\n    |                       ^^^^ `lst2` moved due\
    \ to this implicit call to `.into_iter()`, in previous iteration of loop\n   \
    \ |\nnote: this function takes ownership of the receiver `self`, which moves `lst2`\n\
    help: consider iterating over a slice of the `Vec<String>`'s content to avoid\
    \ moving into the `for` loop\n    |\n23  |             for s2 in &lst2 {\n   \
    \ |                       +\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        lst1\n    } else {\n        let mut\
    \ n = 0;\n        for element in lst1 {\n            if lst2.iter().any(|x| x.contains(element))\
    \ {\n                n += 1;\n            }\n        }\n        lst1.iter().filter(|x|\
    \ !lst2.iter().any(|y| y.contains(x)));\n    }\n}\n\nfn main() {\n    let candidate\
    \ = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n   \
    \ --> /tmp/tmpoww7d7r0.rs:21:47\n     |\n21   |             if lst2.iter().any(|x|\
    \ x.contains(element)) {\n     |                                      --------\
    \ ^^^^^^^ expected an implementor of trait `Pattern<'_>`\n     |             \
    \                         |\n     |                                      required\
    \ by a bound introduced by this call\n     |\n     = note: the trait bound `String:\
    \ Pattern<'_>` is not satisfied\n     = note: required because of the requirements\
    \ on the impl of `Pattern<'_>` for `String`\nnote: required by a bound in `core::str::<impl\
    \ str>::contains`\nhelp: consider borrowing here\n     |\n21   |             if\
    \ lst2.iter().any(|x| x.contains(&element)) {\n     |                        \
    \                       +\n\nerror[E0277]: expected a `Fn<(char,)>` closure, found\
    \ `String`\n    --> /tmp/tmpoww7d7r0.rs:25:64\n     |\n25   |         lst1.iter().filter(|x|\
    \ !lst2.iter().any(|y| y.contains(x)));\n     |                              \
    \                         -------- ^ expected an `Fn<(char,)>` closure, found\
    \ `String`\n     |                                                       |\n \
    \    |                                                       required by a bound\
    \ introduced by this call\n     |\n     = help: the trait `Fn<(char,)>` is not\
    \ implemented for `String`\n     = help: the following other types implement trait\
    \ `Pattern<'a>`:\n               &'b String\n               &'b str\n        \
    \       &'c &'b str\n     = note: required because of the requirements on the\
    \ impl of `FnOnce<(char,)>` for `&String`\n     = note: required because of the\
    \ requirements on the impl of `Pattern<'_>` for `&&String`\nnote: required by\
    \ a bound in `core::str::<impl str>::contains`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpoww7d7r0.rs:18:12\n   |\n18 |       } else {\n   |  ____________^\n\
    19 | |         let mut n = 0;\n20 | |         for element in lst1 {\n21 | |  \
    \           if lst2.iter().any(|x| x.contains(element)) {\n...  |\n25 | |    \
    \     lst1.iter().filter(|x| !lst2.iter()."
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    match lst1.len() {\n        0 => vec![],\n        1 => lst1,\n        _ =>\
    \ lst1.iter()\n            .zip(lst2.iter())\n            .filter(|&(lhs, rhs)|\
    \ {\n                lhs.len() < rhs.len()\n            })\n            .map(|(lhs,\
    \ rhs)| {\n                lhs\n            })\n            .collect()\n    }\n\
    }\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&String`\n    --> /tmp/tmp5b1cpeze.rs:27:14\n     |\n\
    27   |             .collect()\n     |              ^^^^^^^ value of type `Vec<String>`\
    \ cannot be built from `std::iter::Iterator<Item=&String>`\n     |\n     = help:\
    \ the trait `FromIterator<&String>` is not implemented for `Vec<String>`\n   \
    \  = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_len\
    \ = lst1.len();\n    for x in lst2 {\n        if lst1.iter().any(|x| *x == *x)\
    \ {\n            total_len += 1;\n        }\n    }\n    if total_len == lst1.len()\
    \ {\n        return lst1;\n    }\n    return lst1.iter().filter_map(|x| {\n  \
    \      Some(x.filter(|c| *c < *c))\n    }).collect();\n}\n\nfn main() {\n    let\
    \ candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `&String` is not an iterator\n   --> /tmp/tmpgp3y4igy.rs:29:16\n\
    \    |\n29  |           Some(x.filter(|c| *c < *c))\n    |                  ^^^^^^\
    \ `&String` is not an iterator\n    |\n    = note: the following trait bounds\
    \ were not satisfied:\n            `&String: Iterator`\n            which is required\
    \ by `&mut &String: Iterator`\n            `String: Iterator`\n            which\
    \ is required by `&mut String: Iterator`\n            `str: Iterator`\n      \
    \      which is required by `&mut str: Iterator`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    // use vector with map to store key value pair\n    let mut vec1 = vec![];\n\
    \    for v in lst1 {\n        vec1.push(v);\n    }\n    let mut vec2 = vec![];\n\
    \    for v in lst2 {\n        vec2.push(v);\n    }\n    if vec1.len() != vec2.len()\
    \ {\n        return vec1;\n    }\n    let mut new_vec: Vec<String> = vec![String::new()];\n\
    \    let mut num = 0;\n    for i in 0..vec1.len() {\n        let key = vec1[i];\n\
    \        for j in 0..vec2.len() {\n            if vec2[j] == key {\n         \
    \       new_vec.push(vec1[i]);\n                break;\n            }\n      \
    \      num = num + 1;\n        }\n    }\n    if num == vec2.len() {\n        return\
    \ new_vec;\n    }\n    return vec1;\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpjxo9gl80.rs:31:19\n\
    \   |\n31 |         let key = vec1[i];\n   |                   ^^^^^^^\n   | \
    \                  |\n   |                   move occurs because value has type\
    \ `String`, which does not implement the `Copy` trait\n   |                  \
    \ help: consider borrowing here: `&vec1[i]`\n\nerror[E0507]: cannot move out of\
    \ index of `Vec<String>`\n  --> /tmp/tmpjxo9gl80.rs:34:30\n   |\n34 |        \
    \         new_vec.push(vec1[i]);\n   |                              ^^^^^^^ move\
    \ occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0507`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut n = 0usize;\n    for s in lst1 {\n        if lst2.contains(&s) {\n\
    \            n += s.len();\n        }\n    }\n    lst1.iter().filter(|s| lst2.contains(&s)).cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "warning: variable `n` is assigned to, but never used\n  --> /tmp/tmpcdjozkm1.rs:16:13\n\
    \   |\n16 |     let mut n = 0usize;\n   |             ^\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n   = note: consider using `_n` instead\n\nerror[E0382]: borrow\
    \ of moved value: `lst1`\n   --> /tmp/tmpcdjozkm1.rs:22:5\n    |\n15  | fn total_match(lst1:\
    \ Vec<String>, lst2: Vec<String>) -> Vec<String> {\n    |                ----\
    \ move occurs because `lst1` has type `Vec<String>`, which does not implement\
    \ the `Copy` trait\n16  |     let mut n = 0usize;\n17  |     for s in lst1 {\n\
    \    |              ---- `lst1` moved due to this implicit call to `.into_iter()`\n\
    ...\n22  |     lst1.iter().filter(|s| lst2.contains(&s)).cloned().collect()\n\
    \    |     ^^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `lst1`\n    = note: borrow\
    \ occurs due to deref coercion to `[String]`\nhelp: consider iterating over a\
    \ slice of the `Vec<String>`'s content to avoid moving into the `for` loop\n \
    \   |\n17  |     for s in &lst1 {\n    |              +\n\nerror: aborting due\
    \ to previous error; 1 warning emitted\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    match lst1.len() {\n        0 => lst2,\n        _ => total_match(lst1.iter().rev(),\
    \ lst2.iter().rev()),\n    }\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkukv_nko.rs:18:26\n   |\n\
    18 |         _ => total_match(lst1.iter().rev(), lst2.iter().rev()),\n   |   \
    \                       ^^^^^^^^^^^^^^^^^ expected struct `Vec`, found struct\
    \ `Rev`\n   |\n   = note: expected struct `Vec<String>`\n              found struct\
    \ `Rev<std::slice::Iter<'_, String>>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpkukv_nko.rs:18:45\n   |\n18 |         _ => total_match(lst1.iter().rev(),\
    \ lst2.iter().rev()),\n   |                                             ^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found struct `Rev`\n   |\n   = note: expected struct\
    \ `Vec<String>`\n              found struct `Rev<std::slice::Iter<'_, String>>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == 0 || lst2.len() == 0 {\n        return vec![];\n    }\n\
    \    if lst1.len() == lst2.len() {\n        return vec![lst1[0]];\n    }\n   \
    \ let mut total_matched = vec![];\n    for entry in lst1 {\n        let (matched1,\
    \ matched2) = entry.chars().filter(|c| c <= lst2.first());\n        let mut total_matched\
    \ = total_matched.into_iter().map(|e| e + &*matched1.clone()).collect();\n   \
    \     total_matched = total_matched.into_iter().filter(|e| e <= &*matched2).collect();\n\
    \        if total_matched.len() > 0 {\n            break;\n        }\n    }\n\
    \    total_matched.dedup();\n    total_matched.collect()\n}\n\nfn main() {\n \
    \   let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzpe0pnx7.rs:24:66\n   |\n\
    24 |         let (matched1, matched2) = entry.chars().filter(|c| c <= lst2.first());\n\
    \   |                                                                  ^^^^^^^^^^^^\
    \ expected `&char`, found enum `Option`\n   |\n   = note: expected reference `&char`\n\
    \                   found enum `Option<&String>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpzpe0pnx7.rs:24:13\n   |\n24 |         let (matched1, matched2)\
    \ = entry.chars().filter(|c| c <= lst2.first());\n   |             ^^^^^^^^^^^^^^^^^^^^\
    \   -------------------------------------------\n   |             |          \
    \            |                    |\n   |             |                      |\
    \                    the expected closure\n   |             |                \
    \      this expression has type `Filter<Chars<'_>, [closure@/tmp/tmpzpe0pnx7.rs:24:57:\
    \ 24:78]>`\n   |             expected struct `Filter`, found tuple\n   |\n   =\
    \ note: expected struct `Filter<Chars<'_>, [closure@/tmp/tmpzpe0pnx7.rs:24:57:\
    \ 24:78]>`\n               found tuple `(_, _)`\n\nerror[E0599]: `Vec<_>` is not\
    \ an iterator\n   --> /tmp/tmpzpe0pnx7.rs:32:19\n    |\n32  |       total_matched.collect()\n\
    \    |                     ^^^^^^^ `Vec<_>` is not an iterator\n    |\n    = note:\
    \ the following trait bounds were not satisfied:\n            `Vec<_>: Iterator`\n\
    \            which is required by `&mut Vec<_>: Iterator`\n            `[_]: Iterator`\n\
    \            which is required by `&mut [_]: Iterator`\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    lst1.iter().cloned().chain(lst2.iter().cloned()).cloned().filter(|x| x.len()\
    \ <= lst2.len()).cloned().collect()\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<std::slice::Iter<'_, String> as\
    \ Iterator>::Item == &&_`\n  --> /tmp/tmp6_8qumcs.rs:16:54\n   |\n16 |     lst1.iter().cloned().chain(lst2.iter().cloned()).cloned().filter(|x|\
    \ x.len() <= lst2.len()).cloned().collect()\n   |                            \
    \                          ^^^^^^ expected reference, found struct `String`\n\
    \   |\n   = note: expected reference `&&_`\n              found reference `&String`\n\
    \   = note: required because of the requirements on the impl of `Iterator` for\
    \ `Cloned<std::slice::Iter<'_, String>>`\n   = note: 1 redundant requirement hidden\n\
    \   = note: required because of the requirements on the impl of `Iterator` for\
    \ `std::iter::Chain<Cloned<std::slice::Iter<'_, String>>, Cloned<std::slice::Iter<'_,\
    \ String>>>`\n\nerror[E0599]: the method `filter` exists for struct `Cloned<std::iter::Chain<Cloned<std::slice::Iter<'_,\
    \ String>>, Cloned<std::slice::Iter<'_, String>>>>`, but its trait bounds were\
    \ not satisfied\n  --> /tmp/tmp6_8qumcs.rs:16:63\n   |\n16 |       lst1.iter().cloned().chain(lst2.iter().cloned()).cloned().filter(|x|\
    \ x.len() <= lst2.len()).cloned().collect()\n   |                            \
    \                                     ^^^^^^ method cannot be called on `Cloned<std::iter::Chain<Cloned<std::slice::Iter<'_,\
    \ String>>, Cloned<std::slice::Iter<'_, String>>>>` due to unsatisfied trait bounds\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `<std::iter::Chain<Cloned<std::slice::Iter<'_,\
    \ String>>, Cloned<std::slice::Iter<'_, String>>> as Iterator>::Item = &_`\n \
    \          which is required by `Cloned<std::iter::Chain<Cloned<std::slice::Iter<'_,\
    \ String>>, Cloned<std::slice::Iter<'_, String>>>>: Iterator`\n           `Cloned<std::iter::Chain<Cloned<std::slice::Iter<'_,\
    \ String>>, Cloned<std::slice::Iter<'_, String>>>>: Iterator`\n           which\
    \ is required by `&mut Cloned<std::iter::Chain<Cloned<std::slice::Iter<'_, String>>,\
    \ Cloned<std::slice::Iter<'_, String>>>>: Iterator`\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    match (lst1.len(), lst2.len()) {\n        (true, true) => lst1,\n       \
    \ (true, false) => lst2,\n        (false, true) => lst1,\n        (false, false)\
    \ => vec![],\n    }\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpitiwoqbp.rs:17:10\n   |\n\
    16 |     match (lst1.len(), lst2.len()) {\n   |           ------------------------\
    \ this expression has type `(usize, usize)`\n17 |         (true, true) => lst1,\n\
    \   |          ^^^^ expected `usize`, found `bool`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpitiwoqbp.rs:17:16\n   |\n16 |     match (lst1.len(), lst2.len())\
    \ {\n   |           ------------------------ this expression has type `(usize,\
    \ usize)`\n17 |         (true, true) => lst1,\n   |                ^^^^ expected\
    \ `usize`, found `bool`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpitiwoqbp.rs:18:10\n\
    \   |\n16 |     match (lst1.len(), lst2.len()) {\n   |           ------------------------\
    \ this expression has type `(usize, usize)`\n17 |         (true, true) => lst1,\n\
    18 |         (true, false) => lst2,\n   |          ^^^^ expected `usize`, found\
    \ `bool`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpitiwoqbp.rs:18:16\n\
    \   |\n16 |     match (lst1.len(), lst2.len()) {\n   |           ------------------------\
    \ this expression has type `(usize, usize)`\n17 |         (true, true) => lst1,\n\
    18 |         (true, false) => lst2,\n   |                ^^^^^ expected `usize`,\
    \ found `bool`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpitiwoqbp.rs:19:10\n\
    \   |\n16 |     match (lst1.len(), lst2.len()) {\n   |           ------------------------\
    \ this expression has type `(usize, usize)`\n...\n19 |         (false, true) =>\
    \ lst1,\n   |          ^^^^^ expected `usize`, found `bool`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpitiwoqbp.rs:19:17\n   |\n16 |     match (lst1.len(), lst2.len())\
    \ {\n   |           ------------------------ this expression has type `(usize,\
    \ usize)`\n...\n19 |         (false, true) => lst1,\n   |                 ^^^^\
    \ expected `usize`, found `bool`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpitiwoqbp.rs:20:10\n\
    \   |\n16 |     match (lst1.len(), lst2.len()) {\n   |           ------------------------\
    \ this expression has type `(usize, usize)`\n...\n20 |         (false, false)\
    \ => vec![],\n   |          ^^^^^ expected `usize`, foun"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1\n    }\n    if lst1.len()\
    \ < lst2.len() {\n        lst1.iter().filter(|s| !lst2.iter().any(|s| s == s)).collect()\n\
    \    } else {\n        lst2.iter().filter(|s| !lst1.iter().any(|s| s == s)).collect()\n\
    \    }\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&String`\n    --> /tmp/tmpzo99j5_g.rs:20:62\n     |\n\
    20   |         lst1.iter().filter(|s| !lst2.iter().any(|s| s == s)).collect()\n\
    \     |                                                              ^^^^^^^ value\
    \ of type `Vec<String>` cannot be built from `std::iter::Iterator<Item=&String>`\n\
    \     |\n     = help: the trait `FromIterator<&String>` is not implemented for\
    \ `Vec<String>`\n     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\n\
    note: required by a bound in `collect`\n\nerror[E0277]: a value of type `Vec<String>`\
    \ cannot be built from an iterator over elements of type `&String`\n    --> /tmp/tmpzo99j5_g.rs:22:62\n\
    \     |\n22   |         lst2.iter().filter(|s| !lst1.iter().any(|s| s == s)).collect()\n\
    \     |                                                              ^^^^^^^ value\
    \ of type `Vec<String>` cannot be built from `std::iter::Iterator<Item=&String>`\n\
    \     |\n     = help: the trait `FromIterator<&String>` is not implemented for\
    \ `Vec<String>`\n     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\n\
    note: required by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut count = 0;\n    for v in lst1 {\n        if lst2.iter().any(|x| v\
    \ == x) {\n            count += 1;\n        }\n    }\n    if lst1.len() == count\
    \ {\n        return lst1;\n    }\n    if lst2.len() == count {\n        return\
    \ lst2;\n    }\n    if lst1.len() > count {\n        for v in lst2 {\n       \
    \     if !lst1.iter().any(|x| v == x) {\n                return vec![v];\n   \
    \         }\n        }\n    } else {\n        for v in lst1 {\n            if\
    \ !lst2.iter().any(|x| v == x) {\n                return vec![v];\n          \
    \  }\n        }\n    }\n    vec![]\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `String` with `&String`\n  --> /tmp/tmpbaa_t4ob.rs:18:34\n\
    \   |\n18 |         if lst2.iter().any(|x| v == x) {\n   |                   \
    \               ^^ no implementation for `String == &String`\n   |\n   = help:\
    \ the trait `PartialEq<&String>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `PartialEq<Rhs>`:\n             <&'a str\
    \ as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n     \
    \        <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `String` with `&String`\n  --> /tmp/tmpbaa_t4ob.rs:30:39\n   |\n30 |       \
    \      if !lst1.iter().any(|x| v == x) {\n   |                               \
    \        ^^ no implementation for `String == &String`\n   |\n   = help: the trait\
    \ `PartialEq<&String>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n\
    \             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0277]: can't compare `String` with `&String`\n\
    \  --> /tmp/tmpbaa_t4ob.rs:36:39\n   |\n36 |             if !lst2.iter().any(|x|\
    \ v == x) {\n   |                                       ^^ no implementation for\
    \ `String == &String`\n   |\n   = help: the trait `PartialEq<&String>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n         \
    \    <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as Pa"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut count = 0;\n    for el1 in lst1 {\n        if lst2.iter().any(|el2|\
    \ el1 == el2) {\n            count = count + 1;\n        }\n    }\n    if count\
    \ == lst1.len() {\n        return vec![];\n    }\n    vec![lst1[0] as String]\n\
    }\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `String` with `&String`\n  --> /tmp/tmptorceyzw.rs:18:38\n\
    \   |\n18 |         if lst2.iter().any(|el2| el1 == el2) {\n   |             \
    \                         ^^ no implementation for `String == &String`\n   |\n\
    \   = help: the trait `PartialEq<&String>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `PartialEq<Rhs>`:\n     \
    \        <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 101
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    if lst1.len()\
    \ > lst2.len() {\n        let mut vec2 = lst2.clone();\n        vec2.shrink_to_fit();\n\
    \        return vec2.iter().cloned().collect();\n    }\n    let mut vec1 = lst1.clone();\n\
    \    vec1.shrink_to_fit();\n    return vec1.iter().cloned().collect();\n}\n\n\
    fn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"hi\", \"admin\"]`,\n right: `[\"hi\", \"hi\"]`', /tmp/tmpv56_nv6f.rs:32:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n\n    let mut\
    \ res = vec![];\n\n    for (idx, val1) in lst1.iter().enumerate() {\n        let\
    \ mut val2 = lst2[idx];\n\n        while val2.len() > val1.len() {\n         \
    \   val2 = val2.chars().filter(|c| c <= val1).collect();\n        }\n\n      \
    \  res.push(val2.clone());\n    }\n\n    res\n}\n\nfn main() {\n    let candidate\
    \ = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5wtmj68w.rs:26:49\n   |\n\
    26 |             val2 = val2.chars().filter(|c| c <= val1).collect();\n   |  \
    \                                               ^^^^ expected `char`, found struct\
    \ `String`\n   |\n   = note: expected reference `&char`\n              found reference\
    \ `&String`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    match lst1.len() {\n        0 => vec![],\n        x => {\n            match\
    \ lst2.len() {\n                0 => vec![],\n                x => if x > x {\n\
    \                    vec![lst1[0]]\n                } else {\n               \
    \     vec![lst1[0]]\n                },\n            }\n        },\n    }\n}\n\
    \nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `x`\n  --> /tmp/tmpneacnjgf.rs:18:9\n   |\n18\
    \ |         x => {\n   |         ^ help: if this is intentional, prefix it with\
    \ an underscore: `_x`\n   |\n   = note: `#[warn(unused_variables)]` on by default\n\
    \nerror[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpneacnjgf.rs:22:26\n\
    \   |\n22 |                     vec![lst1[0]]\n   |                          ^^^^^^^\
    \ move occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpneacnjgf.rs:24:26\n\
    \   |\n24 |                     vec![lst1[0]]\n   |                          ^^^^^^^\
    \ move occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\nFor\
    \ more information about this error, try `rustc --explain E0507`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    lst1.iter().zip(lst2.iter()).map(|(_, v)| v).filter(|&x| x.len() < lst2.len()).collect()\n\
    }\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&String`\n    --> /tmp/tmpefuwydek.rs:16:84\n     |\n\
    16   |     lst1.iter().zip(lst2.iter()).map(|(_, v)| v).filter(|&x| x.len() <\
    \ lst2.len()).collect()\n     |                                              \
    \                                      ^^^^^^^ value of type `Vec<String>` cannot\
    \ be built from `std::iter::Iterator<Item=&String>`\n     |\n     = help: the\
    \ trait `FromIterator<&String>` is not implemented for `Vec<String>`\n     = help:\
    \ the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a\
    \ bound in `collect`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut i = 0;\n    let mut j = 0;\n\n    // get the size of both vectors\n\
    \    let mut size_lst1 = lst1.len();\n    let mut size_lst2 = lst2.len();\n\n\
    \    // set the end values to each vectors size\n    size_lst1 = size_lst1 as\
    \ i32;\n    size_lst2 = size_lst2 as i32;\n\n    // if both vectors have same\
    \ size then just return the first one.\n    if size_lst1 == size_lst2 {\n    \
    \    return vec![lst1[0]];\n    }\n\n    // if one vector is empty return empty\
    \ vector\n    if size_lst1 == 0 {\n        return vec![];\n    }\n\n    // set\
    \ the index of the vectors to the end values.\n    i = size_lst1 as i32;\n   \
    \ j = size_lst2 as i32;\n\n    let mut res = vec![];\n    while i < j {\n    \
    \    if lst1[i].len() < lst2[j].len() {\n            i += 1;\n        }\n    \
    \    else {\n            j += 1;\n        }\n        res.push(lst1[i]);\n    }\n\
    \    res\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpktq6g11r.rs:24:17\n   |\n\
    20 |     let mut size_lst1 = lst1.len();\n   |                         ----------\
    \ expected due to this value\n...\n24 |     size_lst1 = size_lst1 as i32;\n  \
    \ |                 ^^^^^^^^^^^^^^^^ expected `usize`, found `i32`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpktq6g11r.rs:25:17\n   |\n21 |     let mut size_lst2\
    \ = lst2.len();\n   |                         ---------- expected due to this\
    \ value\n...\n25 |     size_lst2 = size_lst2 as i32;\n   |                 ^^^^^^^^^^^^^^^^\
    \ expected `usize`, found `i32`\n\nerror[E0277]: the type `[String]` cannot be\
    \ indexed by `i32`\n  --> /tmp/tmpktq6g11r.rs:43:12\n   |\n43 |         if lst1[i].len()\
    \ < lst2[j].len() {\n   |            ^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[String]>` is not\
    \ implemented for `i32`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<i32>` for `Vec<String>`\n\nerror[E0277]: the type `[String]` cannot be\
    \ indexed by `i32`\n  --> /tmp/tmpktq6g11r.rs:43:28\n   |\n43 |         if lst1[i].len()\
    \ < lst2[j].len() {\n   |                            ^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[String]>`\
    \ is not implemented for `i32`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<i32>` for `Vec<String>`\n\nerror[E0277]: the type `[String]` cannot be\
    \ indexed by `i32`\n  --> /tmp/tmpktq6g11r.rs:49:18\n   |\n49 |         res.push(lst1[i]);\n\
    \   |                  ^^^^^^^ slice indices are of type `usize` or ranges of\
    \ `usize`\n   |\n   = help: the trait `SliceIndex<[String]>` is not implemented\
    \ for `i32`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<i32>` for\
    \ `Vec<String>`\n\nerror: aborting due to 5 previous errors\n\nSome errors have\
    \ detailed explan"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return vec!lst1;\n    }\n    let mut\
    \ res = vec![];\n    for s1 in lst1 {\n        let mut sum = 0;\n        for s2\
    \ in lst2 {\n            if s1.len() < s2.len() {\n                continue;\n\
    \            }\n            sum += s1.chars().filter(|c| *c < *s2).count();\n\
    \        }\n        if sum > 0 {\n            res.push(s1);\n        }\n    }\n\
    \    res\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `(`, `[`, or `{`, found `lst1`\n  --> /tmp/tmpxh4zabry.rs:17:20\n\
    \   |\n17 |         return vec!lst1;\n   |                    ^^^^ expected one\
    \ of `(`, `[`, or `{`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxh4zabry.rs:26:47\n\
    \   |\n26 |             sum += s1.chars().filter(|c| *c < *s2).count();\n   |\
    \                                               ^^^ expected `char`, found `str`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 101
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1\n    }\n    for i in 0..lst1.len()\
    \ {\n        if lst1[i].len() > lst2[i].len() {\n            return lst1\n   \
    \     }\n    }\n    return lst2\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"hi\", \"admin\"]`,\n right: `[\"hi\", \"hi\"]`', /tmp/tmpubaiso3l.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut res\
    \ = vec![String::from(\"0\".to_string())];\n    let mut counter = 0;\n    for\
    \ elem in lst1.iter() {\n        if elem.len() == lst2.len() {\n            if\
    \ elem.iter().zip(lst2.iter()).all(|(&a, &b)| a < b) {\n                counter\
    \ = counter + 1;\n            }\n        } else {\n            if elem.iter().zip(lst2.iter()).all(|(&a,\
    \ &b)| a > b) {\n                counter = counter - 1;\n            }\n     \
    \   }\n    }\n    for elem in res.iter_mut() {\n        *elem = match counter\
    \ {\n            0 => \"0\",\n            _ => String::from(\"1\".to_string()),\n\
    \        };\n    }\n    res\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for reference `&String` in the\
    \ current scope\n  --> /tmp/tmpyxbuilxi.rs:23:21\n   |\n23 |             if elem.iter().zip(lst2.iter()).all(|(&a,\
    \ &b)| a < b) {\n   |                     ^^^^ method not found in `&String`\n\
    \   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator`\
    \ over each of its codepoint use method `chars`\n   |\n23 |             if elem.chars().zip(lst2.iter()).all(|(&a,\
    \ &b)| a < b) {\n   |                     ~~~~~\n\nerror[E0599]: no method named\
    \ `iter` found for reference `&String` in the current scope\n  --> /tmp/tmpyxbuilxi.rs:27:21\n\
    \   |\n27 |             if elem.iter().zip(lst2.iter()).all(|(&a, &b)| a > b)\
    \ {\n   |                     ^^^^ method not found in `&String`\n   |\nhelp:\
    \ because of the in-memory representation of `&str`, to obtain an `Iterator` over\
    \ each of its codepoint use method `chars`\n   |\n27 |             if elem.chars().zip(lst2.iter()).all(|(&a,\
    \ &b)| a > b) {\n   |                     ~~~~~\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpyxbuilxi.rs:34:18\n   |\n34 |             0 => \"0\",\n   |   \
    \               ^^^- help: try using a conversion method: `.to_string()`\n   |\
    \                  |\n   |                  expected struct `String`, found `&str`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        lst1\n    } else {\n        lst1.iter().cloned().zip(lst2.iter().cloned()).filter(|t|\
    \ t[0].len() < t[1].len()).collect::<Vec<_>>()\n    }\n}\n\nfn main() {\n    let\
    \ candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0608]: cannot index into a value of type `&(String, String)`\n \
    \ --> /tmp/tmpnnxlgm8j.rs:19:67\n   |\n19 |         lst1.iter().cloned().zip(lst2.iter().cloned()).filter(|t|\
    \ t[0].len() < t[1].len()).collect::<Vec<_>>()\n   |                         \
    \                                          ^^^^\n\nerror[E0608]: cannot index\
    \ into a value of type `&(String, String)`\n  --> /tmp/tmpnnxlgm8j.rs:19:80\n\
    \   |\n19 |         lst1.iter().cloned().zip(lst2.iter().cloned()).filter(|t|\
    \ t[0].len() < t[1].len()).collect::<Vec<_>>()\n   |                         \
    \                                                       ^^^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpnnxlgm8j.rs:19:9\n   |\n15 | fn total_match(lst1:\
    \ Vec<String>, lst2: Vec<String>) -> Vec<String> {\n   |                     \
    \                                    ----------- expected `Vec<String>` because\
    \ of return type\n...\n19 |         lst1.iter().cloned().zip(lst2.iter().cloned()).filter(|t|\
    \ t[0].len() < t[1].len()).collect::<Vec<_>>()\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found tuple\n   |\n   = note: expected struct `Vec<String>`\n\
    \              found struct `Vec<(String, String)>`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0308, E0608.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut cnt\
    \ = 0;\n    for str1 in lst1 {\n        for str2 in lst2 {\n            if str1.chars().all(|x|\
    \ x == str2.chars().first()) {\n                cnt += 1;\n            }\n   \
    \     }\n    }\n    lst1.iter().filter(|&x| x.chars().all(|x| x == cnt)).collect()\n\
    }\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `first` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmp6rnl__rf.rs:22:55\n   |\n22 |             if str1.chars().all(|x|\
    \ x == str2.chars().first()) {\n   |                                         \
    \              ^^^^^ method not found in `Chars<'_>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp6rnl__rf.rs:27:52\n   |\n27 |     lst1.iter().filter(|&x|\
    \ x.chars().all(|x| x == cnt)).collect()\n   |                               \
    \                     ^^^ expected `char`, found integer\n\nerror[E0277]: a value\
    \ of type `Vec<String>` cannot be built from an iterator over elements of type\
    \ `&String`\n    --> /tmp/tmp6rnl__rf.rs:27:58\n     |\n27   |     lst1.iter().filter(|&x|\
    \ x.chars().all(|x| x == cnt)).collect()\n     |                             \
    \                             ^^^^^^^ value of type `Vec<String>` cannot be built\
    \ from `std::iter::Iterator<Item=&String>`\n     |\n     = help: the trait `FromIterator<&String>`\
    \ is not implemented for `Vec<String>`\n     = help: the trait `FromIterator<T>`\
    \ is implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut total_len = 0;\n    for i in lst1.iter() {\n        total_len +=\
    \ i.len() as usize;\n    }\n    for i in lst2.iter() {\n        total_len += i.len()\
    \ as usize;\n    }\n    if total_len == lst1.len() {\n        return lst1\n  \
    \  }\n    if total_len == lst2.len() {\n        return lst2\n    }\n    let mut\
    \ result = vec![];\n    for i in 0..(total_len as usize).saturating_sub(lst1.len())\
    \ {\n        result.push(lst1.get_mut(i));\n    }\n    for i in 0..(total_len\
    \ as usize).saturating_sub(lst2.len()) {\n        result.push(lst2.get_mut(i));\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4b82vv67.rs:36:5\n   |\n\
    15 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n \
    \  |                                                         ----------- expected\
    \ `Vec<String>` because of return type\n...\n36 |     result\n   |     ^^^^^^\
    \ expected struct `String`, found enum `Option`\n   |\n   = note: expected struct\
    \ `Vec<String>`\n              found struct `Vec<Option<&mut String>>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut vec = vec![];\n    for a in lst1 {\n        for b in lst2 {\n   \
    \         if a <= b {\n                vec.push(b);\n                break;\n\
    \            }\n        }\n    }\n    vec\n}\n\nfn main() {\n    let candidate\
    \ = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmpeji9w0xh.rs:18:18\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n18  |  \
    \       for b in lst2 {\n    |                  ^^^^ `lst2` moved due to this\
    \ implicit call to `.into_iter()`, in previous iteration of loop\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `lst2`\nhelp:\
    \ consider iterating over a slice of the `Vec<String>`'s content to avoid moving\
    \ into the `for` loop\n    |\n18  |         for b in &lst2 {\n    |          \
    \        +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut count1 = String::new();\n    let mut count2 = String::new();\n  \
    \  for el in lst1 {\n        count1 += &el;\n    }\n    for el in lst2 {\n   \
    \     count2 += &el;\n    }\n    if count1.len() < count2.len() {\n        return\
    \ lst1;\n    }\n    return lst2;\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst1`\n   --> /tmp/tmpxwd68vfp.rs:25:16\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                ---- move occurs because `lst1` has type `Vec<String>`,\
    \ which does not implement the `Copy` trait\n...\n18  |     for el in lst1 {\n\
    \    |               ---- `lst1` moved due to this implicit call to `.into_iter()`\n\
    ...\n25  |         return lst1;\n    |                ^^^^ value used here after\
    \ move\n    |\nnote: this function takes ownership of the receiver `self`, which\
    \ moves `lst1`\nhelp: consider iterating over a slice of the `Vec<String>`'s content\
    \ to avoid moving into the `for` loop\n    |\n18  |     for el in &lst1 {\n  \
    \  |               +\n\nerror[E0382]: use of moved value: `lst2`\n  --> /tmp/tmpxwd68vfp.rs:27:12\n\
    \   |\n15 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n21 |   \
    \  for el in lst2 {\n   |               ---- `lst2` moved due to this implicit\
    \ call to `.into_iter()`\n...\n27 |     return lst2;\n   |            ^^^^ value\
    \ used here after move\n   |\nhelp: consider iterating over a slice of the `Vec<String>`'s\
    \ content to avoid moving into the `for` loop\n   |\n21 |     for el in &lst2\
    \ {\n   |               +\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    debugln!(\"total match: {:?}, {:?}\", lst1, lst2);\n    let mut i = 0;\n\
    \    lst1.sort_by_key(|x| x.len());\n    lst2.sort_by_key(|x| x.len());\n    while\
    \ i < lst1.len() && i < lst2.len() {\n        debugln!(\"comparing between {:?}\
    \ and {:?}\", lst1[i], lst2[i]);\n        if lst1[i].len() > lst2[i].len() {\n\
    \            i += 1;\n        } else if lst1[i].len() < lst2[i].len() {\n    \
    \        i += 1;\n        } else {\n            if lst1[i] == lst2[i] {\n    \
    \            i += 1;\n            } else {\n                debugln!(\"breaking!\"\
    );\n                break;\n            }\n        }\n    }\n    lst1.take(i +\
    \ 1)\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error: cannot find macro `debugln` in this scope\n  --> /tmp/tmp2gr2bid_.rs:16:5\n\
    \   |\n16 |     debugln!(\"total match: {:?}, {:?}\", lst1, lst2);\n   |     ^^^^^^^\n\
    \nerror: cannot find macro `debugln` in this scope\n  --> /tmp/tmp2gr2bid_.rs:21:9\n\
    \   |\n21 |         debugln!(\"comparing between {:?} and {:?}\", lst1[i], lst2[i]);\n\
    \   |         ^^^^^^^\n\nerror: cannot find macro `debugln` in this scope\n  -->\
    \ /tmp/tmp2gr2bid_.rs:30:17\n   |\n30 |                 debugln!(\"breaking!\"\
    );\n   |                 ^^^^^^^\n\nerror[E0599]: `Vec<String>` is not an iterator\n\
    \   --> /tmp/tmp2gr2bid_.rs:35:10\n    |\n35  |       lst1.take(i + 1)\n    |\
    \            ^^^^ `Vec<String>` is not an iterator\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `Vec<String>: Iterator`\n    \
    \        which is required by `&mut Vec<String>: Iterator`\n            `[String]:\
    \ Iterator`\n            which is required by `&mut [String]: Iterator`\n\nerror:\
    \ aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return vec![];\n    }\n    let mut\
    \ match_size = 0;\n    for i in 0..lst1.len() {\n        let a = lst1[i];\n  \
    \      let b = lst2[i];\n        if a.len() > b.len() {\n            match_size\
    \ = a.len();\n        }\n        if a.len() < b.len() {\n            match_size\
    \ = b.len();\n        }\n    }\n    if lst1.len() > lst2.len() {\n        return\
    \ vec![lst1[0]];\n    }\n    if lst1.len() < lst2.len() {\n        return vec![lst2[0]];\n\
    \    }\n    for i in 0..lst1.len() {\n        let a = lst1[i];\n        let b\
    \ = lst2[i];\n        if a.len() > b.len() {\n            match_size = a.len();\n\
    \        }\n        if a.len() < b.len() {\n            match_size = b.len();\n\
    \        }\n    }\n    vec![String::from_str(&(match_size as usize).to_string())]\n\
    }\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no function or associated item named `from_str` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmpwcwec26z.rs:46:18\n   |\n\
    46 |     vec![String::from_str(&(match_size as usize).to_string())]\n   |    \
    \              ^^^^^^^^ function or associated item not found in `String`\n  \
    \ |\n   = help: items from traits can only be used if the trait is in scope\n\
    help: the following trait is implemented but not in scope; perhaps add a `use`\
    \ for it:\n   |\n1  | use std::str::FromStr;\n   |\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut vec = vec![];\n    for el1 in lst1 {\n        let mut flag = false;\n\
    \        for el2 in lst2 {\n            if el1 == el2 {\n                flag\
    \ = true;\n                break;\n            }\n        }\n        if flag {\n\
    \            vec.push(el1);\n        }\n    }\n    vec\n}\n\nfn main() {\n   \
    \ let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmprbvo8om_.rs:19:20\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n19  |  \
    \       for el2 in lst2 {\n    |                    ^^^^ `lst2` moved due to this\
    \ implicit call to `.into_iter()`, in previous iteration of loop\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `lst2`\nhelp:\
    \ consider iterating over a slice of the `Vec<String>`'s content to avoid moving\
    \ into the `for` loop\n    |\n19  |         for el2 in &lst2 {\n    |        \
    \            +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 101
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        lst1\n    } else {\n        if lst1.len()\
    \ > lst2.len() {\n            vec![String::from(\"\")]\n        } else {\n   \
    \         vec![String::from(\"\")]\n        }\n    }\n}\n\nfn main() {\n    let\
    \ candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"hi\", \"admin\"]`,\n right: `[\"hi\", \"hi\"]`', /tmp/tmp8kjnzova.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == 0 || lst2.len() == 0 {\n        return vec![];\n    }\n\
    \    let mut res = vec![];\n    for &str1 in lst1 {\n        if !lst2.contains(&str1)\
    \ {\n            res.push(str1);\n        }\n    }\n    for &str2 in lst2 {\n\
    \        if !lst1.contains(&str2) {\n            res.push(str2);\n        }\n\
    \    }\n    return res;\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9ai8ead6.rs:20:9\n   |\n\
    20 |     for &str1 in lst1 {\n   |         ^^^^^    ---- this expression has type\
    \ `Option<String>`\n   |         |\n   |         expected struct `String`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `str1`\n\
    \   |\n   = note: expected struct `String`\n           found reference `&_`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp9ai8ead6.rs:25:9\n   |\n25 |   \
    \  for &str2 in lst2 {\n   |         ^^^^^    ---- this expression has type `Option<String>`\n\
    \   |         |\n   |         expected struct `String`, found reference\n   |\
    \         help: you can probably remove the explicit borrow: `str2`\n   |\n  \
    \ = note: expected struct `String`\n           found reference `&_`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    lst1.iter().fold(lst1, |mut acc, &mut elem| {\n        acc.iter().filter(|&x|\
    \ elem.iter().any(|y| y.contains(x))).collect::<Vec<_>>()\n    }).cloned()\n}\n\
    \nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp50tkehkm.rs:16:38\n   |\n\
    16 |     lst1.iter().fold(lst1, |mut acc, &mut elem| {\n   |                 \
    \                     ^^^^^-----\n   |                                      |\
    \    |\n   |                                      |    expected due to this\n\
    \   |                                      types differ in mutability\n   |  \
    \                                    help: did you mean `elem`: `&&String`\n \
    \  |\n   = note:      expected reference `&String`\n           found mutable reference\
    \ `&mut _`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp50tkehkm.rs:17:9\n\
    \   |\n17 |         acc.iter().filter(|&x| elem.iter().any(|y| y.contains(x))).collect::<Vec<_>>()\n\
    \   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&String`\n   |\n   = note: expected struct\
    \ `Vec<String>`\n              found struct `Vec<&String>`\n\nerror[E0599]: `Vec<String>`\
    \ is not an iterator\n   --> /tmp/tmp50tkehkm.rs:18:8\n    |\n18  |       }).cloned()\n\
    \    |          ^^^^^^ `Vec<String>` is not an iterator\n    |\n    = note: the\
    \ following trait bounds were not satisfied:\n            `Vec<String>: Iterator`\n\
    \            which is required by `&mut Vec<String>: Iterator`\n            `[String]:\
    \ Iterator`\n            which is required by `&mut [String]: Iterator`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    match lst1.len() {\n        0 => lst2,\n        1 => lst1,\n        _ =>\
    \ lst1.iter().copied().collect::<Vec<_>>().iter().chain(total_match(lst1.iter().copied().collect::<Vec<_>>(),\
    \ lst2.iter().copied().collect::<Vec<_>>())).take(lst1.iter().copied().collect::<Vec<_>>().len()),\n\
    \    }\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `String: Copy` is not satisfied\n    -->\
    \ /tmp/tmpbpzg4f5p.rs:19:26\n     |\n19   | ...   _ => lst1.iter().copied().collect::<Vec<_>>().iter().chain(total_match(lst1.iter().copied().collect::<Vec<_>>(),\
    \ lst2.iter().copied...\n     |                        ^^^^^^ the trait `Copy`\
    \ is not implemented for `String`\n     |\nnote: required by a bound in `copied`\n\
    \nerror[E0599]: the method `collect` exists for struct `Copied<std::slice::Iter<'_,\
    \ String>>`, but its trait bounds were not satisfied\n  --> /tmp/tmpbpzg4f5p.rs:19:35\n\
    \   |\n19 |   ...er().copied().collect::<Vec<_>>().iter().chain(total_match(lst1.iter().copied().collect::<Vec<_>>(),\
    \ lst2.iter().copied().collect::<Ve...\n   |                    ^^^^^^^ method\
    \ cannot be called on `Copied<std::slice::Iter<'_, String>>` due to unsatisfied\
    \ trait bounds\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `Copied<std::slice::Iter<'_, String>>: Iterator`\n           which\
    \ is required by `&mut Copied<std::slice::Iter<'_, String>>: Iterator`\n\nerror[E0277]:\
    \ the trait bound `String: Copy` is not satisfied\n    --> /tmp/tmpbpzg4f5p.rs:19:92\n\
    \     |\n19   | ...).iter().chain(total_match(lst1.iter().copied().collect::<Vec<_>>(),\
    \ lst2.iter().copied().collect::<Vec<_>>())).take(lst1.iter().copie...\n     |\
    \                                           ^^^^^^ the trait `Copy` is not implemented\
    \ for `String`\n     |\nnote: required by a bound in `copied`\n\nerror[E0599]:\
    \ the method `collect` exists for struct `Copied<std::slice::Iter<'_, String>>`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmpbpzg4f5p.rs:19:101\n\
    \   |\n19 |   ...er().copied().collect::<Vec<_>>(), lst2.iter().copied().collect::<Vec<_>>())).take(lst1.iter().copied().collect::<Vec<_>>().len()),\n\
    \   |                    ^^^^^^^ method cannot be called on `Copied<std::slice::Iter<'_,\
    \ String>>` due to unsatisfied trait bounds\n   |\n   = note: the following trait\
    \ bounds were not satisfied:\n           `Copied<std::slice::Iter<'_, String>>:\
    \ Iterator`\n           which is required by `&mut C"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut vec1 = lst1.len();\n    let mut vec2 = lst2.len();\n    if vec1 ==\
    \ vec2 {\n        return vec1.iter().cloned().collect();\n    }\n    if vec1 >\
    \ vec2 {\n        vec1.iter().cloned().sort_by(|a, b| a.cmp(b)).collect();\n \
    \   } else {\n        vec2.iter().cloned().sort_by(|a, b| a.cmp(b)).collect();\n\
    \    }\n    let mut count = 0;\n    for el in vec1.iter().cloned().zip(vec2.iter().cloned())\
    \ {\n        if *el.0 == *el.1 {\n            count += 1;\n        }\n    }\n\
    \    vec1.iter().cloned().collect::<Vec<_>>().take(count).cloned().chain(vec2.iter().cloned().collect::<Vec<_>>().take(count)).collect()\n\
    }\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for type `usize` in the current\
    \ scope\n  --> /tmp/tmpz_1tzlro.rs:19:21\n   |\n19 |         return vec1.iter().cloned().collect();\n\
    \   |                     ^^^^ method not found in `usize`\n\nerror[E0599]: no\
    \ method named `iter` found for type `usize` in the current scope\n  --> /tmp/tmpz_1tzlro.rs:22:14\n\
    \   |\n22 |         vec1.iter().cloned().sort_by(|a, b| a.cmp(b)).collect();\n\
    \   |              ^^^^ method not found in `usize`\n\nerror[E0599]: no method\
    \ named `iter` found for type `usize` in the current scope\n  --> /tmp/tmpz_1tzlro.rs:24:14\n\
    \   |\n24 |         vec2.iter().cloned().sort_by(|a, b| a.cmp(b)).collect();\n\
    \   |              ^^^^ method not found in `usize`\n\nerror[E0599]: no method\
    \ named `iter` found for type `usize` in the current scope\n  --> /tmp/tmpz_1tzlro.rs:27:20\n\
    \   |\n27 |     for el in vec1.iter().cloned().zip(vec2.iter().cloned()) {\n \
    \  |                    ^^^^ method not found in `usize`\n\nerror[E0599]: no method\
    \ named `iter` found for type `usize` in the current scope\n  --> /tmp/tmpz_1tzlro.rs:27:45\n\
    \   |\n27 |     for el in vec1.iter().cloned().zip(vec2.iter().cloned()) {\n \
    \  |                                             ^^^^ method not found in `usize`\n\
    \nerror[E0599]: no method named `iter` found for type `usize` in the current scope\n\
    \  --> /tmp/tmpz_1tzlro.rs:32:10\n   |\n32 |     vec1.iter().cloned().collect::<Vec<_>>().take(count).cloned().chain(vec2.iter().cloned().collect::<Vec<_>>().take(count)).collect()\n\
    \   |          ^^^^ method not found in `usize`\n\nerror[E0599]: no method named\
    \ `iter` found for type `usize` in the current scope\n  --> /tmp/tmpz_1tzlro.rs:32:78\n\
    \   |\n32 |     vec1.iter().cloned().collect::<Vec<_>>().take(count).cloned().chain(vec2.iter().cloned().collect::<Vec<_>>().take(count)).collect()\n\
    \   |                                                                        \
    \      ^^^^ method not found in `usize`\n\nerror: aborting due to 7 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut total = 0;\n    for elem in &lst1 {\n        if elem.len() >= &lst2.len()\
    \ {\n            total += elem.len();\n        } else {\n            total +=\
    \ lst2.len();\n        }\n    }\n    lst1.clone() + lst2\n}\n\nfn main() {\n \
    \   let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpaz2nbtqu.rs:18:26\n   |\n\
    18 |         if elem.len() >= &lst2.len() {\n   |                          ^^^^^^^^^^^\
    \ expected `usize`, found `&usize`\n   |\nhelp: consider removing the borrow\n\
    \   |\n18 -         if elem.len() >= &lst2.len() {\n18 +         if elem.len()\
    \ >= lst2.len() {\n   | \n\nerror[E0369]: cannot add `Vec<String>` to `Vec<String>`\n\
    \  --> /tmp/tmpaz2nbtqu.rs:24:18\n   |\n24 |     lst1.clone() + lst2\n   |   \
    \  ------------ ^ ---- Vec<String>\n   |     |\n   |     Vec<String>\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n\n    let mut\
    \ total_match = 0;\n    for word1 in lst1 {\n        for word2 in lst2 {\n   \
    \         if word1 <= word2 {\n                total_match += 1;\n           \
    \ }\n        }\n    }\n\n    vec![lst1[0]]\n}\n\nfn main() {\n    let candidate\
    \ = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "warning: variable `total_match` is assigned to, but never used\n  --> /tmp/tmpnnl2rqvv.rs:20:13\n\
    \   |\n20 |     let mut total_match = 0;\n   |             ^^^^^^^^^^^\n   |\n\
    \   = note: `#[warn(unused_variables)]` on by default\n   = note: consider using\
    \ `_total_match` instead\n\nerror[E0382]: use of moved value: `lst2`\n   --> /tmp/tmpnnl2rqvv.rs:22:22\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n22  |  \
    \       for word2 in lst2 {\n    |                      ^^^^ `lst2` moved due\
    \ to this implicit call to `.into_iter()`, in previous iteration of loop\n   \
    \ |\nnote: this function takes ownership of the receiver `self`, which moves `lst2`\n\
    help: consider iterating over a slice of the `Vec<String>`'s content to avoid\
    \ moving into the `for` loop\n    |\n22  |         for word2 in &lst2 {\n    |\
    \                      +\n\nerror[E0382]: borrow of moved value: `lst1`\n  -->\
    \ /tmp/tmpnnl2rqvv.rs:29:10\n   |\n15 | fn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n   |                ---- move occurs because\
    \ `lst1` has type `Vec<String>`, which does not implement the `Copy` trait\n...\n\
    21 |     for word1 in lst1 {\n   |                  ---- `lst1` moved due to this\
    \ implicit call to `.into_iter()`\n...\n29 |     vec![lst1[0]]\n   |         \
    \ ^^^^ value borrowed here after move\n   |\nhelp: consider iterating over a slice\
    \ of the `Vec<String>`'s content to avoid moving into the `for` loop\n   |\n21\
    \ |     for word1 in &lst1 {\n   |                  +\n\nerror[E0507]: cannot\
    \ move out of index of `Vec<String>`\n  --> /tmp/tmpnnl2rqvv.rs:29:10\n   |\n\
    29 |     vec![lst1[0]]\n   |          ^^^^^^^ move occurs because value has type\
    \ `String`, which does not implement the `Copy` trait\n\nerror: aborting due to\
    \ 3 previous errors; 1 warning emitted\n\nSome errors have detailed explanations:\
    \ E0382, E0507.\nFor more information about an error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1\n    } else {\n      \
    \  let mut max = 0;\n        let mut min_idx = -1;\n        for (i, elt1) in enumerate(lst1)\
    \ {\n            for (j, elt2) in enumerate(lst2) {\n                if elt1.len()\
    \ > max {\n                    max = elt1.len();\n                    min_idx\
    \ = j;\n                }\n                if elt2.len() > max {\n           \
    \         max = elt2.len();\n                    min_idx = i;\n              \
    \  }\n            }\n        }\n        let mut rev = lst2.clone();\n        rev.swap(0,\
    \ min_idx);\n        vec![lst1[min_idx]..rev]\n    }\n}\n\nfn main() {\n    let\
    \ candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `enumerate` in this scope\n  --> /tmp/tmp5tjgl1l1.rs:21:26\n\
    \   |\n21 |         for (i, elt1) in enumerate(lst1) {\n   |                 \
    \         ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `enumerate` in this scope\n  --> /tmp/tmp5tjgl1l1.rs:22:30\n   |\n22 |     \
    \        for (j, elt2) in enumerate(lst2) {\n   |                            \
    \  ^^^^^^^^^ not found in this scope\n\nerror[E0277]: the trait bound `usize:\
    \ Neg` is not satisfied\n  --> /tmp/tmp5tjgl1l1.rs:20:27\n   |\n20 |         let\
    \ mut min_idx = -1;\n   |                           ^^ the trait `Neg` is not\
    \ implemented for `usize`\n   |\n   = help: the following other types implement\
    \ trait `Neg`:\n             &f32\n             &f64\n             &i128\n   \
    \          &i16\n             &i32\n             &i64\n             &i8\n    \
    \         &isize\n           and 8 others\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp5tjgl1l1.rs:35:29\n   |\n35 |         vec![lst1[min_idx]..rev]\n\
    \   |                             ^^^ expected struct `String`, found struct `Vec`\n\
    \   |\n   = note: expected struct `String`\n              found struct `Vec<String>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp5tjgl1l1.rs:35:14\n   |\n35 |\
    \         vec![lst1[min_idx]..rev]\n   |              ^^^^^^^^^^^^^^^^^^ expected\
    \ struct `String`, found struct `std::ops::Range`\n   |\n   = note: expected struct\
    \ `String`\n              found struct `std::ops::Range<String>`\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0425.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == 0 || lst2.len() == 0 {\n        return vec![];\n    }\n\n\
    \    let len = lst1.len() + lst2.len();\n    let mut ret: Vec<String> = vec![];\n\
    \    let mut idx: usize = 0;\n    while idx < len {\n        let (mut i, mut j)\
    \ = if idx == 0 {\n            (0, lst1.len())\n        } else {\n           \
    \ (i1, j1) => {\n                if lst1[i1] < lst2[j1] {\n                  \
    \  (i1, j1 + 1)\n                } else {\n                    (j1 + 1, j1)\n\
    \                }\n            }\n        }\n\n        if i >= lst1.len() ||\
    \ j >= lst2.len() {\n            break;\n        }\n\n        let mut tmp = lst1[i];\n\
    \        lst1[i] = lst1[j];\n        lst1[j] = tmp;\n\n        tmp = lst2[i];\n\
    \        lst2[i] = lst2[j];\n        lst2[j] = tmp;\n\n        if i != j {\n \
    \           ret.push(String::from(&lst1[i]));\n        }\n    }\n\n    ret\n}\n\
    \nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `=>`\n\
    \  --> /tmp/tmp6wscya3x.rs:27:22\n   |\n27 |             (i1, j1) => {\n   | \
    \                     ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\n\
    error: expected `;`, found keyword `if`\n  --> /tmp/tmp6wscya3x.rs:34:10\n   |\n\
    34 |         }\n   |          ^ help: add `;` here\n35 | \n36 |         if i >=\
    \ lst1.len() || j >= lst2.len() {\n   |         -- unexpected token\n\nerror:\
    \ aborting due to 2 previous errors\n\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n\n    match lst1.len()\
    \ {\n        0 => return vec![],\n        1 => return vec![lst1[0]],\n       \
    \ _ => {\n            lst1.iter().zip(lst2.iter()).filter(|&(x, &y)| x < y).map(|&(x,\
    \ &y)| x).collect()\n        }\n    }\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp86czx543.rs:24:64\n   |\n\
    24 |             lst1.iter().zip(lst2.iter()).filter(|&(x, &y)| x < y).map(|&(x,\
    \ &y)| x).collect()\n   |                                                    \
    \            ^\n   |                                                         \
    \       |\n   |                                                              \
    \  expected `&String`, found struct `String`\n   |                           \
    \                                     help: consider borrowing here: `&y`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp86czx543.rs:24:72\n   |\n24 |  \
    \           lst1.iter().zip(lst2.iter()).filter(|&(x, &y)| x < y).map(|&(x, &y)|\
    \ x).collect()\n   |                                                         \
    \               ^^^^^^^-\n   |                                               \
    \                         |      |\n   |                                     \
    \                                   |      expected due to this\n   |        \
    \                                                                expected tuple,\
    \ found reference\n   |\n   = note:  expected tuple `(&String, &String)`\n   \
    \        found reference `&_`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == 0 || lst2.len() == 0 {\n        return vec![];\n    }\n\
    \    if lst1.len() == lst2.len() {\n        if lst1.len() == 0 {\n           \
    \ return vec![];\n        }\n        return vec![lst1[0]];\n    }\n    let mut\
    \ counter = Arc::new(Mutex::new(0));\n    let lst_1 = Arc::new(lst1.clone());\n\
    \    let lst_2 = Arc::new(lst2.clone());\n    let counter = Arc::clone(&counter);\n\
    \    let mut lst_3 = Vec::new();\n    let mut lst_4 = Vec::new();\n    let mut\
    \ mut lst_5 = Vec::new();\n    let mut lst_6 = Vec::new();\n    let mut lst_7\
    \ = Vec::new();\n    let mut lst_8 = Vec::new();\n    let mut lst_9 = Vec::new();\n\
    \    let mut lst_10 = Vec::new();\n    let mut lst_11 = Vec::new();\n    let mut\
    \ lst_12 = Vec::new();\n    let mut lst_13 = Vec::new();\n    let mut lst_14 =\
    \ Vec::new();\n    let mut lst_15 = Vec::new();\n    let mut lst_16 = Vec::new();\n\
    \    let mut lst_17 = Vec::new();\n    let mut lst_18 = Vec::new();\n    let mut\
    \ lst_19 = Vec::new();\n    let mut lst_20 = Vec::new();\n    let mut lst_21 =\
    \ Vec::new();\n    let mut lst_22 = Vec::new();\n    let mut lst_23 = Vec::new();\n\
    \    let mut lst_24 = Vec::new();\n    let mut lst_25 = Vec::new();\n    let mut\
    \ lst_26 = Vec::new();\n    let mut lst_27 = Vec::new();\n    let mut lst_28 =\
    \ Vec::new();\n    let mut lst_29 = Vec::new();\n    let mut lst_30 = Vec::new();\n\
    \    let mut lst_31 = Vec::new();\n    let mut lst_32 = Vec::new();\n    let mut\
    \ lst_33 = Vec::new();\n    let mut lst_34 = Vec::new();\n    let mut lst_35 =\
    \ Vec::new();\n    let mut lst_36 = Vec::new();\n    let mut lst_37 = Vec::\n\
    }\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error: `mut` on a binding may not be repeated\n  --> /tmp/tmpy0ruqt_s.rs:31:13\n\
    \   |\n31 |     let mut mut lst_5 = Vec::new();\n   |             ^^^ help: remove\
    \ the additional `mut`s\n\nerror: expected identifier, found `}`\n  --> /tmp/tmpy0ruqt_s.rs:64:1\n\
    \   |\n64 | }\n   | ^ expected identifier\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `Arc`\n  --> /tmp/tmpy0ruqt_s.rs:25:23\n   |\n25 |  \
    \   let mut counter = Arc::new(Mutex::new(0));\n   |                       ^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::sync::Arc;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `Mutex`\n  --> /tmp/tmpy0ruqt_s.rs:25:32\n   |\n25 |     let mut counter\
    \ = Arc::new(Mutex::new(0));\n   |                                ^^^^^ not found\
    \ in this scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::sync::Mutex;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Arc`\n  -->\
    \ /tmp/tmpy0ruqt_s.rs:26:17\n   |\n26 |     let lst_1 = Arc::new(lst1.clone());\n\
    \   |                 ^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::sync::Arc;\n   |\n\nerror[E0433]: failed to\
    \ resolve: use of undeclared type `Arc`\n  --> /tmp/tmpy0ruqt_s.rs:27:17\n   |\n\
    27 |     let lst_2 = Arc::new(lst2.clone());\n   |                 ^^^ not found\
    \ in this scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::sync::Arc;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Arc`\n  -->\
    \ /tmp/tmpy0ruqt_s.rs:28:19\n   |\n28 |     let counter = Arc::clone(&counter);\n\
    \   |                   ^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::sync::Arc;\n   |\n\nerror: aborting due to\
    \ 7 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    lst1.iter().zip(lst2.iter()).filter(|&(k, v)| v.len() < k.len()).collect::<Vec<_>>()\n\
    }\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk67ynob2.rs:16:5\n   |\n\
    15 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n \
    \  |                                                         ----------- expected\
    \ `Vec<String>` because of return type\n16 |     lst1.iter().zip(lst2.iter()).filter(|&(k,\
    \ v)| v.len() < k.len()).collect::<Vec<_>>()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found tuple\n   |\n   = note: expected struct `Vec<String>`\n\
    \              found struct `Vec<(&String, &String)>`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        lst1\n    } else {\n        let mut\
    \ counter = HashMap::new();\n        for value in lst1.iter() {\n            counter.insert(value,\
    \ counter.get(&value).unwrap() + 1);\n        }\n        let mut res = vec![];\n\
    \        for value in lst2.iter() {\n            if counter.get(&value).unwrap()\
    \ <= lst1.len() {\n                res.push(value);\n            }\n        }\n\
    \        res\n    }\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpobom2jjb.rs:19:27\n   |\n19 |         let mut counter = HashMap::new();\n\
    \   |                           ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpobom2jjb.rs:29:9\n   |\n15 | fn total_match(lst1:\
    \ Vec<String>, lst2: Vec<String>) -> Vec<String> {\n   |                     \
    \                                    ----------- expected `Vec<String>` because\
    \ of return type\n...\n29 |         res\n   |         ^^^ expected struct `String`,\
    \ found `&String`\n   |\n   = note: expected struct `Vec<String>`\n          \
    \    found struct `Vec<&String>`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    for e in\
    \ lst1 {\n        if lst2.iter().all(|s| !s.contains(e)) {\n            return\
    \ lst1;\n        }\n    }\n    for e in lst2 {\n        if lst1.iter().all(|s|\
    \ !s.contains(e)) {\n            return lst2;\n        }\n    }\n    lst1\n}\n\
    \nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n   \
    \ --> /tmp/tmp3ufpnr8t.rs:20:44\n     |\n20   |         if lst2.iter().all(|s|\
    \ !s.contains(e)) {\n     |                                   -------- ^ expected\
    \ an implementor of trait `Pattern<'_>`\n     |                              \
    \     |\n     |                                   required by a bound introduced\
    \ by this call\n     |\n     = note: the trait bound `String: Pattern<'_>` is\
    \ not satisfied\n     = note: required because of the requirements on the impl\
    \ of `Pattern<'_>` for `String`\nnote: required by a bound in `core::str::<impl\
    \ str>::contains`\nhelp: consider borrowing here\n     |\n20   |         if lst2.iter().all(|s|\
    \ !s.contains(&e)) {\n     |                                            +\n\n\
    error[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n    --> /tmp/tmp3ufpnr8t.rs:25:44\n\
    \     |\n25   |         if lst1.iter().all(|s| !s.contains(e)) {\n     |     \
    \                              -------- ^ expected an implementor of trait `Pattern<'_>`\n\
    \     |                                   |\n     |                          \
    \         required by a bound introduced by this call\n     |\n     = note: the\
    \ trait bound `String: Pattern<'_>` is not satisfied\n     = note: required because\
    \ of the requirements on the impl of `Pattern<'_>` for `String`\nnote: required\
    \ by a bound in `core::str::<impl str>::contains`\nhelp: consider borrowing here\n\
    \     |\n25   |         if lst1.iter().all(|s| !s.contains(&e)) {\n     |    \
    \                                        +\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut new_lst = lst1.clone();\n    for elem in lst2 {\n        let idx\
    \ = new_lst.iter().position(|x| x == elem);\n        if idx < new_lst.len() {\n\
    \            new_lst[idx] = elem;\n        }\n    }\n    new_lst\n}\n\nfn main()\
    \ {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&String` with `String`\n  --> /tmp/tmpc090qoui.rs:18:49\n\
    \   |\n18 |         let idx = new_lst.iter().position(|x| x == elem);\n   |  \
    \                                               ^^ no implementation for `&String\
    \ == String`\n   |\n   = help: the trait `PartialEq<String>` is not implemented\
    \ for `&String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpc090qoui.rs:19:18\n   |\n19 |         if idx < new_lst.len()\
    \ {\n   |                  ^^^^^^^^^^^^^ expected enum `Option`, found `usize`\n\
    \   |\n   = note: expected enum `Option<usize>`\n              found type `usize`\n\
    help: try wrapping the expression in `Some`\n   |\n19 |         if idx < Some(new_lst.len())\
    \ {\n   |                  +++++             +\n\nerror[E0277]: the type `[String]`\
    \ cannot be indexed by `Option<usize>`\n  --> /tmp/tmpc090qoui.rs:20:13\n   |\n\
    20 |             new_lst[idx] = elem;\n   |             ^^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[String]>`\
    \ is not implemented for `Option<usize>`\n   = note: required because of the requirements\
    \ on the impl of `Index<Option<usize>>` for `Vec<String>`\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() != lst2.len() {\n        return lst1;\n    }\n    let mut total_matcher\
    \ = String::new();\n    let mut j = 0;\n    for i in 0..lst1.len() {\n       \
    \ total_matcher.push_str(&total_matcher.chars().filter(|&x| x != lst2[j]).count());\n\
    \        j = total_matcher.chars().filter(|&x| x != lst2[j]).count();\n    }\n\
    \    return total_matcher.chars().filter(|&x| x != total_matcher.chars().filter(|&x|\
    \ x != lst2[j]).count()).collect();\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1t4n3gav.rs:22:72\n   |\n\
    22 |         total_matcher.push_str(&total_matcher.chars().filter(|&x| x != lst2[j]).count());\n\
    \   |                                                                        ^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmp1t4n3gav.rs:22:32\n   |\n22 |         total_matcher.push_str(&total_matcher.chars().filter(|&x|\
    \ x != lst2[j]).count());\n   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `str`, found `usize`\n   |\n   = note: expected reference `&str`\n\
    \              found reference `&usize`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp1t4n3gav.rs:23:52\n   |\n23 |         j = total_matcher.chars().filter(|&x|\
    \ x != lst2[j]).count();\n   |                                               \
    \     ^^^^^^^ expected `char`, found struct `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp1t4n3gav.rs:25:90\n   |\n25 |     return total_matcher.chars().filter(|&x|\
    \ x != total_matcher.chars().filter(|&x| x != lst2[j]).count()).collect();\n \
    \  |                                                                         \
    \                 ^^^^^^^ expected `char`, found struct `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp1t4n3gav.rs:25:51\n   |\n25 |     return total_matcher.chars().filter(|&x|\
    \ x != total_matcher.chars().filter(|&x| x != lst2[j]).count()).collect();\n \
    \  |                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found `usize`\n\nerror[E0277]: a value of type `Vec<String>`\
    \ cannot be built from an iterator over elements of type `char`\n    --> /tmp/tmp1t4n3gav.rs:25:108\n\
    \     |\n25   |     return total_matcher.chars().filter(|&x| x != total_matcher.chars().filter(|&x|\
    \ x != lst2[j]).count()).collect();\n     |                                  \
    \                                                                          ^^^^^^^\
    \ value of type `Vec<String>` cannot be built from `std::iter::Iterator<Item=char>`\n\
    \   "
  stdout: ''
  timestamp: 1659976548
- exit_code: 101
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1\n    }\n    if lst1.len()\
    \ > lst2.len() {\n        lst2\n    } else {\n        lst1\n    }\n}\n\nfn main()\
    \ {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"hi\", \"admin\"]`,\n right: `[\"hi\", \"hi\"]`', /tmp/tmpeasl8bb6.rs:29:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut total_matches = Vec::new();\n    for i in lst1.iter() {\n       \
    \ if lst2.iter().any(|&s| s <= i) {\n            total_matches.push(i);\n    \
    \    }\n    }\n    total_matches\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp57770y6k.rs:18:38\n   |\n\
    18 |         if lst2.iter().any(|&s| s <= i) {\n   |                         \
    \             ^- help: try using a conversion method: `.to_string()`\n   |   \
    \                                   |\n   |                                  \
    \    expected struct `String`, found `&String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp57770y6k.rs:22:5\n   |\n15 | fn total_match(lst1: Vec<String>,\
    \ lst2: Vec<String>) -> Vec<String> {\n   |                                  \
    \                       ----------- expected `Vec<String>` because of return type\n\
    ...\n22 |     total_matches\n   |     ^^^^^^^^^^^^^ expected struct `String`,\
    \ found `&String`\n   |\n   = note: expected struct `Vec<String>`\n          \
    \    found struct `Vec<&String>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1\n    } else {\n      \
    \  let mut res = Vec::new();\n        lst1.iter().for_each(|x| {\n           \
    \ lst2.iter().for_each(|y| {\n                if x.len() + y.len() <= y.len()\
    \ {\n                    res.push(x);\n                    return;\n         \
    \       }\n            });\n        });\n        res\n    }\n}\n\nfn main() {\n\
    \    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmponxrgvq7.rs:28:9\n   |\n\
    15 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n \
    \  |                                                         ----------- expected\
    \ `Vec<String>` because of return type\n...\n28 |         res\n   |         ^^^\
    \ expected struct `String`, found `&String`\n   |\n   = note: expected struct\
    \ `Vec<String>`\n              found struct `Vec<&String>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut res = vec![];\n    for i in 0..lst1.len() {\n        let n = lst1[i].len();\n\
    \        let m = lst2[i].len();\n        if n < m {\n            res.push(lst1[i]);\n\
    \        }\n        else {\n            res.push(lst2[i]);\n        }\n    }\n\
    \    res\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpax9p90p1.rs:21:22\n\
    \   |\n21 |             res.push(lst1[i]);\n   |                      ^^^^^^^\
    \ move occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpax9p90p1.rs:24:22\n\
    \   |\n24 |             res.push(lst2[i]);\n   |                      ^^^^^^^\
    \ move occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0507`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut total_matching = vec![];\n    let mut i = 0;\n    while i < lst1.len()\
    \ {\n        for j in 0..lst2.len() {\n            if i >= lst1.len() && j < lst2.len()\
    \ {\n                break;\n            }\n            \n            if i >=\
    \ lst1.len() && j >= lst2.len() {\n                break;\n            }\n   \
    \         \n            if lst1[i] == lst2[j] {\n                total_matching.push(lst1[i]);\n\
    \                i += 1;\n                break;\n            }\n        }\n \
    \   }\n    total_matching\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpj0j4v7lg.rs:29:37\n\
    \   |\n29 |                 total_matching.push(lst1[i]);\n   |              \
    \                       ^^^^^^^ move occurs because value has type `String`, which\
    \ does not implement the `Copy` trait\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0507`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        lst1\n    } else {\n        let mut\
    \ total_len = lst1.len();\n        let mut match_chars = lst2.len();\n       \
    \ let mut pos = Vec::new();\n        let mut i = 0;\n        while i < lst1.len()\
    \ && i < lst2.len() {\n            let current_len = lst1.len() - i;\n       \
    \     if current_len < total_len {\n                break;\n            }\n  \
    \          let current_char_pos = current_len - total_len;\n            let char_pos\
    \ = i - current_char_pos;\n            if char_pos < match_chars {\n         \
    \       break;\n            }\n            pos.push(current_char_pos as usize);\n\
    \            total_len -= current_char_pos;\n            i += 1;\n        }\n\
    \        match total_len {\n            0 => vec![String::new()],\n          \
    \  _ => vec![String::from_utf8(lst1.to_vec()).unwrap()],\n        }\n    }\n}\n\
    \nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptbpop7fn.rs:39:41\n   |\n\
    39 |             _ => vec![String::from_utf8(lst1.to_vec()).unwrap()],\n   | \
    \                                        ^^^^^^^^^^^^^ expected `u8`, found struct\
    \ `String`\n   |\n   = note: expected struct `Vec<u8>`\n              found struct\
    \ `Vec<String>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        for s in lst1.iter().filter(|s| s\
    \ < &lst2).filter(|s| !lst2.contains(&s)) {\n            lst1.remove(*s);\n  \
    \      }\n        lst1\n    } else {\n        lst1\n    }\n}\n\nfn main() {\n\
    \    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphhtmtx2e.rs:17:45\n   |\n\
    17 |         for s in lst1.iter().filter(|s| s < &lst2).filter(|s| !lst2.contains(&s))\
    \ {\n   |                                             ^^^^^ expected `&String`,\
    \ found struct `Vec`\n   |\n   = note: expected reference `&&String`\n       \
    \       found reference `&Vec<String>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmphhtmtx2e.rs:18:25\n   |\n18 |             lst1.remove(*s);\n   |   \
    \                      ^^ expected `usize`, found struct `String`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut total_length = 0;\n    for elem in lst1 {\n        total_length +=\
    \ elem.len();\n    }\n    let mut length_difference = lst1.len();\n    for elem\
    \ in lst2 {\n        length_difference -= elem.len();\n        if length_difference\
    \ == 0 {\n            break;\n        }\n    }\n    let mut output = lst1;\n \
    \   if length_difference == 0 {\n        for elem in lst2 {\n            output.push(elem);\n\
    \        }\n    } else {\n        for elem in lst2 {\n            if elem.len()\
    \ < total_length {\n                output.push(elem);\n            }\n      \
    \  }\n    }\n    output\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `lst1`\n   --> /tmp/tmp6ysd2122.rs:20:33\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                ---- move occurs because `lst1` has type `Vec<String>`,\
    \ which does not implement the `Copy` trait\n16  |     let mut total_length =\
    \ 0;\n17  |     for elem in lst1 {\n    |                 ---- `lst1` moved due\
    \ to this implicit call to `.into_iter()`\n...\n20  |     let mut length_difference\
    \ = lst1.len();\n    |                                 ^^^^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `lst1`\nhelp: consider iterating over a slice of the `Vec<String>`'s\
    \ content to avoid moving into the `for` loop\n    |\n17  |     for elem in &lst1\
    \ {\n    |                 +\n\nerror[E0382]: use of moved value: `lst2`\n  -->\
    \ /tmp/tmp6ysd2122.rs:29:21\n   |\n15 | fn total_match(lst1: Vec<String>, lst2:\
    \ Vec<String>) -> Vec<String> {\n   |                                   ---- move\
    \ occurs because `lst2` has type `Vec<String>`, which does not implement the `Copy`\
    \ trait\n...\n21 |     for elem in lst2 {\n   |                 ---- `lst2` moved\
    \ due to this implicit call to `.into_iter()`\n...\n29 |         for elem in lst2\
    \ {\n   |                     ^^^^ value used here after move\n   |\nhelp: consider\
    \ iterating over a slice of the `Vec<String>`'s content to avoid moving into the\
    \ `for` loop\n   |\n21 |     for elem in &lst2 {\n   |                 +\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 101
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    for x in\
    \ lst2 {\n        if !lst1.contains(&x) {\n            return Vec::new();\n  \
    \      }\n    }\n    lst1\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"hi\", \"admin\"]`,\n right: `[\"hi\", \"hi\"]`', /tmp/tmpwrfs3x13.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut lst = lst1.clone();\n    lst.extend(lst2.into_iter().collect::<Vec<String>>());\n\
    \    let mut count = vec![];\n    for s in lst {\n        if count > lst1.len()\
    \ {\n            return lst1;\n        }\n        count.push(s.chars().filter(|c|\
    \ *c <= 32).count());\n    }\n    lst1\n}\n\nfn main() {\n    let candidate =\
    \ total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplravga45.rs:20:20\n   |\n\
    20 |         if count > lst1.len() {\n   |                    ^^^^^^^^^^ expected\
    \ struct `Vec`, found `usize`\n   |\n   = note: expected struct `Vec<_>`\n   \
    \             found type `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplravga45.rs:23:47\n\
    \   |\n23 |         count.push(s.chars().filter(|c| *c <= 32).count());\n   |\
    \                                               ^^ expected `char`, found `u8`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == 0 || lst2.len() == 0 {\n        return vec![];\n    }\n\n\
    \    if lst1.len() == 1 && lst2.len() == 1 {\n        return vec![lst1[0]];\n\
    \    }\n\n    let mut min_len = min(lst1.len(), lst2.len());\n    let mut min_len\
    \ = min_len.min(|a, b| a.cmp(&b));\n\n    for _ in 0..min_len {\n        let mut\
    \ index = vec![String::new(), String::new(), String::new(), String::new(), String::new(),\
    \ String::new()];\n        let mut index = index.mut_iter().collect::<Vec<String>>();\n\
    \n        let mut count = 0;\n        for _ in 0..4 { index.push(String::new());\
    \ }\n        for _ in 0..4 { index.push(String::new()); }\n        for _ in 0..4\
    \ { index.push(String::new()); }\n        for _ in 0..4 { index.push(String::new());\
    \ }\n        for _ in 0..4 { index.push(String::new()); }\n        for _ in 0..4\
    \ { index.push(String::new()); }\n\n        let mut count = 0;\n        let mut\
    \ index = index.mut_iter().collect::<Vec<String>>();\n\n        for a in lst1\
    \ {\n            for b in lst2 {\n                if a.len() < b.len() {\n   \
    \                 if index[count][a] < index[count][b] {\n                   \
    \     index[count][a] = b;\n                    }\n                } else {\n\
    \                    if index[count][a] > index[count][b] {\n                \
    \        index[count][a] = b;\n                    }\n                }\n    \
    \            count += 1;\n            }\n        }\n\n        for _ in 0..min_len\
    \ {\n            for a in index {\n                for b in index {\n        \
    \            if index[count][a] == index[count][b] {\n                       \
    \ index[count][a] = \"\";\n                    }\n                }\n        \
    \        count += 1;\n            }\n        }\n\n        count = count / 4;\n\
    \        for _ in 0..4 { index.push(String::new()); }\n        for _ in 0..4 {\
    \ index.push(String::new()); }\n        for _ in 0..4 { index.push(String::new());\
    \ }\n        for _ in 0..4 { index.push(String::new()); }\n        for _ in 0..4\
    \ { index.push(String::new()); }\n        for _ in 0..4 { index.push(String::new());\
    \ }\n        for _ in 0..4 { index.push(String::new()); }\n\n        let mut count\
    \ = 0;\n        let mut index = index.mut_iter().collect::<Vec<String>>();\n\n\
    \        for a in lst1 {\n            for b in \n}\n\nfn main() {\n    let candidate\
    \ = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpfr8j6_4l.rs:95:3\n\
    \   |\n15 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |                                                                    \
    \ - unclosed delimiter\n...\n27 |     for _ in 0..min_len {\n   |            \
    \             - unclosed delimiter\n...\n80 |         for a in lst1 {\n   |  \
    \                     - this delimiter might not be properly closed...\n81 | \
    \            for b in \n82 | }\n   | - ...as it matches this but it has different\
    \ indentation\n...\n95 | }\n   |   ^\n\nerror: expected expression, found `}`\n\
    \  --> /tmp/tmpfr8j6_4l.rs:82:1\n   |\n82 | }\n   | ^ expected expression\n\n\
    error[E0425]: cannot find function `min` in this scope\n  --> /tmp/tmpfr8j6_4l.rs:24:23\n\
    \   |\n24 |     let mut min_len = min(lst1.len(), lst2.len());\n   |         \
    \              ^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ function\n   |\n1  | use std::cmp::min;\n   |\n\nerror[E0599]: no method named\
    \ `mut_iter` found for struct `Vec<String>` in the current scope\n  --> /tmp/tmpfr8j6_4l.rs:29:31\n\
    \   |\n29 |         let mut index = index.mut_iter().collect::<Vec<String>>();\n\
    \   |                               ^^^^^^^^ help: there is an associated function\
    \ with a similar name: `iter`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfr8j6_4l.rs:27:5\n\
    \   |\n15 |   fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |                                                           -----------\
    \ expected `Vec<String>` because of return type\n...\n27 | /     for _ in 0..min_len\
    \ {\n28 | |         let mut index = vec![String::new(), String::new(), String::new(),\
    \ String::new(), String::new(), String::new()];\n29 | |         let mut index\
    \ = index.mut_iter().collect::<Vec<String>>();\n30 | |\n...  |\n94 | |     assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n95 | | }\n   | |__^ expected\
    \ struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<String>`\n \
    \          found unit type `()`\n\nerror: aborting due to 5 "
  stdout: ''
  timestamp: 1659976548
- exit_code: 101
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        lst1\n    } else {\n        lst2\n\
    \    }\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"hi\", \"admin\"]`,\n right: `[\"hi\", \"hi\"]`', /tmp/tmp5fohhy0d.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 101
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n\n    let mut\
    \ i = 0;\n    while i < lst1.len() {\n        if lst1[i].len() < lst2[i].len()\
    \ {\n            return lst1;\n        }\n    }\n    return lst2;\n}\n\nfn main()\
    \ {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"hi\", \"admin\"]`,\n right: `[\"hi\", \"hi\"]`', /tmp/tmpvum0do00.rs:32:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut total = 0;\n    for i in 0..lst1.len() {\n        if lst1[i] < lst2[i]\
    \ {\n            total += lst1[i].len();\n        } else {\n            total\
    \ += lst2[i].len();\n        }\n    }\n    vec![lst1[0]] if total == lst1.len()\
    \ && total < lst2.len()\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found keyword\
    \ `if`\n  --> /tmp/tmpd_02lpbs.rs:24:19\n   |\n24 |     vec![lst1[0]] if total\
    \ == lst1.len() && total < lst2.len()\n   |                   ^^ expected one\
    \ of `.`, `;`, `?`, `}`, or an operator\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut res = Vec::new();\n    for (a, b) in lst1.iter().zip(lst2.iter())\
    \ {\n        if *a > *b {\n            res.push(*a);\n        } else {\n     \
    \       res.push(*b);\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0507]: cannot move out of `*a` which is behind a shared reference\n\
    \  --> /tmp/tmp8xnqri4g.rs:19:22\n   |\n19 |             res.push(*a);\n   | \
    \                     ^^ move occurs because `*a` has type `String`, which does\
    \ not implement the `Copy` trait\n\nerror[E0507]: cannot move out of `*b` which\
    \ is behind a shared reference\n  --> /tmp/tmp8xnqri4g.rs:21:22\n   |\n21 |  \
    \           res.push(*b);\n   |                      ^^ move occurs because `*b`\
    \ has type `String`, which does not implement the `Copy` trait\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0507`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 101
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    lst1.iter().cloned().collect::<Vec<_>>()\n\
    \        .into_iter()\n        .zip(lst2.iter().cloned().collect::<Vec<_>>()).take(lst1.len())\n\
    \        .map(|(a, b)| if a.len() == b.len() {\n            a\n        } else\
    \ {\n            b\n        }).collect::<Vec<_>>()\n}\n\nfn main() {\n    let\
    \ candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"hi\", \"admin\"]`,\n right: `[\"hi\", \"hi\"]`', /tmp/tmpvfxwlaz6.rs:32:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976549
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut i = 0;\n    lst2.into_iter().filter(|x| {\n        lst1.iter().any(|y|\
    \ {\n            y.len() > i && y.substr(0, i) == x\n        })\n    }).cloned()\n\
    }\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `substr` found for reference `&String` in\
    \ the current scope\n  --> /tmp/tmp_7qlmg3t.rs:19:30\n   |\n19 |             y.len()\
    \ > i && y.substr(0, i) == x\n   |                              ^^^^^^ method\
    \ not found in `&String`\n\nerror[E0271]: type mismatch resolving `<Filter<std::vec::IntoIter<String>,\
    \ [closure@/tmp/tmp_7qlmg3t.rs:17:29: 21:6]> as Iterator>::Item == &_`\n    -->\
    \ /tmp/tmp_7qlmg3t.rs:21:8\n     |\n21   |     }).cloned()\n     |        ^^^^^^\
    \ expected reference, found struct `String`\n     |\n     = note: expected reference\
    \ `&_`\n                   found struct `String`\nnote: required by a bound in\
    \ `cloned`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_7qlmg3t.rs:17:5\n\
    \   |\n15 |   fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |                                                           -----------\
    \ expected `Vec<String>` because of return type\n16 |       let mut i = 0;\n17\
    \ | /     lst2.into_iter().filter(|x| {\n18 | |         lst1.iter().any(|y| {\n\
    19 | |             y.len() > i && y.substr(0, i) == x\n20 | |         })\n21 |\
    \ |     }).cloned()\n   | |_______________^ expected struct `Vec`, found struct\
    \ `Cloned`\n   |\n   = note: expected struct `Vec<String>`\n              found\
    \ struct `Cloned<Filter<std::vec::IntoIter<String>, [closure@/tmp/tmp_7qlmg3t.rs:17:29:\
    \ 21:6]>>`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0271, E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        lst1\n    } else {\n        if let\
    \ Some(idx) = lst2.iter().position(|e| e > &lst1[0]) {\n            lst1.iter().skip(idx).take(lst2.len()\
    \ - idx).collect()\n        } else {\n            vec![lst1[0]]\n        }\n \
    \   }\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&String`\n    --> /tmp/tmpk_cwrfpy.rs:20:58\n     |\n\
    20   |             lst1.iter().skip(idx).take(lst2.len() - idx).collect()\n  \
    \   |                                                          ^^^^^^^ value of\
    \ type `Vec<String>` cannot be built from `std::iter::Iterator<Item=&String>`\n\
    \     |\n     = help: the trait `FromIterator<&String>` is not implemented for\
    \ `Vec<String>`\n     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\n\
    note: required by a bound in `collect`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_matcher\
    \ = Vec::new();\n    let mut current_index = -1;\n    let mut current_count =\
    \ 0;\n    for str1 in lst1 {\n        let mut flag = false;\n        for str2\
    \ in lst2 {\n            if current_index == -1 {\n                flag = true;\n\
    \                total_matcher.push(str1);\n                break;\n         \
    \   } else if current_index != -1 {\n                if str2.chars().all(|c| c\
    \ == current_count) {\n                    total_matcher.push(str1);\n       \
    \             break;\n                }\n            }\n            current_index\
    \ = current_index + 1;\n            current_count += 1;\n        }\n        if\
    \ !flag {\n            total_matcher.push(str1);\n        }\n    }\n    total_matcher\n\
    }\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphjs94e1y.rs:30:46\n   |\n\
    30 |                 if str2.chars().all(|c| c == current_count) {\n   |     \
    \                                         ^^^^^^^^^^^^^ expected `char`, found\
    \ integer\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    lst1.iter().filter(|s| lst2.iter().any(|s2| s2 > s)).collect::<Vec<String>>()\n\
    }\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&String`\n    --> /tmp/tmptfqc1rfr.rs:16:58\n     |\n\
    16   |     lst1.iter().filter(|s| lst2.iter().any(|s2| s2 > s)).collect::<Vec<String>>()\n\
    \     |                                                          ^^^^^^^ value\
    \ of type `Vec<String>` cannot be built from `std::iter::Iterator<Item=&String>`\n\
    \     |\n     = help: the trait `FromIterator<&String>` is not implemented for\
    \ `Vec<String>`\n     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\n\
    note: required by a bound in `collect`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == 0 || lst2.len() == 0 {\n        return vec![];\n    }\n\
    \    \n    // Find longest matching chars from each string\n    let mut max_match\
    \ = 0;\n    let mut min_match = MAX_LEN;\n    for (i, i1s) in lst1.iter().enumerate()\
    \ {\n        for (j, j2s) in lst2.iter().enumerate() {\n            // Find the\
    \ max and min char matches\n            if i1s.len() > j2s.len() {\n         \
    \       max_match = max(max_match, i1s.len());\n                min_match = min(min_match,\
    \ j2s.len());\n            } else if i1s.len() < j2s.len() {\n               \
    \ max_match = max(max_match, j2s.len());\n                min_match = min(min_match,\
    \ i1s.len());\n            } else {\n                max_match = max(max_match,\
    \ i1s.len());\n                min_match = min(min_match, j2s.len());\n      \
    \      }\n        }\n    }\n    let mut lst_matches = vec![String::new(); lst2.len()];\n\
    \    for (i, i1s) in lst1.iter().enumerate() {\n        // Compare each of remaining\
    \ chars in lst1 with the remaining chars in lst2\n        let mut i2_match = max_match;\n\
    \        for (j, j2s) in lst2.iter().enumerate() {\n            if j > i2_match\
    \ {\n                break;\n            }\n            if i1s[i2_match..].iter().all(|&c|\
    \ c == '_' || c == '-' || c == '/') {\n                i2_match += 1;\n      \
    \      } else {\n                break;\n            }\n        }\n        lst_matches[i]\
    \ = i1s[i2_match..];\n    }\n    \n    return lst_matches;\n}\n\nfn main() {\n\
    \    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `MAX_LEN` in this scope\n  --> /tmp/tmpgkxtql2d.rs:22:25\n\
    \   |\n22 |     let mut min_match = MAX_LEN;\n   |                         ^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `max` in this\
    \ scope\n  --> /tmp/tmpgkxtql2d.rs:27:29\n   |\n27 |                 max_match\
    \ = max(max_match, i1s.len());\n   |                             ^^^ not found\
    \ in this scope\n   |\nhelp: consider importing this function\n   |\n1  | use\
    \ std::cmp::max;\n   |\n\nerror[E0425]: cannot find function `min` in this scope\n\
    \  --> /tmp/tmpgkxtql2d.rs:28:29\n   |\n28 |                 min_match = min(min_match,\
    \ j2s.len());\n   |                             ^^^\n...\n58 | fn main() {\n \
    \  | --------- similarly named function `main` defined here\n   |\nhelp: a function\
    \ with a similar name exists\n   |\n28 |                 min_match = main(min_match,\
    \ j2s.len());\n   |                             ~~~~\nhelp: consider importing\
    \ this function\n   |\n1  | use std::cmp::min;\n   |\n\nerror[E0425]: cannot find\
    \ function `max` in this scope\n  --> /tmp/tmpgkxtql2d.rs:30:29\n   |\n30 |  \
    \               max_match = max(max_match, j2s.len());\n   |                 \
    \            ^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ function\n   |\n1  | use std::cmp::max;\n   |\n\nerror[E0425]: cannot find function\
    \ `min` in this scope\n  --> /tmp/tmpgkxtql2d.rs:31:29\n   |\n31 |           \
    \      min_match = min(min_match, i1s.len());\n   |                          \
    \   ^^^\n...\n58 | fn main() {\n   | --------- similarly named function `main`\
    \ defined here\n   |\nhelp: a function with a similar name exists\n   |\n31 |\
    \                 min_match = main(min_match, i1s.len());\n   |              \
    \               ~~~~\nhelp: consider importing this function\n   |\n1  | use std::cmp::min;\n\
    \   |\n\nerror[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpgkxtql2d.rs:33:29\n\
    \   |\n33 |                 max_match = max(max_match, i1s.len());\n   |     \
    \                        ^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this function\n   |\n1  | use std::c"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    if lst1.len()\
    \ > lst2.len() {\n        return vec![\"\".to_string(); lst2.len()];\n    }\n\
    \    if lst2.len() > lst1.len() {\n        return vec![\"\".to_string(); lst1.len()];\n\
    \    }\n\n    vec![\"\".to_string(); lst1.len()].iter().zip(lst2.iter()).fold(\n\
    \        vec![\"\".to_string(); lst1.len()],\n        |acc, (mut acc, x| {\n \
    \           if acc.len() == 0 {\n                acc += vec![x];\n           \
    \ } else {\n                if acc.len() == 1 {\n                    acc += vec![x];\n\
    \                } else {\n                    if x.len() < acc.len() {\n    \
    \                    acc += vec![x];\n                    } else if x.len() >\
    \ acc.len() {\n                        acc += vec![\"\".to_string(); x.len()];\n\
    \                    }\n                }\n            }\n            acc\n  \
    \      }))\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `{`\n  --> /tmp/tmp93x_r94x.rs:28:28\n \
    \  |\n28 |         |acc, (mut acc, x| {\n   |                         -  ^ expected\
    \ pattern\n   |                         |\n   |                         while\
    \ parsing this or-pattern starting here\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    // TODO: Improve performance\n    let mut total_count = 0;\n    let mut common_chars:\
    \ usize = 0;\n    for el1 in lst1 {\n        let mut el2_chars = 0;\n        for\
    \ el2 in lst2 {\n            if el1 == el2 {\n                el2_chars += 1;\n\
    \            }\n        }\n        total_count += el2_chars;\n        common_chars\
    \ += el2_chars;\n    }\n    if total_count == common_chars {\n        lst1\n \
    \   } else {\n        lst2\n    }\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmp5ikttvv7.rs:21:20\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n21  |  \
    \       for el2 in lst2 {\n    |                    ^^^^ `lst2` moved due to this\
    \ implicit call to `.into_iter()`, in previous iteration of loop\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `lst2`\nhelp:\
    \ consider iterating over a slice of the `Vec<String>`'s content to avoid moving\
    \ into the `for` loop\n    |\n21  |         for el2 in &lst2 {\n    |        \
    \            +\n\nerror[E0382]: use of moved value: `lst1`\n  --> /tmp/tmp5ikttvv7.rs:30:9\n\
    \   |\n15 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |                ---- move occurs because `lst1` has type `Vec<String>`,\
    \ which does not implement the `Copy` trait\n...\n19 |     for el1 in lst1 {\n\
    \   |                ---- `lst1` moved due to this implicit call to `.into_iter()`\n\
    ...\n30 |         lst1\n   |         ^^^^ value used here after move\n   |\nhelp:\
    \ consider iterating over a slice of the `Vec<String>`'s content to avoid moving\
    \ into the `for` loop\n   |\n19 |     for el1 in &lst1 {\n   |               \
    \ +\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut lst = vec![];\n    for s1 in lst1 {\n        for s2 in lst2 {\n \
    \           if s1.len() < s2.len() {\n                let mut lst = s1.clone();\n\
    \                lst.push_str(&s2[s1.len()..]);\n                lst.sort();\n\
    \                if lst.is_permutation() {\n                    lst.sort();\n\
    \                    lst.push_s(\"...\");\n                    lst.sort();\n \
    \                   lst.push_s(\"...\");\n                    lst.sort();\n  \
    \                  return lst;\n                }\n            }\n        }\n\
    \    }\n    lst1\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp17q1sq91.rs:22:21\n   |\n22 |                 lst.sort();\n\
    \   |                     ^^^^ method not found in `String`\n\nerror[E0599]: no\
    \ method named `is_permutation` found for struct `String` in the current scope\n\
    \  --> /tmp/tmp17q1sq91.rs:23:24\n   |\n23 |                 if lst.is_permutation()\
    \ {\n   |                        ^^^^^^^^^^^^^^ method not found in `String`\n\
    \nerror[E0599]: no method named `sort` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp17q1sq91.rs:24:25\n   |\n24 |                     lst.sort();\n\
    \   |                         ^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `push_s` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmp17q1sq91.rs:25:25\n   |\n25 |                     lst.push_s(\"...\"\
    );\n   |                         ^^^^^^ help: there is an associated function\
    \ with a similar name: `push`\n\nerror[E0599]: no method named `sort` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmp17q1sq91.rs:26:25\n   |\n\
    26 |                     lst.sort();\n   |                         ^^^^ method\
    \ not found in `String`\n\nerror[E0599]: no method named `push_s` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmp17q1sq91.rs:27:25\n   |\n27 | \
    \                    lst.push_s(\"...\");\n   |                         ^^^^^^\
    \ help: there is an associated function with a similar name: `push`\n\nerror[E0599]:\
    \ no method named `sort` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmp17q1sq91.rs:28:25\n   |\n28 |                     lst.sort();\n   |\
    \                         ^^^^ method not found in `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp17q1sq91.rs:29:28\n   |\n29 |                     return\
    \ lst;\n   |                            ^^^ expected struct `Vec`, found struct\
    \ `String`\n   |\n   = note: expected struct `Vec<String>`\n              found\
    \ struct `String`\n\nerror: aborting due to 8 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more inf"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n\n    if lst1.len()\
    \ > lst2.len() {\n        return total_match(lst2, lst1);\n    }\n\n    total_match(vec![String::new()],\
    \ lst1).unwrap()\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap` found for struct `Vec<String>` in\
    \ the current scope\n  --> /tmp/tmp1snl4p5i.rs:24:44\n   |\n24 |     total_match(vec![String::new()],\
    \ lst1).unwrap()\n   |                                            ^^^^^^ help:\
    \ there is an associated function with a similar name: `swap`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut total = 0;\n    let mut count = 0;\n    for el1 in lst1 {\n     \
    \   for el2 in lst2 {\n            if el1.len() < el2.len() {\n              \
    \  total += el1.len();\n                count += 1;\n            }\n        }\n\
    \    }\n    if count > 0 {\n        vec![lst1[total as usize - 1]]\n    } else\
    \ {\n        vec![]\n    }\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmpaygg7j2x.rs:19:20\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n19  |  \
    \       for el2 in lst2 {\n    |                    ^^^^ `lst2` moved due to this\
    \ implicit call to `.into_iter()`, in previous iteration of loop\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `lst2`\nhelp:\
    \ consider iterating over a slice of the `Vec<String>`'s content to avoid moving\
    \ into the `for` loop\n    |\n19  |         for el2 in &lst2 {\n    |        \
    \            +\n\nerror[E0382]: borrow of moved value: `lst1`\n  --> /tmp/tmpaygg7j2x.rs:27:14\n\
    \   |\n15 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |                ---- move occurs because `lst1` has type `Vec<String>`,\
    \ which does not implement the `Copy` trait\n...\n18 |     for el1 in lst1 {\n\
    \   |                ---- `lst1` moved due to this implicit call to `.into_iter()`\n\
    ...\n27 |         vec![lst1[total as usize - 1]]\n   |              ^^^^ value\
    \ borrowed here after move\n   |\nhelp: consider iterating over a slice of the\
    \ `Vec<String>`'s content to avoid moving into the `for` loop\n   |\n18 |    \
    \ for el1 in &lst1 {\n   |                +\n\nerror[E0507]: cannot move out of\
    \ index of `Vec<String>`\n  --> /tmp/tmpaygg7j2x.rs:27:14\n   |\n27 |        \
    \ vec![lst1[total as usize - 1]]\n   |              ^^^^^^^^^^^^^^^^^^^^^^^^ move\
    \ occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0382, E0507.\nFor more information about an error, try `rustc\
    \ --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 101
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    for i in\
    \ 0..lst1.len() {\n        if lst1[i] > lst2[i] {\n            return lst1;\n\
    \        }\n    }\n    return lst2;\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"hi\", \"admin\"]`,\n right: `[\"hi\", \"hi\"]`', /tmp/tmpqkz0w9b7.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    \n    let\
    \ mut lst = vec![String::from(\"0\"); lst2.len()];\n    for i in 0..lst1.len()\
    \ {\n        for j in 0..lst2.len() {\n            if lst1[i] == lst2[j] {\n \
    \               lst[j] += 1;\n            }\n        }\n    }\n    for i in 0..lst1.len()\
    \ {\n        if lst[i] > lst2[0] {\n            lst[i] = String::from(\"0\");\n\
    \        }\n    }\n    for i in 0..lst2.len() {\n        if lst2[i] > lst[0] {\n\
    \            lst2[i] = String::from(\"0\");\n        }\n    }\n    for i in 0..lst.len()\
    \ {\n        if lst[i] != lst2[i] {\n            break;\n        }\n    }\n  \
    \  for i in 0..lst.len() {\n        if lst[i] != lst2[i] {\n            return\
    \ vec![String::from(\"0\"); lst2.len()];\n        }\n    }\n    vec![String::from(\"\
    0\") for _ in 0..lst.len()]\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `<eof>`\n  --> /tmp/tmpjaldscdr.rs:48:48\n \
    \  |\n48 |     vec![String::from(\"0\") for _ in 0..lst.len()]\n   |         \
    \                                       ^ expected `{`\n\nerror: no rules expected\
    \ the token `for`\n  --> /tmp/tmpjaldscdr.rs:48:28\n   |\n48 |     vec![String::from(\"\
    0\") for _ in 0..lst.len()]\n   |                            ^^^ no rules expected\
    \ this token in macro call\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjaldscdr.rs:24:27\n\
    \   |\n24 |                 lst[j] += 1;\n   |                           ^ expected\
    \ `&str`, found integer\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut result = Vec::with_capacity(lst1.len());\n    for i in 0..lst1.len()\
    \ {\n        if i < lst2.len() && lst1[i] != lst2[i] {\n            result.push(lst1[i]);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpvfv80r2m.rs:19:25\n\
    \   |\n19 |             result.push(lst1[i]);\n   |                         ^^^^^^^\
    \ move occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0507`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    lst1.iter().filter(|x| x <= &lst2).collect()\n}\n\nfn main() {\n    let candidate\
    \ = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsk8571lf.rs:16:33\n   |\n\
    16 |     lst1.iter().filter(|x| x <= &lst2).collect()\n   |                  \
    \               ^^^^^ expected `&String`, found struct `Vec`\n   |\n   = note:\
    \ expected reference `&&String`\n              found reference `&Vec<String>`\n\
    \nerror[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&String`\n    --> /tmp/tmpsk8571lf.rs:16:40\n     |\n\
    16   |     lst1.iter().filter(|x| x <= &lst2).collect()\n     |              \
    \                          ^^^^^^^ value of type `Vec<String>` cannot be built\
    \ from `std::iter::Iterator<Item=&String>`\n     |\n     = help: the trait `FromIterator<&String>`\
    \ is not implemented for `Vec<String>`\n     = help: the trait `FromIterator<T>`\
    \ is implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut total_chars = 0;\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    for v in lst1 {\n        total_chars += v.len();\n    }\n    if total_chars\
    \ == lst1.len() {\n        lst1\n    } else {\n        lst2\n    }\n}\n\nfn main()\
    \ {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `lst1`\n   --> /tmp/tmprnjz_j7q.rs:23:23\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                ---- move occurs because `lst1` has type `Vec<String>`,\
    \ which does not implement the `Copy` trait\n...\n20  |     for v in lst1 {\n\
    \    |              ---- `lst1` moved due to this implicit call to `.into_iter()`\n\
    ...\n23  |     if total_chars == lst1.len() {\n    |                       ^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `lst1`\nhelp: consider iterating over a slice\
    \ of the `Vec<String>`'s content to avoid moving into the `for` loop\n    |\n\
    20  |     for v in &lst1 {\n    |              +\n\nerror[E0382]: use of moved\
    \ value: `lst2`\n  --> /tmp/tmprnjz_j7q.rs:26:9\n   |\n15 | fn total_match(lst1:\
    \ Vec<String>, lst2: Vec<String>) -> Vec<String> {\n   |                     \
    \              ---- move occurs because `lst2` has type `Vec<String>`, which does\
    \ not implement the `Copy` trait\n16 |     let mut total_chars = 0;\n17 |    \
    \ for v in lst2 {\n   |              ---- `lst2` moved due to this implicit call\
    \ to `.into_iter()`\n...\n26 |         lst2\n   |         ^^^^ value used here\
    \ after move\n   |\nhelp: consider iterating over a slice of the `Vec<String>`'s\
    \ content to avoid moving into the `for` loop\n   |\n17 |     for v in &lst2 {\n\
    \   |              +\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    for i in\
    \ 0..lst1.len() {\n        if lst1[i] < lst2[i] {\n            return vec![lst1[i]];\n\
    \        }\n    }\n    lst1\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmptfx97qym.rs:21:25\n\
    \   |\n21 |             return vec![lst1[i]];\n   |                         ^^^^^^^\
    \ move occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0507`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    lst1.iter().zip(lst2.iter()).filter(|(a, b)| a < b).map(|(a, b)| b).collect()\n\
    }\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&String`\n    --> /tmp/tmpgid9g1jh.rs:16:73\n     |\n\
    16   |     lst1.iter().zip(lst2.iter()).filter(|(a, b)| a < b).map(|(a, b)| b).collect()\n\
    \     |                                                                      \
    \   ^^^^^^^ value of type `Vec<String>` cannot be built from `std::iter::Iterator<Item=&String>`\n\
    \     |\n     = help: the trait `FromIterator<&String>` is not implemented for\
    \ `Vec<String>`\n     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\n\
    note: required by a bound in `collect`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976548
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    match lst1.len() {\n        0 => lst2,\n        1 => vec![lst1[0]],\n   \
    \     _ => {\n            let mut new_lst: Vec<String> = vec![String::new()];\n\
    \            for i in 0..(lst1.len() + 1) {\n                new_lst.push(new_lst.last().unwrap().clone());\n\
    \            }\n            new_lst.extend(vec![String::from(\"0\"), String::from(\"\
    1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"\
    5\")]);\n            for i in 0..(lst2.len() + 1) {\n                new_lst.push(new_lst.last().unwrap().clone());\n\
    \            }\n            let mut counter = vec![String::new()];\n         \
    \   for i in 0..(lst1.len() + 1) {\n                counter.push(counter.last().unwrap().clone());\n\
    \            }\n            for i in 0..(lst2.len() + 1) {\n                counter.push(counter.last().unwrap().clone());\n\
    \            }\n            for (i, str1) in lst1.iter().enumerate() {\n     \
    \           for (j, str2) in lst2.iter().enumerate() {\n                    let\
    \ counter_index = (i + j + 1) * lst2.len() + lst1.len() + 1;\n               \
    \     let counter_index = counter_index.wrapping_add(1).wrapping_mul(2).wrapping_add(1);\n\
    \                    let str_index = (i + j + 1) * lst2.len() + lst1.len() + 1;\n\
    \                    let str_index = str_index.wrapping_add(1).wrapping_mul(2).wrapping_add(1);\n\
    \                    let mut counter_index2 = vec![String::new()];\n         \
    \           for k in 0..(counter_index.len() + 1) {\n                        counter_index2.push(counter_index2.last().unwrap().clone());\n\
    \                    }\n                    let counter_index2 = counter_index2.iter().map(|x|\
    \ *x).collect::<Vec<String>>();\n                    for ki in 0..(counter_index.len()\
    \ + 1) {\n                        counter_index2[ki].push(counter.last().unwrap().clone());\n\
    \                    }\n                    counter_index2.extend(vec![String::from(\"\
    0\"), String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]);\n                    let mut counter_index3 = vec![String::new()];\n\
    \                    for k in 0..(counter_index2.len() + 1) {\n              \
    \          counter_index3.push(counter_index3.last().unwrap().clone());\n    \
    \                }\n                    let counter_index3 = counter_index3.iter().map(|x|\
    \ *x).collect::<Vec<String>>();\n                    for k\n}\n\nfn main() {\n\
    \    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpf22dqeim.rs:69:3\n\
    \   |\n15 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |                                                                    \
    \ - unclosed delimiter\n16 |     match lst1.len() {\n   |                    \
    \  - unclosed delimiter\n...\n19 |         _ => {\n   |              - unclosed\
    \ delimiter\n...\n35 |             for (i, str1) in lst1.iter().enumerate() {\n\
    \   |                                                      - unclosed delimiter\n\
    36 |                 for (j, str2) in lst2.iter().enumerate() {\n   |        \
    \                                                  - this delimiter might not\
    \ be properly closed...\n...\n56 | }\n   | - ...as it matches this but it has\
    \ different indentation\n...\n69 | }\n   |   ^\n\nerror: missing `in` in `for`\
    \ loop\n  --> /tmp/tmpf22dqeim.rs:55:26\n   |\n55 |                       for\
    \ k\n   |  __________________________^\n56 | | }\n   | |_ help: try adding `in`\
    \ here\n\nerror: expected expression, found `}`\n  --> /tmp/tmpf22dqeim.rs:56:1\n\
    \   |\n56 | }\n   | ^ expected expression\n\nerror[E0599]: no method named `len`\
    \ found for type `usize` in the current scope\n  --> /tmp/tmpf22dqeim.rs:42:48\n\
    \   |\n42 |                     for k in 0..(counter_index.len() + 1) {\n   |\
    \                                                ^^^ method not found in `usize`\n\
    \nerror[E0599]: no method named `len` found for type `usize` in the current scope\n\
    \  --> /tmp/tmpf22dqeim.rs:46:49\n   |\n46 |                     for ki in 0..(counter_index.len()\
    \ + 1) {\n   |                                                 ^^^ method not\
    \ found in `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf22dqeim.rs:47:49\n\
    \   |\n47 |                         counter_index2[ki].push(counter.last().unwrap().clone());\n\
    \   |                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpf22dqeim.rs:35:13\n   |\n15 |   fn total_match(lst1: Vec<String>,\
    \ lst2: Vec<String>) -> Vec<St"
  stdout: ''
  timestamp: 1659976548
