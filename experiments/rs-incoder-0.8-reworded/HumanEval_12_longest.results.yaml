language: rs
name: HumanEval_12_longest
results:
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    // Find the longest string in the vector.\n    let mut max_len = strings.len();\n\
    \    let mut longest_str = strings[0];\n    for s in strings {\n        if s.len()\
    \ > max_len {\n            max_len = s.len();\n            longest_str = s;\n\
    \        }\n    }\n    Some(longest_str)\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpu_qgs0td.rs:12:27\n\
    \   |\n12 |     let mut longest_str = strings[0];\n   |                      \
    \     ^^^^^^^^^^\n   |                           |\n   |                     \
    \      move occurs because value has type `String`, which does not implement the\
    \ `Copy` trait\n   |                           help: consider borrowing here:\
    \ `&strings[0]`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0507`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 101
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max = String::new();\n    for s in strings {\n        if s.len()\
    \ > max.len() {\n            max = s;\n        }\n    }\n    Some(max)\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"\")`,\n right: `None`', /tmp/tmp2yxrwq50.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings\n        .iter()\n        .fold(String::new(), |mut acc, s| {\n\
    \            let len = s.len();\n            acc.push_str(&s[len..]);\n      \
    \      Some(acc)\n        })\n        .or(None)\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpr49un3ys.rs:15:13\n   |\n\
    15 |             Some(acc)\n   |             ^^^^^^^^^ expected struct `String`,\
    \ found enum `Option`\n   |\n   = note: expected struct `String`\n           \
    \     found enum `Option<String>`\n\nerror[E0599]: no method named `or` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmpr49un3ys.rs:17:10\n\
    \   |\n17 |         .or(None)\n   |          ^^ method not found in `String`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.iter().max_by_key(|s| s.len())\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6vmdccn3.rs:10:5\n   |\n\
    9  | fn longest(strings: Vec<String>) -> Option<String> {\n   |              \
    \                       -------------- expected `Option<String>` because of return\
    \ type\n10 |     strings.iter().max_by_key(|s| s.len())\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&String`\n   |\n   = note: expected enum `Option<String>`\n\
    \              found enum `Option<&String>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n\n    let max_len\
    \ = String::new();\n    let mut max = String::new();\n\n    for s in strings {\n\
    \        if s.len() > max_len.len() {\n            max_len = s;\n        }\n \
    \       if s == max {\n            continue;\n        }\n        max = s;\n  \
    \  }\n    Some(max_len)\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign twice to immutable variable `max_len`\n  -->\
    \ /tmp/tmprsq0x2lp.rs:19:13\n   |\n14 |     let max_len = String::new();\n   |\
    \         -------\n   |         |\n   |         first assignment to `max_len`\n\
    \   |         help: consider making this binding mutable: `mut max_len`\n...\n\
    19 |             max_len = s;\n   |             ^^^^^^^ cannot assign twice to\
    \ immutable variable\n\nerror[E0382]: borrow of moved value: `s`\n  --> /tmp/tmprsq0x2lp.rs:21:12\n\
    \   |\n17 |     for s in strings {\n   |         -\n   |         |\n   |     \
    \    this reinitialization might get skipped\n   |         move occurs because\
    \ `s` has type `String`, which does not implement the `Copy` trait\n18 |     \
    \    if s.len() > max_len.len() {\n19 |             max_len = s;\n   |       \
    \                - value moved here\n20 |         }\n21 |         if s == max\
    \ {\n   |            ^ value borrowed here after move\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\n\
    For more information about an error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    // We use the longest string as the result if there are multiple ones\n\
    \    // with the same length.\n    if strings.len() <= 1 {\n        return None;\n\
    \    }\n    let max_len = strings[0].len();\n    for s in strings {\n        if\
    \ s.len() > max_len {\n            max_len = s.len();\n        }\n    }\n    Some(String::from(strings[0][max_len..].to_string()))\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign twice to immutable variable `max_len`\n  -->\
    \ /tmp/tmpage0obwm.rs:18:13\n   |\n15 |     let max_len = strings[0].len();\n\
    \   |         -------\n   |         |\n   |         first assignment to `max_len`\n\
    \   |         help: consider making this binding mutable: `mut max_len`\n...\n\
    18 |             max_len = s.len();\n   |             ^^^^^^^^^^^^^^^^^ cannot\
    \ assign twice to immutable variable\n\nerror[E0382]: borrow of moved value: `strings`\n\
    \   --> /tmp/tmpage0obwm.rs:21:23\n    |\n9   | fn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    |            ------- move occurs because `strings`\
    \ has type `Vec<String>`, which does not implement the `Copy` trait\n...\n16 \
    \ |     for s in strings {\n    |              ------- `strings` moved due to\
    \ this implicit call to `.into_iter()`\n...\n21  |     Some(String::from(strings[0][max_len..].to_string()))\n\
    \    |                       ^^^^^^^ value borrowed here after move\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `strings`\n\
    help: consider iterating over a slice of the `Vec<String>`'s content to avoid\
    \ moving into the `for` loop\n    |\n16  |     for s in &strings {\n    |    \
    \          +\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0382, E0384.\nFor more information about an error, try `rustc\
    \ --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut string_iter\
    \ = strings.iter().cloned();\n    let first = string_iter.next();\n    let mut\
    \ string_with_lengths = Vec::new();\n    string_with_lengths.push(first);\n  \
    \  for string in string_iter {\n        let current_string_len = string.len();\n\
    \        if string_with_lengths.iter().any(|s| s.len() == current_string_len)\
    \ {\n            continue;\n        }\n        string_with_lengths.push(string);\n\
    \    }\n    longest(string_with_lengths)\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for reference `&Option<String>`\
    \ in the current scope\n  --> /tmp/tmp_3r1pnv_.rs:19:49\n   |\n19 |         if\
    \ string_with_lengths.iter().any(|s| s.len() == current_string_len) {\n   |  \
    \                                               ^^^ method not found in `&Option<String>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp_3r1pnv_.rs:22:34\n   |\n22 |\
    \         string_with_lengths.push(string);\n   |                            \
    \      ^^^^^^ expected enum `Option`, found struct `String`\n   |\n   = note:\
    \ expected enum `Option<String>`\n            found struct `String`\nhelp: try\
    \ wrapping the expression in `Some`\n   |\n22 |         string_with_lengths.push(Some(string));\n\
    \   |                                  +++++      +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_3r1pnv_.rs:24:13\n   |\n24 |     longest(string_with_lengths)\n\
    \   |             ^^^^^^^^^^^^^^^^^^^ expected struct `String`, found enum `Option`\n\
    \   |\n   = note: expected struct `Vec<String>`\n              found struct `Vec<Option<String>>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.iter().fold(None, |mut max_len, string| {\n        if *string.len()\
    \ > max_len {\n            max_len = string.len();\n        }\n        Some(string)\n\
    \    })\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `usize` cannot be dereferenced\n  --> /tmp/tmpclbwu5v_.rs:11:12\n\
    \   |\n11 |         if *string.len() > max_len {\n   |            ^^^^^^^^^^^^^\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpclbwu5v_.rs:12:23\n   |\n10 |\
    \     strings.iter().fold(None, |mut max_len, string| {\n   |                \
    \                    ------- expected due to this parameter type\n11 |       \
    \  if *string.len() > max_len {\n12 |             max_len = string.len();\n  \
    \ |                       ^^^^^^^^^^^^ expected enum `Option`, found `usize`\n\
    \   |\n   = note: expected enum `Option<String>`\n              found type `usize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpclbwu5v_.rs:14:14\n   |\n14 |\
    \         Some(string)\n   |              ^^^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |              |\n   |              expected struct\
    \ `String`, found `&String`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0614.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut min = strings[0].len();\n    for s in strings {\n        if s.len()\
    \ < min {\n            min = s.len();\n        }\n    }\n    let mut longest_len\
    \ = min;\n    let mut longest_string = strings[0];\n    for s in strings {\n \
    \       if s.len() > longest_len {\n            longest_len = s.len();\n     \
    \       longest_string = s;\n        }\n    }\n    Some(longest_string)\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `strings`\n   --> /tmp/tmpsrqtr77k.rs:17:30\n\
    \    |\n9   | fn longest(strings: Vec<String>) -> Option<String> {\n    |    \
    \        ------- move occurs because `strings` has type `Vec<String>`, which does\
    \ not implement the `Copy` trait\n10  |     let mut min = strings[0].len();\n\
    11  |     for s in strings {\n    |              ------- `strings` moved due to\
    \ this implicit call to `.into_iter()`\n...\n17  |     let mut longest_string\
    \ = strings[0];\n    |                              ^^^^^^^ value borrowed here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `strings`\nhelp: consider iterating over a slice of the `Vec<String>`'s\
    \ content to avoid moving into the `for` loop\n    |\n11  |     for s in &strings\
    \ {\n    |              +\n\nerror[E0507]: cannot move out of index of `Vec<String>`\n\
    \  --> /tmp/tmpsrqtr77k.rs:17:30\n   |\n17 |     let mut longest_string = strings[0];\n\
    \   |                              ^^^^^^^^^^\n   |                          \
    \    |\n   |                              move occurs because value has type `String`,\
    \ which does not implement the `Copy` trait\n   |                            \
    \  help: consider borrowing here: `&strings[0]`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0382, E0507.\nFor more information\
    \ about an error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest_len: usize = 0;\n    let mut longest_string: Option<String>\
    \ = None;\n    for string in strings {\n        let len = string.len();\n    \
    \    if len > longest_len {\n            longest_len = len;\n            longest_string\
    \ = Some(string);\n        }\n    }\n    longest_string\n}\n\nfn main() {\n  \
    \  let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.iter().max_by(|a, b| a.len() < b.len())\n}\n\nfn main() {\n \
    \   let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdrlg0yxg.rs:10:34\n   |\n\
    10 |     strings.iter().max_by(|a, b| a.len() < b.len())\n   |               \
    \                   ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`, found\
    \ `bool`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdrlg0yxg.rs:10:5\n \
    \  |\n9  | fn longest(strings: Vec<String>) -> Option<String> {\n   |        \
    \                             -------------- expected `Option<String>` because\
    \ of return type\n10 |     strings.iter().max_by(|a, b| a.len() < b.len())\n \
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found `&String`\n   |\n   = note: expected enum `Option<String>`\n         \
    \     found enum `Option<&String>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut len = -1;\n    let mut res = String::from(\"\");\n    for (i,\
    \ s) in strings.into_iter().enumerate() {\n        if len < s.len() {\n      \
    \      len = s.len();\n            res = s;\n        }\n        if i == 0 {\n\
    \            break;\n        }\n    }\n    Some(res)\n}\n\nfn main() {\n    let\
    \ candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpjx5c0r1k.rs:10:19\n\
    \   |\n10 |     let mut len = -1;\n   |                   ^^ the trait `Neg` is\
    \ not implemented for `usize`\n   |\n   = help: the following other types implement\
    \ trait `Neg`:\n             &f32\n             &f64\n             &i128\n   \
    \          &i16\n             &i32\n             &i64\n             &i8\n    \
    \         &isize\n           and 8 others\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings\n        .into_iter()\n        .map(|s| s.len())\n        .max()\n\
    \        .and_then(|max_len| strings.iter().take(max_len).cloned().collect())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Option<_>` cannot be built from an iterator\
    \ over elements of type `String`\n    --> /tmp/tmp84pbhutg.rs:14:67\n     |\n\
    14   |         .and_then(|max_len| strings.iter().take(max_len).cloned().collect())\n\
    \     |                                                                   ^^^^^^^\
    \ value of type `Option<_>` cannot be built from `std::iter::Iterator<Item=String>`\n\
    \     |\n     = help: the trait `FromIterator<String>` is not implemented for\
    \ `Option<_>`\n     = help: the trait `FromIterator<Option<A>>` is implemented\
    \ for `Option<V>`\nnote: required by a bound in `collect`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.iter().filter_map(|s| s.len()).max()\n}\n\nfn main() {\n    let\
    \ candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj5rfmnl6.rs:10:35\n   |\n\
    9  | fn longest(strings: Vec<String>) -> Option<String> {\n   |              \
    \                       -------------- expected `Option<_>` because of return\
    \ type\n10 |     strings.iter().filter_map(|s| s.len()).max()\n   |          \
    \                         ^^^^^^^ expected enum `Option`, found `usize`\n   |\n\
    \   = note: expected enum `Option<_>`\n              found type `usize`\nhelp:\
    \ try wrapping the expression in `Some`\n   |\n10 |     strings.iter().filter_map(|s|\
    \ Some(s.len())).max()\n   |                                   +++++       +\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        None\n    } else {\n        let mut\
    \ max_len = std::u32::MAX;\n        let mut max_string = None;\n        for s\
    \ in strings.iter() {\n            if s.len() > max_len {\n                max_len\
    \ = s.len();\n                max_string = Some(s);\n            }\n        }\n\
    \        max_string\n    }\n}\n\nfn main() {\n    let candidate = longest;\n \
    \   assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptwpvra0u.rs:16:26\n   |\n\
    16 |             if s.len() > max_len {\n   |                          ^^^^^^^\
    \ expected `usize`, found `u32`\n   |\nhelp: you can convert a `u32` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n16 |             if s.len()\
    \ > max_len.try_into().unwrap() {\n   |                                 ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmptwpvra0u.rs:17:27\n   |\n13 |\
    \         let mut max_len = std::u32::MAX;\n   |                           -------------\
    \ expected due to this value\n...\n17 |                 max_len = s.len();\n \
    \  |                           ^^^^^^^ expected `u32`, found `usize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmptwpvra0u.rs:21:9\n   |\n9  | fn longest(strings:\
    \ Vec<String>) -> Option<String> {\n   |                                     --------------\
    \ expected `Option<String>` because of return type\n...\n21 |         max_string\n\
    \   |         ^^^^^^^^^^ expected struct `String`, found `&String`\n   |\n   =\
    \ note: expected enum `Option<String>`\n              found enum `Option<&String>`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest_len = std::i32::MAX;\n    let mut longest_str = None;\n\
    \    for s in strings {\n        if s.len() > longest_len {\n            longest_len\
    \ = s.len();\n            longest_str = Some(s);\n        }\n    }\n    longest_str\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpe4pszpg3.rs:13:22\n   |\n\
    13 |         if s.len() > longest_len {\n   |                      ^^^^^^^^^^^\
    \ expected `usize`, found `i32`\n   |\nhelp: you can convert an `i32` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n13 |         if s.len()\
    \ > longest_len.try_into().unwrap() {\n   |                                 ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpe4pszpg3.rs:14:27\n   |\n10 |\
    \     let mut longest_len = std::i32::MAX;\n   |                           -------------\
    \ expected due to this value\n...\n14 |             longest_len = s.len();\n \
    \  |                           ^^^^^^^ expected `i32`, found `usize`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n\n    let mut max_len\
    \ = String::new();\n    let mut best_string = String::new();\n    for string in\
    \ strings.iter() {\n        string.chars().for_each(|c| {\n            if c.len()\
    \ > max_len.len() {\n                max_len.copy_from_slice(&c);\n          \
    \      best_string.copy_from_slice(&c);\n            }\n        });\n    }\n \
    \   Some(best_string)\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp16aogdrs.rs:18:18\n   |\n18 |             if c.len() >\
    \ max_len.len() {\n   |                  ^^^ method not found in `char`\n\nerror[E0599]:\
    \ no method named `copy_from_slice` found for struct `String` in the current scope\n\
    \  --> /tmp/tmp16aogdrs.rs:19:25\n   |\n19 |                 max_len.copy_from_slice(&c);\n\
    \   |                         ^^^^^^^^^^^^^^^ method not found in `String`\n\n\
    error[E0599]: no method named `copy_from_slice` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp16aogdrs.rs:20:29\n   |\n20 |                 best_string.copy_from_slice(&c);\n\
    \   |                             ^^^^^^^^^^^^^^^ method not found in `String`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    // This is inefficient, but we are guaranteed that the strings are in\
    \ sorted\n    // order and are all short enough to fit in one cache line.\n  \
    \  let mut maxlen = 0;\n    let mut maxlen_string = None;\n    for s in strings\
    \ {\n        // This is the length of the string and we want it to be >= 0\n \
    \       let len = s.chars().count();\n        if len > maxlen {\n            maxlen\
    \ = len;\n            maxlen_string = Some(s);\n        }\n    }\n    maxlen_string\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976609
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut longest_length\
    \ = 0;\n    let mut longest_string = String::from(\"\");\n    for s in strings\
    \ {\n        if s.len() > longest_length {\n            longest_length = s.len();\n\
    \            longest_string = s;\n        }\n    }\n    Some(longest_string)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        None\n    } else if strings.len() ==\
    \ 1 {\n        Some(strings.iter().max().unwrap())\n    } else {\n        Some(strings.iter().max_by_key(|s|\
    \ s.len()).unwrap())\n    }\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprhgl36bf.rs:13:14\n   |\n\
    13 |         Some(strings.iter().max().unwrap())\n   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |              |\n \
    \  |              expected struct `String`, found `&String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmprhgl36bf.rs:15:14\n   |\n15 |         Some(strings.iter().max_by_key(|s|\
    \ s.len()).unwrap())\n   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |              |\n \
    \  |              expected struct `String`, found `&String`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings\n        .iter()\n        .fold(String::new(), |mut a, s| {\n\
    \            if a.len() > s.len() {\n                a.clear();\n            \
    \    a.append(s);\n            } else {\n                a.append(s);\n      \
    \      }\n            a\n        })\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp53_ildpe.rs:12:15\n   |\n\
    12 |         .fold(String::new(), |mut a, s| {\n   |               ^^^^^^^^^^^^^\
    \ expected enum `Option`, found struct `String`\n   |\n   = note: expected enum\
    \ `Option<String>`\n            found struct `String`\nhelp: try wrapping the\
    \ expression in `Some`\n   |\n12 |         .fold(Some(String::new()), |mut a,\
    \ s| {\n   |               +++++             +\n\nerror[E0599]: no method named\
    \ `len` found for enum `Option` in the current scope\n  --> /tmp/tmp53_ildpe.rs:13:18\n\
    \   |\n13 |             if a.len() > s.len() {\n   |                  ^^^ method\
    \ not found in `Option<String>`\n\nerror[E0599]: no method named `clear` found\
    \ for enum `Option` in the current scope\n  --> /tmp/tmp53_ildpe.rs:14:19\n  \
    \ |\n14 |                 a.clear();\n   |                   ^^^^^ method not\
    \ found in `Option<String>`\n\nerror[E0599]: no method named `append` found for\
    \ enum `Option` in the current scope\n  --> /tmp/tmp53_ildpe.rs:15:19\n   |\n\
    15 |                 a.append(s);\n   |                   ^^^^^^ help: there is\
    \ an associated function with a similar name: `and`\n\nerror[E0599]: no method\
    \ named `append` found for enum `Option` in the current scope\n  --> /tmp/tmp53_ildpe.rs:17:19\n\
    \   |\n17 |                 a.append(s);\n   |                   ^^^^^^ help:\
    \ there is an associated function with a similar name: `and`\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.iter().max_by_key(|s| s.length()).ok()\n}\n\nfn main() {\n  \
    \  let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for reference `&&String` in\
    \ the current scope\n  --> /tmp/tmp6msfjou0.rs:10:37\n   |\n10 |     strings.iter().max_by_key(|s|\
    \ s.length()).ok()\n   |                                     ^^^^^^ help: there\
    \ is an associated function with a similar name: `len`\n\nerror[E0599]: no method\
    \ named `ok` found for enum `Option` in the current scope\n  --> /tmp/tmp6msfjou0.rs:10:47\n\
    \   |\n10 |     strings.iter().max_by_key(|s| s.length()).ok()\n   |         \
    \                                      ^^ help: there is an associated function\
    \ with a similar name: `or`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = String::new();\n    for s in strings {\n        if\
    \ s.len() > max_len.len() {\n            max_len = s;\n        }\n    }\n    if\
    \ max_len.is_empty() {\n        None\n    } else {\n        Some(max_len)\n  \
    \  }\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_length: usize = 0;\n    for s in strings {\n        max_length\
    \ = s.len() if max_length < s.len() else max_length;\n    }\n    let mut longest:\
    \ Option<String> = None;\n    for s in strings {\n        longest |= Some(s);\n\
    \        if longest != None && longest.len() > max_length {\n            longest\
    \ = None;\n        }\n    }\n    longest\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found keyword\
    \ `if`\n  --> /tmp/tmpq17r6i0x.rs:12:30\n   |\n12 |         max_length = s.len()\
    \ if max_length < s.len() else max_length;\n   |                             \
    \ ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0368]: binary\
    \ assignment operation `|=` cannot be applied to type `Option<String>`\n  -->\
    \ /tmp/tmpq17r6i0x.rs:16:9\n   |\n16 |         longest |= Some(s);\n   |     \
    \    -------^^^^^^^^^^^\n   |         |\n   |         cannot use `|=` on type\
    \ `Option<String>`\n\nerror[E0599]: no method named `len` found for enum `Option`\
    \ in the current scope\n  --> /tmp/tmpq17r6i0x.rs:17:39\n   |\n17 |         if\
    \ longest != None && longest.len() > max_length {\n   |                      \
    \                 ^^^ method not found in `Option<String>`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0368, E0599.\n\
    For more information about an error, try `rustc --explain E0368`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut result = std::collections::Vec::new();\n    for string in strings\
    \ {\n        result.push((string.len(), string));\n    }\n    let mut current_size\
    \ = std::collections::Vec::new();\n    for (len, _) in result {\n        current_size.push(len);\n\
    \    }\n    let mut best_len = std::collections::Vec::new();\n    let mut current_max\
    \ = std::collections::Vec::new();\n    let mut current_max2 = std::collections::Vec::new();\n\
    \    let mut best_name = std::collections::Vec::new();\n    let mut max_len =\
    \ std::collections::Vec::new();\n    let mut min_len = std::collections::Vec::new();\n\
    \    let mut min_value = std::collections::Vec::new();\n    for (len, string)\
    \ in result {\n        if let Some(name) = string {\n            if current_size.get(len).unwrap()\
    \ < current_max.get(len).unwrap() {\n                current_max.push(len);\n\
    \                best_name.push(name);\n                max_len.push(len);\n \
    \               min_len.push(len);\n                min_value.push(name);\n  \
    \          }\n        }\n    }\n    if current_size.len() == 0 {\n        return\
    \ None;\n    }\n    if current_max.len() == 0 {\n        return None;\n    }\n\
    \    if min_len.len() == 0 {\n        return None;\n    }\n    if max_len.len()\
    \ == 0 {\n        return None;\n    }\n    if min_value.len() == 0 {\n       \
    \ return None;\n    }\n    if best_name.len() == 0 {\n        return None;\n \
    \   }\n    if current_size.len() == 1 {\n        return Some(best_name[0]);\n\
    \    }\n    let best_len = best_name.iter().max().unwrap();\n    if min_len.get(best_len).unwrap()\
    \ > best_len {\n        return Some(min_value.get(best_len).unwrap());\n    }\n\
    \    if max_len.get(best_len).unwrap() < best_len {\n        return Some(best_name.get(best_len).unwrap());\n\
    \    }\n    Some(best_name.get(best_len).unwrap())\n}\n\nfn main() {\n    let\
    \ candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: could not find `Vec` in `collections`\n\
    \  --> /tmp/tmpyii1n101.rs:10:40\n   |\n10 |     let mut result = std::collections::Vec::new();\n\
    \   |                                        ^^^ not found in `std::collections`\n\
    \   |\nhelp: consider importing this struct\n   |\n1  | use std::vec::Vec;\n \
    \  |\nhelp: if you import `Vec`, refer to it directly\n   |\n10 -     let mut\
    \ result = std::collections::Vec::new();\n10 +     let mut result = Vec::new();\n\
    \   | \n\nerror[E0433]: failed to resolve: could not find `Vec` in `collections`\n\
    \  --> /tmp/tmpyii1n101.rs:14:46\n   |\n14 |     let mut current_size = std::collections::Vec::new();\n\
    \   |                                              ^^^ not found in `std::collections`\n\
    \   |\nhelp: consider importing this struct\n   |\n1  | use std::vec::Vec;\n \
    \  |\nhelp: if you import `Vec`, refer to it directly\n   |\n14 -     let mut\
    \ current_size = std::collections::Vec::new();\n14 +     let mut current_size\
    \ = Vec::new();\n   | \n\nerror[E0433]: failed to resolve: could not find `Vec`\
    \ in `collections`\n  --> /tmp/tmpyii1n101.rs:18:42\n   |\n18 |     let mut best_len\
    \ = std::collections::Vec::new();\n   |                                      \
    \    ^^^ not found in `std::collections`\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::vec::Vec;\n   |\nhelp: if you import `Vec`, refer\
    \ to it directly\n   |\n18 -     let mut best_len = std::collections::Vec::new();\n\
    18 +     let mut best_len = Vec::new();\n   | \n\nerror[E0433]: failed to resolve:\
    \ could not find `Vec` in `collections`\n  --> /tmp/tmpyii1n101.rs:19:45\n   |\n\
    19 |     let mut current_max = std::collections::Vec::new();\n   |           \
    \                                  ^^^ not found in `std::collections`\n   |\n\
    help: consider importing this struct\n   |\n1  | use std::vec::Vec;\n   |\nhelp:\
    \ if you import `Vec`, refer to it directly\n   |\n19 -     let mut current_max\
    \ = std::collections::Vec::new();\n19 +     let mut current_max = Vec::new();\n\
    \   | \n\nerror[E0433]: failed to resolve: could not find `Vec` in `collections`\n\
    \  --> /tmp/tmpyii1n101.rs:20:"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.iter().max_by_key(|s| s.len())\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6vmdccn3.rs:10:5\n   |\n\
    9  | fn longest(strings: Vec<String>) -> Option<String> {\n   |              \
    \                       -------------- expected `Option<String>` because of return\
    \ type\n10 |     strings.iter().max_by_key(|s| s.len())\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&String`\n   |\n   = note: expected enum `Option<String>`\n\
    \              found enum `Option<&String>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 101
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        None\n    } else {\n        let mut\
    \ max_length = strings.iter().map(|s| s.len()).max().unwrap();\n        for s\
    \ in strings {\n            if s.len() == max_length {\n                return\
    \ Some(s);\n            }\n            max_length = s.len();\n        }\n    \
    \    None\n    }\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `None`,\n right: `Some(\"zzzz\")`', /tmp/tmp839uh5ni.rs:28:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 101
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest_len = 0;\n    let mut max_string = None;\n    for s in\
    \ strings {\n        longest_len = s.len();\n        if longest_len > longest_len\
    \ {\n            max_string = Some(s);\n        }\n    }\n    max_string\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `None`,\n right: `Some(\"x\")`', /tmp/tmpdah5k604.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.iter()\n        .map(|s| s.chars().max().unwrap())\n        .max()\n\
    \        .and_then(|s| strings.iter().find(|s| s == s))\n}\n\nfn main() {\n  \
    \  let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprnrlc6os.rs:10:5\n   |\n\
    9  |   fn longest(strings: Vec<String>) -> Option<String> {\n   |            \
    \                           -------------- expected `Option<String>` because of\
    \ return type\n10 | /     strings.iter()\n11 | |         .map(|s| s.chars().max().unwrap())\n\
    12 | |         .max()\n13 | |         .and_then(|s| strings.iter().find(|s| s\
    \ == s))\n   | |______________________________________________________^ expected\
    \ struct `String`, found `&String`\n   |\n   = note: expected enum `Option<String>`\n\
    \              found enum `Option<&String>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut max_len\
    \ = std::cmp::max::<i32>(\n        strings.iter().map(|s| s.len()).sum::<i32>(),\n\
    \    );\n    let mut best_string = None;\n    for s in strings {\n        if s.len()\
    \ > max_len {\n            max_len = s.len();\n            best_string = Some(s);\n\
    \        }\n    }\n    Some(best_string)\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `i32: Sum<usize>` is not satisfied\n    -->\
    \ /tmp/tmpsakvd5mb.rs:14:41\n     |\n14   |         strings.iter().map(|s| s.len()).sum::<i32>(),\n\
    \     |                                         ^^^ the trait `Sum<usize>` is\
    \ not implemented for `i32`\n     |\n     = help: the following other types implement\
    \ trait `Sum<A>`:\n               <f32 as Sum<&'a f32>>\n               <f32 as\
    \ Sum>\n               <f64 as Sum<&'a f64>>\n               <f64 as Sum>\n  \
    \             <i128 as Sum<&'a i128>>\n               <i128 as Sum>\n        \
    \       <i16 as Sum<&'a i16>>\n               <i16 as Sum>\n             and 20\
    \ others\nnote: required by a bound in `std::iter::Iterator::sum`\n\nerror[E0061]:\
    \ this function takes 2 arguments but 1 argument was supplied\n    --> /tmp/tmpsakvd5mb.rs:13:23\n\
    \     |\n13   |     let mut max_len = std::cmp::max::<i32>(\n     |          \
    \             ^^^^^^^^^^^^^^^^^^^^ expected 2 arguments\n14   |         strings.iter().map(|s|\
    \ s.len()).sum::<i32>(),\n     |         --------------------------------------------\
    \ supplied 1 argument\n     |\nnote: function defined here\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpsakvd5mb.rs:18:22\n   |\n18 |         if s.len() > max_len\
    \ {\n   |                      ^^^^^^^ expected `usize`, found `i32`\n   |\nhelp:\
    \ you can convert an `i32` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n18 |         if s.len() > max_len.try_into().unwrap() {\n   |   \
    \                          ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsakvd5mb.rs:19:23\n   |\n13 |       let mut max_len = std::cmp::max::<i32>(\n\
    \   |  _______________________-\n14 | |         strings.iter().map(|s| s.len()).sum::<i32>(),\n\
    15 | |     );\n   | |_____- expected due to this value\n...\n19 |            \
    \   max_len = s.len();\n   |                         ^^^^^^^ expected `i32`, found\
    \ `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsakvd5mb.rs:23:10\n\
    \   |\n23 |     Some(best_string)\n   |          ^^^^^^^^^^^ expected struct `String`,\
    \ found enum `Option`\n   |\n   = note: expected "
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        None\n    } else {\n        let mut\
    \ longest_len = strings.iter().map(|s| s.len()).max().unwrap();\n        let mut\
    \ longest = strings[0];\n        for (idx, s) in strings.iter().enumerate() {\n\
    \            if s.len() == longest_len {\n                longest = s;\n     \
    \           break;\n            }\n            if s.len() < longest_len {\n  \
    \              longest_len = s.len();\n                longest = s;\n        \
    \    }\n        }\n        longest\n    }\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1zrt01x6.rs:17:27\n   |\n\
    14 |         let mut longest = strings[0];\n   |                           ----------\
    \ expected due to this value\n...\n17 |                 longest = s;\n   |   \
    \                        ^- help: try using a conversion method: `.to_string()`\n\
    \   |                           |\n   |                           expected struct\
    \ `String`, found `&String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1zrt01x6.rs:22:27\n\
    \   |\n14 |         let mut longest = strings[0];\n   |                      \
    \     ---------- expected due to this value\n...\n22 |                 longest\
    \ = s;\n   |                           ^- help: try using a conversion method:\
    \ `.to_string()`\n   |                           |\n   |                     \
    \      expected struct `String`, found `&String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp1zrt01x6.rs:25:9\n   |\n9  | fn longest(strings: Vec<String>) ->\
    \ Option<String> {\n   |                                     -------------- expected\
    \ `Option<String>` because of return type\n...\n25 |         longest\n   |   \
    \      ^^^^^^^ expected enum `Option`, found struct `String`\n   |\n   = note:\
    \ expected enum `Option<String>`\n            found struct `String`\nhelp: try\
    \ wrapping the expression in `Some`\n   |\n25 |         Some(longest)\n   |  \
    \       +++++       +\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings\n        .into_iter()\n        .scan(String::new(), |(out, s)|\
    \ {\n            if out\n                .len() < s.len()\n                .expect(\"\
    Can't sort by length when no longer in vector order\")\n            {\n      \
    \          (out, s)\n            } else {\n                (None, s)\n       \
    \     }\n        })\n        .next()\n        .and_then(|(_, s)| s.clone())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0593]: closure is expected to take 2 distinct arguments, but it\
    \ takes a single 2-tuple as argument\n  --> /tmp/tmpt9ih63j9.rs:12:10\n   |\n\
    12 |         .scan(String::new(), |(out, s)| {\n   |          ^^^^           \
    \     ---------- takes a single 2-tuple as argument\n   |          |\n   |   \
    \       expected closure that takes 2 distinct arguments\n   |\nhelp: change the\
    \ closure to take multiple arguments instead of a single tuple\n   |\n12 |   \
    \      .scan(String::new(), |out, s| {\n   |                              ~~~~~~~~\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0593`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings\n        .iter()\n        .fold(\n            None,\n       \
    \     |max_so_far, max_in_string| {\n                if !max_in_string.is_empty()\
    \ {\n                    if max_in_string.length() > max_so_far.length() {\n \
    \                       max_so_far\n                    }\n                } else\
    \ {\n                    max_so_far\n                }\n            },\n     \
    \   )\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for reference `&String` in\
    \ the current scope\n  --> /tmp/tmp8vkylts8.rs:16:38\n   |\n16 |             \
    \        if max_in_string.length() > max_so_far.length() {\n   |             \
    \                         ^^^^^^ help: there is an associated function with a\
    \ similar name: `len`\n\nerror[E0599]: no method named `length` found for enum\
    \ `Option` in the current scope\n  --> /tmp/tmp8vkylts8.rs:16:60\n   |\n16 | \
    \                    if max_in_string.length() > max_so_far.length() {\n   | \
    \                                                           ^^^^^^ method not\
    \ found in `Option<String>`\n\nerror[E0317]: `if` may be missing an `else` clause\n\
    \  --> /tmp/tmp8vkylts8.rs:16:21\n   |\n16 | /                     if max_in_string.length()\
    \ > max_so_far.length() {\n17 | |                         max_so_far\n   | | \
    \                        ---------- found here\n18 | |                     }\n\
    \   | |_____________________^ expected `()`, found enum `Option`\n   |\n   = note:\
    \ expected unit type `()`\n                   found enum `Option<String>`\n  \
    \ = note: `if` expressions without `else` evaluate to `()`\n   = help: consider\
    \ adding an `else` block that evaluates to the expected type\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0317, E0599.\n\
    For more information about an error, try `rustc --explain E0317`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n\n    let mut len\
    \ = String::new();\n    let mut max_len = String::new();\n    let mut max_string:\
    \ Option<String> = None;\n\n    for s in strings {\n        let len = s.len();\n\
    \        if len > max_len.len() {\n            max_len = len;\n            max_string\
    \ = Some(s);\n        }\n    }\n\n    max_string.or(None)\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpr47fx2xl.rs:21:23\n   |\n\
    15 |     let mut max_len = String::new();\n   |                       -------------\
    \ expected due to this value\n...\n21 |             max_len = len;\n   |     \
    \                  ^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                       |\n   |                       expected struct `String`,\
    \ found `usize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest_string\
    \ = &strings[0];\n    let mut longest_string_length = 0;\n    for &s in strings\
    \ {\n        longest_string_length = s.len() as u32;\n        if longest_string_length\
    \ > longest_string.len() {\n            longest_string = &s;\n        }\n    }\n\
    \    Some(longest_string)\n}\n\nfn main() {\n    let candidate = longest;\n  \
    \  assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2crkpp6p.rs:16:9\n   |\n\
    16 |     for &s in strings {\n   |         ^^    ------- this expression has type\
    \ `Option<String>`\n   |         |\n   |         expected struct `String`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `s`\n\
    \   |\n   = note: expected struct `String`\n           found reference `&_`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp2crkpp6p.rs:22:10\n   |\n22 |  \
    \   Some(longest_string)\n   |          ^^^^^^^^^^^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |          |\n   |          expected struct `String`,\
    \ found `&String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.iter().max_by(|a, b| a.len() as u32 - b.len() as u32)\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw_jdp4oi.rs:10:34\n   |\n\
    10 |     strings.iter().max_by(|a, b| a.len() as u32 - b.len() as u32)\n   | \
    \                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected enum\
    \ `std::cmp::Ordering`, found `u32`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw_jdp4oi.rs:10:5\n\
    \   |\n9  | fn longest(strings: Vec<String>) -> Option<String> {\n   |       \
    \                              -------------- expected `Option<String>` because\
    \ of return type\n10 |     strings.iter().max_by(|a, b| a.len() as u32 - b.len()\
    \ as u32)\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&String`\n   |\n   = note: expected enum `Option<String>`\n\
    \              found enum `Option<&String>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        None\n    } else {\n        strings.iter().chain(\n\
    \            strings.iter().cloned().map(|s| s.chars().filter(|c| !c.is_ascii_letter()).map(|c|\
    \ c.to_string()).collect()),\n        )\n            .zip(strings.iter().cloned().map(|s|\
    \ s.len()))\n            .max_by(|(a, b)| a.cmp(b))\n            .map(|(a, b)|\
    \ a)\n    }\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpns4cgyg2.rs:14:69\n   |\n14 |          \
    \   strings.iter().cloned().map(|s| s.chars().filter(|c| !c.is_ascii_letter()).map(|c|\
    \ c.to_string()).collect()),\n   |                                           \
    \                          ^^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `is_ascii`\n\nerror[E0277]: a value of type `&String` cannot\
    \ be built from an iterator over elements of type `String`\n    --> /tmp/tmpns4cgyg2.rs:14:111\n\
    \     |\n14   |             strings.iter().cloned().map(|s| s.chars().filter(|c|\
    \ !c.is_ascii_letter()).map(|c| c.to_string()).collect()),\n     |           \
    \                                                                            \
    \                        ^^^^^^^ value of type `&String` cannot be built from\
    \ `std::iter::Iterator<Item=String>`\n     |\n     = help: the trait `FromIterator<String>`\
    \ is not implemented for `&String`\n     = help: the following other types implement\
    \ trait `FromIterator<A>`:\n               <String as FromIterator<&'a char>>\n\
    \               <String as FromIterator<&'a str>>\n               <String as FromIterator<Box<str>>>\n\
    \               <String as FromIterator<Cow<'a, str>>>\n               <String\
    \ as FromIterator<String>>\n               <String as FromIterator<char>>\nnote:\
    \ required by a bound in `collect`\n\nerror[E0593]: closure is expected to take\
    \ 2 distinct arguments, but it takes a single 2-tuple as argument\n  --> /tmp/tmpns4cgyg2.rs:17:14\n\
    \   |\n17 |             .max_by(|(a, b)| a.cmp(b))\n   |              ^^^^^^ --------\
    \ takes a single 2-tuple as argument\n   |              |\n   |              expected\
    \ closure that takes 2 distinct arguments\n   |\nhelp: change the closure to take\
    \ multiple arguments instead of a single tuple\n   |\n17 |             .max_by(|a,\
    \ b| a.cmp(b))\n   |                     ~~~~~~\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpns4cgyg2.rs:13:9\n   |\n9  |   fn longest(strings: Vec<String>)\
    \ -> Option<String> {\n   |             "
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut current_size\
    \ = Vec::new();\n    for s in strings {\n        current_size.push(s.len());\n\
    \    }\n    if current_size.len() > 0 {\n        Some(strings.iter().max_by_key(|s|\
    \ s.len() as usize).unwrap())\n    } else {\n        None\n    }\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmzy33vv6.rs:18:14\n   |\n\
    18 |         Some(strings.iter().max_by_key(|s| s.len() as usize).unwrap())\n\
    \   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help:\
    \ try using a conversion method: `.to_string()`\n   |              |\n   |   \
    \           expected struct `String`, found `&String`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.iter()\n        .cloned()\n        .flat_map(|s| {\n        \
    \    s.chars().count();\n        })\n        .max()\n        .map(|len| strings.iter().take(len).fold(\n\
    \            None,\n            |mut x, s| Some(x.join(s),\n        ),\n     \
    \   )\n    }\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error: unexpected closing delimiter: `}`\n  --> /tmp/tmptj3wzzyx.rs:22:1\n\
    \   |\n9  | fn longest(strings: Vec<String>) -> Option<String> {\n   |       \
    \                                             - this opening brace...\n...\n21\
    \ |     }\n   |     - ...matches this closing brace\n22 | }\n   | ^ unexpected\
    \ closing delimiter\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmptj3wzzyx.rs:16:13\n\
    \   |\n16 |         .map(|len| strings.iter().take(len).fold(\n   |          \
    \   ^ unclosed delimiter\n...\n21 |     }\n   |     ^ mismatched closing delimiter\n\
    \nerror: aborting due to 2 previous errors\n\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest_len = 0;\n    let mut longest_string = String::from(\"\
    \");\n    for str in strings {\n        let mut len = str.chars().filter(|c| *c\
    \ != '/').count();\n        if len > longest_len {\n            longest_len =\
    \ len;\n            longest_string = str;\n        }\n    }\n    longest_string.into_owned()\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `into_owned` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmp5abk6u4i.rs:19:20\n   |\n19 |     longest_string.into_owned()\n\
    \   |                    ^^^^^^^^^^ method not found in `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n\n    let mut string_len\
    \ = String::from(\"\");\n    let mut first_string = String::from(\"\");\n\n  \
    \  strings\n        .iter()\n        .fold(first_string, |mut acc, s| {\n    \
    \        if string_len == s.len() {\n                string_len = s.len();\n \
    \               Some(s);\n            } else {\n                string_len = s.len();\n\
    \                Some(acc);\n            }\n        })\n}\n\nfn main() {\n   \
    \ let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpr2cjzxoj.rs:19:15\n   |\n\
    19 |         .fold(first_string, |mut acc, s| {\n   |               ^^^^^^^^^^^^\
    \ expected enum `Option`, found struct `String`\n   |\n   = note: expected enum\
    \ `Option<String>`\n            found struct `String`\nhelp: try wrapping the\
    \ expression in `Some`\n   |\n19 |         .fold(Some(first_string), |mut acc,\
    \ s| {\n   |               +++++            +\n\nerror[E0277]: can't compare `String`\
    \ with `usize`\n  --> /tmp/tmpr2cjzxoj.rs:20:27\n   |\n20 |             if string_len\
    \ == s.len() {\n   |                           ^^ no implementation for `String\
    \ == usize`\n   |\n   = help: the trait `PartialEq<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpr2cjzxoj.rs:21:30\n   |\n14 |     let mut string_len =\
    \ String::from(\"\");\n   |                          ---------------- expected\
    \ due to this value\n...\n21 |                 string_len = s.len();\n   |   \
    \                           ^^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                              |\n   |                              expected\
    \ struct `String`, found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpr2cjzxoj.rs:20:38\n\
    \   |\n20 |               if string_len == s.len() {\n   |  ______________________________________^\n\
    21 | |                 string_len = s.len();\n22 | |                 Some(s);\n\
    23 | |             } else {\n   | |_____________^ expected enum `Option`, found\
    \ `()`\n   |\n   = note:   expected enum `Option<String>`\n           found unit\
    \ type `()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpr2cjzxoj"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings\n        .iter()\n        .fold(\n            None,\n       \
    \     |max, &string| {\n                if max.len() < string.len() {\n      \
    \              max = Some(string);\n                }\n                max\n \
    \           },\n        )\n}\n\nfn main() {\n    let candidate = longest;\n  \
    \  assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmptixqpy89.rs:15:24\n   |\n15 |                 if max.len()\
    \ < string.len() {\n   |                        ^^^ method not found in `Option<String>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings\n        .into_iter()\n        .cloned()\n        .windows(2)\n\
    \        .max()\n        .flatten()\n        .next()\n}\n\nfn main() {\n    let\
    \ candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<std::vec::IntoIter<String> as Iterator>::Item\
    \ == &_`\n    --> /tmp/tmpqft7nrz1.rs:12:10\n     |\n12   |         .cloned()\n\
    \     |          ^^^^^^ expected reference, found struct `String`\n     |\n  \
    \   = note: expected reference `&_`\n                   found struct `String`\n\
    note: required by a bound in `cloned`\n\nerror[E0599]: no method named `windows`\
    \ found for struct `Cloned` in the current scope\n  --> /tmp/tmpqft7nrz1.rs:13:10\n\
    \   |\n13 |         .windows(2)\n   |          ^^^^^^^ method not found in `Cloned<std::vec::IntoIter<String>>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = Some(\"\");\n    for str in strings {\n        if !longest.is_some()\
    \ || longest.as_ref().len() < str.len() {\n            longest = Some(str);\n\
    \        }\n    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmpzkjof37l.rs:12:51\n   |\n12 |         if !longest.is_some()\
    \ || longest.as_ref().len() < str.len() {\n   |                              \
    \                     ^^^ method not found in `Option<&&str>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpzkjof37l.rs:13:28\n   |\n13 |             longest\
    \ = Some(str);\n   |                            ^^^\n   |                    \
    \        |\n   |                            expected `&str`, found struct `String`\n\
    \   |                            help: consider borrowing here: `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpzkjof37l.rs:16:5\n   |\n9  | fn longest(strings:\
    \ Vec<String>) -> Option<String> {\n   |                                     --------------\
    \ expected `Option<String>` because of return type\n...\n16 |     longest\n  \
    \ |     ^^^^^^^ expected struct `String`, found `&str`\n   |\n   = note: expected\
    \ enum `Option<String>`\n              found enum `Option<&str>`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut longest\
    \ = strings[0];\n    let mut string_len = 0;\n    for string in strings {\n  \
    \      string_len = string.len();\n        if longest == string {\n          \
    \  continue;\n        }\n        if string_len > longest {\n            longest\
    \ = string;\n        }\n    }\n    longest\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpog8gs7kq.rs:20:25\n   |\n\
    20 |         if string_len > longest {\n   |                         ^^^^^^^ expected\
    \ `usize`, found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpog8gs7kq.rs:24:5\n\
    \   |\n9  | fn longest(strings: Vec<String>) -> Option<String> {\n   |       \
    \                              -------------- expected `Option<String>` because\
    \ of return type\n...\n24 |     longest\n   |     ^^^^^^^ expected enum `Option`,\
    \ found struct `String`\n   |\n   = note: expected enum `Option<String>`\n   \
    \         found struct `String`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n24 |     Some(longest)\n   |     +++++       +\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut result = String::new();\n    for s in strings.iter() {\n    \
    \    if s.length() > result.len() {\n            result = s;\n        }\n    }\n\
    \    result.is_some()\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for reference `&String` in\
    \ the current scope\n  --> /tmp/tmp39i64rbr.rs:12:14\n   |\n12 |         if s.length()\
    \ > result.len() {\n   |              ^^^^^^ help: there is an associated function\
    \ with a similar name: `len`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp39i64rbr.rs:13:22\n\
    \   |\n10 |     let mut result = String::new();\n   |                      -------------\
    \ expected due to this value\n...\n13 |             result = s;\n   |        \
    \              ^- help: try using a conversion method: `.to_string()`\n   |  \
    \                    |\n   |                      expected struct `String`, found\
    \ `&String`\n\nerror[E0599]: no method named `is_some` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp39i64rbr.rs:16:12\n   |\n16 |     result.is_some()\n\
    \   |            ^^^^^^^ method not found in `String`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut lengths\
    \ = Vec::new();\n    for str in strings {\n        let len = str.len();\n    \
    \    if let Some(len) = lengths.iter().position(|x| x == len) {\n            lengths[len]\
    \ = *len + 1;\n        } else {\n            lengths.push(len);\n        }\n \
    \   }\n    let mut max = lengths.iter().max().unwrap();\n    let mut max_index\
    \ = 0;\n    let mut pos = 0;\n    for len in lengths {\n        if *len > max\
    \ {\n            max = *len;\n            max_index = pos;\n        }\n      \
    \  pos += 1;\n    }\n    Some(strings[max_index])\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&_` with `usize`\n  --> /tmp/tmpbav1316w.rs:16:58\n\
    \   |\n16 |         if let Some(len) = lengths.iter().position(|x| x == len) {\n\
    \   |                                                          ^^ no implementation\
    \ for `&_ == usize`\n   |\n   = help: the trait `PartialEq<usize>` is not implemented\
    \ for `&_`\n\nerror[E0614]: type `usize` cannot be dereferenced\n  --> /tmp/tmpbav1316w.rs:17:28\n\
    \   |\n17 |             lengths[len] = *len + 1;\n   |                       \
    \     ^^^^\n\nerror[E0614]: type `usize` cannot be dereferenced\n  --> /tmp/tmpbav1316w.rs:26:12\n\
    \   |\n26 |         if *len > max {\n   |            ^^^^\n\nerror[E0614]: type\
    \ `usize` cannot be dereferenced\n  --> /tmp/tmpbav1316w.rs:27:19\n   |\n27 |\
    \             max = *len;\n   |                   ^^^^\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0614.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    strings.iter().fold(None,\
    \ |a, b| {\n        if a.len() > b.len() {\n            Some(a)\n        } else\
    \ {\n            Some(b)\n        }\n    })\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmpbxj7de78.rs:14:14\n   |\n14 |         if a.len() > b.len()\
    \ {\n   |              ^^^ method not found in `Option<String>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpbxj7de78.rs:15:18\n   |\n15 |             Some(a)\n\
    \   |                  ^ expected struct `String`, found enum `Option`\n   |\n\
    \   = note: expected struct `String`\n                found enum `Option<String>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpbxj7de78.rs:17:18\n   |\n17 |\
    \             Some(b)\n   |                  ^- help: try using a conversion method:\
    \ `.to_string()`\n   |                  |\n   |                  expected struct\
    \ `String`, found `&String`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n\n    let mut max_length\
    \ = strings[0]\n        .len()\n        .unwrap()\n        .try_clone()\n    \
    \    .unwrap();\n    for &s in strings {\n        if s.len() > max_length {\n\
    \            max_length = s.len().unwrap();\n        }\n    }\n\n    for &s in\
    \ strings {\n        if max_length < s.len().unwrap() {\n            return Some(s);\n\
    \        }\n    }\n\n    None\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap` found for type `usize` in the current\
    \ scope\n  --> /tmp/tmp3r0_kyv7.rs:16:10\n   |\n16 |         .unwrap()\n   | \
    \         ^^^^^^ method not found in `usize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp3r0_kyv7.rs:19:9\n   |\n19 |     for &s in strings {\n   |    \
    \     ^^    ------- this expression has type `Option<String>`\n   |         |\n\
    \   |         expected struct `String`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `s`\n   |\n   = note: expected struct\
    \ `String`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp3r0_kyv7.rs:25:9\n   |\n25 |     for &s in strings {\n   |    \
    \     ^^    ------- this expression has type `Option<String>`\n   |         |\n\
    \   |         expected struct `String`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `s`\n   |\n   = note: expected struct\
    \ `String`\n           found reference `&_`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 101
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n\n    let mut max_len\
    \ = String::new();\n    for s in strings {\n        if max_len.len() > s.len()\
    \ {\n            max_len = s;\n        }\n    }\n\n    Some(max_len)\n}\n\nfn\
    \ main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"\")`,\n right: `Some(\"x\")`', /tmp/tmpvw3gyay4.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = std::i32::MAX;\n    let mut max_index = -1;\n    for\
    \ (index, item) in strings.iter().enumerate() {\n        let len = item.chars().count();\n\
    \        if len > max_len {\n            max_len = len;\n            max_index\
    \ = index;\n        }\n    }\n    if max_index < 0 {\n        return None;\n \
    \   }\n    Some(strings[max_index])\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpi4ptu96v.rs:14:18\n   |\n\
    14 |         if len > max_len {\n   |                  ^^^^^^^ expected `usize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to a `usize` and panic if\
    \ the converted value doesn't fit\n   |\n14 |         if len > max_len.try_into().unwrap()\
    \ {\n   |                         ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpi4ptu96v.rs:15:23\n   |\n10 |     let mut max_len = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n15\
    \ |             max_len = len;\n   |                       ^^^ expected `i32`,\
    \ found `usize`\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n\
    \  --> /tmp/tmpi4ptu96v.rs:11:25\n   |\n11 |     let mut max_index = -1;\n   |\
    \                         ^^ the trait `Neg` is not implemented for `usize`\n\
    \   |\n   = help: the following other types implement trait `Neg`:\n         \
    \    &f32\n             &f64\n             &i128\n             &i16\n        \
    \     &i32\n             &i64\n             &i8\n             &isize\n       \
    \    and 8 others\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n\n    strings.iter().fold(\n\
    \        None,\n        |max_str| {\n            if let Some(len) = (max_str.len()).max()\
    \ {\n                Some(max_str.to_owned().replace(len, len, \"\"));\n     \
    \       } else {\n                max_str\n            }\n        },\n    )\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0593]: closure is expected to take 2 arguments, but it takes 1 argument\n\
    \  --> /tmp/tmpjp7qq01b.rs:14:20\n   |\n14 |     strings.iter().fold(\n   |  \
    \                  ^^^^ expected closure that takes 2 arguments\n15 |        \
    \ None,\n16 |         |max_str| {\n   |         --------- takes 1 argument\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0593`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.iter().cloned().max_by_key(|s| s.len()).cloned()\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `Option<String>` is not an iterator\n   --> /tmp/tmpccu7if8h.rs:10:53\n\
    \    |\n10  |       strings.iter().cloned().max_by_key(|s| s.len()).cloned()\n\
    \    |                                                       ^^^^^^ `Option<String>`\
    \ is not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Option<String>: Iterator`\n            which is required by `&mut\
    \ Option<String>: Iterator`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings\n        .iter()\n        .map(|s| s.len())\n        .max().ok_or(String::from(\"\
    empty\"))\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl_jc_pgx.rs:10:5\n   |\n\
    9  |   fn longest(strings: Vec<String>) -> Option<String> {\n   |            \
    \                           -------------- expected `Option<String>` because of\
    \ return type\n10 | /     strings\n11 | |         .iter()\n12 | |         .map(|s|\
    \ s.len())\n13 | |         .max().ok_or(String::from(\"empty\"))\n   | |___________________________________________^\
    \ expected enum `Option`, found enum `Result`\n   |\n   = note: expected enum\
    \ `Option<String>`\n              found enum `Result<usize, String>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings\n        .iter()\n        .fold(\n            None,\n       \
    \     |max_len, current_str| {\n                if let Some(current_len) = current_str.len()\
    \ {\n                    if max_len\n                        .as_ref()\n     \
    \                   .map(|current_max_len| current_max_len + current_len)\n  \
    \                      .unwrap_or(current_len) > current_len {\n             \
    \           Some(current_str)\n                    } else {\n                \
    \        None\n                    }\n                } else {\n             \
    \       None\n                }\n            },\n        )\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpanofz0k9.rs:15:24\n   |\n\
    15 |                 if let Some(current_len) = current_str.len() {\n   |    \
    \                    ^^^^^^^^^^^^^^^^^   ----------------- this expression has\
    \ type `usize`\n   |                        |\n   |                        expected\
    \ `usize`, found enum `Option`\n   |\n   = note: expected type `usize`\n     \
    \         found enum `Option<_>`\n\nerror[E0369]: cannot add `_` to `&String`\n\
    \  --> /tmp/tmpanofz0k9.rs:18:64\n   |\n18 |                         .map(|current_max_len|\
    \ current_max_len + current_len)\n   |                                       \
    \         --------------- ^ ----------- _\n   |                              \
    \                  |\n   |                                                &String\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpanofz0k9.rs:20:30\n   |\n20 |\
    \                         Some(current_str)\n   |                            \
    \  ^^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |    \
    \                          |\n   |                              expected struct\
    \ `String`, found `&String`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 101
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings\n        .iter()\n        .max_by(|&x, &y| x.len().cmp(&y.len()))\n\
    \        .cloned()\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmpc6bcc5ar.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 101
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.iter().max().map(|s| s).cloned()\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmpalpqoxat.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings\n        .iter()\n        .enumerate()\n        .max_by(|(_,\
    \ a), (_, b)| a.len().cmp(&b.len()))\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppqbxt6q_.rs:10:5\n   |\n\
    9  |   fn longest(strings: Vec<String>) -> Option<String> {\n   |            \
    \                           -------------- expected `Option<String>` because of\
    \ return type\n10 | /     strings\n11 | |         .iter()\n12 | |         .enumerate()\n\
    13 | |         .max_by(|(_, a), (_, b)| a.len().cmp(&b.len()))\n   | |_______________________________________________________^\
    \ expected struct `String`, found tuple\n   |\n   = note: expected enum `Option<String>`\n\
    \              found enum `Option<(usize, &String)>`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = String::new();\n    let mut max_length = 0;\n\n   \
    \ for s in strings {\n        if max_len.len() > max_length {\n            max_length\
    \ = max_len.len();\n            max_len = String::new();\n        }\n        max_len\
    \ = max_len.push_str(&s.as_str());\n    }\n\n    if max_len.len() > max_length\
    \ {\n        max_len = max_len.clone();\n        max_length = max_len.len();\n\
    \    }\n\n    if max_length == 0 {\n        return None;\n    }\n\n    for s in\
    \ strings {\n        if max_len.len() == max_length {\n            return Some(s);\n\
    \        }\n    }\n\n    return None;\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp04q4eogm.rs:18:19\n   |\n\
    10 |     let mut max_len = String::new();\n   |                       -------------\
    \ expected due to this value\n...\n18 |         max_len = max_len.push_str(&s.as_str());\n\
    \   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found `()`\n   |\nnote: method `push_str` modifies its receiver in-place\n \
    \ --> /tmp/tmp04q4eogm.rs:18:27\n   |\n18 |         max_len = max_len.push_str(&s.as_str());\n\
    \   |                   ------- ^^^^^^^^ this call modifies `max_len` in-place\n\
    \   |                   |\n   |                   you probably want to use this\
    \ value after calling the method...\n   = note: ...instead of the `()` output\
    \ of method `push_str`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest_string = None;\n    let mut current_len = 0;\n\n    for\
    \ s in strings {\n        current_len = s.len();\n        if longest_string.is_none()\
    \ || current_len > longest_string.as_ref().unwrap().len() {\n            longest_string\
    \ = Some(s);\n        }\n    }\n\n    longest_string\n}\n\nfn main() {\n    let\
    \ candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Option<T>`\n  --> /tmp/tmpb7bafpcn.rs:15:69\n\
    \   |\n10 |     let mut longest_string = None;\n   |         ------------------\
    \ consider giving `longest_string` the explicit type `Option<T>`, where the type\
    \ parameter `T` is specified\n...\n15 |         if longest_string.is_none() ||\
    \ current_len > longest_string.as_ref().unwrap().len() {\n   |               \
    \                                                      ^^^^^^ cannot infer type\
    \ for type parameter `T`\n   |\n   = note: type must be known at this point\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 101
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings\n        .into_iter()\n        .enumerate()\n        .find_map(|(i,\
    \ s)| {\n            if s.len() == i {\n                Some(s.clone())\n    \
    \        } else {\n                None\n            }\n        })\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"y\")`,\n right: `Some(\"x\")`', /tmp/tmpnwc9wvjl.rs:25:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest_len = std::u32::MAX;\n    let mut longest_str = None;\n\
    \    for str in strings {\n        let len =\n            if let Some(len) = str\n\
    \                .len()\n                .checked_mul(longest_len)\n         \
    \       .expect(\"Can't multiply string lengths by negative number\")\n      \
    \      {\n                len\n            } else {\n                longest_len\
    \ = std::u32::MAX;\n                str\n            };\n        if len > longest_len\
    \ {\n            longest_len = len;\n            longest_str = str;\n        }\n\
    \    }\n    longest_str\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxcmf2x6n.rs:16:30\n   |\n\
    16 |                 .checked_mul(longest_len)\n   |                         \
    \     ^^^^^^^^^^^ expected `usize`, found `u32`\n   |\nhelp: you can convert a\
    \ `u32` to a `usize` and panic if the converted value doesn't fit\n   |\n16 |\
    \                 .checked_mul(longest_len.try_into().unwrap())\n   |        \
    \                                 ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpxcmf2x6n.rs:14:20\n   |\n14 |               if let Some(len)\
    \ = str\n   |  ____________________^^^^^^^^^___-\n   | |                    |\n\
    \   | |                    expected `usize`, found enum `Option`\n15 | |     \
    \            .len()\n16 | |                 .checked_mul(longest_len)\n17 | |\
    \                 .expect(\"Can't multiply string lengths by negative number\"\
    )\n   | |___________________________________________________________________________-\
    \ this expression has type `usize`\n   |\n   = note: expected type `usize`\n \
    \             found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpxcmf2x6n.rs:24:18\n   |\n24 |         if len > longest_len {\n   | \
    \                 ^^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                  |\n   |                  expected struct `String`, found\
    \ `u32`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxcmf2x6n.rs:25:27\n \
    \  |\n10 |     let mut longest_len = std::u32::MAX;\n   |                    \
    \       ------------- expected due to this value\n...\n25 |             longest_len\
    \ = len;\n   |                           ^^^ expected `u32`, found struct `String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpxcmf2x6n.rs:26:27\n   |\n11 |\
    \     let mut longest_str = None;\n   |                           ---- expected\
    \ due to this value\n...\n26 |             longest_str = str;\n   |          \
    \                 ^^^ expected enum `Option`, found struct `String`\n   |\n  \
    \ = note: expected enum `Option<_>`\n            found struct `String`\nhelp:\
    \ try wrapping the expression in `Some`\n   |\n26 |             longest_str =\
    \ Some(str"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut len = String::new();\n    for s in strings {\n        len.push_str(s);\n\
    \    }\n    if len.chars().count() >= strings.len() {\n        return Some(len.clone());\n\
    \    }\n    strings.iter().map(|s| {\n        s.chars().take(s.len()).count()\n\
    \    }).max()\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjxo6bds7.rs:12:22\n   |\n\
    12 |         len.push_str(s);\n   |                      ^\n   |             \
    \         |\n   |                      expected `&str`, found struct `String`\n\
    \   |                      help: consider borrowing here: `&s`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpjxo6bds7.rs:17:5\n   |\n9  |   fn longest(strings:\
    \ Vec<String>) -> Option<String> {\n   |                                     \
    \  -------------- expected `Option<String>` because of return type\n...\n17 |\
    \ /     strings.iter().map(|s| {\n18 | |         s.chars().take(s.len()).count()\n\
    19 | |     }).max()\n   | |____________^ expected struct `String`, found `usize`\n\
    \   |\n   = note: expected enum `Option<String>`\n              found enum `Option<usize>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.iter().max_by(|a, b| a.len().cmp(&b.len()).unwrap_or(0))\n}\n\
    \nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap_or` found for enum `std::cmp::Ordering`\
    \ in the current scope\n  --> /tmp/tmptr9tuc7p.rs:10:56\n   |\n10 |     strings.iter().max_by(|a,\
    \ b| a.len().cmp(&b.len()).unwrap_or(0))\n   |                               \
    \                         ^^^^^^^^^ method not found in `std::cmp::Ordering`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmptr9tuc7p.rs:10:5\n   |\n9  | fn\
    \ longest(strings: Vec<String>) -> Option<String> {\n   |                    \
    \                 -------------- expected `Option<String>` because of return type\n\
    10 |     strings.iter().max_by(|a, b| a.len().cmp(&b.len()).unwrap_or(0))\n  \
    \ |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `String`, found `&String`\n   |\n   = note: expected enum `Option<String>`\n\
    \              found enum `Option<&String>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest_string = String::new();\n    let mut first_string = None;\n\
    \    for s in strings {\n        if !s.is_empty() {\n            if longest_string.is_empty()\
    \ {\n                longest_string = s;\n                first_string = Some(s);\n\
    \            } else {\n                let len = s.len();\n                if\
    \ len < longest_string.len() {\n                    longest_string = s;\n    \
    \                first_string = Some(s);\n                }\n            }\n \
    \       }\n    }\n    Some(longest_string)\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "warning: variable `first_string` is assigned to, but never used\n  -->\
    \ /tmp/tmpwimr17q2.rs:11:13\n   |\n11 |     let mut first_string = None;\n   |\
    \             ^^^^^^^^^^^^\n   |\n   = note: `#[warn(unused_variables)]` on by\
    \ default\n   = note: consider using `_first_string` instead\n\nwarning: value\
    \ assigned to `first_string` is never read\n  --> /tmp/tmpwimr17q2.rs:16:17\n\
    \   |\n16 |                 first_string = Some(s);\n   |                 ^^^^^^^^^^^^\n\
    \   |\n   = note: `#[warn(unused_assignments)]` on by default\n   = help: maybe\
    \ it is overwritten before being read?\n\nwarning: value assigned to `first_string`\
    \ is never read\n  --> /tmp/tmpwimr17q2.rs:21:21\n   |\n21 |                 \
    \    first_string = Some(s);\n   |                     ^^^^^^^^^^^^\n   |\n  \
    \ = help: maybe it is overwritten before being read?\n\nerror[E0382]: use of moved\
    \ value: `s`\n  --> /tmp/tmpwimr17q2.rs:16:37\n   |\n12 |     for s in strings\
    \ {\n   |         - move occurs because `s` has type `String`, which does not\
    \ implement the `Copy` trait\n...\n15 |                 longest_string = s;\n\
    \   |                                  - value moved here\n16 |              \
    \   first_string = Some(s);\n   |                                     ^ value\
    \ used here after move\n\nerror[E0382]: use of moved value: `s`\n  --> /tmp/tmpwimr17q2.rs:21:41\n\
    \   |\n12 |     for s in strings {\n   |         - move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n20 |        \
    \             longest_string = s;\n   |                                      -\
    \ value moved here\n21 |                     first_string = Some(s);\n   |   \
    \                                      ^ value used here after move\n\nerror:\
    \ aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 101
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max = String::new();\n    for s in strings {\n        if s.len()\
    \ > max.len() {\n            max = s;\n        }\n    }\n    Some(max)\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"\")`,\n right: `None`', /tmp/tmp2yxrwq50.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings\n        .iter()\n        .cloned()\n        .map(|s| s.len().max())\n\
    \        .max()\n        .cloned()\n        .or_else(|| None)\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \   --> /tmp/tmpfdu336cn.rs:13:26\n    |\n13  |         .map(|s| s.len().max())\n\
    \    |                          ^^^- supplied 0 arguments\n    |             \
    \             |\n    |                          expected 1 argument\n    |\nnote:\
    \ associated function defined here\n\nerror[E0599]: `Option<usize>` is not an\
    \ iterator\n   --> /tmp/tmpfdu336cn.rs:15:10\n    |\n15  |           .cloned()\n\
    \    |            ^^^^^^ `Option<usize>` is not an iterator\n    |\n    = note:\
    \ the following trait bounds were not satisfied:\n            `Option<usize>:\
    \ Iterator`\n            which is required by `&mut Option<usize>: Iterator`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut strings_iter = strings.iter();\n    let mut max_size = 0;\n \
    \   let mut max_len: usize = 0;\n    let mut max_length: usize = 0;\n    for s\
    \ in strings_iter {\n        if !s.is_empty() {\n            let len = s.len();\n\
    \            if len > max_size {\n                max_size = len;\n          \
    \      max_len = len;\n                max_length = len;\n            }\n    \
    \    }\n    }\n\n    if max_size >= max_len {\n        Some(strings[max_length])\n\
    \    } else {\n        None\n    }\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmp8hul9px2.rs:10:9\n\
    \   |\n10 |     let mut strings_iter = strings.iter();\n   |         ----^^^^^^^^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0507]: cannot move out of index of `Vec<String>`\n \
    \ --> /tmp/tmp8hul9px2.rs:26:14\n   |\n26 |         Some(strings[max_length])\n\
    \   |              ^^^^^^^^^^^^^^^^^^^ move occurs because value has type `String`,\
    \ which does not implement the `Copy` trait\n\nerror: aborting due to previous\
    \ error; 1 warning emitted\n\nFor more information about this error, try `rustc\
    \ --explain E0507`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_length = String::new();\n    for s in strings {\n       \
    \ if s.len() > max_length.len() {\n            max_length = s;\n        }\n  \
    \  }\n    if strings.len() == 0 {\n        return None;\n    }\n    if max_length.len()\
    \ == 0 {\n        return None;\n    }\n    Some(max_length)\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `strings`\n   --> /tmp/tmpu1681g9w.rs:16:8\n\
    \    |\n9   | fn longest(strings: Vec<String>) -> Option<String> {\n    |    \
    \        ------- move occurs because `strings` has type `Vec<String>`, which does\
    \ not implement the `Copy` trait\n10  |     let mut max_length = String::new();\n\
    11  |     for s in strings {\n    |              ------- `strings` moved due to\
    \ this implicit call to `.into_iter()`\n...\n16  |     if strings.len() == 0 {\n\
    \    |        ^^^^^^^^^^^^^ value borrowed here after move\n    |\nnote: this\
    \ function takes ownership of the receiver `self`, which moves `strings`\nhelp:\
    \ consider iterating over a slice of the `Vec<String>`'s content to avoid moving\
    \ into the `for` loop\n    |\n11  |     for s in &strings {\n    |           \
    \   +\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut current_longest_len = 0;\n    let mut current_longest_str = None;\n\
    \    for string in strings {\n        let (longest_str, longest_len) = longest_common_str(string,\
    \ &mut current_longest_len, &mut current_longest_str);\n        current_longest_len\
    \ = longest_len;\n        current_longest_str = longest_str;\n    }\n\n    current_longest_str\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `longest_common_str` in this scope\n\
    \  --> /tmp/tmp8h9jk44e.rs:13:42\n   |\n13 |         let (longest_str, longest_len)\
    \ = longest_common_str(string, &mut current_longest_len, &mut current_longest_str);\n\
    \   |                                          ^^^^^^^^^^^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings\n        .iter()\n        .fold(\n            vec![String::new()],\n\
    \            |mut acc, s| {\n                if acc.len() > s.len() {\n      \
    \              acc.pop();\n                }\n                acc.push(s)\n  \
    \          },\n        )\n        .last()\n        .unwrap_or(None)\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdq0v7ij6.rs:18:26\n   |\n\
    18 |                 acc.push(s)\n   |                          ^- help: try using\
    \ a conversion method: `.to_string()`\n   |                          |\n   | \
    \                         expected struct `String`, found `&String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpdq0v7ij6.rs:18:17\n   |\n18 |              \
    \   acc.push(s)\n   |                 ^^^^^^^^^^^ expected struct `Vec`, found\
    \ `()`\n   |\n   = note: expected struct `Vec<String>`\n           found unit\
    \ type `()`\nnote: method `push` modifies its receiver in-place\n  --> /tmp/tmpdq0v7ij6.rs:18:21\n\
    \   |\n18 |                 acc.push(s)\n   |                 --- ^^^^ this call\
    \ modifies `acc` in-place\n   |                 |\n   |                 you probably\
    \ want to use this value after calling the method...\n   = note: ...instead of\
    \ the `()` output of method `push`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdq0v7ij6.rs:22:20\n\
    \   |\n22 |         .unwrap_or(None)\n   |                    ^^^^ expected `&String`,\
    \ found enum `Option`\n   |\n   = note: expected reference `&String`\n       \
    \            found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdq0v7ij6.rs:10:5\n\
    \   |\n9  |   fn longest(strings: Vec<String>) -> Option<String> {\n   |     \
    \                                  -------------- expected `Option<String>` because\
    \ of return type\n10 | /     strings\n11 | |         .iter()\n12 | |         .fold(\n\
    13 | |             vec![String::new()],\n...  |\n21 | |         .last()\n22 |\
    \ |         .unwrap_or(None)\n   | |________________________^ expected enum `Option`,\
    \ found `&String`\n   |\n   = note:   expected enum `Option<String>`\n       \
    \    found reference `&String`\n\nerror: aborting due to 4 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest_len\
    \ = 0;\n    let mut longest_len_ind = -1;\n    for i in 0..strings.len() {\n \
    \       longest_len = strings[i].len() > longest_len ? strings[i].len() : longest_len;\n\
    \        if longest_len == strings[i].len() {\n            longest_len_ind = i;\n\
    \        }\n    }\n\n    let mut longest_str = strings[longest_len_ind];\n   \
    \ for j in longest_len_ind..strings.len() {\n        if longest_len_ind != j {\n\
    \            longest_str = strings[j];\n            break;\n        }\n    }\n\
    \n    Some(longest_str)\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `strings`\n\
    \  --> /tmp/tmpp4aob9_v.rs:17:56\n   |\n17 |         longest_len = strings[i].len()\
    \ > longest_len ? strings[i].len() : longest_len;\n   |                      \
    \                                  ^^^^^^^ expected one of `.`, `;`, `?`, `}`,\
    \ or an operator\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n\
    \  --> /tmp/tmpp4aob9_v.rs:15:31\n   |\n15 |     let mut longest_len_ind = -1;\n\
    \   |                               ^^ the trait `Neg` is not implemented for\
    \ `usize`\n   |\n   = help: the following other types implement trait `Neg`:\n\
    \             &f32\n             &f64\n             &i128\n             &i16\n\
    \             &i32\n             &i64\n             &i8\n             &isize\n\
    \           and 8 others\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut longest_len\
    \ = String::new(\"\").len();\n    let mut i = 0;\n    for s in strings {\n   \
    \     if s.len() > longest_len {\n            longest_len = s.len();\n       \
    \ }\n        if i == 0 {\n            i = 1;\n        }\n        if longest_len\
    \ == s.len() {\n            return Some(s);\n        }\n        i += 1;\n    }\n\
    \    None\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmpcpz8sqa0.rs:13:27\n    |\n13  |     let mut longest_len = String::new(\"\
    \").len();\n    |                           ^^^^^^^^^^^ -- supplied 1 argument\n\
    \    |                           |\n    |                           expected 0\
    \ arguments\n    |\nnote: associated function defined here\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0061`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        None\n    } else {\n        let mut\
    \ max_length = 0;\n        let mut max_length_str = String::new();\n        for\
    \ str in strings {\n            if str.len() > max_length {\n                max_length\
    \ = str.len();\n                max_length_str = str;\n            }\n       \
    \ }\n        Some(max_length_str)\n    }\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.iter().map(|s| {\n        let mut len = 0;\n        for (i, c)\
    \ in s.chars().enumerate()\n            .skip_while(|c| *c != c.to_ascii_lowercase())\n\
    \            .take_while(|c| {\n                len += 1;\n                len\
    \ <= c.len_utf8()\n            })\n        {\n            len = i;\n        }\n\
    \        Some(s)\n    }).max().cloned()\n}\n\nfn main() {\n    let candidate =\
    \ longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_ascii_lowercase` found for reference\
    \ `&(usize, char)` in the current scope\n  --> /tmp/tmpd8hmp6cc.rs:13:37\n   |\n\
    13 |             .skip_while(|c| *c != c.to_ascii_lowercase())\n   |         \
    \                            ^^^^^^^^^^^^^^^^^^ method not found in `&(usize,\
    \ char)`\n\nerror[E0599]: no method named `len_utf8` found for reference `&(usize,\
    \ char)` in the current scope\n  --> /tmp/tmpd8hmp6cc.rs:16:26\n   |\n16 |   \
    \              len <= c.len_utf8()\n   |                          ^^^^^^^^ method\
    \ not found in `&(usize, char)`\n\nerror[E0599]: the method `cloned` exists for\
    \ enum `Option<Option<&String>>`, but its trait bounds were not satisfied\n  \
    \ --> /tmp/tmpd8hmp6cc.rs:22:14\n    |\n22  |       }).max().cloned()\n    | \
    \               ^^^^^^ method cannot be called on `Option<Option<&String>>` due\
    \ to unsatisfied trait bounds\n    |\n    = note: the following trait bounds were\
    \ not satisfied:\n            `Option<Option<&String>>: Iterator`\n          \
    \  which is required by `&mut Option<Option<&String>>: Iterator`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings\n        .iter()\n        .enumerate()\n        .filter_map(|(i,\
    \ s)| {\n            let l = s.len();\n            if i > 0 && l != strings[i\
    \ - 1].len() {\n                Some(Some(s))\n            } else {\n        \
    \        Some(None)\n            }\n        })\n        .max()\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwfgaivcq.rs:10:5\n   |\n\
    9  |   fn longest(strings: Vec<String>) -> Option<String> {\n   |            \
    \                           -------------- expected `Option<String>` because of\
    \ return type\n10 | /     strings\n11 | |         .iter()\n12 | |         .enumerate()\n\
    13 | |         .filter_map(|(i, s)| {\n...  |\n20 | |         })\n21 | |     \
    \    .max()\n   | |______________^ expected struct `String`, found enum `Option`\n\
    \   |\n   = note: expected enum `Option<String>`\n              found enum `Option<Option<&String>>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut len = String::from_str(\"0\");\n    for s in strings {\n    \
    \    len = s.len() > len ? s.len() : len.clone();\n    }\n    Some(len.clone())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `s`\n\
    \  --> /tmp/tmpj15mmkn7.rs:12:31\n   |\n12 |         len = s.len() > len ? s.len()\
    \ : len.clone();\n   |                               ^ expected one of `.`, `;`,\
    \ `?`, `}`, or an operator\n\nerror[E0599]: no function or associated item named\
    \ `from_str` found for struct `String` in the current scope\n  --> /tmp/tmpj15mmkn7.rs:10:27\n\
    \   |\n10 |     let mut len = String::from_str(\"0\");\n   |                 \
    \          ^^^^^^^^ function or associated item not found in `String`\n   |\n\
    \   = help: items from traits can only be used if the trait is in scope\nhelp:\
    \ the following trait is implemented but not in scope; perhaps add a `use` for\
    \ it:\n   |\n1  | use std::str::FromStr;\n   |\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        None\n    } else {\n        let mut\
    \ lens = String::new();\n        let mut max_len = String::new();\n        for\
    \ s in strings {\n            lens.push_str(&s.chars().count());\n           \
    \ if lens.len() > max_len.len() {\n                max_len = lens;\n         \
    \   }\n        }\n        Some(max_len)\n    }\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjq1pgyog.rs:16:27\n   |\n\
    16 |             lens.push_str(&s.chars().count());\n   |                    \
    \       ^^^^^^^^^^^^^^^^^^ expected `str`, found `usize`\n   |\n   = note: expected\
    \ reference `&str`\n              found reference `&usize`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = strings[0];\n    for &s in strings {\n        if longest.len()\
    \ < s.len() {\n            longest = s;\n        }\n    }\n    longest\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplk3h8gal.rs:11:9\n   |\n\
    11 |     for &s in strings {\n   |         ^^    ------- this expression has type\
    \ `Option<String>`\n   |         |\n   |         expected struct `String`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `s`\n\
    \   |\n   = note: expected struct `String`\n           found reference `&_`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmplk3h8gal.rs:16:5\n   |\n9  | fn\
    \ longest(strings: Vec<String>) -> Option<String> {\n   |                    \
    \                 -------------- expected `Option<String>` because of return type\n\
    ...\n16 |     longest\n   |     ^^^^^^^ expected enum `Option`, found struct `String`\n\
    \   |\n   = note: expected enum `Option<String>`\n            found struct `String`\n\
    help: try wrapping the expression in `Some`\n   |\n16 |     Some(longest)\n  \
    \ |     +++++       +\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0];\n    for s in strings {\n        if s.len() > longest.len() {\n\
    \            longest = s;\n        }\n    }\n\n    Some(longest)\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpl0ms4940.rs:14:23\n\
    \   |\n14 |     let mut longest = strings[0];\n   |                       ^^^^^^^^^^\n\
    \   |                       |\n   |                       move occurs because\
    \ value has type `String`, which does not implement the `Copy` trait\n   |   \
    \                    help: consider borrowing here: `&strings[0]`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0507`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        None\n    } else {\n        let mut\
    \ min_len = std::cmp::min((strings.len() as i32), strings[0].length());\n    \
    \    let mut longest_len = min_len;\n        for s in strings.iter() {\n     \
    \       if s.length() > longest_len {\n                longest_len = s.length();\n\
    \            }\n            if s.length() < min_len {\n                min_len\
    \ = s.length;\n            }\n        }\n        if longest_len == min_len {\n\
    \            strings.iter().next().unwrap()\n        } else {\n            None\n\
    \        }\n    }\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around function argument\n  --> /tmp/tmpfvibuiet.rs:13:41\n\
    \   |\n13 |         let mut min_len = std::cmp::min((strings.len() as i32), strings[0].length());\n\
    \   |                                         ^                    ^\n   |\n \
    \  = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n\
    \   |\n13 -         let mut min_len = std::cmp::min((strings.len() as i32), strings[0].length());\n\
    13 +         let mut min_len = std::cmp::min(strings.len() as i32, strings[0].length());\n\
    \   | \n\nerror[E0599]: no method named `length` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmpfvibuiet.rs:13:76\n   |\n13 |         let mut\
    \ min_len = std::cmp::min((strings.len() as i32), strings[0].length());\n   |\
    \                                                                            ^^^^^^\
    \ help: there is an associated function with a similar name: `len`\n\nerror[E0599]:\
    \ no method named `length` found for reference `&String` in the current scope\n\
    \  --> /tmp/tmpfvibuiet.rs:16:18\n   |\n16 |             if s.length() > longest_len\
    \ {\n   |                  ^^^^^^ help: there is an associated function with a\
    \ similar name: `len`\n\nerror[E0599]: no method named `length` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmpfvibuiet.rs:17:33\n   |\n17 |\
    \                 longest_len = s.length();\n   |                            \
    \     ^^^^^^ help: there is an associated function with a similar name: `len`\n\
    \nerror[E0599]: no method named `length` found for reference `&String` in the\
    \ current scope\n  --> /tmp/tmpfvibuiet.rs:19:18\n   |\n19 |             if s.length()\
    \ < min_len {\n   |                  ^^^^^^ help: there is an associated function\
    \ with a similar name: `len`\n\nerror[E0609]: no field `length` on type `&String`\n\
    \  --> /tmp/tmpfvibuiet.rs:20:29\n   |\n20 |                 min_len = s.length;\n\
    \   |                             ^^^^^^ unknown field\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpfvibuiet.rs:24:13\n   |\n9  | fn longest(strings: Vec<String>)\
    \ -> Option<String> {\n   |                  "
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut longest\
    \ = String::from(\"\"); // empty string initially\n    for str in strings.iter()\
    \ {\n        if str.is_empty() {\n            return Some(String::from(\"\"));\n\
    \        }\n        if longest != str {\n            return Some(String::from(\"\
    \"));\n        }\n    }\n    Some(longest)\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `String` with `&String`\n  --> /tmp/tmpf_u_un8h.rs:18:20\n\
    \   |\n18 |         if longest != str {\n   |                    ^^ no implementation\
    \ for `String == &String`\n   |\n   = help: the trait `PartialEq<&String>` is\
    \ not implemented for `String`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n\n    let mut max\
    \ = strings[0];\n    let mut best_len = 0;\n    for &s in strings {\n        let\
    \ len = s.len();\n        if len > best_len {\n            best_len = len;\n \
    \           max = s;\n        }\n    }\n    Some(max)\n}\n\nfn main() {\n    let\
    \ candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppxdevzkh.rs:16:9\n   |\n\
    16 |     for &s in strings {\n   |         ^^    ------- this expression has type\
    \ `Option<String>`\n   |         |\n   |         expected struct `String`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `s`\n\
    \   |\n   = note: expected struct `String`\n           found reference `&_`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n\n    let mut max\
    \ = String::new();\n    let mut max_idx = -1;\n    for i in strings.iter().rposition(|s|\
    \ s.len() > max.len() || s == max) {\n        max = i as usize;\n        max_idx\
    \ = i;\n    }\n    if max_idx == -1 {\n        return None;\n    }\n    Some(strings[max_idx])\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&String` with `String`\n  --> /tmp/tmpc01ppq1y.rs:16:68\n\
    \   |\n16 |     for i in strings.iter().rposition(|s| s.len() > max.len() || s\
    \ == max) {\n   |                                                            \
    \        ^^ no implementation for `&String == String`\n   |\n   = help: the trait\
    \ `PartialEq<String>` is not implemented for `&String`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n\
    \             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc01ppq1y.rs:17:15\n\
    \   |\n14 |     let mut max = String::new();\n   |                   -------------\
    \ expected due to this value\n...\n17 |         max = i as usize;\n   |      \
    \         ^^^^^^^^^^ expected struct `String`, found `usize`\n   |\nhelp: try\
    \ using a conversion method\n   |\n17 |         max = (i as usize).to_string();\n\
    \   |               +          +++++++++++++\n\nerror[E0277]: the trait bound\
    \ `usize: Neg` is not satisfied\n  --> /tmp/tmpc01ppq1y.rs:15:23\n   |\n15 | \
    \    let mut max_idx = -1;\n   |                       ^^ the trait `Neg` is not\
    \ implemented for `usize`\n   |\n   = help: the following other types implement\
    \ trait `Neg`:\n             &f32\n             &f64\n             &i128\n   \
    \          &i16\n             &i32\n             &i64\n             &i8\n    \
    \         &isize\n           and 8 others\n\nerror[E0600]: cannot apply unary\
    \ operator `-` to type `usize`\n  --> /tmp/tmpc01ppq1y.rs:20:19\n   |\n20 |  \
    \   if max_idx == -1 {\n   |                   ^^\n   |                   |\n\
    \   |                   cannot apply unary operator `-`\n   |                \
    \   help: you may have meant the maximum value of `usize`: `usize::MAX`\n   |\n\
    \   = note: unsigned values cannot be negated\n\nerro"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n\n    let longest_len\
    \ = strings[0].chars().count();\n    let mut current_len = longest_len;\n    let\
    \ mut longest_string = String::new();\n    let mut current_string = String::new();\n\
    \    for s in strings {\n        let current_len = s.chars().count();\n\n    \
    \    if longest_len > current_len {\n            current_string = s;\n       \
    \     longest_len = current_len;\n        }\n\n        if longest_len == current_len\
    \ {\n            longest_string = s;\n        }\n    }\n\n    longest_string.to_string()\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9km5uei3.rs:31:5\n   |\n\
    9  | fn longest(strings: Vec<String>) -> Option<String> {\n   |              \
    \                       -------------- expected `Option<String>` because of return\
    \ type\n...\n31 |     longest_string.to_string()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected enum `Option`, found struct `String`\n   |\n   = note: expected enum\
    \ `Option<String>`\n            found struct `String`\nhelp: try wrapping the\
    \ expression in `Some`\n   |\n31 |     Some(longest_string.to_string())\n   |\
    \     +++++                          +\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = String::from(\"\");\n    let mut max_idx = String::from(\"\
    \");\n    for s in strings {\n        let len = s.len();\n        if len > max_len\
    \ {\n            max_len = len;\n            max_idx = s;\n        }\n    }\n\
    \    Some(max_idx)\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpe7lbguft.rs:14:18\n   |\n\
    14 |         if len > max_len {\n   |                  ^^^^^^^ expected `usize`,\
    \ found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpe7lbguft.rs:15:23\n\
    \   |\n10 |     let mut max_len = String::from(\"\");\n   |                  \
    \     ---------------- expected due to this value\n...\n15 |             max_len\
    \ = len;\n   |                       ^^^- help: try using a conversion method:\
    \ `.to_string()`\n   |                       |\n   |                       expected\
    \ struct `String`, found `usize`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = String::MAX;\n    let mut longest_string = None;\n\
    \    for s in strings {\n        if s.len() > max_len {\n            max_len =\
    \ s.len();\n            longest_string = s;\n        }\n    }\n    longest_string\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no associated item named `MAX` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmppw4kp9et.rs:10:31\n   |\n10 |     let mut\
    \ max_len = String::MAX;\n   |                               ^^^ associated item\
    \ not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppw4kp9et.rs:15:30\n\
    \   |\n11 |     let mut longest_string = None;\n   |                         \
    \     ---- expected due to this value\n...\n15 |             longest_string =\
    \ s;\n   |                              ^ expected enum `Option`, found struct\
    \ `String`\n   |\n   = note: expected enum `Option<_>`\n            found struct\
    \ `String`\nhelp: try wrapping the expression in `Some`\n   |\n15 |          \
    \   longest_string = Some(s);\n   |                              +++++ +\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut shortest = String::new();\n    let mut longest = String::new();\n\
    \n    for s in strings {\n        if shortest.len() > s.len() {\n            longest\
    \ = s;\n        }\n\n        if longest.len() < s.len() {\n            shortest\
    \ = s;\n        }\n    }\n\n    if longest.len() == shortest.len() {\n       \
    \ Some(longest)\n    } else {\n        None\n    }\n}\n\nfn main() {\n    let\
    \ candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpchcz_r_x.rs:18:28\n\
    \   |\n13 |     for s in strings {\n   |         -\n   |         |\n   |     \
    \    this reinitialization might get skipped\n   |         move occurs because\
    \ `s` has type `String`, which does not implement the `Copy` trait\n14 |     \
    \    if shortest.len() > s.len() {\n15 |             longest = s;\n   |      \
    \                 - value moved here\n...\n18 |         if longest.len() < s.len()\
    \ {\n   |                            ^^^^^^^ value borrowed here after move\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut string_with_length = String::from(\"~\");\n    let mut longest_len:\
    \ usize = 0;\n    for string in strings {\n        string_with_length += &*string;\n\
    \        let len = string_with_length.len();\n        if len > longest_len {\n\
    \            longest_len = len;\n        }\n    }\n    longest_len\n        .try_clone()\n\
    \        .ok()\n        .and_then(|len| strings.iter().filter(|s| s.len() == len).next())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `try_clone` found for type `usize` in the\
    \ current scope\n  --> /tmp/tmppp0laz7x.rs:20:10\n   |\n20 |         .try_clone()\n\
    \   |          ^^^^^^^^^ help: there is an associated function with a similar\
    \ name: `to_le`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.iter().map(|x| x.len()).max().unwrap_or(None).cloned()\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpx43m939e.rs:10:53\n   |\n\
    10 |     strings.iter().map(|x| x.len()).max().unwrap_or(None).cloned()\n   |\
    \                                                     ^^^^ expected `usize`, found\
    \ enum `Option`\n   |\n   = note: expected type `usize`\n              found enum\
    \ `Option<_>`\n\nerror[E0599]: `usize` is not an iterator\n  --> /tmp/tmpx43m939e.rs:10:59\n\
    \   |\n10 |     strings.iter().map(|x| x.len()).max().unwrap_or(None).cloned()\n\
    \   |                                                           ^^^^^^ `usize`\
    \ is not an iterator\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `usize: Iterator`\n           which is required by `&mut usize: Iterator`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings\n        .iter()\n        .map(|s| {\n            s.chars().max_by(|a,\
    \ b| a.cmp(b))\n        })\n        .next()\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpoq5zfzsi.rs:10:5\n   |\n\
    9  |   fn longest(strings: Vec<String>) -> Option<String> {\n   |            \
    \                           -------------- expected `Option<String>` because of\
    \ return type\n10 | /     strings\n11 | |         .iter()\n12 | |         .map(|s|\
    \ {\n13 | |             s.chars().max_by(|a, b| a.cmp(b))\n14 | |         })\n\
    15 | |         .next()\n   | |_______________^ expected struct `String`, found\
    \ enum `Option`\n   |\n   = note: expected enum `Option<String>`\n           \
    \   found enum `Option<Option<char>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings\n        .iter()\n        .fold(\n            None,\n       \
    \     |mut current, string| {\n                let current_len = current.len();\n\
    \                if string.len() > current_len {\n                    Some(string)\n\
    \                } else {\n                    let mut longest_length = current_len;\n\
    \                    let mut longest_string: String = current;\n             \
    \       strings.iter().for_each(|s| {\n                        if longest_string.length()\
    \ > s {\n                            longest_length = s;\n                   \
    \         longest_string = s;\n                        }\n                   \
    \ });\n                    Some(longest_string)\n                }\n         \
    \   },\n        )\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmp4aicfjer.rs:15:43\n   |\n15 |                 let current_len\
    \ = current.len();\n   |                                           ^^^ method\
    \ not found in `Option<String>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4aicfjer.rs:17:26\n\
    \   |\n17 |                     Some(string)\n   |                          ^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \        |\n   |                          expected struct `String`, found `&String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp4aicfjer.rs:20:54\n   |\n20 |\
    \                     let mut longest_string: String = current;\n   |        \
    \                                     ------   ^^^^^^^ expected struct `String`,\
    \ found enum `Option`\n   |                                             |\n  \
    \ |                                             expected due to this\n   |\n \
    \  = note: expected struct `String`\n                found enum `Option<String>`\n\
    \nerror[E0599]: no method named `length` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp4aicfjer.rs:22:43\n   |\n22 |                         if\
    \ longest_string.length() > s {\n   |                                        \
    \   ^^^^^^ help: there is an associated function with a similar name: `len`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp4aicfjer.rs:23:46\n   |\n19 |  \
    \                   let mut longest_length = current_len;\n   |              \
    \                                ----------- expected due to this value\n...\n\
    23 |                             longest_length = s;\n   |                   \
    \                           ^ expected `usize`, found `&String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp4aicfjer.rs:24:46\n   |\n20 |              \
    \       let mut longest_string: String = current;\n   |                      \
    \                       ------ expected due to this type\n...\n24 |          \
    \                   longest_string = s;\n   |                                \
    \              ^- help: try using a conversion method:"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0];\n    for i in 1..=strings.len() {\n        let len = strings.iter().map(|s|\
    \ s.len()).max().unwrap();\n        if len > longest.len() {\n            longest\
    \ = strings[i];\n        }\n    }\n\n    Some(longest)\n}\n\nfn main() {\n   \
    \ let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmplhqs05md.rs:14:23\n\
    \   |\n14 |     let mut longest = strings[0];\n   |                       ^^^^^^^^^^\n\
    \   |                       |\n   |                       move occurs because\
    \ value has type `String`, which does not implement the `Copy` trait\n   |   \
    \                    help: consider borrowing here: `&strings[0]`\n\nerror[E0507]:\
    \ cannot move out of index of `Vec<String>`\n  --> /tmp/tmplhqs05md.rs:18:23\n\
    \   |\n18 |             longest = strings[i];\n   |                       ^^^^^^^^^^\
    \ move occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0507`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.iter().cloned().enumerate()\n        .filter_map(|(i, s)| {\n\
    \            if i == 0 {\n                // First entry is empty string, so return\
    \ None\n                None\n            } else {\n                let len =\
    \ s.len();\n                if len > strings[i - 1].len() {\n                \
    \    Some(s)\n                } else {\n                    None\n           \
    \     }\n            }\n        })\n        .next()\n        .unwrap_or(None)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpg0yam1ib.rs:25:20\n   |\n\
    25 |         .unwrap_or(None)\n   |                    ^^^^ expected struct `String`,\
    \ found enum `Option`\n   |\n   = note: expected struct `String`\n           \
    \     found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg0yam1ib.rs:10:5\n\
    \   |\n9  |   fn longest(strings: Vec<String>) -> Option<String> {\n   |     \
    \                                  -------------- expected `Option<String>` because\
    \ of return type\n10 | /     strings.iter().cloned().enumerate()\n11 | |     \
    \    .filter_map(|(i, s)| {\n12 | |             if i == 0 {\n13 | |          \
    \       // First entry is empty string, so return None\n...  |\n24 | |       \
    \  .next()\n25 | |         .unwrap_or(None)\n   | |________________________^ expected\
    \ enum `Option`, found struct `String`\n   |\n   = note: expected enum `Option<String>`\n\
    \            found struct `String`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n10 ~     Some(strings.iter().cloned().enumerate()\n11 |         .filter_map(|(i,\
    \ s)| {\n12 |             if i == 0 {\n13 |                 // First entry is\
    \ empty string, so return None\n14 |                 None\n15 |             }\
    \ else {\n ...\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut longest_len\
    \ = String::new();\n    let mut cur = String::new();\n    for s in strings {\n\
    \        if s.len() > longest_len.len() {\n            longest_len = s;\n    \
    \        cur = s;\n        }\n    }\n    Some(cur)\n}\n\nfn main() {\n    let\
    \ candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `s`\n  --> /tmp/tmpxjbirb5z.rs:18:19\n\
    \   |\n15 |     for s in strings {\n   |         - move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n16 |         if s.len()\
    \ > longest_len.len() {\n17 |             longest_len = s;\n   |             \
    \              - value moved here\n18 |             cur = s;\n   |           \
    \        ^ value used here after move\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 101
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut current_max_len = 0;\n    let mut current_best_string = String::from(\"\
    \");\n\n    for s in strings {\n        let len = s.len();\n        if len > current_max_len\
    \ {\n            current_max_len = len;\n            current_best_string = s;\n\
    \        }\n    }\n\n    Some(current_best_string)\n}\n\nfn main() {\n    let\
    \ candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"\")`,\n right: `None`', /tmp/tmp9zsmhsp3.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings\n        .iter()\n        .fold(None, |mut max, s| {\n      \
    \      if *s.len() > *max {\n                *max = *s.len();\n              \
    \  Some(s)\n            } else {\n                None\n            }\n      \
    \  })\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `usize` cannot be dereferenced\n  --> /tmp/tmpk7rhs5ll.rs:13:16\n\
    \   |\n13 |             if *s.len() > *max {\n   |                ^^^^^^^^\n\n\
    error[E0614]: type `Option<String>` cannot be dereferenced\n  --> /tmp/tmpk7rhs5ll.rs:13:27\n\
    \   |\n13 |             if *s.len() > *max {\n   |                           ^^^^\n\
    \nerror[E0614]: type `Option<String>` cannot be dereferenced\n  --> /tmp/tmpk7rhs5ll.rs:14:17\n\
    \   |\n14 |                 *max = *s.len();\n   |                 ^^^^\n\nerror[E0614]:\
    \ type `usize` cannot be dereferenced\n  --> /tmp/tmpk7rhs5ll.rs:14:24\n   |\n\
    14 |                 *max = *s.len();\n   |                        ^^^^^^^^\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpk7rhs5ll.rs:15:22\n   |\n15 |  \
    \               Some(s)\n   |                      ^- help: try using a conversion\
    \ method: `.to_string()`\n   |                      |\n   |                  \
    \    expected struct `String`, found `&String`\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0614.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = 0;\n    for string in strings {\n        if string.len()\
    \ > max_len {\n            max_len = string.len();\n        }\n    }\n    let\
    \ mut best_str = None;\n    for string in strings {\n        if string.len() ==\
    \ max_len {\n            if best_str.is_none() {\n                best_str = Some(string);\n\
    \            } else {\n                if best_str.unwrap().len() < string.len()\
    \ {\n                    best_str = Some(string);\n                }\n       \
    \     }\n        }\n    }\n    match best_str {\n        Some(s) => s,\n     \
    \   None => None,\n    }\n}\n\nfn main() {\n    let candidate = longest;\n   \
    \ assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4zks9w6o.rs:29:20\n   |\n\
    9  | fn longest(strings: Vec<String>) -> Option<String> {\n   |              \
    \                       -------------- expected `Option<String>` because of return\
    \ type\n...\n29 |         Some(s) => s,\n   |                    ^ expected enum\
    \ `Option`, found struct `String`\n   |\n   = note: expected enum `Option<String>`\n\
    \            found struct `String`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n29 |         Some(s) => Some(s),\n   |                    +++++ +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings\n        .iter()\n        .fold(None, |longest, s| longest.max_by(|a,\
    \ b| a.len().cmp(&b.len()).unwrap()).unwrap())\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `Option<String>` is not an iterator\n   --> /tmp/tmpmz19ekhh.rs:12:42\n\
    \    |\n12  |           .fold(None, |longest, s| longest.max_by(|a, b| a.len().cmp(&b.len()).unwrap()).unwrap())\n\
    \    |                                            ^^^^^^ `Option<String>` is not\
    \ an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Option<String>: Iterator`\n            which is required by `&mut\
    \ Option<String>: Iterator`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = String::new();\n    let mut max_len_len = String::new();\n\
    \    for s in strings {\n        let len = s.len();\n        if len > max_len.len()\
    \ {\n            max_len = s;\n            max_len_len = len;\n        }\n   \
    \ }\n    if max_len.len() == 0 {\n        return None;\n    }\n    if max_len_len\
    \ == max_len.len() {\n        return Some(max_len);\n    }\n    Some(String::from(max_len))\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0xa1j4ze.rs:16:27\n   |\n\
    11 |     let mut max_len_len = String::new();\n   |                          \
    \ ------------- expected due to this value\n...\n16 |             max_len_len\
    \ = len;\n   |                           ^^^- help: try using a conversion method:\
    \ `.to_string()`\n   |                           |\n   |                     \
    \      expected struct `String`, found `usize`\n\nerror[E0277]: can't compare\
    \ `String` with `usize`\n  --> /tmp/tmp0xa1j4ze.rs:22:20\n   |\n22 |     if max_len_len\
    \ == max_len.len() {\n   |                    ^^ no implementation for `String\
    \ == usize`\n   |\n   = help: the trait `PartialEq<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.iter().max_by(|a, b| a.len() as i32.CompareTo(b.len() as i32))\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error: casts cannot be followed by a method call\n  --> /tmp/tmpn7qmwglf.rs:10:34\n\
    \   |\n10 |     strings.iter().max_by(|a, b| a.len() as i32.CompareTo(b.len()\
    \ as i32))\n   |                                  ^^^^^^^^^^^^^^\n   |\nhelp:\
    \ try surrounding the expression in parentheses\n   |\n10 |     strings.iter().max_by(|a,\
    \ b| (a.len() as i32).CompareTo(b.len() as i32))\n   |                       \
    \           +              +\n\nerror[E0599]: no method named `CompareTo` found\
    \ for type `i32` in the current scope\n  --> /tmp/tmpn7qmwglf.rs:10:49\n   |\n\
    10 |     strings.iter().max_by(|a, b| a.len() as i32.CompareTo(b.len() as i32))\n\
    \   |                                                 ^^^^^^^^^ method not found\
    \ in `i32`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn7qmwglf.rs:10:5\n\
    \   |\n9  | fn longest(strings: Vec<String>) -> Option<String> {\n   |       \
    \                              -------------- expected `Option<String>` because\
    \ of return type\n10 |     strings.iter().max_by(|a, b| a.len() as i32.CompareTo(b.len()\
    \ as i32))\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&String`\n   |\n   = note: expected enum `Option<String>`\n\
    \              found enum `Option<&String>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut len = String::new();\n    for s in strings {\n        len.push_str(&s);\n\
    \    }\n    let mut max = String::new();\n    let mut i = 0;\n    while i < len.len()\
    \ {\n        if len[i..].len() > max.len() {\n            max = len[i..];\n  \
    \      }\n        i += 1;\n    }\n    if !strings.is_empty() && len.len() > max.len()\
    \ {\n        None\n    } else {\n        Some(max)\n    }\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdtx1zmmf.rs:18:19\n   |\n\
    14 |     let mut max = String::new();\n   |                   ------------- expected\
    \ due to this value\n...\n18 |             max = len[i..];\n   |             \
    \      ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |   \
    \                |\n   |                   expected struct `String`, found `str`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n\n    let mut current_max\
    \ = String::new();\n\n    for s in strings {\n        let len = s.len();\n   \
    \     if len > current_max.len() {\n            current_max = s;\n        }\n\
    \    }\n\n    Some(current_max)\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings\n        .iter()\n        .scan(\n            (None, None),\n\
    \            |(mut max_len, (i, _))| {\n                if *i >= *max_len {\n\
    \                    (*max_len, i)\n                } else {\n               \
    \     (*max_len, None)\n                }\n            },\n        )\n       \
    \ .next()\n        .map(|(a, b)| {\n            strings[a]\n        })\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0593]: closure is expected to take 2 distinct arguments, but it\
    \ takes a single 2-tuple as argument\n  --> /tmp/tmp_w841geg.rs:12:10\n   |\n\
    12 |         .scan(\n   |          ^^^^ expected closure that takes 2 distinct\
    \ arguments\n13 |             (None, None),\n14 |             |(mut max_len, (i,\
    \ _))| {\n   |             ----------------------- takes a single 2-tuple as argument\n\
    \   |\nhelp: change the closure to take multiple arguments instead of a single\
    \ tuple\n   |\n14 |             |mut max_len, (i, _)| {\n   |             ~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0593`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n\n    let mut max_length\
    \ = 0;\n    let mut longest_string = None;\n\n    for (i, s) in strings.iter().enumerate()\
    \ {\n        max_length = if s.len() > max_length {\n            s.len()\n   \
    \     } else {\n            max_length\n        };\n\n        if i == 0 {\n  \
    \          longest_string = Some(s);\n        }\n    }\n\n    longest_string\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwcks658u.rs:29:5\n   |\n\
    9  | fn longest(strings: Vec<String>) -> Option<String> {\n   |              \
    \                       -------------- expected `Option<String>` because of return\
    \ type\n...\n29 |     longest_string\n   |     ^^^^^^^^^^^^^^ expected struct\
    \ `String`, found `&String`\n   |\n   = note: expected enum `Option<String>`\n\
    \              found enum `Option<&String>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.iter().cloned().map(|s| {\n        s.chars().max(|a, b| a.cmp(b)).unwrap_or_else(||\
    \ String::new())\n    }).next()\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmp4vty_5au.rs:11:24\n\
    \   |\n11 |         s.chars().max(|a, b| a.cmp(b)).unwrap_or_else(|| String::new())\n\
    \   |                        ^ consider giving this closure parameter a type\n\
    \   |\n   = note: type must be known at this point\n\nerror[E0061]: this function\
    \ takes 0 arguments but 1 argument was supplied\n    --> /tmp/tmp4vty_5au.rs:11:19\n\
    \     |\n11   |         s.chars().max(|a, b| a.cmp(b)).unwrap_or_else(|| String::new())\n\
    \     |                   ^^^ --------------- supplied 1 argument\n     |    \
    \               |\n     |                   expected 0 arguments\n     |\nnote:\
    \ associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4vty_5au.rs:11:58\n\
    \   |\n11 |         s.chars().max(|a, b| a.cmp(b)).unwrap_or_else(|| String::new())\n\
    \   |                                                          ^^^^^^^^^^^^^ expected\
    \ `char`, found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4vty_5au.rs:10:5\n\
    \   |\n9  |   fn longest(strings: Vec<String>) -> Option<String> {\n   |     \
    \                                  -------------- expected `Option<String>` because\
    \ of return type\n10 | /     strings.iter().cloned().map(|s| {\n11 | |       \
    \  s.chars().max(|a, b| a.cmp(b)).unwrap_or_else(|| String::new())\n12 | |   \
    \  }).next()\n   | |_____________^ expected struct `String`, found `char`\n  \
    \ |\n   = note: expected enum `Option<String>`\n              found enum `Option<char>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0282, E0308.\nFor more information about an error, try `rustc --explain\
    \ E0061`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n\n    let mut best_len\
    \ = String::new();\n    let mut best_str = String::new();\n\n    for s in strings\
    \ {\n        if s.len() < best_len.len() {\n            best_len = s;\n      \
    \      best_str = s;\n        }\n    }\n\n    if best_len.len() == strings[0].len()\
    \ {\n        return None;\n    }\n\n    Some(best_str)\n}\n\nfn main() {\n   \
    \ let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `s`\n  --> /tmp/tmp7p_2jdu9.rs:20:24\n\
    \   |\n17 |     for s in strings {\n   |         - move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n18 |         if s.len()\
    \ < best_len.len() {\n19 |             best_len = s;\n   |                   \
    \     - value moved here\n20 |             best_str = s;\n   |               \
    \         ^ value used here after move\n\nerror[E0382]: borrow of moved value:\
    \ `strings`\n   --> /tmp/tmp7p_2jdu9.rs:24:26\n    |\n9   | fn longest(strings:\
    \ Vec<String>) -> Option<String> {\n    |            ------- move occurs because\
    \ `strings` has type `Vec<String>`, which does not implement the `Copy` trait\n\
    ...\n17  |     for s in strings {\n    |              ------- `strings` moved\
    \ due to this implicit call to `.into_iter()`\n...\n24  |     if best_len.len()\
    \ == strings[0].len() {\n    |                          ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `strings`\nhelp: consider iterating over a slice of the\
    \ `Vec<String>`'s content to avoid moving into the `for` loop\n    |\n17  |  \
    \   for s in &strings {\n    |              +\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.iter().cloned().enumerate().filter_map(|(i, s)| (*s).len() >\
    \ i).max().ok()\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4j2ogq4b.rs:10:61\n   |\n\
    9  | fn longest(strings: Vec<String>) -> Option<String> {\n   |              \
    \                       -------------- expected `Option<_>` because of return\
    \ type\n10 |     strings.iter().cloned().enumerate().filter_map(|(i, s)| (*s).len()\
    \ > i).max().ok()\n   |                                                      \
    \       ^^^^^^^^^^^^^^ expected enum `Option`, found `bool`\n   |\n   = note:\
    \ expected enum `Option<_>`\n              found type `bool`\nhelp: try wrapping\
    \ the expression in `Some`\n   |\n10 |     strings.iter().cloned().enumerate().filter_map(|(i,\
    \ s)| Some((*s).len() > i)).max().ok()\n   |                                 \
    \                            +++++              +\n\nerror[E0599]: no method named\
    \ `ok` found for enum `Option` in the current scope\n  --> /tmp/tmp4j2ogq4b.rs:10:83\n\
    \   |\n10 |     strings.iter().cloned().enumerate().filter_map(|(i, s)| (*s).len()\
    \ > i).max().ok()\n   |                                                      \
    \                             ^^ help: there is an associated function with a\
    \ similar name: `or`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut strings_iter\
    \ = strings.iter();\n    let mut longest_len = std::cmp::max::<usize>(&mut strings_iter,\
    \ |a, b| b.cmp(a).unwrap_or(0));\n    let mut current_len = longest_len;\n   \
    \ let mut current_str = strings_iter.next();\n    while current_str.map(|s| s.len()).unwrap_or(0)\
    \ > current_len {\n        if longest_len > current_len {\n            return\
    \ current_str;\n        }\n        if current_len == longest_len {\n         \
    \   current_len = longest_len + 1;\n        }\n        longest_len += 1;\n   \
    \     current_str = strings_iter.next();\n    }\n    None\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0cp4glmh.rs:14:50\n   |\n\
    14 |     let mut longest_len = std::cmp::max::<usize>(&mut strings_iter, |a, b|\
    \ b.cmp(a).unwrap_or(0));\n   |                                              \
    \    ^^^^^^^^^^^^^^^^^ expected `usize`, found mutable reference\n   |\n   = note:\
    \           expected type `usize`\n           found mutable reference `&mut std::slice::Iter<'_,\
    \ String>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0cp4glmh.rs:19:20\n\
    \   |\n19 |             return current_str;\n   |                    ^^^^^^^^^^^\
    \ expected struct `String`, found `&String`\n   |\n   = note: expected enum `Option<String>`\n\
    \              found enum `Option<&String>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n\n    let mut lengths:\
    \ Vec<usize> = strings\n        .iter()\n        .map(|s| s.chars().count())\n\
    \        .collect();\n    lengths.sort();\n    if lengths.len() > 1 {\n      \
    \  lengths.reverse();\n    }\n    let mut longest = &strings[lengths.iter().rev().next().unwrap()];\n\
    \    for length in lengths {\n        if lengths[length] < longest.chars().count()\
    \ {\n            longest = &strings[lengths.iter().rev().next().unwrap()];\n \
    \       }\n    }\n\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[String]` cannot be indexed by `&usize`\n  -->\
    \ /tmp/tmpuwu3dp29.rs:22:24\n   |\n22 |     let mut longest = &strings[lengths.iter().rev().next().unwrap()];\n\
    \   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[String]>` is not implemented for `&usize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<&usize>` for `Vec<String>`\n\nerror[E0277]:\
    \ the type `[String]` cannot be indexed by `&usize`\n  --> /tmp/tmpuwu3dp29.rs:25:24\n\
    \   |\n25 |             longest = &strings[lengths.iter().rev().next().unwrap()];\n\
    \   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[String]>` is not implemented for `&usize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<&usize>` for `Vec<String>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = String::new();\n    for s in strings {\n        let\
    \ len = s.len();\n        if len > max_len.len() {\n            max_len = len;\n\
    \        }\n    }\n    if strings.is_empty() {\n        None\n    } else {\n \
    \       Some(max_len)\n    }\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpm8di5ntz.rs:14:23\n   |\n\
    10 |     let mut max_len = String::new();\n   |                       -------------\
    \ expected due to this value\n...\n14 |             max_len = len;\n   |     \
    \                  ^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                       |\n   |                       expected struct `String`,\
    \ found `usize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings\n        .into_iter()\n        .fold(None, |acc, x| {\n     \
    \       if acc.is_none() {\n                return Some(x);\n            } else\
    \ if acc.unwrap().len() < x.length() {\n                Some(acc.unwrap())\n \
    \           } else {\n                None\n            }\n        })\n}\n\nfn\
    \ main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp5ivoqcul.rs:15:46\n   |\n15 |             } else\
    \ if acc.unwrap().len() < x.length() {\n   |                                 \
    \             ^^^^^^ help: there is an associated function with a similar name:\
    \ `len`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = -1;\n    for string in strings {\n        let len =\
    \ string.length();\n        if len > max_len {\n            max_len = len;\n \
    \       }\n    }\n    if max_len < 1 {\n        return None;\n    }\n    strings.iter().fold(None,\
    \ |maxstr, &str| {\n        if str.length() > maxstr.length() {\n            maxstr\n\
    \        } else {\n            str\n        }\n    })\n}\n\nfn main() {\n    let\
    \ candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp2u80d7yt.rs:12:26\n   |\n12 |         let len =\
    \ string.length();\n   |                          ^^^^^^ help: there is an associated\
    \ function with a similar name: `len`\n\nerror[E0599]: no method named `length`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmp2u80d7yt.rs:21:16\n\
    \   |\n21 |         if str.length() > maxstr.length() {\n   |                ^^^^^^\
    \ help: there is an associated function with a similar name: `len`\n\nerror[E0599]:\
    \ no method named `length` found for enum `Option` in the current scope\n  -->\
    \ /tmp/tmp2u80d7yt.rs:21:34\n   |\n21 |         if str.length() > maxstr.length()\
    \ {\n   |                                  ^^^^^^ method not found in `Option<String>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp2u80d7yt.rs:24:13\n   |\n24 |\
    \             str\n   |             ^^^ expected enum `Option`, found struct `String`\n\
    \   |\n   = note: expected enum `Option<String>`\n            found struct `String`\n\
    help: try wrapping the expression in `Some`\n   |\n24 |             Some(str)\n\
    \   |             +++++   +\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings\n        .iter()\n        .map(|s| s.len())\n        .max()\n\
    \        .cloned()\n        .ok()\n        .and_then(|s| strings.iter().position(|x|\
    \ x.len() == s))\n        .unwrap_or(None)\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `Option<usize>` is not an iterator\n   --> /tmp/tmpyd24m3eg.rs:14:10\n\
    \    |\n14  |           .cloned()\n    |            ^^^^^^ `Option<usize>` is\
    \ not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Option<usize>: Iterator`\n            which is required by `&mut\
    \ Option<usize>: Iterator`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings\n        .iter()\n        .map(|s| {\n            let mut min_len\
    \ = std::cmp::Ordering::Less;\n            let mut min_s = String::<Latin1>::new();\n\
    \            for c in &s {\n                let c_len = c.len_utf8();\n      \
    \          if c_len < min_len {\n                    min_len = c_len;\n      \
    \              min_s = c;\n                }\n            }\n            min_s\n\
    \        })\n        .max_by_key(|s| s.len_utf8())\n}\n\nfn main() {\n    let\
    \ candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `Latin1` in this scope\n  --> /tmp/tmpypu6ndbv.rs:14:38\n\
    \   |\n9  | fn longest(strings: Vec<String>) -> Option<String> {\n   |       \
    \    - help: you might be missing a type parameter: `<Latin1>`\n...\n14 |    \
    \         let mut min_s = String::<Latin1>::new();\n   |                     \
    \                 ^^^^^^ not found in this scope\n\nerror[E0107]: this struct\
    \ takes 0 generic arguments but 1 generic argument was supplied\n  --> /tmp/tmpypu6ndbv.rs:14:29\n\
    \   |\n14 |             let mut min_s = String::<Latin1>::new();\n   |       \
    \                      ^^^^^^---------- help: remove these generics\n   |    \
    \                         |\n   |                             expected 0 generic\
    \ arguments\n\nerror[E0277]: `&&String` is not an iterator\n  --> /tmp/tmpypu6ndbv.rs:15:22\n\
    \   |\n15 |             for c in &s {\n   |                      ^^ `&&String`\
    \ is not an iterator\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `&&String`\n   = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&&String`\n\nerror[E0599]: no method named `len_utf8`\
    \ found for reference `&String` in the current scope\n  --> /tmp/tmpypu6ndbv.rs:24:27\n\
    \   |\n24 |         .max_by_key(|s| s.len_utf8())\n   |                      \
    \     ^^^^^^^^ method not found in `&String`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0107, E0277, E0412, E0599.\n\
    For more information about an error, try `rustc --explain E0107`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.iter().max_by(|a, b| a.len() as u32).map(|s| s)\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp76_btmih.rs:10:34\n   |\n\
    10 |     strings.iter().max_by(|a, b| a.len() as u32).map(|s| s)\n   |       \
    \                           ^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`,\
    \ found `u32`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp76_btmih.rs:10:5\n\
    \   |\n9  | fn longest(strings: Vec<String>) -> Option<String> {\n   |       \
    \                              -------------- expected `Option<String>` because\
    \ of return type\n10 |     strings.iter().max_by(|a, b| a.len() as u32).map(|s|\
    \ s)\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `String`, found `&String`\n   |\n   = note: expected enum `Option<String>`\n\
    \              found enum `Option<&String>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n\n    let mut max_len\
    \ = strings[0].len();\n    for s in strings {\n        if max_len > s.len() {\n\
    \            max_len = s.len();\n        }\n    }\n\n    if max_len == 0 {\n \
    \       return None;\n    }\n\n    Some(strings.iter().find(|s| s.len() == max_len).unwrap())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1bm428x_.rs:25:10\n   |\n\
    25 |     Some(strings.iter().find(|s| s.len() == max_len).unwrap())\n   |    \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a\
    \ conversion method: `.to_string()`\n   |          |\n   |          expected struct\
    \ `String`, found `&String`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut max\
    \ = String::new();\n    for s in strings {\n        let len = s.len();\n     \
    \   if len > max.len() {\n            max = s;\n        }\n    }\n    Some(max)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976609
- exit_code: 101
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.iter().max().cloned()\n}\n\nfn main() {\n    let candidate =\
    \ longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmpkrjv9r2i.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings\n        .into_iter()\n        .enumerate()\n        .filter_map(|(i,\
    \ str)| (str.len(), i))\n        .max()\n        .map(|(len, _)| strings.iter().map(|s|\
    \ s.len()).sum::<usize>().unwrap())\n        .and_then(|len| strings.iter().take(len).max())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpg33jcgga.rs:13:32\n   |\n\
    9  | fn longest(strings: Vec<String>) -> Option<String> {\n   |              \
    \                       -------------- expected `Option<_>` because of return\
    \ type\n...\n13 |         .filter_map(|(i, str)| (str.len(), i))\n   |       \
    \                         ^^^^^^^^^^^^^^ expected enum `Option`, found tuple\n\
    \   |\n   = note: expected enum `Option<_>`\n             found tuple `(usize,\
    \ usize)`\nhelp: try wrapping the expression in `Some`\n   |\n13 |         .filter_map(|(i,\
    \ str)| Some((str.len(), i)))\n   |                                +++++     \
    \         +\n\nerror[E0599]: no method named `unwrap` found for type `usize` in\
    \ the current scope\n  --> /tmp/tmpg33jcgga.rs:15:72\n   |\n15 |         .map(|(len,\
    \ _)| strings.iter().map(|s| s.len()).sum::<usize>().unwrap())\n   |         \
    \                                                               ^^^^^^ method\
    \ not found in `usize`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = String::empty();\n\n    for &s in strings {\n     \
    \   if longest.len() < s.len() {\n            longest = s;\n        }\n    }\n\
    \n    longest.ok()\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no function or associated item named `empty` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmp0yaqc1xd.rs:10:31\n   |\n10 | \
    \    let mut longest = String::empty();\n   |                               ^^^^^\n\
    \   |                               |\n   |                               function\
    \ or associated item not found in `String`\n   |                             \
    \  help: there is an associated function with a similar name: `is_empty`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp0yaqc1xd.rs:12:9\n   |\n12 |     for &s in strings\
    \ {\n   |         ^^    ------- this expression has type `Option<String>`\n  \
    \ |         |\n   |         expected struct `String`, found reference\n   |  \
    \       help: you can probably remove the explicit borrow: `s`\n   |\n   = note:\
    \ expected struct `String`\n           found reference `&_`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest_len = std::i32::MAX;\n    let mut max_str = None;\n \
    \   for s in strings {\n        if s.len() > longest_len {\n            longest_len\
    \ = s.len();\n            max_str = Some(s);\n        }\n    }\n    max_str\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp681wjuoq.rs:13:22\n   |\n\
    13 |         if s.len() > longest_len {\n   |                      ^^^^^^^^^^^\
    \ expected `usize`, found `i32`\n   |\nhelp: you can convert an `i32` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n13 |         if s.len()\
    \ > longest_len.try_into().unwrap() {\n   |                                 ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp681wjuoq.rs:14:27\n   |\n10 |\
    \     let mut longest_len = std::i32::MAX;\n   |                           -------------\
    \ expected due to this value\n...\n14 |             longest_len = s.len();\n \
    \  |                           ^^^^^^^ expected `i32`, found `usize`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut strings\
    \ = strings.clone();\n    let mut longest_length = 0;\n    let mut longest_string\
    \ = strings[0];\n    for string in strings.iter() {\n        if string.length()\
    \ > longest_length {\n            longest_string = string;\n            longest_length\
    \ = string.length();\n        }\n    }\n    longest_string\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for reference `&String` in\
    \ the current scope\n  --> /tmp/tmpqpl5o_n1.rs:17:19\n   |\n17 |         if string.length()\
    \ > longest_length {\n   |                   ^^^^^^ help: there is an associated\
    \ function with a similar name: `len`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpqpl5o_n1.rs:18:30\n   |\n15 |     let mut longest_string = strings[0];\n\
    \   |                              ---------- expected due to this value\n...\n\
    18 |             longest_string = string;\n   |                              ^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \            |\n   |                              expected struct `String`, found\
    \ `&String`\n\nerror[E0599]: no method named `length` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpqpl5o_n1.rs:19:37\n   |\n19 |          \
    \   longest_length = string.length();\n   |                                  \
    \   ^^^^^^ help: there is an associated function with a similar name: `len`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpqpl5o_n1.rs:22:5\n   |\n9  | fn\
    \ longest(strings: Vec<String>) -> Option<String> {\n   |                    \
    \                 -------------- expected `Option<String>` because of return type\n\
    ...\n22 |     longest_string\n   |     ^^^^^^^^^^^^^^ expected enum `Option`,\
    \ found struct `String`\n   |\n   = note: expected enum `Option<String>`\n   \
    \         found struct `String`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n22 |     Some(longest_string)\n   |     +++++              +\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = String::new();\n    for s in strings.iter() {\n        if longest != s.len()\
    \ {\n            longest = s;\n        }\n    }\n\n    Some(longest)\n}\n\nfn\
    \ main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjzfae9pi.rs:17:23\n   |\n\
    14 |     let mut longest = String::new();\n   |                       -------------\
    \ expected due to this value\n...\n17 |             longest = s;\n   |       \
    \                ^- help: try using a conversion method: `.to_string()`\n   |\
    \                       |\n   |                       expected struct `String`,\
    \ found `&String`\n\nerror[E0277]: can't compare `String` with `usize`\n  -->\
    \ /tmp/tmpjzfae9pi.rs:16:20\n   |\n16 |         if longest != s.len() {\n   |\
    \                    ^^ no implementation for `String == usize`\n   |\n   = help:\
    \ the trait `PartialEq<usize>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `PartialEq<Rhs>`:\n             <&'a str\
    \ as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n     \
    \        <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings\n        .iter()\n        .windows(2)\n        .map(|s| s.len())\n\
    \        .max()\n        .unwrap_or(0)\n}\n\nfn main() {\n    let candidate =\
    \ longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `windows` found for struct `std::slice::Iter`\
    \ in the current scope\n  --> /tmp/tmp7ozn3_xh.rs:12:10\n   |\n12 |         .windows(2)\n\
    \   |          ^^^^^^^ method not found in `std::slice::Iter<'_, String>`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings\n        .into_iter()\n        .map(|s| s.len())\n        .max()\n\
    \        .cloned()\n        .ok_or(std::str::empty())\n}\n\nfn main() {\n    let\
    \ candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `empty` in module `std::str`\n  -->\
    \ /tmp/tmp9zgw_fdo.rs:15:26\n   |\n15 |         .ok_or(std::str::empty())\n  \
    \ |                          ^^^^^ not found in `std::str`\n   |\nhelp: consider\
    \ importing one of these items\n   |\n1  | use std::io::empty;\n   |\n1  | use\
    \ std::iter::empty;\n   |\nhelp: if you import `empty`, refer to it directly\n\
    \   |\n15 -         .ok_or(std::str::empty())\n15 +         .ok_or(empty())\n\
    \   | \n\nerror[E0599]: `Option<usize>` is not an iterator\n   --> /tmp/tmp9zgw_fdo.rs:14:10\n\
    \    |\n14  |           .cloned()\n    |            ^^^^^^ `Option<usize>` is\
    \ not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Option<usize>: Iterator`\n            which is required by `&mut\
    \ Option<usize>: Iterator`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0425, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings\n        .into_iter()\n        .map(|s| s.chars().count())\n\
    \        .max()\n        .map(|i| strings[i as usize])\n}\n\nfn main() {\n   \
    \ let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpijvzcmes.rs:14:18\n\
    \   |\n14 |         .map(|i| strings[i as usize])\n   |                  ^^^^^^^^^^^^^^^^^^^\
    \ move occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror[E0382]: borrow of moved value: `strings`\n   --> /tmp/tmpijvzcmes.rs:14:14\n\
    \    |\n9   | fn longest(strings: Vec<String>) -> Option<String> {\n    |    \
    \        ------- move occurs because `strings` has type `Vec<String>`, which does\
    \ not implement the `Copy` trait\n10  |     strings\n11  |         .into_iter()\n\
    \    |          ----------- `strings` moved due to this method call\n...\n14 \
    \ |         .map(|i| strings[i as usize])\n    |              ^^^ ------- borrow\
    \ occurs due to use in closure\n    |              |\n    |              value\
    \ borrowed here after move\n    |\nnote: this function takes ownership of the\
    \ receiver `self`, which moves `strings`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0382, E0507.\nFor more information\
    \ about an error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings\n        .into_iter()\n        .enumerate()\n        .max()\n\
    \        .map(|(i, s)| {\n            format!(\"{}\", s)\n        })\n       \
    \ .next()\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `next` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmpezug5l6l.rs:17:10\n   |\n17 |         .next()\n   |   \
    \       ^^^^ method not found in `Option<String>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut longest\
    \ = strings[0];\n    for string in strings.iter().rev() {\n        let len = string.len();\n\
    \        if len > longest.len() {\n            longest = string;\n        }\n\
    \    }\n    Some(longest)\n}\n\nfn main() {\n    let candidate = longest;\n  \
    \  assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpa7vhu3wr.rs:17:23\n   |\n\
    13 |     let mut longest = strings[0];\n   |                       ----------\
    \ expected due to this value\n...\n17 |             longest = string;\n   |  \
    \                     ^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                       |\n   |                       expected struct `String`,\
    \ found `&String`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings\n        .into_iter()\n        .chain(\n            strings\n\
    \                .iter()\n                .enumerate()\n                .filter_map(|(i,\
    \ &s)| {\n                    if i == 0 || s.len() > strings[i - 1]().len() {\n\
    \                        Some(s)\n                    } else {\n             \
    \           None\n                    }\n                }),\n        )\n    \
    \    .max_by(|a, b| a.len().cmp(&b.len()).reverse().unwrap_or(0))\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0618]: expected function, found `String`\n  --> /tmp/tmp41rgo6cq.rs:17:44\n\
    \   |\n17 |                     if i == 0 || s.len() > strings[i - 1]().len()\
    \ {\n   |                                            ^^^^^^^^^^^^^^--\n   |  \
    \                                          |\n   |                           \
    \                 call expression requires function\n\nerror[E0599]: no method\
    \ named `unwrap_or` found for enum `std::cmp::Ordering` in the current scope\n\
    \  --> /tmp/tmp41rgo6cq.rs:24:56\n   |\n24 |         .max_by(|a, b| a.len().cmp(&b.len()).reverse().unwrap_or(0))\n\
    \   |                                                        ^^^^^^^^^ method\
    \ not found in `std::cmp::Ordering`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0599, E0618.\nFor more information\
    \ about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_length = String::new();\n    for s in strings {\n       \
    \ if s.len() > max_length.len() {\n            max_length = s;\n        }\n  \
    \  }\n    max_length.cloned()\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `String` is not an iterator\n   --> /tmp/tmp7ye9elof.rs:16:16\n\
    \    |\n16  |       max_length.cloned()\n    |                  ^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = note:\
    \ the following trait bounds were not satisfied:\n            `String: Iterator`\n\
    \            which is required by `&mut String: Iterator`\n            `str: Iterator`\n\
    \            which is required by `&mut str: Iterator`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings\n        .iter()\n        .fold(Some(\"\"), |mut acc, str| {\n\
    \            if acc.len() < str.len() {\n                acc = Some(str);\n  \
    \          }\n            acc\n        })\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp831d07w0.rs:12:20\n   |\n\
    12 |         .fold(Some(\"\"), |mut acc, str| {\n   |                    ^^- help:\
    \ try using a conversion method: `.to_string()`\n   |                    |\n \
    \  |                    expected struct `String`, found `&str`\n\nerror[E0599]:\
    \ no method named `len` found for enum `Option` in the current scope\n  --> /tmp/tmp831d07w0.rs:13:20\n\
    \   |\n13 |             if acc.len() < str.len() {\n   |                    ^^^\
    \ method not found in `Option<String>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp831d07w0.rs:14:28\n   |\n14 |                 acc = Some(str);\n   |\
    \                            ^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                            |\n   |                            expected struct\
    \ `String`, found `&String`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.iter().fold(\n        None,\n        |maxlen, _, item| {\n  \
    \          if item.len() >= *maxlen {\n                Some(item)\n          \
    \  } else {\n                *maxlen = item.len();\n                Some(item)\n\
    \            }\n        },\n    )\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0593]: closure is expected to take 2 arguments, but it takes 3 arguments\n\
    \  --> /tmp/tmpbrxdezy9.rs:10:20\n   |\n10 |     strings.iter().fold(\n   |  \
    \                  ^^^^ expected closure that takes 2 arguments\n11 |        \
    \ None,\n12 |         |maxlen, _, item| {\n   |         ----------------- takes\
    \ 3 arguments\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0593`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.iter().max_by_key(|s| s.len()).ok()\n}\n\nfn main() {\n    let\
    \ candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `ok` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmplxqe0k4e.rs:10:44\n   |\n10 |     strings.iter().max_by_key(|s|\
    \ s.len()).ok()\n   |                                            ^^ help: there\
    \ is an associated function with a similar name: `or`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = std::cmp::max::<usize>();\n    let mut max_index =\
    \ -1;\n\n    for index in 0..strings[0].len() {\n        let mut this_len = strings[0].chars().filter(|c|\
    \ c.is_ascii()).count();\n\n        if this_len > max_len {\n            max_len\
    \ = this_len;\n            max_index = index;\n        }\n\n        for (index,\
    \ s) in strings.iter().enumerate() {\n            let this_len = s.chars().filter(|c|\
    \ c.is_ascii()).count();\n\n            if this_len > max_len {\n            \
    \    max_len = this_len;\n                max_index = index;\n            }\n\
    \        }\n    }\n\n    if strings[max_index].len() == max_len {\n        return\
    \ None;\n    }\n\n    Some(strings[max_index])\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 2 arguments but 0 arguments were supplied\n\
    \    --> /tmp/tmp1clnjrew.rs:10:23\n     |\n10   |     let mut max_len = std::cmp::max::<usize>();\n\
    \     |                       ^^^^^^^^^^^^^^^^^^^^^^-- supplied 0 arguments\n\
    \     |                       |\n     |                       expected 2 arguments\n\
    \     |\nnote: function defined here\n\nerror[E0277]: the trait bound `usize:\
    \ Neg` is not satisfied\n  --> /tmp/tmp1clnjrew.rs:11:25\n   |\n11 |     let mut\
    \ max_index = -1;\n   |                         ^^ the trait `Neg` is not implemented\
    \ for `usize`\n   |\n   = help: the following other types implement trait `Neg`:\n\
    \             &f32\n             &f64\n             &i128\n             &i16\n\
    \             &i32\n             &i64\n             &i8\n             &isize\n\
    \           and 8 others\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0061, E0277.\nFor more information about an error,\
    \ try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings\n        .iter()\n        .max_by(|a, b| a.len() as usize - b.len()\
    \ as usize)\n        .cloned()\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplcrey7ge.rs:12:24\n   |\n\
    12 |         .max_by(|a, b| a.len() as usize - b.len() as usize)\n   |       \
    \                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`,\
    \ found `usize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.iter().map(|s| s.len()).max().ok()\n}\n\nfn main() {\n    let\
    \ candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `ok` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmpw4o0i8ha.rs:10:43\n   |\n10 |     strings.iter().map(|s|\
    \ s.len()).max().ok()\n   |                                           ^^ help:\
    \ there is an associated function with a similar name: `or`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings\n        .iter()\n        .map(|s| s.len().max(s))\n        .max_by(|a,\
    \ b| a.cmp(b).unwrap_or(0))\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwjrky9_o.rs:12:30\n   |\n\
    12 |         .map(|s| s.len().max(s))\n   |                              ^ expected\
    \ `usize`, found `&String`\n\nerror[E0599]: no method named `unwrap_or` found\
    \ for enum `std::cmp::Ordering` in the current scope\n  --> /tmp/tmpwjrky9_o.rs:13:33\n\
    \   |\n13 |         .max_by(|a, b| a.cmp(b).unwrap_or(0))\n   |              \
    \                   ^^^^^^^^^ method not found in `std::cmp::Ordering`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpwjrky9_o.rs:10:5\n   |\n9  |   fn longest(strings:\
    \ Vec<String>) -> Option<String> {\n   |                                     \
    \  -------------- expected `Option<String>` because of return type\n10 | /   \
    \  strings\n11 | |         .iter()\n12 | |         .map(|s| s.len().max(s))\n\
    13 | |         .max_by(|a, b| a.cmp(b).unwrap_or(0))\n   | |_____________________________________________^\
    \ expected struct `String`, found `usize`\n   |\n   = note: expected enum `Option<String>`\n\
    \              found enum `Option<usize>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut lens\
    \ = HashMap::<i32, usize>::new();\n    for string in strings {\n        if let\
    \ Some(mut len) = lens.get(string) {\n            len += 1;\n        }\n     \
    \   else {\n            lens.insert(string.len(), 1);\n        }\n    }\n    let\
    \ mut max: usize = 0;\n    for (len, count) in lens.iter() {\n        if count\
    \ > max {\n            max = count;\n        }\n    }\n    strings.iter().max().map(|s|\
    \ s.len()).unwrap_or(max)\n}\n\nfn main() {\n    let candidate = longest;\n  \
    \  assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpk_sfux8g.rs:13:20\n   |\n13 |     let mut lens = HashMap::<i32, usize>::new();\n\
    \   |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpk_sfux8g.rs:28:5\n   |\n9  | fn longest(strings:\
    \ Vec<String>) -> Option<String> {\n   |                                     --------------\
    \ expected `Option<String>` because of return type\n...\n28 |     strings.iter().max().map(|s|\
    \ s.len()).unwrap_or(max)\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected enum `Option`, found `usize`\n   |\n   = note: expected enum `Option<String>`\n\
    \              found type `usize`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings\n        .iter()\n        .enumerate()\n        .map(|(i, s)|\
    \ (s, i))\n        .max(by_length())\n        .unwrap_or(None)\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `by_length` in this scope\n  --> /tmp/tmpkl7i0q24.rs:14:14\n\
    \   |\n14 |         .max(by_length())\n   |              ^^^^^^^^^ not found in\
    \ this scope\n\nerror[E0061]: this function takes 0 arguments but 1 argument was\
    \ supplied\n    --> /tmp/tmpkl7i0q24.rs:14:10\n     |\n14   |         .max(by_length())\n\
    \     |          ^^^ ----------- supplied 1 argument\n     |          |\n    \
    \ |          expected 0 arguments\n     |\nnote: associated function defined here\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpkl7i0q24.rs:15:20\n   |\n15 |\
    \         .unwrap_or(None)\n   |                    ^^^^ expected tuple, found\
    \ enum `Option`\n   |\n   = note: expected tuple `(&String, usize)`\n        \
    \       found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkl7i0q24.rs:10:5\n\
    \   |\n9  |   fn longest(strings: Vec<String>) -> Option<String> {\n   |     \
    \                                  -------------- expected `Option<String>` because\
    \ of return type\n10 | /     strings\n11 | |         .iter()\n12 | |         .enumerate()\n\
    13 | |         .map(|(i, s)| (s, i))\n14 | |         .max(by_length())\n15 | |\
    \         .unwrap_or(None)\n   | |________________________^ expected enum `Option`,\
    \ found tuple\n   |\n   = note: expected enum `Option<String>`\n             found\
    \ tuple `(&String, usize)`\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0061, E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest_string\
    \ = strings[0];\n    let mut current_length = 0;\n    for &s in strings {\n  \
    \      current_length = current_length.min(s.len());\n        longest_string =\
    \ longest_string.repeat(current_length);\n    }\n\n    Some(longest_string)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0tloiw9r.rs:16:9\n   |\n\
    16 |     for &s in strings {\n   |         ^^    ------- this expression has type\
    \ `Option<String>`\n   |         |\n   |         expected struct `String`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `s`\n\
    \   |\n   = note: expected struct `String`\n           found reference `&_`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = -1;\n    let mut longest = String::new();\n    for\
    \ s in strings {\n        let len = s.len();\n        if max_len == -1 || len\
    \ > max_len {\n            max_len = len;\n            longest = s;\n        }\n\
    \    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpj5udf6le.rs:10:23\n\
    \   |\n10 |     let mut max_len = -1;\n   |                       ^^ the trait\
    \ `Neg` is not implemented for `usize`\n   |\n   = help: the following other types\
    \ implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n\
    \             &i16\n             &i32\n             &i64\n             &i8\n \
    \            &isize\n           and 8 others\n\nerror[E0277]: the trait bound\
    \ `usize: Neg` is not satisfied\n  --> /tmp/tmpj5udf6le.rs:14:23\n   |\n14 | \
    \        if max_len == -1 || len > max_len {\n   |                       ^^ the\
    \ trait `Neg` is not implemented for `usize`\n   |\n   = help: the following other\
    \ types implement trait `Neg`:\n             &f32\n             &f64\n       \
    \      &i128\n             &i16\n             &i32\n             &i64\n      \
    \       &i8\n             &isize\n           and 8 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpj5udf6le.rs:19:5\n   |\n9  | fn longest(strings: Vec<String>)\
    \ -> Option<String> {\n   |                                     --------------\
    \ expected `Option<String>` because of return type\n...\n19 |     longest\n  \
    \ |     ^^^^^^^ expected enum `Option`, found struct `String`\n   |\n   = note:\
    \ expected enum `Option<String>`\n            found struct `String`\nhelp: try\
    \ wrapping the expression in `Some`\n   |\n19 |     Some(longest)\n   |     +++++\
    \       +\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut strings_max = strings.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut index = 0;\n    let mut len = strings_max.len();\n    while index\
    \ < len {\n        let mut new_len = len - 1;\n        let mut index2 = index;\n\
    \        while index2 < len {\n            if strings_max[index2] < strings_max[index2\
    \ + 1] {\n                new_len = index2;\n            }\n            index2\
    \ += 1;\n        }\n        if new_len > index {\n            strings_max[index..new_len\
    \ + 1].cloned().find(|&s| s == strings_max[index])\n                .cloned().ok()\n\
    \                .and_then(|i| {\n                    if index == i {\n      \
    \                  None\n                    } else {\n                      \
    \  Some(strings_max[index])\n                    }\n                })\n     \
    \   } else {\n            index = new_len;\n        }\n        len -= 1;\n   \
    \ }\n    strings_max.last()\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `[String]` is not an iterator\n  --> /tmp/tmpyafndfla.rs:23:45\n\
    \   |\n23 |             strings_max[index..new_len + 1].cloned().find(|&s| s ==\
    \ strings_max[index])\n   |                                             ^^^^^^\
    \ `[String]` is not an iterator; try calling `.into_iter()` or `.iter()`\n   |\n\
    \   = note: the following trait bounds were not satisfied:\n           `[String]:\
    \ Iterator`\n           which is required by `&mut [String]: Iterator`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpyafndfla.rs:37:5\n   |\n9  | fn longest(strings:\
    \ Vec<String>) -> Option<String> {\n   |                                     --------------\
    \ expected `Option<String>` because of return type\n...\n37 |     strings_max.last()\n\
    \   |     ^^^^^^^^^^^^^^^^^^ expected struct `String`, found `&String`\n   |\n\
    \   = note: expected enum `Option<String>`\n              found enum `Option<&String>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest_string\
    \ = None;\n    let mut max_length = 0;\n    for string in strings {\n        if\
    \ string.len() > max_length {\n            max_length = string.len();\n      \
    \      longest_string = Some(string);\n        }\n    }\n\n    longest_string\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings\n        .iter()\n        .fold(\n            None,\n       \
    \     |mut acc, &str| {\n                let len = str.len();\n              \
    \  acc = if len > acc.len() {\n                    Some(str)\n               \
    \ } else {\n                    Some(String::from(str))\n                };\n\
    \                acc\n            },\n        )\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmp8418s0ul.rs:16:36\n   |\n16 |                 acc = if\
    \ len > acc.len() {\n   |                                    ^^^ method not found\
    \ in `Option<String>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest_len = String::new(\"\");\n    let mut longest_iter =\
    \ strings.iter().max_by_key(|s| s.len());\n    longest_iter.for_each(|s| {\n \
    \       longest_len = longest_len.chars().max().unwrap() + s.chars().max().unwrap();\n\
    \    });\n    longest_iter.next()\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmpw7rpzjnl.rs:10:27\n    |\n10  |     let mut longest_len = String::new(\"\
    \");\n    |                           ^^^^^^^^^^^ -- supplied 1 argument\n   \
    \ |                           |\n    |                           expected 0 arguments\n\
    \    |\nnote: associated function defined here\n\nerror[E0599]: `Option<&String>`\
    \ is not an iterator\n   --> /tmp/tmpw7rpzjnl.rs:12:18\n    |\n12  |       longest_iter.for_each(|s|\
    \ {\n    |                    ^^^^^^^^ `Option<&String>` is not an iterator\n\
    \    |\n    = note: the following trait bounds were not satisfied:\n         \
    \   `Option<&String>: Iterator`\n            which is required by `&mut Option<&String>:\
    \ Iterator`\n\nerror[E0599]: no method named `next` found for enum `Option` in\
    \ the current scope\n  --> /tmp/tmpw7rpzjnl.rs:15:18\n   |\n15 |     longest_iter.next()\n\
    \   |                  ^^^^ method not found in `Option<&String>`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0061, E0599.\n\
    For more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings\n        .into_iter()\n        .enumerate()\n        .filter_map(|(i,\
    \ &s)| if i >= strings.len() {\n            None\n        } else {\n         \
    \   let len = s.length;\n            Some(s.chars().take(len).max().unwrap())\n\
    \        })\n        .next()\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5o4i0frb.rs:13:26\n   |\n\
    13 |         .filter_map(|(i, &s)| if i >= strings.len() {\n   |             \
    \             ^^- expected due to this\n   |                          |\n   |\
    \                          expected struct `String`, found reference\n   |   \
    \                       help: you can probably remove the explicit borrow: `s`\n\
    \   |\n   = note: expected struct `String`\n           found reference `&_`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut strings_iter:\
    \ Vec<_> = strings.into_iter().map(String::from).collect();\n    strings_iter.rev().find(|&string|\
    \ string.len() > strings_iter.last().len())\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `Vec<String>` is not an iterator\n   --> /tmp/tmphm_45b_8.rs:14:18\n\
    \    |\n14  |       strings_iter.rev().find(|&string| string.len() > strings_iter.last().len())\n\
    \    |                    ^^^ `Vec<String>` is not an iterator\n    |\n    = note:\
    \ the following trait bounds were not satisfied:\n            `Vec<String>: Iterator`\n\
    \            which is required by `&mut Vec<String>: Iterator`\n            `[String]:\
    \ Iterator`\n            which is required by `&mut [String]: Iterator`\n\nerror[E0599]:\
    \ no method named `len` found for enum `Option` in the current scope\n  --> /tmp/tmphm_45b_8.rs:14:74\n\
    \   |\n14 |     strings_iter.rev().find(|&string| string.len() > strings_iter.last().len())\n\
    \   |                                                                        \
    \  ^^^ method not found in `Option<&String>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.iter()\n        .map(|s| s.len())\n        .max()\n        .cloned()\n\
    \        .cloned()\n        .find(|len| len == strings.iter().map(|s| s.len()).max())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `Option<usize>` is not an iterator\n   --> /tmp/tmpp89qhbn8.rs:13:10\n\
    \    |\n13  |           .cloned()\n    |            ^^^^^^ `Option<usize>` is\
    \ not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Option<usize>: Iterator`\n            which is required by `&mut\
    \ Option<usize>: Iterator`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.iter().fold(None, |max, x| if max.len() > x.len() { Some(x) }\
    \ else { None })\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmpxsduwvkj.rs:10:47\n   |\n10 |     strings.iter().fold(None,\
    \ |max, x| if max.len() > x.len() { Some(x) } else { None })\n   |           \
    \                                    ^^^ method not found in `Option<String>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpxsduwvkj.rs:10:70\n   |\n10 |\
    \     strings.iter().fold(None, |max, x| if max.len() > x.len() { Some(x) } else\
    \ { None })\n   |                                                            \
    \          ^- help: try using a conversion method: `.to_string()`\n   |      \
    \                                                                |\n   |     \
    \                                                                 expected struct\
    \ `String`, found `&String`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings\n        .iter()\n        .enumerate()\n        .max_by(|a, b|\
    \ a.1.cmp(&b.1))\n        .map(|(_, s)| s)\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpu3thdn3p.rs:10:5\n   |\n\
    9  |   fn longest(strings: Vec<String>) -> Option<String> {\n   |            \
    \                           -------------- expected `Option<String>` because of\
    \ return type\n10 | /     strings\n11 | |         .iter()\n12 | |         .enumerate()\n\
    13 | |         .max_by(|a, b| a.1.cmp(&b.1))\n14 | |         .map(|(_, s)| s)\n\
    \   | |________________________^ expected struct `String`, found `&String`\n \
    \  |\n   = note: expected enum `Option<String>`\n              found enum `Option<&String>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.iter().max(|a, b| a.len().cmp(&b.len()).unwrap_or(0)).next()\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmp8q5mwk6j.rs:10:25\n\
    \   |\n10 |     strings.iter().max(|a, b| a.len().cmp(&b.len()).unwrap_or(0)).next()\n\
    \   |                         ^ consider giving this closure parameter a type\n\
    \   |\n   = note: type must be known at this point\n\nerror[E0061]: this function\
    \ takes 0 arguments but 1 argument was supplied\n    --> /tmp/tmp8q5mwk6j.rs:10:20\n\
    \     |\n10   |     strings.iter().max(|a, b| a.len().cmp(&b.len()).unwrap_or(0)).next()\n\
    \     |                    ^^^ ----------------------------------------- supplied\
    \ 1 argument\n     |                    |\n     |                    expected\
    \ 0 arguments\n     |\nnote: associated function defined here\n\nerror[E0599]:\
    \ no method named `next` found for enum `Option` in the current scope\n  --> /tmp/tmp8q5mwk6j.rs:10:67\n\
    \   |\n10 |     strings.iter().max(|a, b| a.len().cmp(&b.len()).unwrap_or(0)).next()\n\
    \   |                                                                   ^^^^ method\
    \ not found in `Option<&String>`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0061, E0282, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n\n    let mut max_length\
    \ = strings[0].len();\n    for i in strings.iter().skip(1) {\n        let len\
    \ = i.len();\n        if len > max_length {\n            max_length = len;\n \
    \       }\n    }\n\n    Some(strings[strings.iter().find(|x| x.len() == max_length).unwrap()])\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[String]` cannot be indexed by `&String`\n  -->\
    \ /tmp/tmpn7yunft5.rs:22:10\n   |\n22 |     Some(strings[strings.iter().find(|x|\
    \ x.len() == max_length).unwrap()])\n   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[String]>` is not implemented for `&String`\n   = note: required\
    \ because of the requirements on the impl of `Index<&String>` for `Vec<String>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.iter().fold(None, |mut result, string| {\n        if let Some(len)\
    \ = result.get() {\n            if len < string.length() {\n                result.swap(string);\n\
    \            }\n        } else {\n            result.swap(string);\n        }\n\
    \        result\n    })\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `get` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmpv065khrr.rs:11:35\n   |\n11 |         if let Some(len)\
    \ = result.get() {\n   |                                   ^^^ method not found\
    \ in `Option<String>`\n\nerror[E0599]: no method named `length` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmpv065khrr.rs:12:29\n   |\n12 |\
    \             if len < string.length() {\n   |                             ^^^^^^\
    \ help: there is an associated function with a similar name: `len`\n\nerror[E0599]:\
    \ no method named `swap` found for enum `Option` in the current scope\n  --> /tmp/tmpv065khrr.rs:13:24\n\
    \   |\n13 |                 result.swap(string);\n   |                       \
    \ ^^^^ method not found in `Option<String>`\n\nerror[E0599]: no method named `swap`\
    \ found for enum `Option` in the current scope\n  --> /tmp/tmpv065khrr.rs:16:20\n\
    \   |\n16 |             result.swap(string);\n   |                    ^^^^ method\
    \ not found in `Option<String>`\n\nerror: aborting due to 4 previous errors\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut lens = strings.values().map(|s| s.len());\n    let longest =\
    \ lens.max_by(|a, b| a as usize < b as usize);\n    if longest == None {\n   \
    \     return None;\n    }\n    strings.iter().position(|s| s == *longest).unwrap()\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error: `<` is interpreted as a start of generic arguments for `usize`,\
    \ not a comparison\n  --> /tmp/tmphozi4l3n.rs:11:49\n   |\n11 |     let longest\
    \ = lens.max_by(|a, b| a as usize < b as usize);\n   |                       \
    \                          ^ ---- interpreted as generic arguments\n   |     \
    \                                            |\n   |                         \
    \                        not interpreted as comparison\n   |\nhelp: try comparing\
    \ the cast value\n   |\n11 |     let longest = lens.max_by(|a, b| (a as usize)\
    \ < b as usize);\n   |                                      +          +\n\nerror[E0599]:\
    \ no method named `values` found for struct `Vec<String>` in the current scope\n\
    \  --> /tmp/tmphozi4l3n.rs:10:28\n   |\n10 |     let mut lens = strings.values().map(|s|\
    \ s.len());\n   |                            ^^^^^^ method not found in `Vec<String>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmphozi4l3n.rs:15:5\n   |\n9  | fn\
    \ longest(strings: Vec<String>) -> Option<String> {\n   |                    \
    \                 -------------- expected `Option<String>` because of return type\n\
    ...\n15 |     strings.iter().position(|s| s == *longest).unwrap()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected enum `Option`, found `usize`\n   |\n   = note: expected enum `Option<String>`\n\
    \              found type `usize`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n\n    let mut max\
    \ = String::new();\n    let mut longest_len = String::new();\n    for s in strings\
    \ {\n        let len = s.len();\n        if len > longest_len {\n            longest_len\
    \ = len;\n            max = s;\n        }\n    }\n    Some(max)\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnip6r57_.rs:18:18\n   |\n\
    18 |         if len > longest_len {\n   |                  ^^^^^^^^^^^ expected\
    \ `usize`, found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnip6r57_.rs:19:27\n\
    \   |\n15 |     let mut longest_len = String::new();\n   |                   \
    \        ------------- expected due to this value\n...\n19 |             longest_len\
    \ = len;\n   |                           ^^^- help: try using a conversion method:\
    \ `.to_string()`\n   |                           |\n   |                     \
    \      expected struct `String`, found `usize`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.iter()\n        .map(|x| x.len())\n        .max()\n        .and_then(|l|\
    \ strings.iter().map(|x| x.len()).max().ok_or(\"Input empty strings?\"))\n   \
    \     .and_then(|(a, b)| a.cmp(b))\n        .and_then(|(a, b)| if *b > 0 { None\
    \ } else { Some(String::from(*a)) })\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp40tfbblo.rs:13:23\n   |\n\
    9  | fn longest(strings: Vec<String>) -> Option<String> {\n   |              \
    \                       -------------- expected `Option<_>` because of return\
    \ type\n...\n13 |         .and_then(|l| strings.iter().map(|x| x.len()).max().ok_or(\"\
    Input empty strings?\"))\n   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected enum `Option`, found enum `Result`\n   |\n   = note: expected enum\
    \ `Option<_>`\n              found enum `Result<usize, &str>`\nhelp: try wrapping\
    \ the expression in `Some`\n   |\n13 |         .and_then(|l| Some(strings.iter().map(|x|\
    \ x.len()).max().ok_or(\"Input empty strings?\")))\n   |                     \
    \  +++++                                                                   +\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len: usize = 0;\n    let mut max_len_string: Option<String>\
    \ = None;\n    for s in strings {\n        let len = s.len();\n        if max_len\
    \ < len {\n            max_len = len;\n            max_len_string = Some(s);\n\
    \        }\n    }\n    max_len_string.ok_or(String::from(\"Empty vector provided\"\
    ))\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfin155ua.rs:19:5\n   |\n\
    9  | fn longest(strings: Vec<String>) -> Option<String> {\n   |              \
    \                       -------------- expected `Option<String>` because of return\
    \ type\n...\n19 |     max_len_string.ok_or(String::from(\"Empty vector provided\"\
    ))\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ enum `Option`, found enum `Result`\n   |\n   = note: expected enum `Option<String>`\n\
    \              found enum `Result<String, String>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        None\n    } else {\n        let mut\
    \ longest = strings.iter().cloned().collect::<Vec<_>>().iter().max().unwrap();\n\
    \        let mut counter = 0;\n        for s in strings.iter() {\n           \
    \ if s.len() == longest {\n                counter += 1;\n            }\n    \
    \    }\n        if counter > 1 {\n            Some(longest)\n        } else {\n\
    \            None\n        }\n    }\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4qf8dg5m.rs:16:27\n   |\n\
    16 |             if s.len() == longest {\n   |                           ^^^^^^^\
    \ expected `usize`, found `&String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4qf8dg5m.rs:21:18\n\
    \   |\n21 |             Some(longest)\n   |                  ^^^^^^^- help: try\
    \ using a conversion method: `.to_string()`\n   |                  |\n   |   \
    \               expected struct `String`, found `&String`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = String::MAX;\n    for s in strings {\n        let len\
    \ = s.chars().count();\n        if len > max_len {\n            max_len = len;\n\
    \        }\n    }\n    if max_len == String::MAX {\n        None\n    } else {\n\
    \        Some(strings[strings.iter().position(|x| x == &strings[strings.iter().rposition(|y|\
    \ y == &strings[strings.len() - 1])]).unwrap()])\n    }\n}\n\nfn main() {\n  \
    \  let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no associated item named `MAX` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpsrbrw7qg.rs:10:31\n   |\n10 |     let mut\
    \ max_len = String::MAX;\n   |                               ^^^ associated item\
    \ not found in `String`\n\nerror[E0599]: no associated item named `MAX` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmpsrbrw7qg.rs:17:27\n\
    \   |\n17 |     if max_len == String::MAX {\n   |                           ^^^\
    \ associated item not found in `String`\n\nerror[E0277]: the type `[String]` cannot\
    \ be indexed by `Option<usize>`\n  --> /tmp/tmpsrbrw7qg.rs:20:56\n   |\n20 | \
    \        Some(strings[strings.iter().position(|x| x == &strings[strings.iter().rposition(|y|\
    \ y == &strings[strings.len() - 1])]).unwrap()])\n   |                       \
    \                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[String]>` is not implemented for `Option<usize>`\n   = note:\
    \ required because of the requirements on the impl of `Index<Option<usize>>` for\
    \ `Vec<String>`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut longest_len\
    \ = String::from(\"?\");\n    let mut longest_len_idx = -1;\n    for &s in strings\
    \ {\n        let len = s.len();\n        if len > longest_len.len() {\n      \
    \      longest_len = s;\n            longest_len_idx = len;\n        }\n    }\n\
    \    if longest_len_idx > 0 {\n        longest_len.clone(),\n    } else {\n  \
    \      None\n    }\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `,`\n\
    \  --> /tmp/tmp9o5lhx_5.rs:23:28\n   |\n23 |         longest_len.clone(),\n  \
    \ |                            ^ expected one of `.`, `;`, `?`, `}`, or an operator\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp9o5lhx_5.rs:15:9\n   |\n15 | \
    \    for &s in strings {\n   |         ^^    ------- this expression has type\
    \ `Option<String>`\n   |         |\n   |         expected struct `String`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `s`\n\
    \   |\n   = note: expected struct `String`\n           found reference `&_`\n\n\
    error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp9o5lhx_5.rs:14:31\n\
    \   |\n14 |     let mut longest_len_idx = -1;\n   |                          \
    \     ^^ the trait `Neg` is not implemented for `usize`\n   |\n   = help: the\
    \ following other types implement trait `Neg`:\n             &f32\n          \
    \   &f64\n             &i128\n             &i16\n             &i32\n         \
    \    &i64\n             &i8\n             &isize\n           and 8 others\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n\n    let mut max_len\
    \ = String::new();\n    let mut max_index = -1;\n    for (i, s) in strings.iter().enumerate()\
    \ {\n        let len = s.len();\n        if len > max_len {\n            max_len\
    \ = len;\n            max_index = i;\n        }\n    }\n    Some(strings[max_index])\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpy7adzzvi.rs:18:18\n   |\n\
    18 |         if len > max_len {\n   |                  ^^^^^^^ expected `usize`,\
    \ found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpy7adzzvi.rs:19:23\n\
    \   |\n14 |     let mut max_len = String::new();\n   |                       -------------\
    \ expected due to this value\n...\n19 |             max_len = len;\n   |     \
    \                  ^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                       |\n   |                       expected struct `String`,\
    \ found `usize`\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n\
    \  --> /tmp/tmpy7adzzvi.rs:15:25\n   |\n15 |     let mut max_index = -1;\n   |\
    \                         ^^ the trait `Neg` is not implemented for `usize`\n\
    \   |\n   = help: the following other types implement trait `Neg`:\n         \
    \    &f32\n             &f64\n             &i128\n             &i16\n        \
    \     &i32\n             &i64\n             &i8\n             &isize\n       \
    \    and 8 others\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    // Find longest string in string vector\n    let mut longest_len = std::cmp::max::<i32>(\n\
    \        0,\n        strings\n            .iter()\n            .map(|s| s.len())\n\
    \            .collect::<Vec<_>>()\n            .iter()\n            .cloned()\n\
    \            .cloned()\n            .collect::<Vec<_>>()\n            .len(),\n\
    \    );\n\n    for s in &strings {\n        if longest_len > s.len() {\n     \
    \       longest_len = s.len();\n        }\n    }\n\n    // Return longest one\
    \ if more than one\n    if strings.len() > 1 {\n        strings.iter().max_by_key(|&s|\
    \ s.len()).unwrap()\n    } else {\n        // Return first string if only one\n\
    \        strings.iter().cloned().map(|s| s).next().cloned()\n    }\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<std::slice::Iter<'_, usize> as\
    \ Iterator>::Item == &&_`\n    --> /tmp/tmpdax3o3_v.rs:19:14\n     |\n19   | \
    \            .cloned()\n     |              ^^^^^^ expected reference, found `usize`\n\
    \     |\n     = note: expected reference `&&_`\n                found reference\
    \ `&usize`\n     = note: required because of the requirements on the impl of `Iterator`\
    \ for `Cloned<std::slice::Iter<'_, usize>>`\nnote: required by a bound in `cloned`\n\
    \nerror[E0599]: the method `collect` exists for struct `Cloned<Cloned<std::slice::Iter<'_,\
    \ usize>>>`, but its trait bounds were not satisfied\n  --> /tmp/tmpdax3o3_v.rs:20:14\n\
    \   |\n20 |               .collect::<Vec<_>>()\n   |                ^^^^^^^ method\
    \ cannot be called on `Cloned<Cloned<std::slice::Iter<'_, usize>>>` due to unsatisfied\
    \ trait bounds\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `<Cloned<std::slice::Iter<'_, usize>> as Iterator>::Item = &_`\n \
    \          which is required by `Cloned<Cloned<std::slice::Iter<'_, usize>>>:\
    \ Iterator`\n           `Cloned<Cloned<std::slice::Iter<'_, usize>>>: Iterator`\n\
    \           which is required by `&mut Cloned<Cloned<std::slice::Iter<'_, usize>>>:\
    \ Iterator`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdax3o3_v.rs:25:26\n\
    \   |\n25 |         if longest_len > s.len() {\n   |                         \
    \ ^^^^^^^ expected `i32`, found `usize`\n   |\nhelp: you can convert a `usize`\
    \ to an `i32` and panic if the converted value doesn't fit\n   |\n25 |       \
    \  if longest_len > s.len().try_into().unwrap() {\n   |                      \
    \           ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdax3o3_v.rs:26:27\n\
    \   |\n11 |       let mut longest_len = std::cmp::max::<i32>(\n   |  ___________________________-\n\
    12 | |         0,\n13 | |         strings\n14 | |             .iter()\n...  |\n\
    21 | |             .len(),\n22 | |     );\n   | |_____- expected due to this value\n\
    ...\n26 |               longest_len = s.len();\n   |                         \
    \    ^^^^^^^ expected `i32`, found `usize`\n\nerror[E0308]: mis"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max = 0;\n    let mut min = 0;\n    for s in strings {\n    \
    \    let len = s.len();\n        if len > max {\n            max = len;\n    \
    \    }\n        if len < min {\n            min = len;\n        }\n    }\n\n \
    \   if min > max {\n        return None;\n    }\n    strings.iter().take(max).last()\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprqnt8obk.rs:25:5\n   |\n\
    9  | fn longest(strings: Vec<String>) -> Option<String> {\n   |              \
    \                       -------------- expected `Option<String>` because of return\
    \ type\n...\n25 |     strings.iter().take(max).last()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&String`\n   |\n   = note: expected enum `Option<String>`\n\
    \              found enum `Option<&String>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = String::new();\n\n    for s in strings.iter() {\n \
    \       if longest.len() == s.len() {\n            longest = s;\n        }\n \
    \   }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpuo96iw5x.rs:14:23\n   |\n\
    10 |     let mut longest = String::new();\n   |                       -------------\
    \ expected due to this value\n...\n14 |             longest = s;\n   |       \
    \                ^- help: try using a conversion method: `.to_string()`\n   |\
    \                       |\n   |                       expected struct `String`,\
    \ found `&String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpuo96iw5x.rs:17:5\n\
    \   |\n9  | fn longest(strings: Vec<String>) -> Option<String> {\n   |       \
    \                              -------------- expected `Option<String>` because\
    \ of return type\n...\n17 |     longest\n   |     ^^^^^^^ expected enum `Option`,\
    \ found struct `String`\n   |\n   = note: expected enum `Option<String>`\n   \
    \         found struct `String`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n17 |     Some(longest)\n   |     +++++       +\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings\n        .into_iter()\n        .map(|s| s.chars().count())\n\
    \        .max()\n        .and_then(|len| strings\n                        .iter()\n\
    \                        .filter_map(|s| s.chars().count())\n                \
    \        .take(len)\n                        .max())\n}\n\nfn main() {\n    let\
    \ candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpagf41l0m.rs:16:41\n   |\n\
    16 |                         .filter_map(|s| s.chars().count())\n   |        \
    \                                 ^^^^^^^^^^^^^^^^^ expected enum `Option`, found\
    \ `usize`\n   |\n   = note: expected enum `Option<_>`\n              found type\
    \ `usize`\nhelp: try wrapping the expression in `Some`\n   |\n16 |           \
    \              .filter_map(|s| Some(s.chars().count()))\n   |                \
    \                         +++++                 +\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        None\n    } else {\n        let mut\
    \ i = 0;\n        strings.iter().for_each(|&x| {\n            if i >= strings.len()\
    \ {\n                i = 0;\n            }\n            i += 1;\n        });\n\
    \        strings.get(i)\n    }\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2_mec2ff.rs:20:9\n   |\n\
    9  | fn longest(strings: Vec<String>) -> Option<String> {\n   |              \
    \                       -------------- expected `Option<String>` because of return\
    \ type\n...\n20 |         strings.get(i)\n   |         ^^^^^^^^^^^^^^ expected\
    \ struct `String`, found `&String`\n   |\n   = note: expected enum `Option<String>`\n\
    \              found enum `Option<&String>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n\n    let mut max_size\
    \ = strings[0].len();\n\n    for string in strings {\n        if string.len()\
    \ > max_size {\n            max_size = string.len();\n        }\n    }\n\n   \
    \ let mut longest_string = None;\n\n    for string in strings {\n        if string.len()\
    \ == max_size {\n            longest_string = Some(string);\n            break;\n\
    \        }\n    }\n\n    longest_string\n}\n\nfn main() {\n    let candidate =\
    \ longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `strings`\n   --> /tmp/tmp3ff2ys83.rs:24:19\n\
    \    |\n9   | fn longest(strings: Vec<String>) -> Option<String> {\n    |    \
    \        ------- move occurs because `strings` has type `Vec<String>`, which does\
    \ not implement the `Copy` trait\n...\n16  |     for string in strings {\n   \
    \ |                   ------- `strings` moved due to this implicit call to `.into_iter()`\n\
    ...\n24  |     for string in strings {\n    |                   ^^^^^^^ value\
    \ used here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `strings`\nhelp: consider iterating over a slice of the\
    \ `Vec<String>`'s content to avoid moving into the `for` loop\n    |\n16  |  \
    \   for string in &strings {\n    |                   +\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut i =\
    \ 0;\n    let mut max_len = strings[0].chars().count();\n    for str in strings.iter().skip(1)\
    \ {\n        if str.chars().count() > max_len {\n            max_len = str.chars().count();\n\
    \        }\n        i += 1;\n    }\n    if max_len == strings[0].chars().count()\
    \ {\n        Some(strings[0])\n    } else {\n        None\n    }\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "warning: variable `i` is assigned to, but never used\n  --> /tmp/tmp8nm1kpdy.rs:13:13\n\
    \   |\n13 |     let mut i = 0;\n   |             ^\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n   = note: consider using `_i` instead\n\nerror[E0507]: cannot\
    \ move out of index of `Vec<String>`\n  --> /tmp/tmp8nm1kpdy.rs:22:14\n   |\n\
    22 |         Some(strings[0])\n   |              ^^^^^^^^^^ move occurs because\
    \ value has type `String`, which does not implement the `Copy` trait\n\nerror:\
    \ aborting due to previous error; 1 warning emitted\n\nFor more information about\
    \ this error, try `rustc --explain E0507`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings\n        .iter()\n        .chain(strings.iter().cloned())\n \
    \       .fold(String::new(), |mut max, string| {\n            if string.length()\
    \ > max.len() {\n                max = string;\n            }\n            max\n\
    \        })\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<std::slice::Iter<'_, String> as\
    \ Iterator>::Item == &&String`\n   --> /tmp/tmp0r58zlew.rs:12:16\n    |\n12  |\
    \         .chain(strings.iter().cloned())\n    |          ----- ^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&String`, found struct `String`\n    |          |\n    |         \
    \ required by a bound introduced by this call\n    |\n    = note: expected reference\
    \ `&&String`\n               found reference `&String`\n    = note: required because\
    \ of the requirements on the impl of `Iterator` for `Cloned<std::slice::Iter<'_,\
    \ String>>`\nnote: required by a bound in `std::iter::Iterator::chain`\n\nerror[E0599]:\
    \ the method `fold` exists for struct `std::iter::Chain<std::slice::Iter<'_, String>,\
    \ Cloned<std::slice::Iter<'_, String>>>`, but its trait bounds were not satisfied\n\
    \  --> /tmp/tmp0r58zlew.rs:13:10\n   |\n13 |           .fold(String::new(), |mut\
    \ max, string| {\n   |            ^^^^ method cannot be called on `std::iter::Chain<std::slice::Iter<'_,\
    \ String>, Cloned<std::slice::Iter<'_, String>>>` due to unsatisfied trait bounds\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `<Cloned<std::slice::Iter<'_,\
    \ String>> as Iterator>::Item = &String`\n           which is required by `std::iter::Chain<std::slice::Iter<'_,\
    \ String>, Cloned<std::slice::Iter<'_, String>>>: Iterator`\n           `std::iter::Chain<std::slice::Iter<'_,\
    \ String>, Cloned<std::slice::Iter<'_, String>>>: Iterator`\n           which\
    \ is required by `&mut std::iter::Chain<std::slice::Iter<'_, String>, Cloned<std::slice::Iter<'_,\
    \ String>>>: Iterator`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0271, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings\n        .iter()\n        .cloned()\n        .map(|string| string.len())\n\
    \        .max()\n        .unwrap_or(0)\n        .to_string()\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw24bgy13.rs:10:5\n   |\n\
    9  |   fn longest(strings: Vec<String>) -> Option<String> {\n   |            \
    \                           -------------- expected `Option<String>` because of\
    \ return type\n10 | /     strings\n11 | |         .iter()\n12 | |         .cloned()\n\
    13 | |         .map(|string| string.len())\n14 | |         .max()\n15 | |    \
    \     .unwrap_or(0)\n16 | |         .to_string()\n   | |____________________^\
    \ expected enum `Option`, found struct `String`\n   |\n   = note: expected enum\
    \ `Option<String>`\n            found struct `String`\nhelp: try wrapping the\
    \ expression in `Some`\n   |\n10 ~     Some(strings\n11 |         .iter()\n12\
    \ |         .cloned()\n13 |         .map(|string| string.len())\n14 |        \
    \ .max()\n15 |         .unwrap_or(0)\n ...\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.iter().map(|s| s.len()).max_by_key(|s| s)\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2bcxtfcv.rs:10:5\n   |\n\
    9  | fn longest(strings: Vec<String>) -> Option<String> {\n   |              \
    \                       -------------- expected `Option<String>` because of return\
    \ type\n10 |     strings.iter().map(|s| s.len()).max_by_key(|s| s)\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `usize`\n   |\n   = note: expected enum `Option<String>`\n\
    \              found enum `Option<usize>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut string = String::from(\"\");\n    for s in strings {\n      \
    \  string = match string.to_inner() {\n            None => return None,\n    \
    \        Some(s) if s.len() > string.len() => s,\n            Some(s) if s.len()\
    \ < string.len() => string = s,\n        };\n    }\n    Some(string)\n}\n\nfn\
    \ main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_inner` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpu2trvok3.rs:12:31\n   |\n12 |         string =\
    \ match string.to_inner() {\n   |                               ^^^^^^^^ method\
    \ not found in `String`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.iter().max(|a, b| a.len() as usize < b.len() as usize).and_then(|s|\
    \ s)\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error: `<` is interpreted as a start of generic arguments for `usize`,\
    \ not a comparison\n  --> /tmp/tmp6zl32fqw.rs:10:48\n   |\n10 |     strings.iter().max(|a,\
    \ b| a.len() as usize < b.len() as usize).and_then(|s| s)\n   |              \
    \                                  ^ -- interpreted as generic arguments\n   |\
    \                                                |\n   |                     \
    \                           not interpreted as comparison\n   |\nhelp: try comparing\
    \ the cast value\n   |\n10 |     strings.iter().max(|a, b| (a.len() as usize)\
    \ < b.len() as usize).and_then(|s| s)\n   |                               +  \
    \              +\n\nerror[E0282]: type annotations needed\n  --> /tmp/tmp6zl32fqw.rs:10:25\n\
    \   |\n10 |     strings.iter().max(|a, b| a.len() as usize < b.len() as usize).and_then(|s|\
    \ s)\n   |                         ^ consider giving this closure parameter a\
    \ type\n   |\n   = note: type must be known at this point\n\nerror[E0061]: this\
    \ function takes 0 arguments but 1 argument was supplied\n    --> /tmp/tmp6zl32fqw.rs:10:20\n\
    \     |\n10   |     strings.iter().max(|a, b| a.len() as usize < b.len() as usize).and_then(|s|\
    \ s)\n     |                    ^^^ ------------------------------------------\
    \ supplied 1 argument\n     |                    |\n     |                   \
    \ expected 0 arguments\n     |\nnote: associated function defined here\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp6zl32fqw.rs:10:81\n   |\n9  | fn longest(strings:\
    \ Vec<String>) -> Option<String> {\n   |                                     --------------\
    \ expected `Option<_>` because of return type\n10 |     strings.iter().max(|a,\
    \ b| a.len() as usize < b.len() as usize).and_then(|s| s)\n   |              \
    \                                                                   ^ expected\
    \ enum `Option`, found `&String`\n   |\n   = note:   expected enum `Option<_>`\n\
    \           found reference `&String`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n10 |     strings.iter().max(|a, b| a.len() as usize < b.len() as usize).and_then(|s|\
    \ Some(s))\n   |                                        "
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings\n        .into_iter()\n        .map(|s| s.len())\n        .max()\n\
    \        .cloned()\n        .unwrap_or(String::new())\n}\n\nfn main() {\n    let\
    \ candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `Option<usize>` is not an iterator\n   --> /tmp/tmpio4y0fmo.rs:14:10\n\
    \    |\n14  |           .cloned()\n    |            ^^^^^^ `Option<usize>` is\
    \ not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Option<usize>: Iterator`\n            which is required by `&mut\
    \ Option<usize>: Iterator`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        None\n    } else {\n        let mut\
    \ max_len = std::cmp::max::<usize>(strings.len(), 1);\n        for string in strings\
    \ {\n            if string.length() > max_len {\n                max_len = string.length();\n\
    \            }\n        }\n        Some(strings[max_len])\n    }\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp3zkb_a79.rs:15:23\n   |\n15 |             if string.length()\
    \ > max_len {\n   |                       ^^^^^^ help: there is an associated\
    \ function with a similar name: `len`\n\nerror[E0599]: no method named `length`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmp3zkb_a79.rs:16:34\n\
    \   |\n16 |                 max_len = string.length();\n   |                 \
    \                 ^^^^^^ help: there is an associated function with a similar\
    \ name: `len`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut it\
    \ = strings.iter().rev();\n    let mut max = it.next();\n    loop {\n        let\
    \ next = it.next();\n        if next == Some(next) {\n            return Some(max);\n\
    \        }\n        max = next;\n    }\n}\n\nfn main() {\n    let candidate =\
    \ longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpo5r36qdt.rs:17:25\n   |\n\
    17 |         if next == Some(next) {\n   |                         ^^^^ expected\
    \ `&String`, found enum `Option`\n   |\n   = note: expected reference `&String`\n\
    \                   found enum `Option<&String>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpo5r36qdt.rs:18:25\n   |\n18 |             return Some(max);\n \
    \  |                         ^^^ expected struct `String`, found enum `Option`\n\
    \   |\n   = note: expected struct `String`\n                found enum `Option<&String>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut len = String::new();\n\n    for s in strings {\n        len =\
    \ s.len() > len.len() ? s : len;\n    }\n    Some(len)\n}\n\nfn main() {\n   \
    \ let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `s`\n\
    \  --> /tmp/tmpyphm5qsp.rs:13:37\n   |\n13 |         len = s.len() > len.len()\
    \ ? s : len;\n   |                                     ^ expected one of `.`,\
    \ `;`, `?`, `}`, or an operator\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut max\
    \ = strings[0]\n        .len()\n        .cmp(&(strings.iter().max().unwrap().len()))\n\
    \        .unwrap();\n    for s in strings {\n        let l = s.len();\n      \
    \  if l > max {\n            max = l;\n        }\n    }\n    Some(max)\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap` found for enum `std::cmp::Ordering`\
    \ in the current scope\n  --> /tmp/tmp8gs7ayys.rs:16:10\n   |\n16 |         .unwrap();\n\
    \   |          ^^^^^^ method not found in `std::cmp::Ordering`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8gs7ayys.rs:23:10\n   |\n23 |     Some(max)\n\
    \   |          ^^^- help: try using a conversion method: `.to_string()`\n   |\
    \          |\n   |          expected struct `String`, found `usize`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings\n        .iter()\n        .map(|s| s.len())\n        .max()\n\
    \        .cloned()\n        .and_then(|x| x.take_while(|c| c.is_ascii_lowercase()))\n\
    \        .next()\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `Option<usize>` is not an iterator\n   --> /tmp/tmpx6rzfyu2.rs:14:10\n\
    \    |\n14  |           .cloned()\n    |            ^^^^^^ `Option<usize>` is\
    \ not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Option<usize>: Iterator`\n            which is required by `&mut\
    \ Option<usize>: Iterator`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n\n    let mut max_len\
    \ = String::new();\n    let mut max_str_len = 0;\n    let mut max_strs = vec![];\n\
    \    for s in strings {\n        let s_len = s.len();\n        if s_len > max_str_len\
    \ {\n            max_str_len = s_len;\n            max_strs.clear();\n       \
    \ }\n        if s_len == max_str_len {\n            max_strs.push(s);\n      \
    \  }\n    }\n\n    if max_strs.is_empty() {\n        return None;\n    }\n\n \
    \   max_strs\n        .iter()\n        .fold(None, |max, &s| if max != None {\
    \ Some(max) } else { Some(s) })\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbhqromyy.rs:34:53\n   |\n\
    34 |         .fold(None, |max, &s| if max != None { Some(max) } else { Some(s)\
    \ })\n   |                                                     ^^^ expected struct\
    \ `String`, found enum `Option`\n   |\n   = note: expected struct `String`\n \
    \               found enum `Option<String>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut max_len\
    \ = std::mem::take_max_unchecked(strings.len());\n    let mut best_string = String::new();\n\
    \    for s in strings {\n        let len = s.len();\n        if max_len < len\
    \ {\n            max_len = len;\n            best_string = s;\n        }\n   \
    \ }\n    Some(best_string)\n}\n\nfn main() {\n    let candidate = longest;\n \
    \   assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `take_max_unchecked` in module `std::mem`\n\
    \  --> /tmp/tmpgzsn7r8o.rs:13:33\n   |\n13 |     let mut max_len = std::mem::take_max_unchecked(strings.len());\n\
    \   |                                 ^^^^^^^^^^^^^^^^^^ not found in `std::mem`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 101
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        None\n    } else {\n        let mut\
    \ current_longest = String::from(\"a\");\n        for s in strings {\n       \
    \     if s.len() > current_longest.len() {\n                current_longest =\
    \ s;\n            }\n        }\n        Some(current_longest)\n    }\n}\n\nfn\
    \ main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"a\")`,\n right: `Some(\"x\")`', /tmp/tmpblw_9x87.rs:26:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut result = String::new();\n\n    for s in strings.iter() {\n  \
    \      if result.len() < s.len() {\n            result = s;\n        }\n    }\n\
    \n    result.is_some()\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2smpfqa1.rs:14:22\n   |\n\
    10 |     let mut result = String::new();\n   |                      -------------\
    \ expected due to this value\n...\n14 |             result = s;\n   |        \
    \              ^- help: try using a conversion method: `.to_string()`\n   |  \
    \                    |\n   |                      expected struct `String`, found\
    \ `&String`\n\nerror[E0599]: no method named `is_some` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp2smpfqa1.rs:18:12\n   |\n18 |     result.is_some()\n\
    \   |            ^^^^^^^ method not found in `String`\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings\n        .into_iter()\n        .map(|s| {\n            s.chars().take_while(|c|\
    \ c < 128).count()\n        })\n        .max()\n        .cloned()\n        .map(|count|\
    \ strings.iter().take_while(|s| count == s.chars().count()).collect::<Vec<_>>().unwrap().first())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp16lxptu4.rs:13:42\n   |\n\
    13 |             s.chars().take_while(|c| c < 128).count()\n   |             \
    \                             ^^^ expected `&char`, found integer\n\nerror[E0599]:\
    \ `Option<usize>` is not an iterator\n   --> /tmp/tmp16lxptu4.rs:16:10\n    |\n\
    16  |           .cloned()\n    |            ^^^^^^ `Option<usize>` is not an iterator\n\
    \    |\n    = note: the following trait bounds were not satisfied:\n         \
    \   `Option<usize>: Iterator`\n            which is required by `&mut Option<usize>:\
    \ Iterator`\n\nerror[E0599]: no method named `unwrap` found for struct `Vec<&String>`\
    \ in the current scope\n  --> /tmp/tmp16lxptu4.rs:17:100\n   |\n17 |         .map(|count|\
    \ strings.iter().take_while(|s| count == s.chars().count()).collect::<Vec<_>>().unwrap().first())\n\
    \   |                                                                        \
    \                            ^^^^^^ help: there is an associated function with\
    \ a similar name: `swap`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.iter()\n        .map(|s| s.len())\n        .max()\n        .cloned()\n\
    \        .or_else(|| None)\n}\n\nfn main() {\n    let candidate = longest;\n \
    \   assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `Option<usize>` is not an iterator\n   --> /tmp/tmpk5vd05i7.rs:13:10\n\
    \    |\n13  |           .cloned()\n    |            ^^^^^^ `Option<usize>` is\
    \ not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Option<usize>: Iterator`\n            which is required by `&mut\
    \ Option<usize>: Iterator`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings\n        .iter()\n        .map(|s| {\n            if s.len()\
    \ > 0 {\n                Some(s)\n            } else {\n                None\n\
    \            }\n        })\n        .max()\n        .unwrap_or(None)\n}\n\nfn\
    \ main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpih4_m53r.rs:10:5\n   |\n\
    9  |   fn longest(strings: Vec<String>) -> Option<String> {\n   |            \
    \                           -------------- expected `Option<String>` because of\
    \ return type\n10 | /     strings\n11 | |         .iter()\n12 | |         .map(|s|\
    \ {\n13 | |             if s.len() > 0 {\n...  |\n19 | |         .max()\n20 |\
    \ |         .unwrap_or(None)\n   | |________________________^ expected struct\
    \ `String`, found `&String`\n   |\n   = note: expected enum `Option<String>`\n\
    \              found enum `Option<&String>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut m = HashMap::new();\n    for s in strings {\n        m.entry(s.len()).or_default().insert(s);\n\
    \    }\n    let mut longest = m.entry(m.len()).or_insert(String::from(\"\"));\n\
    \    for s in m.values() {\n        if s.len() > longest.len() {\n           \
    \ longest = s;\n        }\n    }\n    longest\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmphb_xf1yh.rs:10:17\n   |\n10 |     let mut m = HashMap::new();\n   |\
    \                 ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n\n    let mut lengths:\
    \ Vec<usize> = strings.iter().map(|s| s.chars().count()).collect();\n    lengths.sort_by_key(|length|\
    \ length);\n    let longest = strings[lengths.len() - 1];\n    if longest.len()\
    \ < lengths.len() {\n        longest\n    } else {\n        Some(strings.iter().max_by_key(|s|\
    \ s.len()).unwrap_or(String::new()))\n    }\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0x33yp4m.rs:18:9\n   |\n\
    9  | fn longest(strings: Vec<String>) -> Option<String> {\n   |              \
    \                       -------------- expected `Option<String>` because of return\
    \ type\n...\n18 |         longest\n   |         ^^^^^^^ expected enum `Option`,\
    \ found struct `String`\n   |\n   = note: expected enum `Option<String>`\n   \
    \         found struct `String`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n18 |         Some(longest)\n   |         +++++       +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp0x33yp4m.rs:20:63\n   |\n20 |         Some(strings.iter().max_by_key(|s|\
    \ s.len()).unwrap_or(String::new()))\n   |                                   \
    \                            ^^^^^^^^^^^^^\n   |                             \
    \                                  |\n   |                                   \
    \                            expected `&String`, found struct `String`\n   | \
    \                                                              help: consider\
    \ borrowing here: `&String::new()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0x33yp4m.rs:20:14\n\
    \   |\n20 |         Some(strings.iter().max_by_key(|s| s.len()).unwrap_or(String::new()))\n\
    \   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |              |\n \
    \  |              expected struct `String`, found `&String`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut longest = String::new();\n    let mut current_longest = String::new();\n\
    \    for s in strings {\n        if s.len() > current_longest.len() {\n      \
    \      current_longest = s;\n        }\n        if s.len() > longest {\n     \
    \       longest = s.len();\n        }\n    }\n    if current_longest.len() ==\
    \ longest {\n        Some(current_longest)\n    } else {\n        None\n    }\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdwevqrd_.rs:16:22\n   |\n\
    16 |         if s.len() > longest {\n   |                      ^^^^^^^ expected\
    \ `usize`, found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdwevqrd_.rs:17:23\n\
    \   |\n10 |     let mut longest = String::new();\n   |                       -------------\
    \ expected due to this value\n...\n17 |             longest = s.len();\n   | \
    \                      ^^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                       |\n   |                       expected struct `String`,\
    \ found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdwevqrd_.rs:20:33\n\
    \   |\n20 |     if current_longest.len() == longest {\n   |                  \
    \               ^^^^^^^ expected `usize`, found struct `String`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut lengths = Vec::new();\n    for s in strings {\n        match\
    \ s.length() {\n            0 => return None,\n            x => lengths.push(x.clone()),\n\
    \        }\n    }\n    if lengths.len() == 0 {\n        return None;\n    }\n\
    \    let mut len = 0;\n    for s in lengths {\n        if s < len {\n        \
    \    len = s;\n        }\n    }\n    strings.iter().fold(None, |a, b| {\n    \
    \    if *a > *b {\n            a\n        } else {\n            b\n        }\n\
    \    })\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpzr2ytdu2.rs:12:17\n   |\n12 |         match s.length()\
    \ {\n   |                 ^^^^^^ help: there is an associated function with a\
    \ similar name: `len`\n\nerror[E0614]: type `Option<String>` cannot be dereferenced\n\
    \  --> /tmp/tmpzr2ytdu2.rs:27:12\n   |\n27 |         if *a > *b {\n   |      \
    \      ^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzr2ytdu2.rs:30:13\n\
    \   |\n30 |             b\n   |             ^ expected enum `Option`, found `&String`\n\
    \   |\n   = note:   expected enum `Option<String>`\n           found reference\
    \ `&String`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599, E0614.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.iter().max_by_key(|s| s.len()).unwrap()\n}\n\nfn main() {\n \
    \   let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9fkxcjrf.rs:10:5\n   |\n\
    9  | fn longest(strings: Vec<String>) -> Option<String> {\n   |              \
    \                       -------------- expected `Option<String>` because of return\
    \ type\n10 |     strings.iter().max_by_key(|s| s.len()).unwrap()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected enum `Option`, found `&String`\n   |\n   = note:   expected enum `Option<String>`\n\
    \           found reference `&String`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 101
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    // Find the longest string\n    strings\n        .iter()\n        .max_by_key(|s|\
    \ s.len())\n        .cloned()\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmpd_kf3uf8.rs:20:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.iter().fold(\n        None,\n        |max_strings: Option<String>,\
    \ string: &str| {\n            max_strings.map_or(Some(string), |mut max_string|\
    \ {\n                if max_string.len() > string.len() {\n                  \
    \  Some(max_string)\n                } else {\n                    None\n    \
    \            }\n            })\n        },\n    )\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmph7et30db.rs:15:26\n   |\n\
    15 |                     Some(max_string)\n   |                          ^^^^^^^^^^\n\
    \   |                          |\n   |                          expected `&str`,\
    \ found struct `String`\n   |                          help: consider borrowing\
    \ here: `&max_string`\n\nerror[E0631]: type mismatch in closure arguments\n  \
    \  --> /tmp/tmph7et30db.rs:10:20\n     |\n10   |     strings.iter().fold(\n  \
    \   |                    ^^^^ expected signature of `fn(Option<String>, &String)\
    \ -> _`\n11   |         None,\n12   |         |max_strings: Option<String>, string:\
    \ &str| {\n     |         ------------------------------------------- found signature\
    \ of `for<'r> fn(Option<String>, &'r str) -> _`\n     |\nnote: required by a bound\
    \ in `fold`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0631.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 0
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    if strings.is_empty() {\n        return None;\n    }\n    let mut max_len\
    \ = 0;\n    let mut max_string = String::default();\n    for string in strings\
    \ {\n        if string.len() > max_len {\n            max_len = string.len();\n\
    \            max_string = string;\n        }\n    }\n    Some(max_string)\n}\n\
    \nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.iter().max_by(|a, b| a.len() as usize - b.len() as usize)\n}\n\
    \nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpelxrrzq4.rs:10:34\n   |\n\
    10 |     strings.iter().max_by(|a, b| a.len() as usize - b.len() as usize)\n \
    \  |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ enum `std::cmp::Ordering`, found `usize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpelxrrzq4.rs:10:5\n   |\n9  | fn longest(strings: Vec<String>) ->\
    \ Option<String> {\n   |                                     -------------- expected\
    \ `Option<String>` because of return type\n10 |     strings.iter().max_by(|a,\
    \ b| a.len() as usize - b.len() as usize)\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&String`\n   |\n   = note: expected enum `Option<String>`\n\
    \              found enum `Option<&String>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 101
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    let mut max_len = strings.iter().map(|s| s.len()).max().unwrap();\n \
    \   strings.iter().find(|s| s.len() == max_len).cloned()\n}\n\nfn main() {\n \
    \   let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Option::unwrap()` on a `None` value'',
    /tmp/tmp47pwjzrd.rs:10:61

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.iter().map(|s| s.len()).max().map(|i| strings[i as usize])\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpgm3245v3.rs:10:51\n\
    \   |\n10 |     strings.iter().map(|s| s.len()).max().map(|i| strings[i as usize])\n\
    \   |                                                   ^^^^^^^^^^^^^^^^^^^ move\
    \ occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0507`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    // find the longest length\n    let mut longest_len = strings[0].chars().count();\n\
    \    for s in strings {\n        if longest_len > s.chars().count() {\n      \
    \      longest_len = s.chars().count();\n        }\n    }\n\n    // find the first\
    \ one with that length\n    longest_len\n        .into_iter()\n        .cloned()\n\
    \        .find(|s| strings[0].chars().count() == s)\n        .cloned()\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `usize` is not an iterator\n  --> /tmp/tmpuc3rhvbs.rs:20:10\n\
    \   |\n20 |         .into_iter()\n   |          ^^^^^^^^^ `usize` is not an iterator\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `usize:\
    \ Iterator`\n           which is required by `usize: IntoIterator`\n         \
    \  `&usize: Iterator`\n           which is required by `&usize: IntoIterator`\n\
    \           `&mut usize: Iterator`\n           which is required by `&mut usize:\
    \ IntoIterator`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Out of vector of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n///\
    \ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String>\
    \ {\n    strings.iter().cloned().filter_map(|s| s.chars().max()).next()\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpanr8gs__.rs:10:5\n   |\n\
    9  | fn longest(strings: Vec<String>) -> Option<String> {\n   |              \
    \                       -------------- expected `Option<String>` because of return\
    \ type\n10 |     strings.iter().cloned().filter_map(|s| s.chars().max()).next()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `String`, found `char`\n   |\n   = note: expected enum `Option<String>`\n\
    \              found enum `Option<char>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976610
