language: rs
name: HumanEval_98_count_upper
results:
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ *c >= 'A' && *c <= 'Z').filter(|c| *c & 0b100 != 0).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char & {integer}`\n  --> /tmp/tmpai5njd7i.rs:10:64\n\
    \   |\n10 |     s.chars().filter(|c| *c >= 'A' && *c <= 'Z').filter(|c| *c & 0b100\
    \ != 0).count()\n   |                                                        \
    \     -- ^ ----- {integer}\n   |                                             \
    \                |\n   |                                                     \
    \        char\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpai5njd7i.rs:10:5\n\
    \   |\n9  | fn count_upper(s: String) -> isize {\n   |                       \
    \       ----- expected `isize` because of return type\n10 |     s.chars().filter(|c|\
    \ *c >= 'A' && *c <= 'Z').filter(|c| *c & 0b100 != 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ *c >= 'A' && *c <= 'Z').filter(|c| *c & 0b100 != 0).count().try_into().unwrap()\n\
    \   |                                                                        \
    \             ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0369.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009132
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().count(|&c|\
    \ c >= 'A' && c <= 'Z' && c != 'a' && c != 'e' && c != 'i' && c != 'o' && c !=\
    \ 'u')\n}\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmpu6gfcy45.rs:10:15\n    |\n10  |     s.chars().count(|&c| c >=\
    \ 'A' && c <= 'Z' && c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u')\n\
    \    |               ^^^^^ -------------------------------------------------------------------------------------\
    \ supplied 1 argument\n    |               |\n    |               expected 0 arguments\n\
    \    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpu6gfcy45.rs:10:5\n   |\n9  | fn count_upper(s: String) -> isize\
    \ {\n   |                              ----- expected `isize` because of return\
    \ type\n10 |     s.chars().count(|&c| c >= 'A' && c <= 'Z' && c != 'a' && c !=\
    \ 'e' && c != 'i' && c != 'o' && c != 'u')\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().count(|&c|\
    \ c >= 'A' && c <= 'Z' && c != 'a' && c != 'e' && c != 'i' && c != 'o' && c !=\
    \ 'u').try_into().unwrap()\n   |                                             \
    \                                                              ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0308.\nFor more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660009132
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    let mut count = s.chars().filter_map(|c|\
    \ match c {\n        c if c.is_uppercase() => Some(1),\n        _ => None,\n \
    \   })\n    .count();\n    count.checked_add(1, |&a| a.is_some())\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `&_`\n  --> /tmp/tmpnvbrwvnc.rs:15:27\n\
    \   |\n15 |     count.checked_add(1, |&a| a.is_some())\n   |                 \
    \          ^^ consider giving this closure parameter the explicit type `&_`, with\
    \ the type parameters specified\n   |\n   = note: type must be known at this point\n\
    \nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \   --> /tmp/tmpnvbrwvnc.rs:15:11\n    |\n15  |     count.checked_add(1, |&a|\
    \ a.is_some())\n    |           ^^^^^^^^^^^ -  ---------------- supplied 2 arguments\n\
    \    |           |\n    |           expected 1 argument\n    |\nnote: associated\
    \ function defined here\n    = note: this error originates in the macro `uint_impl`\
    \ (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpnvbrwvnc.rs:15:5\n   |\n9  | fn count_upper(s:\
    \ String) -> isize {\n   |                              ----- expected `isize`\
    \ because of return type\n...\n15 |     count.checked_add(1, |&a| a.is_some())\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found enum\
    \ `Option`\n   |\n   = note: expected type `isize`\n              found enum `Option<usize>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0282, E0308.\nFor more information about an error, try `rustc --explain\
    \ E0061`.\n"
  stdout: ''
  timestamp: 1660009132
- exit_code: 101
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter_map(|c|\
    \ match c {\n        'a' => Some(1),\n        'b' => Some(2),\n        'c' =>\
    \ Some(3),\n        'd' => Some(4),\n        'e' => Some(5),\n        'f' => Some(6),\n\
    \        'g' => Some(7),\n        _ => None,\n    }).sum()\n}\n\nfn main() {\n\
    \    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `11`,\n right: `1`', /tmp/tmp0262n3ix.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter_map(|c|\
    \ match c {\n        c if c.is_uppercase() || c.is_lowercase() => (c, 1),\n  \
    \      _ => None,\n    })\n    .count();\n}\n\nfn main() {\n    let candidate\
    \ = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n  \
    \  assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpljqb4dpc.rs:11:54\n   |\n\
    11 |         c if c.is_uppercase() || c.is_lowercase() => (c, 1),\n   |      \
    \                                                ^^^^^^ expected enum `Option`,\
    \ found tuple\n   |\n   = note: expected enum `Option<_>`\n             found\
    \ tuple `(char, {integer})`\nhelp: try wrapping the expression in `Some`\n   |\n\
    11 |         c if c.is_uppercase() || c.is_lowercase() => Some((c, 1)),\n   |\
    \                                                      +++++      +\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpljqb4dpc.rs:9:30\n  |\n9 | fn count_upper(s:\
    \ String) -> isize {\n  |    -----------               ^^^^^ expected `isize`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009132
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    let mut i = 0;\n  \
    \  while i < s.len() {\n        if s[i].is_upper() {\n            i += 1;\n  \
    \      } else {\n            break;\n        }\n    }\n    i\n}\n\nfn main() {\n\
    \    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpxuvpy8q_.rs:12:12\n\
    \   |\n12 |         if s[i].is_upper() {\n   |            ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxuvpy8q_.rs:18:5\n\
    \   |\n9  | fn count_upper(s: String) -> isize {\n   |                       \
    \       ----- expected `isize` because of return type\n...\n18 |     i\n   | \
    \    ^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize`\
    \ to an `isize` and panic if the converted value doesn't fit\n   |\n18 |     i.try_into().unwrap()\n\
    \   |      ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009132
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    if s.is_empty() {\n\
    \        return 0;\n    }\n    let mut counter = 0;\n    let mut lower = s.to_lowercase();\n\
    \    for c in &lower[..] {\n        if c.is_uppercase() || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u' {\n            counter += 1;\n        }\n    }\n   \
    \ counter\n}\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&str` is not an iterator\n  --> /tmp/tmph6hidvba.rs:15:14\n\
    \   |\n15 |     for c in &lower[..] {\n   |              ^^^^^^^^^^ `&str` is\
    \ not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `&str`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `&str`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660009132
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().enumerate().filter(|(_,\
    \ ch)| ch.is_uppercase()).filter(|(_, ch)| ch.is_ascii_uppercase())\n        .count();\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpsgw5wmkq.rs:9:30\n  |\n9 |\
    \ fn count_upper(s: String) -> isize {\n  |    -----------               ^^^^^\
    \ expected `isize`, found `()`\n  |    |\n  |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009132
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    count_upper_inner(&mut\
    \ s.as_bytes())\n}\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_upper_inner` in this scope\n\
    \  --> /tmp/tmptt_tor3b.rs:10:5\n   |\n10 |     count_upper_inner(&mut s.as_bytes())\n\
    \   |     ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660009132
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    count_by_len(s.as_bytes(),\
    \ s.len(), |&b| b.iter().any(|&x| x == b'A'))\n}\n\nfn main() {\n    let candidate\
    \ = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n  \
    \  assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_by_len` in this scope\n  -->\
    \ /tmp/tmp49vj0kyj.rs:10:5\n   |\n10 |     count_by_len(s.as_bytes(), s.len(),\
    \ |&b| b.iter().any(|&x| x == b'A'))\n   |     ^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009132
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c == b'A' || c == b'a').count() as isize\n}\n\nfn main() {\n    let candidate\
    \ = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n  \
    \  assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpoz24850w.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c == b'A' || c == b'a').count() as isize\n   | \
    \                              ^^^^ expected `char`, found `u8`\n\nerror[E0277]:\
    \ can't compare `&char` with `u8`\n  --> /tmp/tmpoz24850w.rs:10:28\n   |\n10 |\
    \     s.chars().filter(|c| c == b'A' || c == b'a').count() as isize\n   |    \
    \                        ^^ no implementation for `&char == u8`\n   |\n   = help:\
    \ the trait `PartialEq<u8>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpoz24850w.rs:10:44\n   |\n10 |     s.chars().filter(|c| c == b'A' ||\
    \ c == b'a').count() as isize\n   |                                          \
    \  ^^^^ expected `char`, found `u8`\n\nerror[E0277]: can't compare `&char` with\
    \ `u8`\n  --> /tmp/tmpoz24850w.rs:10:41\n   |\n10 |     s.chars().filter(|c| c\
    \ == b'A' || c == b'a').count() as isize\n   |                               \
    \          ^^ no implementation for `&char == u8`\n   |\n   = help: the trait\
    \ `PartialEq<u8>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009132
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    let mut counter = 0;\n\
    \    s.chars()\n        .filter_map(|c| match c {\n            c if c.is_uppercase()\
    \ => counter = counter + 1,\n            c => false,\n        })\n        .count();\n\
    \    counter\n}\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphg_c07d3.rs:13:38\n   |\n\
    13 |             c if c.is_uppercase() => counter = counter + 1,\n   |       \
    \                               ^^^^^^^^^^^^^^^^^^^^^ expected enum `Option`,\
    \ found `()`\n   |\n   = note:   expected enum `Option<_>`\n           found unit\
    \ type `()`\nhelp: try wrapping the expression in `Some`\n   |\n13 |         \
    \    c if c.is_uppercase() => Some(counter = counter + 1),\n   |             \
    \                         +++++                     +\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660009132
- exit_code: 101
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ !c.is_uppercase()).filter(|c| c.is_ascii()).count() as isize\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `1`', /tmp/tmpwzgyq1d5.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    fn f(index: usize)\
    \ -> usize {\n        s[*index..].chars().filter_map(|c| c >= 'A' && c <= 'Z').count()\
    \ + 1\n    }\n\n    s.chars().filter_map(|c| {\n        c >= 'A' && c <= 'Z'\n\
    \    }).fold(0, f)\n}\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0434]: can't capture dynamic environment in a fn item\n  --> /tmp/tmpgjowisji.rs:11:9\n\
    \   |\n11 |         s[*index..].chars().filter_map(|c| c >= 'A' && c <= 'Z').count()\
    \ + 1\n   |         ^\n   |\n   = help: use the `|| { ... }` closure form instead\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpgjowisji.rs:15:9\n   |\n15 | \
    \        c >= 'A' && c <= 'Z'\n   |         ^^^^^^^^^^^^^^^^^^^^ expected enum\
    \ `Option`, found `bool`\n   |\n   = note: expected enum `Option<_>`\n       \
    \       found type `bool`\nhelp: try wrapping the expression in `Some`\n   |\n\
    15 |         Some(c >= 'A' && c <= 'Z')\n   |         +++++                  \
    \  +\n\nerror[E0593]: function is expected to take 2 arguments, but it takes 1\
    \ argument\n    --> /tmp/tmpgjowisji.rs:16:16\n     |\n10   |     fn f(index:\
    \ usize) -> usize {\n     |     --------------------------- takes 1 argument\n\
    ...\n16   |     }).fold(0, f)\n     |        ----    ^ expected function that\
    \ takes 2 arguments\n     |        |\n     |        required by a bound introduced\
    \ by this call\n     |\nnote: required by a bound in `fold`\n\nerror[E0614]: type\
    \ `usize` cannot be dereferenced\n  --> /tmp/tmpgjowisji.rs:11:11\n   |\n11 |\
    \         s[*index..].chars().filter_map(|c| c >= 'A' && c <= 'Z').count() + 1\n\
    \   |           ^^^^^^\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0434, E0593, E0614.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009132
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    count_upper_in_even_indices(s.as_bytes())\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_upper_in_even_indices` in this\
    \ scope\n  --> /tmp/tmpwbynei1u.rs:10:5\n   |\n10 |     count_upper_in_even_indices(s.as_bytes())\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660009132
- exit_code: 101
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    let mut vowel_count\
    \ = 0;\n\n    for (i, c) in s.chars().enumerate() {\n        if ((i & 1) == 0)\
    \ && (c >= 'A' && c <= 'Z') {\n            vowel_count += 1;\n        }\n    }\n\
    \n    vowel_count\n}\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `1`', /tmp/tmp8fz2izvx.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars()\n       \
    \ .filter(|&c| c.is_uppercase())\n        .filter(|&c| {\n            c.is_alphanumeric()\
    \ || c.is_separator()\n        })\n        .filter(|&c| {\n            c.is_lowercase()\
    \ && c != u'-'\n        })\n        .filter(|&c| {\n            c.is_lowercase()\
    \ && !(c >= u'A' && c <= u'Z')\n        })\n        .count()\n}\n\nfn main() {\n\
    \    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator,\
    \ found `'-'`\n  --> /tmp/tmpgkpf3x81.rs:16:39\n   |\n16 |             c.is_lowercase()\
    \ && c != u'-'\n   |                                       ^^^ expected one of\
    \ 8 possible tokens\n\nerror: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`,\
    \ or an operator, found `'A'`\n  --> /tmp/tmpgkpf3x81.rs:19:41\n   |\n19 |   \
    \          c.is_lowercase() && !(c >= u'A' && c <= u'Z')\n   |               \
    \                          -^^\n   |                                         |\n\
    \   |                                         expected one of 8 possible tokens\n\
    \   |                                         help: missing `,`\n\nerror: expected\
    \ one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `'Z'`\n  -->\
    \ /tmp/tmpgkpf3x81.rs:19:54\n   |\n19 |             c.is_lowercase() && !(c >=\
    \ u'A' && c <= u'Z')\n   |                                                   \
    \   -^^\n   |                                                      |\n   |   \
    \                                                   expected one of 8 possible\
    \ tokens\n   |                                                      help: missing\
    \ `,`\n\nerror[E0425]: cannot find value `u` in this scope\n  --> /tmp/tmpgkpf3x81.rs:19:40\n\
    \   |\n19 |             c.is_lowercase() && !(c >= u'A' && c <= u'Z')\n   |  \
    \                                      ^ help: a local variable with a similar\
    \ name exists: `c`\n\nerror[E0425]: cannot find value `u` in this scope\n  -->\
    \ /tmp/tmpgkpf3x81.rs:19:53\n   |\n19 |             c.is_lowercase() && !(c >=\
    \ u'A' && c <= u'Z')\n   |                                                   \
    \  ^ help: a local variable with a similar name exists: `c`\n\nerror[E0599]: no\
    \ method named `is_separator` found for type `char` in the current scope\n  -->\
    \ /tmp/tmpgkpf3x81.rs:13:38\n   |\n13 |             c.is_alphanumeric() || c.is_separator()\n\
    \   |                                      ^^^^^^^^^^^^ method not found in `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpgkpf3x81.rs:19:41\n   |\n19 |\
    \             c.is_lowercase() && !(c "
  stdout: ''
  timestamp: 1660009132
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().count::<u32>(|c|\
    \ c >= 'a' && c <= 'z' && c != 'A' && c != 'E')\n}\n\nfn main() {\n    let candidate\
    \ = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n  \
    \  assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0107]: this associated function takes 0 generic arguments but 1\
    \ generic argument was supplied\n  --> /tmp/tmp4_bj0n_v.rs:10:15\n   |\n10 | \
    \    s.chars().count::<u32>(|c| c >= 'a' && c <= 'z' && c != 'A' && c != 'E')\n\
    \   |               ^^^^^------- help: remove these generics\n   |           \
    \    |\n   |               expected 0 generic arguments\n\nerror[E0061]: this\
    \ function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp4_bj0n_v.rs:10:15\n\
    \    |\n10  |     s.chars().count::<u32>(|c| c >= 'a' && c <= 'z' && c != 'A'\
    \ && c != 'E')\n    |               ^^^^^        ------------------------------------------------\
    \ supplied 1 argument\n    |               |\n    |               expected 0 arguments\n\
    \    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp4_bj0n_v.rs:10:5\n   |\n9  | fn count_upper(s: String) -> isize\
    \ {\n   |                              ----- expected `isize` because of return\
    \ type\n10 |     s.chars().count::<u32>(|c| c >= 'a' && c <= 'z' && c != 'A' &&\
    \ c != 'E')\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().count::<u32>(|c|\
    \ c >= 'a' && c <= 'z' && c != 'A' && c != 'E').try_into().unwrap()\n   |    \
    \                                                                         ++++++++++++++++++++\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0107, E0308.\nFor more information about an error, try `rustc --explain\
    \ E0061`.\n"
  stdout: ''
  timestamp: 1660009132
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').filter(|c| *c != c).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpap9xun2w.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'a' && c <= 'z').filter(|c| *c != c).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'a'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpap9xun2w.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').filter(|c| *c != c).count()\n   |                    \
    \                       ^^^\n   |                                           |\n\
    \   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'z'`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpap9xun2w.rs:10:65\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'a' && c <= 'z').filter(|c| *c != c).count()\n\
    \   |                                                                 ^ expected\
    \ `char`, found `&char`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    10 |     s.chars().filter(|c| c >= 'a' && c <= 'z').filter(|c| *c != *c).count()\n\
    \   |                                                                 +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpap9xun2w.rs:10:5\n   |\n9  | fn count_upper(s:\
    \ String) -> isize {\n   |                              ----- expected `isize`\
    \ because of return type\n10 |     s.chars().filter(|c| c >= 'a' && c <= 'z').filter(|c|\
    \ *c != c).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').filter(|c| *c != c).count().try_into().unwrap()\n   |\
    \                                                                           ++++++++++++++++++++\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009132
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter_map(|c|\
    \ if c == 'A' || c == 'E' || c == 'I' || c == 'O' {\n        Some(true)\n    }\
    \ else {\n        Some(false)\n    }).count()\n}\n\nfn main() {\n    let candidate\
    \ = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n  \
    \  assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp21hsa5x0.rs:10:5\n   |\n\
    9  |   fn count_upper(s: String) -> isize {\n   |                            \
    \    ----- expected `isize` because of return type\n10 | /     s.chars().filter_map(|c|\
    \ if c == 'A' || c == 'E' || c == 'I' || c == 'O' {\n11 | |         Some(true)\n\
    12 | |     } else {\n13 | |         Some(false)\n14 | |     }).count()\n   | |______________^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n14 |     }).count().try_into().unwrap()\n\
    \   |               ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009132
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars()\n       \
    \ .filter(|c| c.is_upper())\n        .filter(|c| c.is_lower())\n        .count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_upper` found for reference `&char` in\
    \ the current scope\n  --> /tmp/tmpwl8bx1j9.rs:11:23\n   |\n11 |         .filter(|c|\
    \ c.is_upper())\n   |                       ^^^^^^^^ help: there is an associated\
    \ function with a similar name: `is_uppercase`\n\nerror[E0599]: no method named\
    \ `is_lower` found for reference `&char` in the current scope\n  --> /tmp/tmpwl8bx1j9.rs:12:23\n\
    \   |\n12 |         .filter(|c| c.is_lower())\n   |                       ^^^^^^^^\
    \ help: there is an associated function with a similar name: `is_lowercase`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpwl8bx1j9.rs:10:5\n   |\n9  |   fn\
    \ count_upper(s: String) -> isize {\n   |                                -----\
    \ expected `isize` because of return type\n10 | /     s.chars()\n11 | |      \
    \   .filter(|c| c.is_upper())\n12 | |         .filter(|c| c.is_lower())\n13 |\
    \ |         .count()\n   | |________________^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         .count().try_into().unwrap()\n   |   \
    \              ++++++++++++++++++++\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009132
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().enumerate().filter(|(_,\
    \ c)| c.is_uppercase()).count().saturating_sub(1).ok_or(Error::OutOfBound)?\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Error`\n  -->\
    \ /tmp/tmpem3kuvr1.rs:10:93\n   |\n10 |     s.chars().enumerate().filter(|(_,\
    \ c)| c.is_uppercase()).count().saturating_sub(1).ok_or(Error::OutOfBound)?\n\
    \   |                                                                        \
    \                     ^^^^^ use of undeclared type `Error`\n\nerror[E0599]: no\
    \ method named `ok_or` found for type `usize` in the current scope\n  --> /tmp/tmpem3kuvr1.rs:10:87\n\
    \   |\n10 |     s.chars().enumerate().filter(|(_, c)| c.is_uppercase()).count().saturating_sub(1).ok_or(Error::OutOfBound)?\n\
    \   |                                                                        \
    \               ^^^^^ method not found in `usize`\n\nerror[E0277]: the `?` operator\
    \ can only be used in a function that returns `Result` or `Option` (or another\
    \ type that implements `FromResidual`)\n  --> /tmp/tmpem3kuvr1.rs:10:111\n   |\n\
    9  | / fn count_upper(s: String) -> isize {\n10 | |     s.chars().enumerate().filter(|(_,\
    \ c)| c.is_uppercase()).count().saturating_sub(1).ok_or(Error::OutOfBound)?\n\
    \   | |                                                                      \
    \                                         ^ cannot use the `?` operator in a function\
    \ that returns `isize`\n11 | | }\n   | |_- this function should return `Result`\
    \ or `Option` to accept `?`\n   |\n   = help: the trait `FromResidual<_>` is not\
    \ implemented for `isize`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0433, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009132
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    let mut i = 0;\n  \
    \  while i < s.len() {\n        if i % 2 == 0 {\n            if s[i].is_uppercase()\
    \ {\n                i += 1;\n                continue;\n            }\n     \
    \   } else {\n            if s[i].is_lowercase() {\n                i += 1;\n\
    \                continue;\n            }\n        }\n        break;\n    }\n\
    \    i\n}\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpx04rqld2.rs:13:16\n\
    \   |\n13 |             if s[i].is_uppercase() {\n   |                ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpx04rqld2.rs:18:16\n   |\n18 |             if s[i].is_lowercase()\
    \ {\n   |                ^^^^ `String` cannot be indexed by `usize`\n   |\n  \
    \ = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpx04rqld2.rs:25:5\n   |\n9  | fn count_upper(s:\
    \ String) -> isize {\n   |                              ----- expected `isize`\
    \ because of return type\n...\n25 |     i\n   |     ^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n25 |     i.try_into().unwrap()\n   |    \
    \  ++++++++++++++++++++\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009132
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars()\n       \
    \ .filter(|c| c.is_uppercase())\n        .filter(|c| c.is_ascii_uppercase())\n\
    \        .filter(|c| c % 2 == 0)\n        .filter(|c| c.is_ascii_lowercase())\n\
    \        .filter(|c| c.is_ascii_ascii_lowercase())\n        .count()\n}\n\nfn\
    \ main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpscx3ojog.rs:13:23\n\
    \   |\n13 |         .filter(|c| c % 2 == 0)\n   |                     - ^ - {integer}\n\
    \   |                     |\n   |                     &char\n\nerror[E0599]: no\
    \ method named `is_ascii_ascii_lowercase` found for reference `&char` in the current\
    \ scope\n  --> /tmp/tmpscx3ojog.rs:15:23\n   |\n15 |         .filter(|c| c.is_ascii_ascii_lowercase())\n\
    \   |                       ^^^^^^^^^^^^^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `is_ascii_lowercase`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpscx3ojog.rs:10:5\n   |\n9  |   fn count_upper(s: String)\
    \ -> isize {\n   |                                ----- expected `isize` because\
    \ of return type\n10 | /     s.chars()\n11 | |         .filter(|c| c.is_uppercase())\n\
    12 | |         .filter(|c| c.is_ascii_uppercase())\n13 | |         .filter(|c|\
    \ c % 2 == 0)\n14 | |         .filter(|c| c.is_ascii_lowercase())\n15 | |    \
    \     .filter(|c| c.is_ascii_ascii_lowercase())\n16 | |         .count()\n   |\
    \ |________________^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    16 |         .count().try_into().unwrap()\n   |                 ++++++++++++++++++++\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660009132
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().enumerate().filter(|(_,\
    \ v)| v >= 'A' && v <= 'Z').filter(|(_, v)| v % 2 != 0).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpalutild3.rs:10:48\n   |\n\
    10 |     s.chars().enumerate().filter(|(_, v)| v >= 'A' && v <= 'Z').filter(|(_,\
    \ v)| v % 2 != 0).count()\n   |                                              \
    \  ^^^\n   |                                                |\n   |          \
    \                                      expected `&char`, found `char`\n   |  \
    \                                              help: consider borrowing here:\
    \ `&'A'`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpalutild3.rs:10:60\n\
    \   |\n10 |     s.chars().enumerate().filter(|(_, v)| v >= 'A' && v <= 'Z').filter(|(_,\
    \ v)| v % 2 != 0).count()\n   |                                              \
    \              ^^^\n   |                                                     \
    \       |\n   |                                                            expected\
    \ `&char`, found `char`\n   |                                                \
    \            help: consider borrowing here: `&'Z'`\n\nerror[E0369]: cannot mod\
    \ `&char` by `{integer}`\n  --> /tmp/tmpalutild3.rs:10:83\n   |\n10 |     s.chars().enumerate().filter(|(_,\
    \ v)| v >= 'A' && v <= 'Z').filter(|(_, v)| v % 2 != 0).count()\n   |        \
    \                                                                         - ^\
    \ - {integer}\n   |                                                          \
    \                       |\n   |                                              \
    \                                   &char\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpalutild3.rs:10:5\n   |\n9  | fn count_upper(s: String) -> isize\
    \ {\n   |                              ----- expected `isize` because of return\
    \ type\n10 |     s.chars().enumerate().filter(|(_, v)| v >= 'A' && v <= 'Z').filter(|(_,\
    \ v)| v % 2 != 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().enumerate().filter(|(_,\
    \ v)| v >= 'A' && v <= 'Z').filter(|(_, v)|"
  stdout: ''
  timestamp: 1660009132
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    count_upper(s.chars(),\
    \ 0, s.len())\n}\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 3 arguments were supplied\n\
    \  --> /tmp/tmp168g_gj2.rs:10:5\n   |\n10 |     count_upper(s.chars(), 0, s.len())\n\
    \   |     ^^^^^^^^^^^ ---------  -  ------- supplied 3 arguments\n   |     |\n\
    \   |     expected 1 argument\n   |\nnote: function defined here\n  --> /tmp/tmp168g_gj2.rs:9:4\n\
    \   |\n9  | fn count_upper(s: String) -> isize {\n   |    ^^^^^^^^^^^ ---------\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660009132
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    let mut i = 0;\n  \
    \  for (i, c) in s.chars().enumerate() {\n        match c {\n            c if\
    \ c.is_uppercase() => i += 1,\n            _ => continue,\n        }\n    }\n\
    \    i\n}\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "warning: variable `i` is assigned to, but never used\n  --> /tmp/tmpv25okbtn.rs:11:10\n\
    \   |\n11 |     for (i, c) in s.chars().enumerate() {\n   |          ^\n   |\n\
    \   = note: `#[warn(unused_variables)]` on by default\n   = note: consider using\
    \ `_i` instead\n\nwarning: value assigned to `i` is never read\n  --> /tmp/tmpv25okbtn.rs:13:38\n\
    \   |\n13 |             c if c.is_uppercase() => i += 1,\n   |               \
    \                       ^\n   |\n   = note: `#[warn(unused_assignments)]` on by\
    \ default\n   = help: maybe it is overwritten before being read?\n\nwarning: variable\
    \ does not need to be mutable\n  --> /tmp/tmpv25okbtn.rs:10:9\n   |\n10 |    \
    \ let mut i = 0;\n   |         ----^\n   |         |\n   |         help: remove\
    \ this `mut`\n   |\n   = note: `#[warn(unused_mut)]` on by default\n\nerror[E0384]:\
    \ cannot assign twice to immutable variable `i`\n  --> /tmp/tmpv25okbtn.rs:13:38\n\
    \   |\n11 |     for (i, c) in s.chars().enumerate() {\n   |          -\n   | \
    \         |\n   |          first assignment to `i`\n   |          help: consider\
    \ making this binding mutable: `mut i`\n12 |         match c {\n13 |         \
    \    c if c.is_uppercase() => i += 1,\n   |                                  \
    \    ^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to\
    \ previous error; 3 warnings emitted\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1660009132
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    let mut isize = s.len();\n\
    \    for i in (0..isize).step_by(2) {\n        if s[i].is_uppercase() && s[i+1].is_uppercase()\
    \ {\n            isize -= 1;\n        }\n    }\n    isize\n}\n\nfn main() {\n\
    \    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpsy5slrip.rs:12:12\n\
    \   |\n12 |         if s[i].is_uppercase() && s[i+1].is_uppercase() {\n   |  \
    \          ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpsy5slrip.rs:12:35\n   |\n12 |         if s[i].is_uppercase() &&\
    \ s[i+1].is_uppercase() {\n   |                                   ^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsy5slrip.rs:16:5\n\
    \   |\n9  | fn count_upper(s: String) -> isize {\n   |                       \
    \       ----- expected `isize` because of return type\n...\n16 |     isize\n \
    \  |     ^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a\
    \ `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n16\
    \ |     isize.try_into().unwrap()\n   |          ++++++++++++++++++++\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009132
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ !c.is_upper()).count() // 0 means no uppercase letters.\n}\n\nfn main() {\n\
    \    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_upper` found for reference `&char` in\
    \ the current scope\n  --> /tmp/tmp78jz0p7z.rs:10:29\n   |\n10 |     s.chars().filter(|c|\
    \ !c.is_upper()).count() // 0 means no uppercase letters.\n   |              \
    \               ^^^^^^^^ help: there is an associated function with a similar\
    \ name: `is_uppercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp78jz0p7z.rs:10:5\n\
    \   |\n9  | fn count_upper(s: String) -> isize {\n   |                       \
    \       ----- expected `isize` because of return type\n10 |     s.chars().filter(|c|\
    \ !c.is_upper()).count() // 0 means no uppercase letters.\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ !c.is_upper()).count().try_into().unwrap() // 0 means no uppercase letters.\n\
    \   |                                                ++++++++++++++++++++\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009132
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().enumerate().filter(|(_,\
    \ v)| v == 'A'..='Z').count();\n}\n\nfn main() {\n    let candidate = count_upper;\n\
    \    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"\
    abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpb8tgbh6n.rs:10:45\n\
    \   |\n10 |     s.chars().enumerate().filter(|(_, v)| v == 'A'..='Z').count();\n\
    \   |                                             ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpb8tgbh6n.rs:10:54\n   |\n10 |     s.chars().enumerate().filter(|(_,\
    \ v)| v == 'A'..='Z').count();\n   |                                         \
    \             ^^^ expected `bool`, found `char`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpb8tgbh6n.rs:10:43\n   |\n10 |     s.chars().enumerate().filter(|(_,\
    \ v)| v == 'A'..='Z').count();\n   |                                         \
    \  ^^^^^^^^^^^^^^ expected `bool`, found struct `RangeInclusive`\n   |\n   = note:\
    \ expected type `bool`\n            found struct `RangeInclusive<bool>`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpb8tgbh6n.rs:9:30\n  |\n9 | fn count_upper(s:\
    \ String) -> isize {\n  |    -----------               ^^^^^ expected `isize`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    iterate_even_indices(s,\
    \ |index| {\n        if index.is_even() {\n            let char = get_char(&s[index]);\n\
    \            if let Some(&'A'..'Z') = char {\n                return 1;\n    \
    \        }\n        }\n        0\n    })\n}\n\nfn main() {\n    let candidate\
    \ = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n  \
    \  assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error: the range pattern here has ambiguous interpretation\n  --> /tmp/tmpyh27zv9f.rs:13:26\n\
    \   |\n13 |             if let Some(&'A'..'Z') = char {\n   |                \
    \          ^^^^^^^^ help: add parentheses to clarify the precedence: `('A'..'Z')`\n\
    \nerror[E0425]: cannot find function `iterate_even_indices` in this scope\n  -->\
    \ /tmp/tmpyh27zv9f.rs:10:5\n   |\n10 |     iterate_even_indices(s, |index| {\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `get_char` in this scope\n  --> /tmp/tmpyh27zv9f.rs:12:24\n  \
    \ |\n12 |             let char = get_char(&s[index]);\n   |                  \
    \      ^^^^^^^^ not found in this scope\n\nerror[E0658]: exclusive range pattern\
    \ syntax is experimental\n  --> /tmp/tmpyh27zv9f.rs:13:26\n   |\n13 |        \
    \     if let Some(&'A'..'Z') = char {\n   |                          ^^^^^^^^\n\
    \   |\n   = note: see issue #37854 <https://github.com/rust-lang/rust/issues/37854>\
    \ for more information\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0425, E0658.\nFor more information about an error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009132
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.char_indices().filter_map(|(i,\
    \ c)| {\n        if c == 'A' || c == 'a' {\n            Some(i)\n        } else\
    \ {\n            None\n        }\n    }).count()\n}\n\nfn main() {\n    let candidate\
    \ = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n  \
    \  assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkc60nolc.rs:10:5\n   |\n\
    9  |   fn count_upper(s: String) -> isize {\n   |                            \
    \    ----- expected `isize` because of return type\n10 | /     s.char_indices().filter_map(|(i,\
    \ c)| {\n11 | |         if c == 'A' || c == 'a' {\n12 | |             Some(i)\n\
    13 | |         } else {\n14 | |             None\n15 | |         }\n16 | |   \
    \  }).count()\n   | |______________^ expected `isize`, found `usize`\n   |\nhelp:\
    \ you can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n16 |     }).count().try_into().unwrap()\n   |               ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009132
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    // https://doc.rust-lang.org/std/primitive.str.html#method.find\n\
    \    // https://doc.rust-lang.org/std/primitive.str.html#method.find_last_index\n\
    \    // https://doc.rust-lang.org/std/primitive.str.html#method.find\n\n    let\
    \ mut i = 0;\n    let mut j = s.len() - 1;\n    while i <= j {\n        let c\
    \ = s[i].chars().next().unwrap();\n        if c.is_uppercase() && (i % 2 == 0)\
    \ {\n            return i;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    0\n}\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpbkb9yok1.rs:17:17\n\
    \   |\n17 |         let c = s[i].chars().next().unwrap();\n   |              \
    \   ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbkb9yok1.rs:19:20\n\
    \   |\n19 |             return i;\n   |                    ^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n19 |             return i.try_into().unwrap();\n\
    \   |                     ++++++++++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009132
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    count_upper_aux(s,\
    \ 0, s.len() - 1)\n}\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_upper_aux` in this scope\n  -->\
    \ /tmp/tmp3d92xb2v.rs:10:5\n   |\n10 |     count_upper_aux(s, 0, s.len() - 1)\n\
    \   |     ^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009132
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ *c >= 'A' && *c <= 'Z').filter(|c| *c % 2 == 0).count()\n}\n\nfn main() {\n\
    \    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `char` by `{integer}`\n  --> /tmp/tmp0wb57gvx.rs:10:64\n\
    \   |\n10 |     s.chars().filter(|c| *c >= 'A' && *c <= 'Z').filter(|c| *c % 2\
    \ == 0).count()\n   |                                                        \
    \     -- ^ - {integer}\n   |                                                 \
    \            |\n   |                                                         \
    \    char\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0wb57gvx.rs:10:5\n\
    \   |\n9  | fn count_upper(s: String) -> isize {\n   |                       \
    \       ----- expected `isize` because of return type\n10 |     s.chars().filter(|c|\
    \ *c >= 'A' && *c <= 'Z').filter(|c| *c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ *c >= 'A' && *c <= 'Z').filter(|c| *c % 2 == 0).count().try_into().unwrap()\n\
    \   |                                                                        \
    \         ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009132
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    count_uppercase_in_even_indices(s,\
    \ s.char_indices().len())\n}\n\nfn main() {\n    let candidate = count_upper;\n\
    \    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"\
    abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_uppercase_in_even_indices` in\
    \ this scope\n  --> /tmp/tmp8360wzsj.rs:10:5\n   |\n10 |     count_uppercase_in_even_indices(s,\
    \ s.char_indices().len())\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror[E0599]: no method named `len` found for struct `CharIndices`\
    \ in the current scope\n  --> /tmp/tmp8360wzsj.rs:10:57\n   |\n10 |     count_uppercase_in_even_indices(s,\
    \ s.char_indices().len())\n   |                                              \
    \           ^^^ method not found in `CharIndices<'_>`\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009132
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    count_sub_range(s,\
    \ 0, s.len(), 'a', |_, v| v == char::Upper || v == 'A')\n}\n\nfn main() {\n  \
    \  let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_sub_range` in this scope\n  -->\
    \ /tmp/tmpbndlsoo5.rs:10:5\n   |\n10 |     count_sub_range(s, 0, s.len(), 'a',\
    \ |_, v| v == char::Upper || v == 'A')\n   |     ^^^^^^^^^^^^^^^ not found in\
    \ this scope\n\nerror[E0599]: no associated item named `Upper` found for type\
    \ `char` in the current scope\n  --> /tmp/tmpbndlsoo5.rs:10:59\n   |\n10 |   \
    \  count_sub_range(s, 0, s.len(), 'a', |_, v| v == char::Upper || v == 'A')\n\
    \   |                                                           ^^^^^ associated\
    \ item not found in `char`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0425, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009132
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    if let Some(i) = get_index(s,\
    \ |&x| x >= 'a' && x <= 'z') {\n        let mut i = 0;\n        while i < s.len()\
    \ && s.starts_with(s.as_bytes()[i..])) {\n            i += 1;\n        }\n   \
    \     i += s.len() - i;\n        i\n    } else {\n        0\n    }\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error: unexpected closing delimiter: `}`\n  --> /tmp/tmp5pa319sb.rs:20:1\n\
    \   |\n17 |     } else {\n   |            - this opening brace...\n18 |      \
    \   0\n19 |     }\n   |     - ...matches this closing brace\n20 | }\n   | ^ unexpected\
    \ closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmp5pa319sb.rs:10:62\n\
    \   |\n10 |     if let Some(i) = get_index(s, |&x| x >= 'a' && x <= 'z') {\n \
    \  |                                                              ^ unclosed delimiter\n\
    11 |         let mut i = 0;\n12 |         while i < s.len() && s.starts_with(s.as_bytes()[i..]))\
    \ {\n   |                                                              ^ mismatched\
    \ closing delimiter\n\nerror: aborting due to 2 previous errors\n\n"
  stdout: ''
  timestamp: 1660009132
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    let mut count = 1;\n\
    \    for i in 0..s.len() {\n        match s.chars().nth(i).unwrap() {\n      \
    \      'a' .. 'z' => count += 1,\n            _ => (),\n        }\n    }\n   \
    \ count\n}\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0658]: exclusive range pattern syntax is experimental\n  --> /tmp/tmpnw2ry0x_.rs:13:13\n\
    \   |\n13 |             'a' .. 'z' => count += 1,\n   |             ^^^^^^^^^^\n\
    \   |\n   = note: see issue #37854 <https://github.com/rust-lang/rust/issues/37854>\
    \ for more information\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0658`.\n"
  stdout: ''
  timestamp: 1660009132
- exit_code: 101
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    let mut chars = s.chars();\n\
    \    let mut count = 0;\n    for (i, c) in chars.enumerate() {\n        if c >=\
    \ 'A' && c <= 'Z' {\n            count += c as isize - 'A' as isize;\n       \
    \ }\n        if i % 2 == 0 {\n            count += 1;\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `10`,\n right: `1`', /tmp/tmp91ji_1yt.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    let mut even_indices\
    \ = 0;\n    for i in s.chars().enumerate().filter(|(_, c)| c.is_upper()) {\n \
    \       if i.1 % 2 == 0 {\n            even_indices += 1;\n        }\n    }\n\
    \    even_indices\n}\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_upper` found for reference `&char` in\
    \ the current scope\n  --> /tmp/tmptcbh__gt.rs:11:54\n   |\n11 |     for i in\
    \ s.chars().enumerate().filter(|(_, c)| c.is_upper()) {\n   |                \
    \                                      ^^^^^^^^ help: there is an associated function\
    \ with a similar name: `is_uppercase`\n\nerror[E0369]: cannot mod `char` by `{integer}`\n\
    \  --> /tmp/tmptcbh__gt.rs:12:16\n   |\n12 |         if i.1 % 2 == 0 {\n   | \
    \           --- ^ - {integer}\n   |            |\n   |            char\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0369, E0599.\nFor more information about an error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009132
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().skip_while(|&b|\
    \ !is_upper(b)).count()\n}\n\nfn main() {\n    let candidate = count_upper;\n\
    \    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"\
    abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_upper` in this scope\n  --> /tmp/tmpm4ch4zpg.rs:10:32\n\
    \   |\n10 |     s.chars().skip_while(|&b| !is_upper(b)).count()\n   |        \
    \                        ^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpm4ch4zpg.rs:10:5\n   |\n9  | fn count_upper(s: String)\
    \ -> isize {\n   |                              ----- expected `isize` because\
    \ of return type\n10 |     s.chars().skip_while(|&b| !is_upper(b)).count()\n \
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n10 |     s.chars().skip_while(|&b| !is_upper(b)).count().try_into().unwrap()\n\
    \   |                                                    ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009132
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().zip(s.chars().skip(1))\n\
    \        .skip_while(|(a, b)| a != b && (a as u8 & 0xE0) == 0xE0)\n        .count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz0qyvchb.rs:10:5\n   |\n\
    9  |   fn count_upper(s: String) -> isize {\n   |                            \
    \    ----- expected `isize` because of return type\n10 | /     s.chars().zip(s.chars().skip(1))\n\
    11 | |         .skip_while(|(a, b)| a != b && (a as u8 & 0xE0) == 0xE0)\n12 |\
    \ |         .count()\n   | |________________^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n12 |         .count().try_into().unwrap()\n   |   \
    \              ++++++++++++++++++++\n\nerror[E0606]: casting `&char` as `u8` is\
    \ invalid\n  --> /tmp/tmpz0qyvchb.rs:11:41\n   |\n11 |         .skip_while(|(a,\
    \ b)| a != b && (a as u8 & 0xE0) == 0xE0)\n   |                              \
    \           ^^^^^^^\n   |\n   = help: cast through a raw pointer first\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0606.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009132
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').count() % 2 == 0\n}\n\nfn main() {\n    let candidate\
    \ = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n  \
    \  assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpq98o8xfy.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').count() % 2 == 0\n   |   \
    \                            ^^^\n   |                               |\n   | \
    \                              expected `&char`, found `char`\n   |          \
    \                     help: consider borrowing here: `&'A'`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpq98o8xfy.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').count() % 2 == 0\n   |                               \
    \            ^^^\n   |                                           |\n   |     \
    \                                      expected `&char`, found `char`\n   |  \
    \                                         help: consider borrowing here: `&'Z'`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpq98o8xfy.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').count() % 2 == 0\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `bool`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.as_bytes()\n    \
    \    .windows(2)\n        .filter(|&b| b >= 'A' && b <= 'Z')\n        .filter(|&b|\
    \ b != 'A' && b != 'Z')\n        .count()\n}\n\nfn main() {\n    let candidate\
    \ = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n  \
    \  assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnmx5kj_r.rs:12:27\n   |\n\
    12 |         .filter(|&b| b >= 'A' && b <= 'Z')\n   |                        \
    \   ^^^ expected `&[u8]`, found `char`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpnmx5kj_r.rs:12:39\n   |\n12 |         .filter(|&b| b >= 'A' && b <=\
    \ 'Z')\n   |                                       ^^^ expected `&[u8]`, found\
    \ `char`\n\nerror[E0277]: can't compare `&[u8]` with `char`\n  --> /tmp/tmpnmx5kj_r.rs:13:24\n\
    \   |\n13 |         .filter(|&b| b != 'A' && b != 'Z')\n   |                 \
    \       ^^ no implementation for `&[u8] == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&[u8]`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&[B] as PartialEq<[A; N]>>\n        \
    \     <&[T] as PartialEq<Vec<U, A>>>\n             <&mut [B] as PartialEq<[A;\
    \ N]>>\n             <&mut [T] as PartialEq<Vec<U, A>>>\n             <[A; N]\
    \ as PartialEq<&[B]>>\n             <[A; N] as PartialEq<&mut [B]>>\n        \
    \     <[A; N] as PartialEq<[B; N]>>\n             <[A; N] as PartialEq<[B]>>\n\
    \           and 3 others\n\nerror[E0277]: can't compare `&[u8]` with `char`\n\
    \  --> /tmp/tmpnmx5kj_r.rs:13:36\n   |\n13 |         .filter(|&b| b != 'A' &&\
    \ b != 'Z')\n   |                                    ^^ no implementation for\
    \ `&[u8] == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&[u8]`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&[B] as PartialEq<[A; N]>>\n             <&[T] as PartialEq<Vec<U,\
    \ A>>>\n             <&mut [B] as PartialEq<[A; N]>>\n             <&mut [T] as\
    \ PartialEq<Vec<U, A>>>\n             <[A; N] as PartialEq<&[B]>>\n          \
    \   <[A; N] as PartialEq<&mut [B]>>\n             <[A; N] as PartialEq<[B; N]>>\n\
    \             <[A; N] as PartialEq<[B]>>\n           and 3 others\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpnmx5kj_r.rs:10:5\n   |\n9  |   fn count_upper(s:\
    \ String) -> isize {\n   |                                ----- expected `isize`\
    \ because of return type\n10 | /     s.as_bytes()\n1"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    count_upper_helper(s.as_bytes()[0..s.len()/2]).1\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_upper_helper` in this scope\n\
    \  --> /tmp/tmpu7lexbf3.rs:10:5\n   |\n10 |     count_upper_helper(s.as_bytes()[0..s.len()/2]).1\n\
    \   |     ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660009132
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    let mut count = 0;\n\
    \    for i in 0..s.len() {\n        match s[i] {\n            c if c.is_uppercase()\
    \ => count += 1,\n            _ => {}\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmplfatykzo.rs:12:15\n\
    \   |\n12 |         match s[i] {\n   |               ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009132
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    let mut count = 0;\n\
    \    for i in 0..s.len() {\n        if s.chars().any(|c| c.is_upper() && c.is_ascii_letter())\
    \ {\n            count += 1;\n            if i % 2 == 0 {\n                count\
    \ += 1;\n            }\n        }\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_upper` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpch_cmpzr.rs:12:32\n   |\n12 |         if s.chars().any(|c|\
    \ c.is_upper() && c.is_ascii_letter()) {\n   |                               \
    \ ^^^^^^^^ help: there is an associated function with a similar name: `is_uppercase`\n\
    \nerror[E0599]: no method named `is_ascii_letter` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpch_cmpzr.rs:12:48\n   |\n12 |         if s.chars().any(|c|\
    \ c.is_upper() && c.is_ascii_letter()) {\n   |                               \
    \                 ^^^^^^^^^^^^^^^ help: there is an associated function with a\
    \ similar name: `is_ascii`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009132
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    let mut counter = 0;\n\
    \n    for i in s.chars() {\n        if i.is_uppercase() {\n            counter\
    \ += 1;\n\n            if i.is_even() {\n                counter += 1;\n     \
    \       }\n        }\n    }\n\n    counter\n}\n\nfn main() {\n    let candidate\
    \ = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n  \
    \  assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_even` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpk04ktqjz.rs:16:18\n   |\n16 |             if i.is_even()\
    \ {\n   |                  ^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660009132
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.char_indices().filter_map(|(i,\
    \ c)| {\n        if c.is_uppercase() {\n            if i % 2 == 0 {\n        \
    \        Some(i)\n            } else {\n                None\n            }\n\
    \        } else {\n            None\n        }\n    })\n    .count()\n}\n\nfn\
    \ main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0dz8tqf5.rs:10:5\n   |\n\
    9  |   fn count_upper(s: String) -> isize {\n   |                            \
    \    ----- expected `isize` because of return type\n10 | /     s.char_indices().filter_map(|(i,\
    \ c)| {\n11 | |         if c.is_uppercase() {\n12 | |             if i % 2 ==\
    \ 0 {\n13 | |                 Some(i)\n...  |\n20 | |     })\n21 | |     .count()\n\
    \   | |____________^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    21 |     .count().try_into().unwrap()\n   |             ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009132
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.char_indices().filter(|x|\
    \ x.1 % 2 == 0).count(|x| x.2.is_uppercase())\n}\n\nfn main() {\n    let candidate\
    \ = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n  \
    \  assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `char` by `{integer}`\n  --> /tmp/tmp825hfcpe.rs:10:37\n\
    \   |\n10 |     s.char_indices().filter(|x| x.1 % 2 == 0).count(|x| x.2.is_uppercase())\n\
    \   |                                 --- ^ - {integer}\n   |                \
    \                 |\n   |                                 char\n\nerror[E0061]:\
    \ this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp825hfcpe.rs:10:47\n\
    \    |\n10  |     s.char_indices().filter(|x| x.1 % 2 == 0).count(|x| x.2.is_uppercase())\n\
    \    |                                               ^^^^^ ----------------------\
    \ supplied 1 argument\n    |                                               |\n\
    \    |                                               expected 0 arguments\n  \
    \  |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp825hfcpe.rs:10:5\n   |\n9  | fn count_upper(s: String) -> isize\
    \ {\n   |                              ----- expected `isize` because of return\
    \ type\n10 |     s.char_indices().filter(|x| x.1 % 2 == 0).count(|x| x.2.is_uppercase())\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.char_indices().filter(|x|\
    \ x.1 % 2 == 0).count(|x| x.2.is_uppercase()).try_into().unwrap()\n   |      \
    \                                                                      ++++++++++++++++++++\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0308, E0369.\nFor more information about an error, try `rustc --explain\
    \ E0061`.\n"
  stdout: ''
  timestamp: 1660009132
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    let mut isize = 0;\n\
    \    for (i, c) in s.chars().enumerate() {\n        if !is_vowel(c) {\n      \
    \      continue;\n        }\n        if i % 2 == 0 {\n            i += 1;\n  \
    \      }\n        isize += 1;\n    }\n    isize\n}\n\nfn main() {\n    let candidate\
    \ = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n  \
    \  assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpc6aae5d4.rs:12:13\n\
    \   |\n12 |         if !is_vowel(c) {\n   |             ^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009132
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmp669j99c8.rs:10:57\n\
    \   |\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \   |                                                       - ^ - {integer}\n\
    \   |                                                       |\n   |          \
    \                                             &char\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp669j99c8.rs:10:5\n   |\n9  | fn count_upper(s: String)\
    \ -> isize {\n   |                              ----- expected `isize` because\
    \ of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c\
    \ % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count().try_into().unwrap()\n   | \
    \                                                                         ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    count_in_even_positions(s,\
    \ |c| c == c.to_ascii_uppercase())\n}\n\nfn main() {\n    let candidate = count_upper;\n\
    \    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"\
    abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_in_even_positions` in this scope\n\
    \  --> /tmp/tmp146tnl43.rs:10:5\n   |\n10 |     count_in_even_positions(s, |c|\
    \ c == c.to_ascii_uppercase())\n   |     ^^^^^^^^^^^^^^^^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ *c >= 'a' && *c <= 'z' && *c != 'A' && *c != 'Z').count()\n}\n\nfn main() {\n\
    \    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpaibtkeqi.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| *c >=\
    \ 'a' && *c <= 'z' && *c != 'A' && *c != 'Z').count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ *c >= 'a' && *c <= 'z' && *c != 'A' && *c != 'Z').count().try_into().unwrap()\n\
    \   |                                                                        \
    \           ++++++++++++++++++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009132
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().enumerate().filter(|&(i,\
    \ c)| {\n        ((i % 2) == 0) && c.is_uppercase()\n    }).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3e111xms.rs:10:5\n   |\n\
    9  |   fn count_upper(s: String) -> isize {\n   |                            \
    \    ----- expected `isize` because of return type\n10 | /     s.chars().enumerate().filter(|&(i,\
    \ c)| {\n11 | |         ((i % 2) == 0) && c.is_uppercase()\n12 | |     }).count()\n\
    \   | |______________^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    12 |     }).count().try_into().unwrap()\n   |               ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpopqobm42.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'a' && c <= 'z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'a'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpopqobm42.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpopqobm42.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'a' && c <= 'z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpopqobm42.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'a' && c\
    \ <= 'z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    if s.len() < 2 {\n\
    \        return 0;\n    }\n\n    let mut cnt = 0;\n\n    let mut iter = s.char_indices();\n\
    \    for i in iter {\n        if i % 2 == 0 {\n            cnt += 1;\n       \
    \ }\n    }\n\n    cnt\n}\n\nfn main() {\n    let candidate = count_upper;\n  \
    \  assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"\
    abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `(usize, char)` by `{integer}`\n  --> /tmp/tmpsm7_vkan.rs:18:14\n\
    \   |\n18 |         if i % 2 == 0 {\n   |            - ^ - {integer}\n   |   \
    \         |\n   |            (usize, char)\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    count_upper_impl(s,\
    \ true)\n}\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_upper_impl` in this scope\n \
    \ --> /tmp/tmpjdf1xixe.rs:10:5\n   |\n10 |     count_upper_impl(s, true)\n   |\
    \     ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().skip_while(|&c|\
    \ *c >= 'A' || *c <= 'Z').filter(|&c| *c >= 'A' && *c <= 'Z').count() % 2 == 0\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmp0_2giic3.rs:10:31\n\
    \   |\n10 |     s.chars().skip_while(|&c| *c >= 'A' || *c <= 'Z').filter(|&c|\
    \ *c >= 'A' && *c <= 'Z').count() % 2 == 0\n   |                             \
    \  ^^\n\nerror[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmp0_2giic3.rs:10:44\n\
    \   |\n10 |     s.chars().skip_while(|&c| *c >= 'A' || *c <= 'Z').filter(|&c|\
    \ *c >= 'A' && *c <= 'Z').count() % 2 == 0\n   |                             \
    \               ^^\n\nerror[E0614]: type `char` cannot be dereferenced\n  -->\
    \ /tmp/tmp0_2giic3.rs:10:67\n   |\n10 |     s.chars().skip_while(|&c| *c >= 'A'\
    \ || *c <= 'Z').filter(|&c| *c >= 'A' && *c <= 'Z').count() % 2 == 0\n   |   \
    \                                                                ^^\n\nerror[E0614]:\
    \ type `char` cannot be dereferenced\n  --> /tmp/tmp0_2giic3.rs:10:80\n   |\n\
    10 |     s.chars().skip_while(|&c| *c >= 'A' || *c <= 'Z').filter(|&c| *c >= 'A'\
    \ && *c <= 'Z').count() % 2 == 0\n   |                                       \
    \                                         ^^\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp0_2giic3.rs:10:5\n   |\n9  | fn count_upper(s: String) -> isize\
    \ {\n   |                              ----- expected `isize` because of return\
    \ type\n10 |     s.chars().skip_while(|&c| *c >= 'A' || *c <= 'Z').filter(|&c|\
    \ *c >= 'A' && *c <= 'Z').count() % 2 == 0\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `bool`\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0614.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    count_upper_indices2(s,\
    \ 0, s.len(), |i| i & 1).0\n}\n\nfn main() {\n    let candidate = count_upper;\n\
    \    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"\
    abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_upper_indices2` in this scope\n\
    \  --> /tmp/tmpc0pg_dl8.rs:10:5\n   |\n10 |     count_upper_indices2(s, 0, s.len(),\
    \ |i| i & 1).0\n   |     ^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    let mut i = 0;\n  \
    \  let mut upper = 0;\n    let mut c = s.chars().filter(|c| c.is_uppercase());\n\
    \    while i < c.len() {\n        if c[i].is_uppercase() {\n            i += 1;\n\
    \            if i % 2 == 0 {\n                upper += 1;\n            }\n   \
    \     }\n        i += 1;\n    }\n    upper\n}\n\nfn main() {\n    let candidate\
    \ = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n  \
    \  assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `Filter` in the current\
    \ scope\n  --> /tmp/tmpwtvb3z2a.rs:13:17\n   |\n13 |     while i < c.len() {\n\
    \   |                 ^^^ method not found in `Filter<Chars<'_>, [closure@/tmp/tmpwtvb3z2a.rs:12:34:\
    \ 12:54]>`\n\nerror[E0608]: cannot index into a value of type `Filter<Chars<'_>,\
    \ [closure@/tmp/tmpwtvb3z2a.rs:12:34: 12:54]>`\n  --> /tmp/tmpwtvb3z2a.rs:14:12\n\
    \   |\n14 |         if c[i].is_uppercase() {\n   |            ^^^^\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0599, E0608.\n\
    For more information about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    let mut counter = 0;\n\
    \    for &i in s.char_indices() {\n        match i {\n            0 => break,\n\
    \            _ => counter += if i % 2 == 0 { 1 } else { 0 },\n        }\n    }\n\
    \    counter\n}\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6mcop5mc.rs:11:9\n   |\n\
    11 |     for &i in s.char_indices() {\n   |         ^^    ---------------- this\
    \ expression has type `Option<(usize, char)>`\n   |         |\n   |         expected\
    \ tuple, found reference\n   |         help: you can probably remove the explicit\
    \ borrow: `i`\n   |\n   = note:  expected tuple `(usize, char)`\n           found\
    \ reference `&_`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    count_even_indices(s,\
    \ |index| {\n        s[index] == 'A' || s[index] == 'a' || s[index] == 'E' ||\
    \ s[index] == 'e'\n    })\n}\n\nfn main() {\n    let candidate = count_upper;\n\
    \    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"\
    abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_even_indices` in this scope\n\
    \  --> /tmp/tmpj2phcmwi.rs:10:5\n   |\n10 |     count_even_indices(s, |index|\
    \ {\n   |     ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    match s.chars() {\n\
    \        \"\" => 0,\n        'a' .. 'z' => 1,\n        'A' .. 'Z' => 1,\n    \
    \    _ => 0,\n    }\n}\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0658]: exclusive range pattern syntax is experimental\n  --> /tmp/tmpbs1koev7.rs:12:9\n\
    \   |\n12 |         'a' .. 'z' => 1,\n   |         ^^^^^^^^^^\n   |\n   = note:\
    \ see issue #37854 <https://github.com/rust-lang/rust/issues/37854> for more information\n\
    \nerror[E0658]: exclusive range pattern syntax is experimental\n  --> /tmp/tmpbs1koev7.rs:13:9\n\
    \   |\n13 |         'A' .. 'Z' => 1,\n   |         ^^^^^^^^^^\n   |\n   = note:\
    \ see issue #37854 <https://github.com/rust-lang/rust/issues/37854> for more information\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpbs1koev7.rs:11:9\n   |\n10 | \
    \    match s.chars() {\n   |           --------- this expression has type `Chars<'_>`\n\
    11 |         \"\" => 0,\n   |         ^^ expected struct `Chars`, found `&str`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpbs1koev7.rs:12:9\n   |\n10 | \
    \    match s.chars() {\n   |           --------- this expression has type `Chars<'_>`\n\
    11 |         \"\" => 0,\n12 |         'a' .. 'z' => 1,\n   |         ^^^    ---\
    \ this is of type `char`\n   |         |\n   |         expected struct `Chars`,\
    \ found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbs1koev7.rs:12:16\n\
    \   |\n10 |     match s.chars() {\n   |           --------- this expression has\
    \ type `Chars<'_>`\n11 |         \"\" => 0,\n12 |         'a' .. 'z' => 1,\n \
    \  |         ---    ^^^ expected struct `Chars`, found `char`\n   |         |\n\
    \   |         this is of type `char`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpbs1koev7.rs:13:9\n   |\n10 |     match s.chars() {\n   |           ---------\
    \ this expression has type `Chars<'_>`\n...\n13 |         'A' .. 'Z' => 1,\n \
    \  |         ^^^    --- this is of type `char`\n   |         |\n   |         expected\
    \ struct `Chars`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbs1koev7.rs:13:16\n\
    \   |\n10 |     match s.chars() {\n   |           --------- this expression has\
    \ type `Chars<'_>`\n...\n13 |         'A' .. 'Z' => 1,\n   |         ---    ^^^\
    \ expected struct `Chars`, found `char`\n   |         |\n   |         this is\
    \ of type `char`\n\nerror: aborting due to 7 previous errors\n\nSome erro"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter_map(|c|\
    \ match c {\n        c if is_vowel(c) => Some(c + 1),\n        _ => None,\n  \
    \  }).sum()\n}\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpudb82m9j.rs:11:14\n\
    \   |\n11 |         c if is_vowel(c) => Some(c + 1),\n   |              ^^^^^^^^\
    \ not found in this scope\n\nerror[E0369]: cannot add `{integer}` to `char`\n\
    \  --> /tmp/tmpudb82m9j.rs:11:36\n   |\n11 |         c if is_vowel(c) => Some(c\
    \ + 1),\n   |                                  - ^ - {integer}\n   |         \
    \                         |\n   |                                  char\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0369, E0425.\nFor more information about an error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars()\n       \
    \ .filter(|c| c.is_uppercase())\n        .filter(|c| c.is_ascii_upper())\n   \
    \     .filter(|c| c.is_ascii_lowercase())\n        .count()\n}\n\nfn main() {\n\
    \    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_upper` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpvrtbacgs.rs:12:23\n   |\n12 |         .filter(|c|\
    \ c.is_ascii_upper())\n   |                       ^^^^^^^^^^^^^^ help: there is\
    \ an associated function with a similar name: `is_ascii`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpvrtbacgs.rs:10:5\n   |\n9  |   fn count_upper(s: String)\
    \ -> isize {\n   |                                ----- expected `isize` because\
    \ of return type\n10 | /     s.chars()\n11 | |         .filter(|c| c.is_uppercase())\n\
    12 | |         .filter(|c| c.is_ascii_upper())\n13 | |         .filter(|c| c.is_ascii_lowercase())\n\
    14 | |         .count()\n   | |________________^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n14 |         .count().try_into().unwrap()\n   |   \
    \              ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars()\n       \
    \ .filter(|c| c.is_uppercase())\n        .filter(|c| c != 'd')\n        .count(|c|\
    \ {\n            if c != 'd' {\n                c.is_odd()\n            } else\
    \ {\n                false\n            }\n        })\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpif713b96.rs:12:23\n\
    \   |\n12 |         .filter(|c| c != 'd')\n   |                       ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0061]: this function takes 0 arguments but 1 argument was supplied\n  \
    \ --> /tmp/tmpif713b96.rs:13:10\n    |\n13  |           .count(|c| {\n    |  __________^^^^^_-\n\
    \    | |          |\n    | |          expected 0 arguments\n14  | |          \
    \   if c != 'd' {\n15  | |                 c.is_odd()\n16  | |             } else\
    \ {\n17  | |                 false\n18  | |             }\n19  | |         })\n\
    \    | |_________- supplied 1 argument\n    |\nnote: associated function defined\
    \ here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpif713b96.rs:10:5\n   |\n\
    9  |   fn count_upper(s: String) -> isize {\n   |                            \
    \    ----- expected `isize` because of return type\n10 | /     s.chars()\n11 |\
    \ |         .filter(|c| c.is_uppercase())\n12 | |         .filter(|c| c != 'd')\n\
    13 | |         .count(|c| {\n...  |\n18 | |             }\n19 | |         })\n\
    \   | |__________^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    19 |         }).try_into().unwrap()\n   |           ++++++++++++++++++++\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0277, E0308.\nFor more information about an error, try `rustc --explain\
    \ E0061`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.char_indices().filter(|i|\
    \ i % 2 == 0).filter(|i| s.chars().any(|c| c.is_upper()))\n        .count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&(usize, char)` by `{integer}`\n  --> /tmp/tmph22t6u90.rs:10:35\n\
    \   |\n10 |     s.char_indices().filter(|i| i % 2 == 0).filter(|i| s.chars().any(|c|\
    \ c.is_upper()))\n   |                                 - ^ - {integer}\n   | \
    \                                |\n   |                                 &(usize,\
    \ char)\n\nerror[E0599]: no method named `is_upper` found for type `char` in the\
    \ current scope\n  --> /tmp/tmph22t6u90.rs:10:76\n   |\n10 |     s.char_indices().filter(|i|\
    \ i % 2 == 0).filter(|i| s.chars().any(|c| c.is_upper()))\n   |              \
    \                                                              ^^^^^^^^ help:\
    \ there is an associated function with a similar name: `is_uppercase`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmph22t6u90.rs:10:5\n   |\n9  |   fn count_upper(s:\
    \ String) -> isize {\n   |                                ----- expected `isize`\
    \ because of return type\n10 | /     s.char_indices().filter(|i| i % 2 == 0).filter(|i|\
    \ s.chars().any(|c| c.is_upper()))\n11 | |         .count()\n   | |________________^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n11 |         .count().try_into().unwrap()\n\
    \   |                 ++++++++++++++++++++\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0369, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().count();\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp9axw6dxl.rs:9:30\n  |\n9 |\
    \ fn count_upper(s: String) -> isize {\n  |    -----------               ^^^^^\
    \ expected `isize`, found `()`\n  |    |\n  |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.char_indices().filter(|&(ref\
    \ x, _)| x.is_uppercase()).filter(|&(_, y)| y % 2 == 0).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_uppercase` found for reference `&usize`\
    \ in the current scope\n  --> /tmp/tmp8azu_i4a.rs:10:45\n   |\n10 |     s.char_indices().filter(|&(ref\
    \ x, _)| x.is_uppercase()).filter(|&(_, y)| y % 2 == 0).count()\n   |        \
    \                                     ^^^^^^^^^^^^ method not found in `&usize`\n\
    \nerror[E0369]: cannot mod `char` by `{integer}`\n  --> /tmp/tmp8azu_i4a.rs:10:80\n\
    \   |\n10 |     s.char_indices().filter(|&(ref x, _)| x.is_uppercase()).filter(|&(_,\
    \ y)| y % 2 == 0).count()\n   |                                              \
    \                                - ^ - {integer}\n   |                       \
    \                                                       |\n   |              \
    \                                                                char\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8azu_i4a.rs:10:5\n   |\n9  | fn count_upper(s:\
    \ String) -> isize {\n   |                              ----- expected `isize`\
    \ because of return type\n10 |     s.char_indices().filter(|&(ref x, _)| x.is_uppercase()).filter(|&(_,\
    \ y)| y % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.char_indices().filter(|&(ref\
    \ x, _)| x.is_uppercase()).filter(|&(_, y)| y % 2 == 0).count().try_into().unwrap()\n\
    \   |                                                                        \
    \                         ++++++++++++++++++++\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0369, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    let mut i = 0;\n  \
    \  let mut j = 0;\n    while i < s.len() {\n        if s[i] >= 'a' && s[i] <=\
    \ 'z' {\n            i += 1;\n        } else if s[i] >= 'A' && s[i] <= 'Z' {\n\
    \            j += 1;\n            i += 1;\n        } else {\n            i +=\
    \ 1;\n        }\n    }\n    j\n}\n\nfn main() {\n    let candidate = count_upper;\n\
    \    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"\
    abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpb9nv2950.rs:13:12\n\
    \   |\n13 |         if s[i] >= 'a' && s[i] <= 'z' {\n   |            ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpb9nv2950.rs:13:27\n   |\n13 |         if s[i] >= 'a' && s[i] <=\
    \ 'z' {\n   |                           ^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpb9nv2950.rs:15:19\n   |\n15 |         } else if s[i] >= 'A' &&\
    \ s[i] <= 'Z' {\n   |                   ^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    count_upper_helper(\n\
    \        &s.chars(),\n        0,\n        &s.chars().last().unwrap(),\n      \
    \  |v| match v {\n            Some(c) => c.is_uppercase(),\n            None =>\
    \ false,\n        },\n    )\n}\n\nfn main() {\n    let candidate = count_upper;\n\
    \    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"\
    abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_upper_helper` in this scope\n\
    \  --> /tmp/tmppdyeida0.rs:10:5\n   |\n10 |     count_upper_helper(\n   |    \
    \ ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.char_indices().filter(|c|\
    \ *c % 2 == 0).count()\n}\n\nfn main() {\n    let candidate = count_upper;\n \
    \   assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"\
    abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `(usize, char)` by `{integer}`\n  --> /tmp/tmpaa50odh_.rs:10:36\n\
    \   |\n10 |     s.char_indices().filter(|c| *c % 2 == 0).count()\n   |       \
    \                          -- ^ - {integer}\n   |                            \
    \     |\n   |                                 (usize, char)\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpaa50odh_.rs:10:5\n   |\n9  | fn count_upper(s: String)\
    \ -> isize {\n   |                              ----- expected `isize` because\
    \ of return type\n10 |     s.char_indices().filter(|c| *c % 2 == 0).count()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n10 |     s.char_indices().filter(|c| *c %\
    \ 2 == 0).count().try_into().unwrap()\n   |                                  \
    \                   ++++++++++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    let mut even = s.char_indices().filter(|&(_,\
    \ c)| c & 1 == 0).count();\n    for &(c, _) in s.char_indices() {\n        if\
    \ c & 1 == 0 {\n            even += 1;\n        }\n    }\n    even\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char & {integer}`\n  --> /tmp/tmpwpp41a1b.rs:10:56\n\
    \   |\n10 |     let mut even = s.char_indices().filter(|&(_, c)| c & 1 == 0).count();\n\
    \   |                                                      - ^ - {integer}\n \
    \  |                                                      |\n   |            \
    \                                          char\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpwpp41a1b.rs:11:9\n   |\n11 |     for &(c, _) in s.char_indices()\
    \ {\n   |         ^^^^^^^    ---------------- this expression has type `Option<(usize,\
    \ char)>`\n   |         |\n   |         expected tuple, found reference\n   |\n\
    \   = note:  expected tuple `(usize, char)`\n           found reference `&_`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpwpp41a1b.rs:16:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n...\n16 |     even\n   |     ^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n16 |     even.try_into().unwrap()\n\
    \   |         ++++++++++++++++++++\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0369.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().enumerate().filter(|&(i,\
    \ c)| {\n        i % 2 == 0 && c.is_uppercase()\n    }).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpr98c8t_g.rs:10:5\n   |\n\
    9  |   fn count_upper(s: String) -> isize {\n   |                            \
    \    ----- expected `isize` because of return type\n10 | /     s.chars().enumerate().filter(|&(i,\
    \ c)| {\n11 | |         i % 2 == 0 && c.is_uppercase()\n12 | |     }).count()\n\
    \   | |______________^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    12 |     }).count().try_into().unwrap()\n   |               ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 != 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6hoqbi27.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 != 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp6hoqbi27.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 != 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmp6hoqbi27.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 !=\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp6hoqbi27.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 != 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 != 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    let mut lower = s.chars().enumerate().filter(|(_,\
    \ ch)| ch >= 'a' && ch <= 'z');\n    let mut upper = lower.skip(1);\n    let mut\
    \ evens = 0;\n    for (_, ch) in upper {\n        if ch >= 'A' && ch <= 'Z' {\n\
    \            evens += 1;\n        }\n    }\n    evens\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqby9ys4d.rs:10:66\n   |\n\
    10 |     let mut lower = s.chars().enumerate().filter(|(_, ch)| ch >= 'a' && ch\
    \ <= 'z');\n   |                                                             \
    \     ^^^\n   |                                                              \
    \    |\n   |                                                                 \
    \ expected `&char`, found `char`\n   |                                       \
    \                           help: consider borrowing here: `&'a'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpqby9ys4d.rs:10:79\n   |\n10 |     let mut lower\
    \ = s.chars().enumerate().filter(|(_, ch)| ch >= 'a' && ch <= 'z');\n   |    \
    \                                                                           ^^^\n\
    \   |                                                                        \
    \       |\n   |                                                              \
    \                 expected `&char`, found `char`\n   |                       \
    \                                                        help: consider borrowing\
    \ here: `&'z'`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| {\n        c.is_lowercase() && !c.is_uppercase()\n\
    \    }).count()\n}\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2484sgqu.rs:10:5\n   |\n\
    9  |   fn count_upper(s: String) -> isize {\n   |                            \
    \    ----- expected `isize` because of return type\n10 | /     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| {\n11 | |         c.is_lowercase() && !c.is_uppercase()\n\
    12 | |     }).count()\n   | |______________^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n12 |     }).count().try_into().unwrap()\n   |     \
    \          ++++++++++++++++++++\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ *c >= 'A' && *c <= 'Z' && *c != '_').count() / 2 -\n        1\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1qimw_b0.rs:10:5\n   |\n\
    9  |   fn count_upper(s: String) -> isize {\n   |                            \
    \    ----- expected `isize` because of return type\n10 | /     s.chars().filter(|c|\
    \ *c >= 'A' && *c <= 'Z' && *c != '_').count() / 2 -\n11 | |         1\n   | |_________^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 ~     (s.chars().filter(|c|\
    \ *c >= 'A' && *c <= 'Z' && *c != '_').count() / 2 -\n11 ~         1).try_into().unwrap()\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    count_with_conditions(s,\
    \ |c| c.is_uppercase() && c.is_even())\n}\n\nfn main() {\n    let candidate =\
    \ count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"\
    abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_with_conditions` in this scope\n\
    \  --> /tmp/tmplw6qajgp.rs:10:5\n   |\n10 |     count_with_conditions(s, |c| c.is_uppercase()\
    \ && c.is_even())\n   |     ^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    let mut i = 0;\n  \
    \  while i < s.len() {\n        match s.chars().nth(i).unwrap() {\n          \
    \  'a' .. 'z' => i += 1,\n            _ => i += 1,\n        }\n    }\n    i\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0658]: exclusive range pattern syntax is experimental\n  --> /tmp/tmpxk6z67hz.rs:13:13\n\
    \   |\n13 |             'a' .. 'z' => i += 1,\n   |             ^^^^^^^^^^\n \
    \  |\n   = note: see issue #37854 <https://github.com/rust-lang/rust/issues/37854>\
    \ for more information\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxk6z67hz.rs:17:5\n\
    \   |\n9  | fn count_upper(s: String) -> isize {\n   |                       \
    \       ----- expected `isize` because of return type\n...\n17 |     i\n   | \
    \    ^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize`\
    \ to an `isize` and panic if the converted value doesn't fit\n   |\n17 |     i.try_into().unwrap()\n\
    \   |      ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0658.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    let mut num_upper =\
    \ 0;\n    for (i, &ch) in s.chars().enumerate() {\n        if i & 1 == 0 {\n \
    \           if ch == 'A' || ch == 'E' || ch == 'I' || ch == 'O' || ch == 'U' {\n\
    \                num_upper += 1;\n            }\n        }\n    }\n    return\
    \ num_upper;\n}\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4m10690i.rs:11:13\n   |\n\
    11 |     for (i, &ch) in s.chars().enumerate() {\n   |             ^^^     ---------------------\
    \ this expression has type `Option<(usize, char)>`\n   |             |\n   | \
    \            expected `char`, found reference\n   |             help: you can\
    \ probably remove the explicit borrow: `ch`\n   |\n   = note:   expected type\
    \ `char`\n           found reference `&_`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c > 64).filter(|c| c < 91)\n        .filter_map(|c| if c >= 65 && c <= 90 {\
    \ Some(c - 65) } else { None })\n        .filter(|c| c % 2 == 0)\n        .count()\
    \ as isize\n}\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5k5_ip9j.rs:10:30\n   |\n\
    10 |     s.chars().filter(|c| c > 64).filter(|c| c < 91)\n   |               \
    \               ^^ expected `&char`, found integer\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp5k5_ip9j.rs:10:49\n   |\n10 |     s.chars().filter(|c|\
    \ c > 64).filter(|c| c < 91)\n   |                                           \
    \      ^^ expected `&char`, found integer\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp5k5_ip9j.rs:11:33\n   |\n11 |         .filter_map(|c| if c >= 65\
    \ && c <= 90 { Some(c - 65) } else { None })\n   |                           \
    \      ^^ expected `char`, found `u8`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp5k5_ip9j.rs:11:44\n   |\n11 |         .filter_map(|c| if c >= 65 &&\
    \ c <= 90 { Some(c - 65) } else { None })\n   |                              \
    \              ^^ expected `char`, found `u8`\n\nerror[E0369]: cannot subtract\
    \ `{integer}` from `char`\n  --> /tmp/tmp5k5_ip9j.rs:11:56\n   |\n11 |       \
    \  .filter_map(|c| if c >= 65 && c <= 90 { Some(c - 65) } else { None })\n   |\
    \                                                      - ^ -- {integer}\n   |\
    \                                                      |\n   |               \
    \                                       char\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase() && c.is_ascii()).count();\n}\n\nfn main() {\n    let candidate\
    \ = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n  \
    \  assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpfxa_ld4a.rs:9:30\n  |\n9 |\
    \ fn count_upper(s: String) -> isize {\n  |    -----------               ^^^^^\
    \ expected `isize`, found `()`\n  |    |\n  |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    count_upper_helper(s.as_bytes(),\
    \ s.len(), 0)\n}\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_upper_helper` in this scope\n\
    \  --> /tmp/tmp1o7omt_6.rs:10:5\n   |\n10 |     count_upper_helper(s.as_bytes(),\
    \ s.len(), 0)\n   |     ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.char_indices()\n\
    \        .filter(|&(idx, _)| idx % 2 == 0)\n        .filter(|&(_, c)| char::is_uppercase(c))\n\
    \        .count()\n}\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfn1qpai_.rs:10:5\n   |\n\
    9  |   fn count_upper(s: String) -> isize {\n   |                            \
    \    ----- expected `isize` because of return type\n10 | /     s.char_indices()\n\
    11 | |         .filter(|&(idx, _)| idx % 2 == 0)\n12 | |         .filter(|&(_,\
    \ c)| char::is_uppercase(c))\n13 | |         .count()\n   | |________________^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n13 |         .count().try_into().unwrap()\n\
    \   |                 ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.char_indices().filter(|&(idx,\
    \ _)| idx % 2 == 0).map(|(idx, _)| s[idx]).filter(|c| c.is_uppercase()).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpv8lapm84.rs:10:70\n\
    \   |\n10 |     s.char_indices().filter(|&(idx, _)| idx % 2 == 0).map(|(idx, _)|\
    \ s[idx]).filter(|c| c.is_uppercase()).count()\n   |                         \
    \                                             ^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    count_upper_core(s.as_bytes())\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_upper_core` in this scope\n \
    \ --> /tmp/tmpd38x0zpv.rs:10:5\n   |\n10 |     count_upper_core(s.as_bytes())\n\
    \   |     ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 101
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    if s.len() == 0 {\n\
    \        return 0;\n    }\n    let mut n = 0;\n    for ch in s.chars() {\n   \
    \     if ch.is_uppercase() {\n            n += 1;\n        }\n        if ch.is_lowercase()\
    \ {\n            break;\n        }\n    }\n    n\n}\n\nfn main() {\n    let candidate\
    \ = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n  \
    \  assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `1`', /tmp/tmpgqfqfo6z.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter_map(|c|\
    \ if c.is_uppercase() || c == 'z' { return c }).count()\n}\n\nfn main() {\n  \
    \  let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjga02dh9.rs:10:71\n   |\n\
    10 |     s.chars().filter_map(|c| if c.is_uppercase() || c == 'z' { return c }).count()\n\
    \   |                                                                       ^\
    \ expected enum `Option`, found `char`\n   |\n   = note: expected enum `Option<_>`\n\
    \              found type `char`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n10 |     s.chars().filter_map(|c| if c.is_uppercase() || c == 'z' { return\
    \ Some(c) }).count()\n   |                                                   \
    \                    +++++ +\n\nerror[E0317]: `if` may be missing an `else` clause\n\
    \  --> /tmp/tmpjga02dh9.rs:10:30\n   |\n10 |     s.chars().filter_map(|c| if c.is_uppercase()\
    \ || c == 'z' { return c }).count()\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^--------^^\n\
    \   |                              |                                 |\n   | \
    \                             |                                 found here\n \
    \  |                              expected `()`, found enum `Option`\n   |\n \
    \  = note: expected unit type `()`\n                   found enum `Option<_>`\n\
    \   = note: `if` expressions without `else` evaluate to `()`\n   = help: consider\
    \ adding an `else` block that evaluates to the expected type\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpjga02dh9.rs:10:5\n   |\n9  | fn count_upper(s:\
    \ String) -> isize {\n   |                              ----- expected `isize`\
    \ because of return type\n10 |     s.chars().filter_map(|c| if c.is_uppercase()\
    \ || c == 'z' { return c }).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter_map(|c|\
    \ if c.is_uppercase() || c == 'z' { return c }).count().try_into().unwrap()\n\
    \   |                                                                        \
    \           ++++++++++++++++++++\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    let mut count = 0.;\n\
    \    let len = s.len();\n\n    for i in (0..len).filter(|&x| x >= 'a' && x <=\
    \ 'z') {\n        if s[i] == s[i..].chars().filter(|&x| x == 'A' || x == 'a').count()\
    \ {\n            count += 1.;\n        }\n    }\n\n    count\n}\n\nfn main() {\n\
    \    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzvwvej06.rs:13:40\n   |\n\
    13 |     for i in (0..len).filter(|&x| x >= 'a' && x <= 'z') {\n   |         \
    \                               ^^^ expected `usize`, found `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpzvwvej06.rs:13:52\n   |\n13 |     for i in (0..len).filter(|&x|\
    \ x >= 'a' && x <= 'z') {\n   |                                              \
    \      ^^^ expected `usize`, found `char`\n\nerror[E0277]: the type `String` cannot\
    \ be indexed by `usize`\n  --> /tmp/tmpzvwvej06.rs:14:12\n   |\n14 |         if\
    \ s[i] == s[i..].chars().filter(|&x| x == 'A' || x == 'a').count() {\n   |   \
    \         ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzvwvej06.rs:19:5\n\
    \   |\n9  | fn count_upper(s: String) -> isize {\n   |                       \
    \       ----- expected `isize` because of return type\n...\n19 |     count\n \
    \  |     ^^^^^ expected `isize`, found floating-point number\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    count_chars(s, |c|\
    \ *c == c as u8)\n}\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_chars` in this scope\n  --> /tmp/tmpik7vbgyb.rs:10:5\n\
    \   |\n10 |     count_chars(s, |c| *c == c as u8)\n   |     ^^^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|&c|\
    \ c.is_uppercase()).filter(|&c| !c.is_ascii()).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0gt20isy.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|&c| c.is_uppercase()).filter(|&c|\
    \ !c.is_ascii()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|&c|\
    \ c.is_uppercase()).filter(|&c| !c.is_ascii()).count().try_into().unwrap()\n \
    \  |                                                                         \
    \      ++++++++++++++++++++\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().enumerate()\n\
    \        .filter(|(_, ch)| ch.is_uppercase())\n        .filter(|(_, ch)| ch.is_ascii())\n\
    \        .filter(|(_, ch)| ch != b'z')\n        .count(|(_, ch)| ch.is_uppercase())\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkx52pzya.rs:13:33\n   |\n\
    13 |         .filter(|(_, ch)| ch != b'z')\n   |                             \
    \    ^^^^ expected `char`, found `u8`\n\nerror[E0277]: can't compare `&char` with\
    \ `u8`\n  --> /tmp/tmpkx52pzya.rs:13:30\n   |\n13 |         .filter(|(_, ch)|\
    \ ch != b'z')\n   |                              ^^ no implementation for `&char\
    \ == u8`\n   |\n   = help: the trait `PartialEq<u8>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0061]: this\
    \ function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpkx52pzya.rs:14:10\n\
    \    |\n14  |         .count(|(_, ch)| ch.is_uppercase())\n    |          ^^^^^\
    \ --------------------------- supplied 1 argument\n    |          |\n    |   \
    \       expected 0 arguments\n    |\nnote: associated function defined here\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpkx52pzya.rs:10:5\n   |\n9  |   fn\
    \ count_upper(s: String) -> isize {\n   |                                -----\
    \ expected `isize` because of return type\n10 | /     s.chars().enumerate()\n\
    11 | |         .filter(|(_, ch)| ch.is_uppercase())\n12 | |         .filter(|(_,\
    \ ch)| ch.is_ascii())\n13 | |         .filter(|(_, ch)| ch != b'z')\n14 | |  \
    \       .count(|(_, ch)| ch.is_uppercase())\n   | |___________________________________________^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n14 |         .count(|(_,\
    \ ch)| ch.is_uppercase()).try_into().unwrap()\n   |                          \
    \                  ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0061, E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.char_indices()\n\
    \        .filter_map(|i| match i.next() {\n            None => None,\n       \
    \     Some(idx) => Some(*idx),\n        })\n        .filter(|idx| {\n        \
    \    if idx % 2 == 0 {\n                let c = s.chars().nth(idx);\n        \
    \        c.is_uppercase()\n            } else {\n                false\n     \
    \       }\n        })\n        .count()\n}\n\nfn main() {\n    let candidate =\
    \ count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"\
    abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `next` found for tuple `(usize, char)` in\
    \ the current scope\n  --> /tmp/tmpv4cw77jl.rs:11:33\n   |\n11 |         .filter_map(|i|\
    \ match i.next() {\n   |                                 ^^^^ method not found\
    \ in `(usize, char)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpv4cw77jl.rs:17:39\n\
    \   |\n17 |                 let c = s.chars().nth(idx);\n   |                \
    \                       ^^^ expected `usize`, found reference\n   |\n   = note:\
    \   expected type `usize`\n           found reference `&_`\nhelp: consider dereferencing\
    \ the borrow\n   |\n17 |                 let c = s.chars().nth(*idx);\n   |  \
    \                                     +\n\nerror[E0599]: no method named `is_uppercase`\
    \ found for enum `Option` in the current scope\n  --> /tmp/tmpv4cw77jl.rs:18:19\n\
    \   |\n18 |                 c.is_uppercase()\n   |                   ^^^^^^^^^^^^\
    \ method not found in `Option<char>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpv4cw77jl.rs:10:5\n   |\n9  |   fn count_upper(s: String) -> isize {\n\
    \   |                                ----- expected `isize` because of return\
    \ type\n10 | /     s.char_indices()\n11 | |         .filter_map(|i| match i.next()\
    \ {\n12 | |             None => None,\n13 | |             Some(idx) => Some(*idx),\n\
    ...  |\n22 | |         })\n23 | |         .count()\n   | |________________^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n23 |         .count().try_into().unwrap()\n\
    \   |                 ++++++++++++++++++++\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    count_upper_helper(s.as_bytes())?\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_upper_helper` in this scope\n\
    \  --> /tmp/tmpiztki4dm.rs:10:5\n   |\n10 |     count_upper_helper(s.as_bytes())?\n\
    \   |     ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0277]: the `?`\
    \ operator can only be used in a function that returns `Result` or `Option` (or\
    \ another type that implements `FromResidual`)\n  --> /tmp/tmpiztki4dm.rs:10:37\n\
    \   |\n9  | / fn count_upper(s: String) -> isize {\n10 | |     count_upper_helper(s.as_bytes())?\n\
    \   | |                                     ^ cannot use the `?` operator in a\
    \ function that returns `isize`\n11 | | }\n   | |_- this function should return\
    \ `Result` or `Option` to accept `?`\n   |\n   = help: the trait `FromResidual<_>`\
    \ is not implemented for `isize`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars()\n       \
    \ .filter(|c| c.is_upper())\n        .filter(|c| c.is_ascii())\n        .filter(|c|\
    \ c % 2 == 0)\n        .count()\n}\n\nfn main() {\n    let candidate = count_upper;\n\
    \    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"\
    abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_upper` found for reference `&char` in\
    \ the current scope\n  --> /tmp/tmp8yqs8j6q.rs:11:23\n   |\n11 |         .filter(|c|\
    \ c.is_upper())\n   |                       ^^^^^^^^ help: there is an associated\
    \ function with a similar name: `is_uppercase`\n\nerror[E0369]: cannot mod `&char`\
    \ by `{integer}`\n  --> /tmp/tmp8yqs8j6q.rs:13:23\n   |\n13 |         .filter(|c|\
    \ c % 2 == 0)\n   |                     - ^ - {integer}\n   |                \
    \     |\n   |                     &char\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp8yqs8j6q.rs:10:5\n   |\n9  |   fn count_upper(s: String) -> isize {\n\
    \   |                                ----- expected `isize` because of return\
    \ type\n10 | /     s.chars()\n11 | |         .filter(|c| c.is_upper())\n12 | |\
    \         .filter(|c| c.is_ascii())\n13 | |         .filter(|c| c % 2 == 0)\n\
    14 | |         .count()\n   | |________________^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n14 |         .count().try_into().unwrap()\n   |   \
    \              ++++++++++++++++++++\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0369, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().enumerate().filter(|(_,\
    \ ch)| ch >= 'A' && ch <= 'Z').count() as isize\n}\n\nfn main() {\n    let candidate\
    \ = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n  \
    \  assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz507tjvt.rs:10:50\n   |\n\
    10 |     s.chars().enumerate().filter(|(_, ch)| ch >= 'A' && ch <= 'Z').count()\
    \ as isize\n   |                                                  ^^^\n   |  \
    \                                                |\n   |                     \
    \                             expected `&char`, found `char`\n   |           \
    \                                       help: consider borrowing here: `&'A'`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpz507tjvt.rs:10:63\n   |\n10 |\
    \     s.chars().enumerate().filter(|(_, ch)| ch >= 'A' && ch <= 'Z').count() as\
    \ isize\n   |                                                               ^^^\n\
    \   |                                                               |\n   |  \
    \                                                             expected `&char`,\
    \ found `char`\n   |                                                         \
    \      help: consider borrowing here: `&'Z'`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ *c >= 'a' && *c <= 'z').filter(|c| *c % 2 != 0).count()\n}\n\nfn main() {\n\
    \    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `char` by `{integer}`\n  --> /tmp/tmpdzslhwx6.rs:10:64\n\
    \   |\n10 |     s.chars().filter(|c| *c >= 'a' && *c <= 'z').filter(|c| *c % 2\
    \ != 0).count()\n   |                                                        \
    \     -- ^ - {integer}\n   |                                                 \
    \            |\n   |                                                         \
    \    char\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdzslhwx6.rs:10:5\n\
    \   |\n9  | fn count_upper(s: String) -> isize {\n   |                       \
    \       ----- expected `isize` because of return type\n10 |     s.chars().filter(|c|\
    \ *c >= 'a' && *c <= 'z').filter(|c| *c % 2 != 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ *c >= 'a' && *c <= 'z').filter(|c| *c % 2 != 0).count().try_into().unwrap()\n\
    \   |                                                                        \
    \         ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    let mut i = 0;\n  \
    \  while i < s.len() {\n        if s[i].is_uppercase() {\n            if i % 2\
    \ == 0 {\n                i += 1;\n            }\n        } else if s[i].is_lowercase()\
    \ {\n            i += 1;\n        }\n    }\n    i\n}\n\nfn main() {\n    let candidate\
    \ = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n  \
    \  assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpx_rrkmqr.rs:12:12\n\
    \   |\n12 |         if s[i].is_uppercase() {\n   |            ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpx_rrkmqr.rs:16:19\n   |\n16 |         } else if s[i].is_lowercase()\
    \ {\n   |                   ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpx_rrkmqr.rs:20:5\n   |\n9  | fn count_upper(s:\
    \ String) -> isize {\n   |                              ----- expected `isize`\
    \ because of return type\n...\n20 |     i\n   |     ^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n20 |     i.try_into().unwrap()\n   |    \
    \  ++++++++++++++++++++\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.char_indices().filter_map(|(i,\
    \ c)| if i % 2 == 0 { Some(c as usize) } else { None }).sum()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `isize: Sum<usize>` is not satisfied\n  \
    \  --> /tmp/tmpt_nr_i64.rs:10:92\n     |\n10   |     s.char_indices().filter_map(|(i,\
    \ c)| if i % 2 == 0 { Some(c as usize) } else { None }).sum()\n     |        \
    \                                                                            \
    \        ^^^ the trait `Sum<usize>` is not implemented for `isize`\n     |\n \
    \    = help: the following other types implement trait `Sum<A>`:\n           \
    \    <f32 as Sum<&'a f32>>\n               <f32 as Sum>\n               <f64 as\
    \ Sum<&'a f64>>\n               <f64 as Sum>\n               <i128 as Sum<&'a\
    \ i128>>\n               <i128 as Sum>\n               <i16 as Sum<&'a i16>>\n\
    \               <i16 as Sum>\n             and 20 others\nnote: required by a\
    \ bound in `std::iter::Iterator::sum`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().enumerate().filter(|(_,\
    \ c)| c >= 'A' && c <= 'Z').filter(|(_, c)| c != 'Z').count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6b21jq46.rs:10:48\n   |\n\
    10 |     s.chars().enumerate().filter(|(_, c)| c >= 'A' && c <= 'Z').filter(|(_,\
    \ c)| c != 'Z').count()\n   |                                                ^^^\n\
    \   |                                                |\n   |                 \
    \                               expected `&char`, found `char`\n   |         \
    \                                       help: consider borrowing here: `&'A'`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp6b21jq46.rs:10:60\n   |\n10 |\
    \     s.chars().enumerate().filter(|(_, c)| c >= 'A' && c <= 'Z').filter(|(_,\
    \ c)| c != 'Z').count()\n   |                                                \
    \            ^^^\n   |                                                       \
    \     |\n   |                                                            expected\
    \ `&char`, found `char`\n   |                                                \
    \            help: consider borrowing here: `&'Z'`\n\nerror[E0277]: can't compare\
    \ `&char` with `char`\n  --> /tmp/tmp6b21jq46.rs:10:83\n   |\n10 |     s.chars().enumerate().filter(|(_,\
    \ c)| c >= 'A' && c <= 'Z').filter(|(_, c)| c != 'Z').count()\n   |          \
    \                                                                         ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6b21jq46.rs:10:5\n\
    \   |\n9  | fn count_upper(s: String) -> isize {\n   |                       \
    \       ----- expected `isize` because of return type\n10 |     s.chars().enumerate().filter(|(_,\
    \ c)| c >= 'A' && c <= 'Z').filter(|(_, c)| c != 'Z').count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().enumerate().filter(|(_,\
    \ c)| c >= 'A' && c <= 'Z').filter(|(_, c)| c != 'Z').count().try_into"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    count_up_to(s.len(),\
    \ |i| s.chars().any(|c| c >= 'a' && c <= 'z'))\n}\n\nfn main() {\n    let candidate\
    \ = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n  \
    \  assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_up_to` in this scope\n  --> /tmp/tmprtqxhahr.rs:10:5\n\
    \   |\n10 |     count_up_to(s.len(), |i| s.chars().any(|c| c >= 'a' && c <= 'z'))\n\
    \   |     ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().enumerate().filter(|(_,\
    \ x)| x.is_uppercase()).filter(|(_, x)| x % 2 == 0).count()\n}\n\nfn main() {\n\
    \    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpw4vm_034.rs:10:79\n\
    \   |\n10 |     s.chars().enumerate().filter(|(_, x)| x.is_uppercase()).filter(|(_,\
    \ x)| x % 2 == 0).count()\n   |                                              \
    \                               - ^ - {integer}\n   |                        \
    \                                                     |\n   |                \
    \                                                             &char\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpw4vm_034.rs:10:5\n   |\n9  | fn count_upper(s:\
    \ String) -> isize {\n   |                              ----- expected `isize`\
    \ because of return type\n10 |     s.chars().enumerate().filter(|(_, x)| x.is_uppercase()).filter(|(_,\
    \ x)| x % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().enumerate().filter(|(_,\
    \ x)| x.is_uppercase()).filter(|(_, x)| x % 2 == 0).count().try_into().unwrap()\n\
    \   |                                                                        \
    \                        ++++++++++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ *c >= 'A' && *c <= 'Z').filter(|c| *c % 2 != 0).count() + 1\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `char` by `{integer}`\n  --> /tmp/tmp9bxp23by.rs:10:64\n\
    \   |\n10 |     s.chars().filter(|c| *c >= 'A' && *c <= 'Z').filter(|c| *c % 2\
    \ != 0).count() + 1\n   |                                                    \
    \         -- ^ - {integer}\n   |                                             \
    \                |\n   |                                                     \
    \        char\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9bxp23by.rs:10:5\n\
    \   |\n9  | fn count_upper(s: String) -> isize {\n   |                       \
    \       ----- expected `isize` because of return type\n10 |     s.chars().filter(|c|\
    \ *c >= 'A' && *c <= 'Z').filter(|c| *c % 2 != 0).count() + 1\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     (s.chars().filter(|c|\
    \ *c >= 'A' && *c <= 'Z').filter(|c| *c % 2 != 0).count() + 1).try_into().unwrap()\n\
    \   |     +                                                                  \
    \              +++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0369.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    loop {\n        if\
    \ let Some(pos) = s.find('A') {\n            let s = s[..pos + 1];\n         \
    \   if s.chars().any(|c| c >= 'A' && c <= 'Z') {\n                return 1;\n\
    \            }\n        }\n        let mut s = s.chars().collect::<String>();\n\
    \        s.pop();\n        if let Some(pos) = s.find('A') {\n            let s\
    \ = s[..pos + 1];\n            if s.chars().any(|c| c >= 'A' && c <= 'Z') {\n\
    \                return 1;\n            }\n        }\n        s += 'A';\n    }\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n  --> /tmp/tmpfibniv8b.rs:12:17\n   |\n12 |             let s = s[..pos\
    \ + 1];\n   |                 ^ doesn't have a size known at compile-time\n  \
    \ |\n   = help: the trait `Sized` is not implemented for `str`\n   = note: all\
    \ local variables must have a statically known size\n   = help: unsized locals\
    \ are gated as an unstable feature\nhelp: consider borrowing here\n   |\n12 |\
    \             let s = &s[..pos + 1];\n   |                     +\n\nerror[E0277]:\
    \ the size for values of type `str` cannot be known at compilation time\n  -->\
    \ /tmp/tmpfibniv8b.rs:20:17\n   |\n20 |             let s = s[..pos + 1];\n  \
    \ |                 ^ doesn't have a size known at compile-time\n   |\n   = help:\
    \ the trait `Sized` is not implemented for `str`\n   = note: all local variables\
    \ must have a statically known size\n   = help: unsized locals are gated as an\
    \ unstable feature\nhelp: consider borrowing here\n   |\n20 |             let\
    \ s = &s[..pos + 1];\n   |                     +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpfibniv8b.rs:25:14\n   |\n25 |         s += 'A';\n   |         \
    \     ^^^ expected `&str`, found `char`\n   |\nhelp: if you meant to write a `str`\
    \ literal, use double quotes\n   |\n25 |         s += \"A\";\n   |           \
    \   ~~~\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ *c == c).filter(|c| *c >= 'A' && *c <= 'Z').filter(|c| *c % 2 == 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7kku47k_.rs:10:32\n   |\n\
    10 |     s.chars().filter(|c| *c == c).filter(|c| *c >= 'A' && *c <= 'Z').filter(|c|\
    \ *c % 2 == 0).count()\n   |                                ^ expected `char`,\
    \ found `&char`\n   |\nhelp: consider dereferencing the borrow\n   |\n10 |   \
    \  s.chars().filter(|c| *c == *c).filter(|c| *c >= 'A' && *c <= 'Z').filter(|c|\
    \ *c % 2 == 0).count()\n   |                                +\n\nerror[E0369]:\
    \ cannot mod `char` by `{integer}`\n  --> /tmp/tmp7kku47k_.rs:10:84\n   |\n10\
    \ |     s.chars().filter(|c| *c == c).filter(|c| *c >= 'A' && *c <= 'Z').filter(|c|\
    \ *c % 2 == 0).count()\n   |                                                 \
    \                                -- ^ - {integer}\n   |                      \
    \                                                           |\n   |          \
    \                                                                       char\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp7kku47k_.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| *c == c).filter(|c|\
    \ *c >= 'A' && *c <= 'Z').filter(|c| *c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ *c == c).filter(|c| *c >= 'A' && *c <= 'Z').filter(|c| *c % 2 == 0).count().try_into().unwrap()\n\
    \   |                                                                        \
    \                             ++++++++++++++++++++\n\nerror: aborting due to 3\
    \ previous errors\n\nSome errors have detailed explanations: E0308, E0369.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    count_upper_impl(s.as_bytes(),\
    \ 0, s.len())\n}\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_upper_impl` in this scope\n \
    \ --> /tmp/tmpeu5aquzf.rs:10:5\n   |\n10 |     count_upper_impl(s.as_bytes(),\
    \ 0, s.len())\n   |     ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ *c >= 'A' && *c <= 'Z' && *c != 'i').count()\n}\n\nfn main() {\n    let candidate\
    \ = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n  \
    \  assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp77kk2ei1.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| *c >=\
    \ 'A' && *c <= 'Z' && *c != 'i').count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ *c >= 'A' && *c <= 'Z' && *c != 'i').count().try_into().unwrap()\n   |     \
    \                                                                 ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.char_indices().filter_map(|i|\
    \ {\n        if i.1 % 2 == 0 {\n            Some(i)\n        } else {\n      \
    \      None\n        }\n    }).count(|&i| s.chars()[i.0 as usize] >= b'A' && s.chars()[i.0\
    \ as usize] <= b'Z')\n}\n\nfn main() {\n    let candidate = count_upper;\n   \
    \ assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"\
    abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `char` by `{integer}`\n  --> /tmp/tmpeqkq5mv_.rs:11:16\n\
    \   |\n11 |         if i.1 % 2 == 0 {\n   |            --- ^ - {integer}\n   |\
    \            |\n   |            char\n\nerror[E0061]: this function takes 0 arguments\
    \ but 1 argument was supplied\n   --> /tmp/tmpeqkq5mv_.rs:16:8\n    |\n16  | \
    \    }).count(|&i| s.chars()[i.0 as usize] >= b'A' && s.chars()[i.0 as usize]\
    \ <= b'Z')\n    |        ^^^^^ -----------------------------------------------------------------------\
    \ supplied 1 argument\n    |        |\n    |        expected 0 arguments\n   \
    \ |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpeqkq5mv_.rs:10:5\n   |\n9  |   fn count_upper(s: String) -> isize\
    \ {\n   |                                ----- expected `isize` because of return\
    \ type\n10 | /     s.char_indices().filter_map(|i| {\n11 | |         if i.1 %\
    \ 2 == 0 {\n12 | |             Some(i)\n13 | |         } else {\n14 | |      \
    \       None\n15 | |         }\n16 | |     }).count(|&i| s.chars()[i.0 as usize]\
    \ >= b'A' && s.chars()[i.0 as usize] <= b'Z')\n   | |_____________________________________________________________________________________^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n16 |     }).count(|&i|\
    \ s.chars()[i.0 as usize] >= b'A' && s.chars()[i.0 as usize] <= b'Z').try_into().unwrap()\n\
    \   |                                                                        \
    \              ++++++++++++++++++++\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0061, E0308, E0369.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ *c >= 'A' && *c <= 'Z').filter(|c| *c % 2 != 0).count()\n}\n\nfn main() {\n\
    \    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `char` by `{integer}`\n  --> /tmp/tmp1tomhmi0.rs:10:64\n\
    \   |\n10 |     s.chars().filter(|c| *c >= 'A' && *c <= 'Z').filter(|c| *c % 2\
    \ != 0).count()\n   |                                                        \
    \     -- ^ - {integer}\n   |                                                 \
    \            |\n   |                                                         \
    \    char\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1tomhmi0.rs:10:5\n\
    \   |\n9  | fn count_upper(s: String) -> isize {\n   |                       \
    \       ----- expected `isize` because of return type\n10 |     s.chars().filter(|c|\
    \ *c >= 'A' && *c <= 'Z').filter(|c| *c % 2 != 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ *c >= 'A' && *c <= 'Z').filter(|c| *c % 2 != 0).count().try_into().unwrap()\n\
    \   |                                                                        \
    \         ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().enumerate().filter(|&(i,\
    \ _)| i % 2 == 0).count().unwrap_or(0)\n}\n\nfn main() {\n    let candidate =\
    \ count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"\
    abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap_or` found for type `usize` in the\
    \ current scope\n  --> /tmp/tmp6jwcri8f.rs:10:64\n   |\n10 |     s.chars().enumerate().filter(|&(i,\
    \ _)| i % 2 == 0).count().unwrap_or(0)\n   |                                 \
    \                               ^^^^^^^^^ method not found in `usize`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 101
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    let mut counter = 0;\n\
    \    let mut last = 0;\n    let mut last_upper = 0;\n    for c in s.chars() {\n\
    \        if !c.is_uppercase() {\n            counter = counter + 1;\n        }\
    \ else {\n            if last < 3 {\n                counter = counter + 2;\n\
    \                last = counter;\n            } else {\n                counter\
    \ = counter + 2;\n                last = counter - 1;\n            }\n       \
    \     last_upper = counter;\n        }\n    }\n    last_upper\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `8`,\n right: `1`', /tmp/tmpu0b5qttu.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.char_indices()\n\
    \        .filter_map(|&(i, c)| if i % 2 == 0 && c == 'A'; Some(i - 1); None)\n\
    \        .count()\n}\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `;`\n  --> /tmp/tmpx_g3kc5f.rs:11:56\n   |\n\
    11 |         .filter_map(|&(i, c)| if i % 2 == 0 && c == 'A'; Some(i - 1); None)\n\
    \   |                               --                       ^ expected `{`\n\
    \   |                               |\n   |                               this\
    \ `if` expression has a condition, but no block\n\nerror: aborting due to previous\
    \ error\n\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    let mut i = 0;\n  \
    \  for c in s.as_bytes() {\n        if *c >= 'A' && *c <= 'Z' {\n            i\
    \ += 1;\n        }\n    }\n    i\n}\n\nfn main() {\n    let candidate = count_upper;\n\
    \    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"\
    abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7jgbmeas.rs:12:18\n   |\n\
    12 |         if *c >= 'A' && *c <= 'Z' {\n   |                  ^^^ expected `u8`,\
    \ found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7jgbmeas.rs:12:31\n\
    \   |\n12 |         if *c >= 'A' && *c <= 'Z' {\n   |                        \
    \       ^^^ expected `u8`, found `char`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ *c >= 'A' && *c <= 'Z').count() / 2\n}\n\nfn main() {\n    let candidate = count_upper;\n\
    \    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"\
    abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4y2uo7w5.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| *c >=\
    \ 'A' && *c <= 'Z').count() / 2\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     (s.chars().filter(|c|\
    \ *c >= 'A' && *c <= 'Z').count() / 2).try_into().unwrap()\n   |     +       \
    \                                                 +++++++++++++++++++++\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.char_indices().filter_map(|i|\
    \ i.filter(|c| c.is_uppercase()).count()).unwrap_or(0)\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `(usize, char)` is not an iterator\n  --> /tmp/tmp5g4bt6fj.rs:10:39\n\
    \   |\n10 |     s.char_indices().filter_map(|i| i.filter(|c| c.is_uppercase()).count()).unwrap_or(0)\n\
    \   |                                       ^^^^^^ `(usize, char)` is not an iterator\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `(usize,\
    \ char): Iterator`\n           which is required by `&mut (usize, char): Iterator`\n\
    \nerror[E0599]: no method named `unwrap_or` found for struct `FilterMap` in the\
    \ current scope\n  --> /tmp/tmp5g4bt6fj.rs:10:77\n   |\n10 |     s.char_indices().filter_map(|i|\
    \ i.filter(|c| c.is_uppercase()).count()).unwrap_or(0)\n   |                 \
    \                                                            ^^^^^^^^^ method\
    \ not found in `FilterMap<CharIndices<'_>, [closure@/tmp/tmp5g4bt6fj.rs:10:33:\
    \ 10:75]>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter_map(|c|\n\
    \        if c.is_upper() {\n            Some(c as u32)\n        } else {\n   \
    \         None\n        }\n        .count() as usize\n    }).sum()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error: unexpected closing delimiter: `)`\n  --> /tmp/tmpgb74mjl3.rs:17:6\n\
    \   |\n16 |         .count() as usize\n   |               -- block is empty, you\
    \ might have not meant to close it\n17 |     }).sum()\n   |      ^ unexpected\
    \ closing delimiter\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpgb74mjl3.rs:10:25\n\
    \   |\n10 |     s.chars().filter_map(|c|\n   |                         ^ unclosed\
    \ delimiter\n...\n17 |     }).sum()\n   |     ^ mismatched closing delimiter\n\
    \nerror: aborting due to 2 previous errors\n\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    if s.is_empty() {\n\
    \        return 0;\n    }\n    match s.chars().position(|x| x.is_uppercase())\
    \ {\n        Some(pos) => pos.step() / 2,\n        None => 0,\n    }\n}\n\nfn\
    \ main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `step` found for type `usize` in the current\
    \ scope\n  --> /tmp/tmpifc83w71.rs:14:26\n   |\n14 |         Some(pos) => pos.step()\
    \ / 2,\n   |                          ^^^^ method not found in `usize`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c > 'z').count() + count_lower(s)\n}\n\nfn main() {\n    let candidate = count_upper;\n\
    \    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"\
    abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_lower` in this scope\n  --> /tmp/tmp6xci9m46.rs:10:45\n\
    \   |\n10 |     s.chars().filter(|c| c > 'z').count() + count_lower(s)\n   | \
    \                                            ^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp6xci9m46.rs:10:30\n   |\n10 |\
    \     s.chars().filter(|c| c > 'z').count() + count_lower(s)\n   |           \
    \                   ^^^\n   |                              |\n   |           \
    \                   expected `&char`, found `char`\n   |                     \
    \         help: consider borrowing here: `&'z'`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp6xci9m46.rs:10:5\n   |\n9  | fn count_upper(s: String) -> isize\
    \ {\n   |                              ----- expected `isize` because of return\
    \ type\n10 |     s.chars().filter(|c| c > 'z').count() + count_lower(s)\n   |\
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n10 |     (s.chars().filter(|c| c >\
    \ 'z').count() + count_lower(s)).try_into().unwrap()\n   |     +             \
    \                                         +++++++++++++++++++++\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    let mut count_upper\
    \ = 0usize;\n    let mut last_upper = s.len_utf8();\n    for c in s.chars().iter()\
    \ {\n        count_upper += if is_upper(c) {\n            c as isize - last_upper\
    \ as isize\n        } else {\n            0\n        };\n        last_upper =\
    \ c;\n    }\n    count_upper\n}\n\nfn main() {\n    let candidate = count_upper;\n\
    \    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"\
    abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_upper` in this scope\n  --> /tmp/tmpsigl6nop.rs:13:27\n\
    \   |\n13 |         count_upper += if is_upper(c) {\n   |                    \
    \       ^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `len_utf8`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpsigl6nop.rs:11:28\n\
    \   |\n11 |     let mut last_upper = s.len_utf8();\n   |                     \
    \       ^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method named\
    \ `iter` found for struct `Chars` in the current scope\n  --> /tmp/tmpsigl6nop.rs:12:24\n\
    \   |\n12 |     for c in s.chars().iter() {\n   |                        ^^^^\
    \ private field, not a method\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsigl6nop.rs:20:5\n\
    \   |\n9  | fn count_upper(s: String) -> isize {\n   |                       \
    \       ----- expected `isize` because of return type\n...\n20 |     count_upper\n\
    \   |     ^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    20 |     count_upper.try_into().unwrap()\n   |                ++++++++++++++++++++\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    count_upper(s.as_bytes())\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpve4ibb3o.rs:10:17\n   |\n\
    10 |     count_upper(s.as_bytes())\n   |                 ^^^^^^^^^^^^ expected\
    \ struct `String`, found `&[u8]`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.char_indices().filter(|&(_,\
    \ c)| {\n        c.is_uppercase()\n    }).filter(|(_, c)| {\n        c.is_vowel()\n\
    \    }).count()\n}\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_vowel` found for reference `&char` in\
    \ the current scope\n  --> /tmp/tmp9zuh125s.rs:13:11\n   |\n13 |         c.is_vowel()\n\
    \   |           ^^^^^^^^ method not found in `&char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp9zuh125s.rs:10:5\n   |\n9  |   fn count_upper(s: String)\
    \ -> isize {\n   |                                ----- expected `isize` because\
    \ of return type\n10 | /     s.char_indices().filter(|&(_, c)| {\n11 | |     \
    \    c.is_uppercase()\n12 | |     }).filter(|(_, c)| {\n13 | |         c.is_vowel()\n\
    14 | |     }).count()\n   | |______________^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n14 |     }).count().try_into().unwrap()\n   |     \
    \          ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    let mut chars = s.chars();\n\
    \    let mut i = 0;\n    let mut has_uv = false;\n    while i < chars.len() {\n\
    \        match chars[i] {\n            c if !c.is_ascii_uppercase() => *i += 1,\n\
    \            c if c.is_ascii_uppercase() => has_uv = true,\n            _ => i\
    \ += 1,\n        }\n    }\n    if !has_uv {\n        0\n    } else {\n       \
    \ i\n    }\n}\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmpfk9lapmi.rs:13:21\n   |\n13 |     while i < chars.len()\
    \ {\n   |                     ^^^ method not found in `Chars<'_>`\n\nerror[E0608]:\
    \ cannot index into a value of type `Chars<'_>`\n  --> /tmp/tmpfk9lapmi.rs:14:15\n\
    \   |\n14 |         match chars[i] {\n   |               ^^^^^^^^\n\nerror[E0614]:\
    \ type `{integer}` cannot be dereferenced\n  --> /tmp/tmpfk9lapmi.rs:15:45\n \
    \  |\n15 |             c if !c.is_ascii_uppercase() => *i += 1,\n   |        \
    \                                     ^^\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0599, E0608, E0614.\nFor\
    \ more information about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    count_upper_impl(s,\
    \ 0, s.len())\n}\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_upper_impl` in this scope\n \
    \ --> /tmp/tmpopumhevi.rs:10:5\n   |\n10 |     count_upper_impl(s, 0, s.len())\n\
    \   |     ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    let mut c = 0;\n  \
    \  for c in s.chars().filter(|c| *c >= 'A' && *c <= 'Z') {\n        if *c >= 'a'\
    \ && *c <= 'z' && *c != 'A' && *c != 'a' && *c != 'e' &&\n             *c != 'i'\
    \ && *c != 'o' && *c != 'u'\n        {\n            break;\n        }\n    }\n\
    \    c\n}\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmp0tbqed3n.rs:12:12\n\
    \   |\n12 |         if *c >= 'a' && *c <= 'z' && *c != 'A' && *c != 'a' && *c\
    \ != 'e' &&\n   |            ^^\n\nerror[E0614]: type `char` cannot be dereferenced\n\
    \  --> /tmp/tmp0tbqed3n.rs:12:25\n   |\n12 |         if *c >= 'a' && *c <= 'z'\
    \ && *c != 'A' && *c != 'a' && *c != 'e' &&\n   |                         ^^\n\
    \nerror[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmp0tbqed3n.rs:12:38\n\
    \   |\n12 |         if *c >= 'a' && *c <= 'z' && *c != 'A' && *c != 'a' && *c\
    \ != 'e' &&\n   |                                      ^^\n\nerror[E0614]: type\
    \ `char` cannot be dereferenced\n  --> /tmp/tmp0tbqed3n.rs:12:51\n   |\n12 | \
    \        if *c >= 'a' && *c <= 'z' && *c != 'A' && *c != 'a' && *c != 'e' &&\n\
    \   |                                                   ^^\n\nerror[E0614]: type\
    \ `char` cannot be dereferenced\n  --> /tmp/tmp0tbqed3n.rs:12:64\n   |\n12 | \
    \        if *c >= 'a' && *c <= 'z' && *c != 'A' && *c != 'a' && *c != 'e' &&\n\
    \   |                                                                ^^\n\nerror[E0614]:\
    \ type `char` cannot be dereferenced\n  --> /tmp/tmp0tbqed3n.rs:13:14\n   |\n\
    13 |              *c != 'i' && *c != 'o' && *c != 'u'\n   |              ^^\n\n\
    error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmp0tbqed3n.rs:13:27\n\
    \   |\n13 |              *c != 'i' && *c != 'o' && *c != 'u'\n   |           \
    \                ^^\n\nerror[E0614]: type `char` cannot be dereferenced\n  -->\
    \ /tmp/tmp0tbqed3n.rs:13:40\n   |\n13 |              *c != 'i' && *c != 'o' &&\
    \ *c != 'u'\n   |                                        ^^\n\nerror: aborting\
    \ due to 8 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0614`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    let mut res = 0;\n\
    \    for (i, c) in s.chars().enumerate() {\n        if i % 2 == 0 && c.is_uppercase()\
    \ {\n            res++;\n        }\n    }\n    res\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpeijg8lbd.rs:13:16\n\
    \   |\n13 |             res++;\n   |                ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n13 |             { let tmp = res; res +=\
    \ 1; tmp };\n   |             +++++++++++    ~~~~~~~~~~~~~~~~~\n13 -         \
    \    res++;\n13 +             res += 1;\n   | \n\nerror: aborting due to previous\
    \ error\n\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 101
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    let mut vowels = 0;\n\
    \    for c in s.as_bytes() {\n        if *c >= b'a' && *c <= b'z' {\n        \
    \    vowels += 1;\n        }\n    }\n    vowels\n}\n\nfn main() {\n    let candidate\
    \ = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n  \
    \  assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `1`', /tmp/tmpr8zq_8a5.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    count_upper_helper(&mut\
    \ s, 0)\n}\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_upper_helper` in this scope\n\
    \  --> /tmp/tmphk73mjjo.rs:10:5\n   |\n10 |     count_upper_helper(&mut s, 0)\n\
    \   |     ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    // `isize` can represent\
    \ signed and unsigned integer numbers, as long as\n    // the number is not larger\
    \ than `isize::MAX`.\n    unsafe { s.chars().skip_while(|&c| c >= b'A' && c <=\
    \ b'Z') }\n        .filter(|c| c >= b'a' && c <= b'z')\n        .count() as isize\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpep8_157k.rs:12:45\n   |\n\
    12 |     unsafe { s.chars().skip_while(|&c| c >= b'A' && c <= b'Z') }\n   |  \
    \                                           ^^^^ expected `char`, found `u8`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpep8_157k.rs:12:58\n   |\n12 |\
    \     unsafe { s.chars().skip_while(|&c| c >= b'A' && c <= b'Z') }\n   |     \
    \                                                     ^^^^ expected `char`, found\
    \ `u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpep8_157k.rs:13:26\n  \
    \ |\n13 |         .filter(|c| c >= b'a' && c <= b'z')\n   |                  \
    \        ^^^^ expected `&char`, found `u8`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpep8_157k.rs:13:39\n   |\n13 |         .filter(|c| c >= b'a' &&\
    \ c <= b'z')\n   |                                       ^^^^ expected `&char`,\
    \ found `u8`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    count_chars(s.as_bytes(),\
    \ |c| match c {\n        b'A' => 0,\n        b'a' => 0,\n        _ => 1,\n   \
    \ })\n}\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_chars` in this scope\n  --> /tmp/tmp6j31d0kx.rs:10:5\n\
    \   |\n10 |     count_chars(s.as_bytes(), |c| match c {\n   |     ^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().zip(s.chars().skip(1)).filter(|(c,\
    \ _)| {\n        (c >= 'A' && c <= 'Z') && (c != 'E')\n    }).count()\n}\n\nfn\
    \ main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7nbrkrx4.rs:11:15\n   |\n\
    11 |         (c >= 'A' && c <= 'Z') && (c != 'E')\n   |               ^^^\n  \
    \ |               |\n   |               expected `&char`, found `char`\n   | \
    \              help: consider borrowing here: `&'A'`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp7nbrkrx4.rs:11:27\n   |\n11 |         (c >= 'A' && c <=\
    \ 'Z') && (c != 'E')\n   |                           ^^^\n   |               \
    \            |\n   |                           expected `&char`, found `char`\n\
    \   |                           help: consider borrowing here: `&'Z'`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmp7nbrkrx4.rs:11:38\n   |\n11\
    \ |         (c >= 'A' && c <= 'Z') && (c != 'E')\n   |                       \
    \               ^^ no implementation for `&char == char`\n   |\n   = help: the\
    \ trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp7nbrkrx4.rs:10:5\n   |\n9  |   fn count_upper(s: String) -> isize {\n\
    \   |                                ----- expected `isize` because of return\
    \ type\n10 | /     s.chars().zip(s.chars().skip(1)).filter(|(c, _)| {\n11 | |\
    \         (c >= 'A' && c <= 'Z') && (c != 'E')\n12 | |     }).count()\n   | |______________^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n12 |     }).count().try_into().unwrap()\n\
    \   |               ++++++++++++++++++++\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.char_indices()\n\
    \        .filter_map(|(i,_)| if i % 2 == 0 { Some(true) } else { None })\n   \
    \     .filter(|b| b)\n        .count()\n}\n\nfn main() {\n    let candidate =\
    \ count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"\
    abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqd80um_m.rs:12:21\n   |\n\
    12 |         .filter(|b| b)\n   |                     ^ expected `bool`, found\
    \ `&bool`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |         .filter(|b|\
    \ *b)\n   |                     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqd80um_m.rs:10:5\n\
    \   |\n9  |   fn count_upper(s: String) -> isize {\n   |                     \
    \           ----- expected `isize` because of return type\n10 | /     s.char_indices()\n\
    11 | |         .filter_map(|(i,_)| if i % 2 == 0 { Some(true) } else { None })\n\
    12 | |         .filter(|b| b)\n13 | |         .count()\n   | |________________^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n13 |         .count().try_into().unwrap()\n\
    \   |                 ++++++++++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 101
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ *c >= 'A' && *c <= 'Z').filter(|c| *c >= 'a' && *c <= 'z').count() as isize\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `1`', /tmp/tmpdtz7i1s0.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| *c != '\\0').count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdgz4i6hb.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ *c != '\\0').count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| *c != '\\0').count().try_into().unwrap()\n   |\
    \                                                                          ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    let mut count = 0;\
    \ // number of vowels up to the current position\n    let len = s.len();\n   \
    \ for i in 0..len {\n        if s[i].chars().all(|c| *c >= 'A'..'Z' && c <= 'Z')\
    \ {\n            count += 1;\n        }\n        if s[i].is_uppercase() && i +\
    \ 1 < len && s[i + 1].is_uppercase() {\n            count += 1;\n        }\n \
    \       if s[i].is_uppercase() && i == 0 && !s[i + 1].is_uppercase() {\n     \
    \       count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n  \
    \  assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp2v5iomrv.rs:13:12\n\
    \   |\n13 |         if s[i].chars().all(|c| *c >= 'A'..'Z' && c <= 'Z') {\n  \
    \ |            ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2v5iomrv.rs:13:44\n\
    \   |\n13 |         if s[i].chars().all(|c| *c >= 'A'..'Z' && c <= 'Z') {\n  \
    \ |                                            ^^^ expected `bool`, found `char`\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp2v5iomrv.rs:16:12\n\
    \   |\n16 |         if s[i].is_uppercase() && i + 1 < len && s[i + 1].is_uppercase()\
    \ {\n   |            ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp2v5iomrv.rs:16:50\n   |\n16 |         if s[i].is_uppercase() &&\
    \ i + 1 < len && s[i + 1].is_uppercase() {\n   |                             \
    \                     ^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 101
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).count() as isize\n}\n\nfn main() {\n    let candidate = count_upper;\n\
    \    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"\
    abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `1`', /tmp/tmpaiv92hhy.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    count_upper_aux(&s,\
    \ s.length(), 0, 0)\n}\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_upper_aux` in this scope\n  -->\
    \ /tmp/tmp2pf147ak.rs:10:5\n   |\n10 |     count_upper_aux(&s, s.length(), 0,\
    \ 0)\n   |     ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method\
    \ named `length` found for struct `String` in the current scope\n  --> /tmp/tmp2pf147ak.rs:10:27\n\
    \   |\n10 |     count_upper_aux(&s, s.length(), 0, 0)\n   |                  \
    \         ^^^^^^ help: there is an associated function with a similar name: `len`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    let mut cnt = 0;\n\
    \    for &c in self.chars() {\n        if c.is_uppercase() && c < 'A' {\n    \
    \        cnt += 1;\n        }\n    }\n    cnt\n}\n\nfn main() {\n    let candidate\
    \ = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n  \
    \  assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0424]: expected value, found module `self`\n  --> /tmp/tmpex8jc9sq.rs:11:15\n\
    \   |\n9  | fn count_upper(s: String) -> isize {\n   |    ----------- this function\
    \ can't have a `self` parameter\n10 |     let mut cnt = 0;\n11 |     for &c in\
    \ self.chars() {\n   |               ^^^^ `self` value is a keyword only available\
    \ in methods with a `self` parameter\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0424`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| {\n        c % 2 == 0\n    }).count()\n}\n\nfn\
    \ main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmp1l59qpg_.rs:11:11\n\
    \   |\n11 |         c % 2 == 0\n   |         - ^ - {integer}\n   |         |\n\
    \   |         &char\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1l59qpg_.rs:10:5\n\
    \   |\n9  |   fn count_upper(s: String) -> isize {\n   |                     \
    \           ----- expected `isize` because of return type\n10 | /     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| {\n11 | |         c % 2 == 0\n12 | |     }).count()\n\
    \   | |______________^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    12 |     }).count().try_into().unwrap()\n   |               ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).count() // TODO: handle zero case\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpr5dfl7ck.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).count()\
    \ // TODO: handle zero case\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).count().try_into().unwrap() // TODO: handle zero case\n  \
    \ |                                                   ++++++++++++++++++++\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().enumerate().filter(|&(i,\
    \ c)| c >= 'A' && c <= 'Z' && i % 2 == 0).count()\n}\n\nfn main() {\n    let candidate\
    \ = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n  \
    \  assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf49jlrj0.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().enumerate().filter(|&(i,\
    \ c)| c >= 'A' && c <= 'Z' && i % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().enumerate().filter(|&(i,\
    \ c)| c >= 'A' && c <= 'Z' && i % 2 == 0).count().try_into().unwrap()\n   |  \
    \                                                                            \
    \         ++++++++++++++++++++\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().enumerate().filter(|&(_,\
    \ c)| *c >= 'A' && *c <= 'Z').count(|&(c, _)| *c >= 'A' && *c <= 'Z')\n}\n\nfn\
    \ main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpz95718mi.rs:10:44\n\
    \   |\n10 |     s.chars().enumerate().filter(|&(_, c)| *c >= 'A' && *c <= 'Z').count(|&(c,\
    \ _)| *c >= 'A' && *c <= 'Z')\n   |                                          \
    \  ^^\n\nerror[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpz95718mi.rs:10:57\n\
    \   |\n10 |     s.chars().enumerate().filter(|&(_, c)| *c >= 'A' && *c <= 'Z').count(|&(c,\
    \ _)| *c >= 'A' && *c <= 'Z')\n   |                                          \
    \               ^^\n\nerror[E0061]: this function takes 0 arguments but 1 argument\
    \ was supplied\n   --> /tmp/tmpz95718mi.rs:10:68\n    |\n10  |     s.chars().enumerate().filter(|&(_,\
    \ c)| *c >= 'A' && *c <= 'Z').count(|&(c, _)| *c >= 'A' && *c <= 'Z')\n    | \
    \                                                                   ^^^^^ --------------------------------\
    \ supplied 1 argument\n    |                                                 \
    \                   |\n    |                                                 \
    \                   expected 0 arguments\n    |\nnote: associated function defined\
    \ here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpz95718mi.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().enumerate().filter(|&(_,\
    \ c)| *c >= 'A' && *c <= 'Z').count(|&(c, _)| *c >= 'A' && *c <= 'Z')\n   |  \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().enumerate().filter(|&(_,\
    \ c)| *c >= 'A' && *c <= 'Z').count(|&(c, _)| *c >= 'A' && *c <= 'Z').try_into().unwrap()\n\
    \   |                                                                        \
    \                                   ++++++++++++++++++++\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0061, E0308,\
    \ E0614.\nFor more information about an error, try `rustc "
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    match (0..s.len()).filter(|&x|\
    \ x >= 'A' && x <= 'Z') {\n        0 => 0,\n        _ => 1 + match (&s[..]) {\n\
    \            'A'..'E' => 1,\n            'a'..'e' => 1,\n            _ => 0,\n\
    \        }\n    }\n}\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0658]: exclusive range pattern syntax is experimental\n  --> /tmp/tmpgdavpfmu.rs:13:13\n\
    \   |\n13 |             'A'..'E' => 1,\n   |             ^^^^^^^^\n   |\n   =\
    \ note: see issue #37854 <https://github.com/rust-lang/rust/issues/37854> for\
    \ more information\n\nerror[E0658]: exclusive range pattern syntax is experimental\n\
    \  --> /tmp/tmpgdavpfmu.rs:14:13\n   |\n14 |             'a'..'e' => 1,\n   |\
    \             ^^^^^^^^\n   |\n   = note: see issue #37854 <https://github.com/rust-lang/rust/issues/37854>\
    \ for more information\n\nwarning: unnecessary parentheses around `match` scrutinee\
    \ expression\n  --> /tmp/tmpgdavpfmu.rs:12:24\n   |\n12 |         _ => 1 + match\
    \ (&s[..]) {\n   |                        ^      ^\n   |\n   = note: `#[warn(unused_parens)]`\
    \ on by default\nhelp: remove these parentheses\n   |\n12 -         _ => 1 + match\
    \ (&s[..]) {\n12 +         _ => 1 + match &s[..] {\n   | \n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpgdavpfmu.rs:10:41\n   |\n10 |     match (0..s.len()).filter(|&x|\
    \ x >= 'A' && x <= 'Z') {\n   |                                         ^^^ expected\
    \ `usize`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgdavpfmu.rs:10:53\n\
    \   |\n10 |     match (0..s.len()).filter(|&x| x >= 'A' && x <= 'Z') {\n   | \
    \                                                    ^^^ expected `usize`, found\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgdavpfmu.rs:11:9\n \
    \  |\n10 |     match (0..s.len()).filter(|&x| x >= 'A' && x <= 'Z') {\n   |  \
    \         ----------------------------------------------\n   |           |   \
    \                |\n   |           |                   the expected closure\n\
    \   |           this expression has type `Filter<std::ops::Range<usize>, [closure@/tmp/tmpgdavpfmu.rs:10:31:\
    \ 10:56]>`\n11 |         0 => 0,\n   |         ^ expected struct `Filter`, found\
    \ integer\n   |\n   = note: expected struct `Filter<std::ops::Range<usize>, [closure@/tmp/tmpgdavpfmu.rs:10:31:\
    \ 10:56]>`\n                found type `{integer}`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpgdavpfmu.rs:13:13\n   |\n12 |         _ => 1 + match (&s[..])\
    \ {"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    let mut cnt = 0;\n\
    \    for c in s.chars() {\n        match c {\n            b'A'..=b'Z' => cnt +=\
    \ 1,\n            b'a'..=b'z' => cnt += 1,\n            _ => continue,\n     \
    \   }\n    }\n    cnt\n}\n\nfn main() {\n    let candidate = count_upper;\n  \
    \  assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"\
    abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7exy1hqg.rs:13:13\n   |\n\
    12 |         match c {\n   |               - this expression has type `char`\n\
    13 |             b'A'..=b'Z' => cnt += 1,\n   |             ^^^^   ---- this is\
    \ of type `u8`\n   |             |\n   |             expected `char`, found `u8`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp7exy1hqg.rs:13:20\n   |\n12 |\
    \         match c {\n   |               - this expression has type `char`\n13\
    \ |             b'A'..=b'Z' => cnt += 1,\n   |             ----   ^^^^ expected\
    \ `char`, found `u8`\n   |             |\n   |             this is of type `u8`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp7exy1hqg.rs:14:13\n   |\n12 |\
    \         match c {\n   |               - this expression has type `char`\n13\
    \ |             b'A'..=b'Z' => cnt += 1,\n14 |             b'a'..=b'z' => cnt\
    \ += 1,\n   |             ^^^^   ---- this is of type `u8`\n   |             |\n\
    \   |             expected `char`, found `u8`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp7exy1hqg.rs:14:20\n   |\n12 |         match c {\n   |         \
    \      - this expression has type `char`\n13 |             b'A'..=b'Z' => cnt\
    \ += 1,\n14 |             b'a'..=b'z' => cnt += 1,\n   |             ----   ^^^^\
    \ expected `char`, found `u8`\n   |             |\n   |             this is of\
    \ type `u8`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    count_upper_aux(s.chars(),\
    \ s.len() as usize)\n}\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_upper_aux` in this scope\n  -->\
    \ /tmp/tmpvydzl4eh.rs:10:5\n   |\n10 |     count_upper_aux(s.chars(), s.len()\
    \ as usize)\n   |     ^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().count();\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp9axw6dxl.rs:9:30\n  |\n9 |\
    \ fn count_upper(s: String) -> isize {\n  |    -----------               ^^^^^\
    \ expected `isize`, found `()`\n  |    |\n  |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.into_iter()\n   \
    \     .filter(|c| *c >= 'a' && *c <= 'z')\n        .filter(|c| '*' != c)\n   \
    \     .filter(|c| 'A' != c)\n        .filter(|c| 'a' != c)\n        .filter(|c|\
    \ '0' != c)\n        .count()\n}\n\nfn main() {\n    let candidate = count_upper;\n\
    \    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"\
    abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: the method `into_iter` exists for struct `String`, but its\
    \ trait bounds were not satisfied\n   --> /tmp/tmp0k7hlm4a.rs:10:7\n    |\n10\
    \  |       s.into_iter()\n    |         ^^^^^^^^^\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `String: Iterator`\n         \
    \   which is required by `String: IntoIterator`\n            `&String: Iterator`\n\
    \            which is required by `&String: IntoIterator`\n            `&mut String:\
    \ Iterator`\n            which is required by `&mut String: IntoIterator`\n  \
    \          `str: Sized`\n            which is required by `str: IntoIterator`\n\
    \            `str: Iterator`\n            which is required by `str: IntoIterator`\n\
    \            `&str: Iterator`\n            which is required by `&str: IntoIterator`\n\
    \            `&mut str: Iterator`\n            which is required by `&mut str:\
    \ IntoIterator`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    count_upper_rec(s,\
    \ 0, true)\n}\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_upper_rec` in this scope\n  -->\
    \ /tmp/tmp5_lefyth.rs:10:5\n   |\n10 |     count_upper_rec(s, 0, true)\n   | \
    \    ^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars()\n       \
    \ .zip(s.chars().skip(1))\n        .filter(|(c, next)| c == next)\n        .filter(|(c,\
    \ next)| c <= 'Z' && c >= 'A')\n        .count()\n}\n\nfn main() {\n    let candidate\
    \ = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n  \
    \  assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk_nn9ap0.rs:13:34\n   |\n\
    13 |         .filter(|(c, next)| c <= 'Z' && c >= 'A')\n   |                 \
    \                 ^^^\n   |                                  |\n   |         \
    \                         expected `&char`, found `char`\n   |               \
    \                   help: consider borrowing here: `&'Z'`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpk_nn9ap0.rs:13:46\n   |\n13 |         .filter(|(c, next)|\
    \ c <= 'Z' && c >= 'A')\n   |                                              ^^^\n\
    \   |                                              |\n   |                   \
    \                           expected `&char`, found `char`\n   |             \
    \                                 help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpk_nn9ap0.rs:10:5\n   |\n9  |   fn count_upper(s:\
    \ String) -> isize {\n   |                                ----- expected `isize`\
    \ because of return type\n10 | /     s.chars()\n11 | |         .zip(s.chars().skip(1))\n\
    12 | |         .filter(|(c, next)| c == next)\n13 | |         .filter(|(c, next)|\
    \ c <= 'Z' && c >= 'A')\n14 | |         .count()\n   | |________________^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n14 |         .count().try_into().unwrap()\n\
    \   |                 ++++++++++++++++++++\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter_map(|c|\n\
    \        if c.is_uppercase() && c.is_ascii() {\n            Some(c.to_ascii_lowercase())\n\
    \        } else {\n            None\n        }\n    )\n    .count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd6finda3.rs:10:5\n   |\n\
    9  |   fn count_upper(s: String) -> isize {\n   |                            \
    \    ----- expected `isize` because of return type\n10 | /     s.chars().filter_map(|c|\n\
    11 | |         if c.is_uppercase() && c.is_ascii() {\n12 | |             Some(c.to_ascii_lowercase())\n\
    13 | |         } else {\n...  |\n16 | |     )\n17 | |     .count()\n   | |____________^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n17 |     .count().try_into().unwrap()\n\
    \   |             ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().enumerate().filter(|&(idx,\
    \ _)| idx % 2 == 0).filter(|&(_, c)| c == c.to_uppercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjpvp3owu.rs:10:82\n   |\n\
    10 |     s.chars().enumerate().filter(|&(idx, _)| idx % 2 == 0).filter(|&(_, c)|\
    \ c == c.to_uppercase()).count()\n   |                                       \
    \                                           ^^^^^^^^^^^^^^^^ expected `char`,\
    \ found struct `ToUppercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjpvp3owu.rs:10:5\n\
    \   |\n9  | fn count_upper(s: String) -> isize {\n   |                       \
    \       ----- expected `isize` because of return type\n10 |     s.chars().enumerate().filter(|&(idx,\
    \ _)| idx % 2 == 0).filter(|&(_, c)| c == c.to_uppercase()).count()\n   |    \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().enumerate().filter(|&(idx,\
    \ _)| idx % 2 == 0).filter(|&(_, c)| c == c.to_uppercase()).count().try_into().unwrap()\n\
    \   |                                                                        \
    \                                   ++++++++++++++++++++\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    count_upper_helper(s.as_bytes(),\
    \ 0, true)\n}\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_upper_helper` in this scope\n\
    \  --> /tmp/tmpgviz9413.rs:10:5\n   |\n10 |     count_upper_helper(s.as_bytes(),\
    \ 0, true)\n   |     ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| *c != '_').count()\n}\n\nfn main() {\n    let candidate\
    \ = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n  \
    \  assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpitrh85wi.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ *c != '_').count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| *c != '_').count().try_into().unwrap()\n   |  \
    \                                                                       ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    count_upper_inner(s,\
    \ 0)\n}\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_upper_inner` in this scope\n\
    \  --> /tmp/tmp3c7pf268.rs:10:5\n   |\n10 |     count_upper_inner(s, 0)\n   |\
    \     ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    count_chars(s, |c:\
    \ char| c == char::Upper)\n}\n\nfn main() {\n    let candidate = count_upper;\n\
    \    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"\
    abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_chars` in this scope\n  --> /tmp/tmprxq_84ir.rs:10:5\n\
    \   |\n10 |     count_chars(s, |c: char| c == char::Upper)\n   |     ^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0599]: no associated item named `Upper` found\
    \ for type `char` in the current scope\n  --> /tmp/tmprxq_84ir.rs:10:41\n   |\n\
    10 |     count_chars(s, |c: char| c == char::Upper)\n   |                    \
    \                     ^^^^^ associated item not found in `char`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().count(|c|\
    \ c.is_uppercase() && !c.is_lowercase())\n}\n\nfn main() {\n    let candidate\
    \ = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n  \
    \  assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmptkzrs9bk.rs:10:22\n\
    \   |\n10 |     s.chars().count(|c| c.is_uppercase() && !c.is_lowercase())\n \
    \  |                      ^ consider giving this closure parameter a type\n  \
    \ |\n   = note: type must be known at this point\n\nerror[E0061]: this function\
    \ takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmptkzrs9bk.rs:10:15\n\
    \    |\n10  |     s.chars().count(|c| c.is_uppercase() && !c.is_lowercase())\n\
    \    |               ^^^^^ ----------------------------------------- supplied\
    \ 1 argument\n    |               |\n    |               expected 0 arguments\n\
    \    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmptkzrs9bk.rs:10:5\n   |\n9  | fn count_upper(s: String) -> isize\
    \ {\n   |                              ----- expected `isize` because of return\
    \ type\n10 |     s.chars().count(|c| c.is_uppercase() && !c.is_lowercase())\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n10 |     s.chars().count(|c|\
    \ c.is_uppercase() && !c.is_lowercase()).try_into().unwrap()\n   |           \
    \                                                    ++++++++++++++++++++\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0282, E0308.\nFor more information about an error, try `rustc --explain\
    \ E0061`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars()\n       \
    \ .map(|c| if c >= 'A' && c <= 'Z' { c - 'A' + 1 })\n        .filter(|&x| x %\
    \ 2 == 0)\n        .count()\n}\n\nfn main() {\n    let candidate = count_upper;\n\
    \    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"\
    abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot subtract `char` from `char`\n  --> /tmp/tmpd7ykxo90.rs:11:46\n\
    \   |\n11 |         .map(|c| if c >= 'A' && c <= 'Z' { c - 'A' + 1 })\n   |  \
    \                                          - ^ --- char\n   |                \
    \                            |\n   |                                         \
    \   char\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpd7ykxo90.rs:10:5\n \
    \  |\n9  |   fn count_upper(s: String) -> isize {\n   |                      \
    \          ----- expected `isize` because of return type\n10 | /     s.chars()\n\
    11 | |         .map(|c| if c >= 'A' && c <= 'Z' { c - 'A' + 1 })\n12 | |     \
    \    .filter(|&x| x % 2 == 0)\n13 | |         .count()\n   | |________________^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n13 |         .count().try_into().unwrap()\n\
    \   |                 ++++++++++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase() && c.is_ascii()).count() / s.len()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_utnwcah.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()\
    \ && c.is_ascii()).count() / s.len()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     (s.chars().filter(|c|\
    \ c.is_uppercase() && c.is_ascii()).count() / s.len()).try_into().unwrap()\n \
    \  |     +                                                                   \
    \     +++++++++++++++++++++\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ *c >= 'A' && *c <= 'Z').filter(|c| *c % 2 != 0).count()\n}\n\nfn main() {\n\
    \    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `char` by `{integer}`\n  --> /tmp/tmp1tomhmi0.rs:10:64\n\
    \   |\n10 |     s.chars().filter(|c| *c >= 'A' && *c <= 'Z').filter(|c| *c % 2\
    \ != 0).count()\n   |                                                        \
    \     -- ^ - {integer}\n   |                                                 \
    \            |\n   |                                                         \
    \    char\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1tomhmi0.rs:10:5\n\
    \   |\n9  | fn count_upper(s: String) -> isize {\n   |                       \
    \       ----- expected `isize` because of return type\n10 |     s.chars().filter(|c|\
    \ *c >= 'A' && *c <= 'Z').filter(|c| *c % 2 != 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ *c >= 'A' && *c <= 'Z').filter(|c| *c % 2 != 0).count().try_into().unwrap()\n\
    \   |                                                                        \
    \         ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ *c == c::Upper).count()\n}\n\nfn main() {\n    let candidate = count_upper;\n\
    \    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"\
    abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `c`\n\
    \  --> /tmp/tmpf9rs7oz4.rs:10:32\n   |\n10 |     s.chars().filter(|c| *c == c::Upper).count()\n\
    \   |                                ^ use of undeclared crate or module `c`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpf9rs7oz4.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| *c == c::Upper).count()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n10 |     s.chars().filter(|c| *c == c::Upper).count().try_into().unwrap()\n\
    \   |                                                 ++++++++++++++++++++\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    count_up_down(s, 'A'\
    \ as u8, 0)\n}\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_up_down` in this scope\n  -->\
    \ /tmp/tmpbuu572do.rs:10:5\n   |\n10 |     count_up_down(s, 'A' as u8, 0)\n  \
    \ |     ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    count_matches_at(s,\
    \ |c| {\n        c.is_upper() && c.is_ascii_letter() && !c.is_digit()\n    })\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_matches_at` in this scope\n \
    \ --> /tmp/tmp4g2eb9z8.rs:10:5\n   |\n10 |     count_matches_at(s, |c| {\n   |\
    \     ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    let mut count = 0;\n\
    \    for &c in s.chars() {\n        if (c == 'A' || c == 'a') {\n            count\
    \ += 1;\n        }\n        if (c == 'E' || c == 'e') {\n            count +=\
    \ 1;\n        }\n        if (c == 'I' || c == 'i') {\n            count += 1;\n\
    \        }\n        if (c == 'O' || c == 'o') {\n            count += 1;\n   \
    \     }\n        if (c == 'U' || c == 'u') {\n            count += 1;\n      \
    \  }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = count_upper;\n\
    \    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"\
    abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpb5usuoo1.rs:12:12\n\
    \   |\n12 |         if (c == 'A' || c == 'a') {\n   |            ^           \
    \         ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove\
    \ these parentheses\n   |\n12 -         if (c == 'A' || c == 'a') {\n12 +    \
    \     if c == 'A' || c == 'a' {\n   | \n\nwarning: unnecessary parentheses around\
    \ `if` condition\n  --> /tmp/tmpb5usuoo1.rs:15:12\n   |\n15 |         if (c ==\
    \ 'E' || c == 'e') {\n   |            ^                    ^\n   |\nhelp: remove\
    \ these parentheses\n   |\n15 -         if (c == 'E' || c == 'e') {\n15 +    \
    \     if c == 'E' || c == 'e' {\n   | \n\nwarning: unnecessary parentheses around\
    \ `if` condition\n  --> /tmp/tmpb5usuoo1.rs:18:12\n   |\n18 |         if (c ==\
    \ 'I' || c == 'i') {\n   |            ^                    ^\n   |\nhelp: remove\
    \ these parentheses\n   |\n18 -         if (c == 'I' || c == 'i') {\n18 +    \
    \     if c == 'I' || c == 'i' {\n   | \n\nwarning: unnecessary parentheses around\
    \ `if` condition\n  --> /tmp/tmpb5usuoo1.rs:21:12\n   |\n21 |         if (c ==\
    \ 'O' || c == 'o') {\n   |            ^                    ^\n   |\nhelp: remove\
    \ these parentheses\n   |\n21 -         if (c == 'O' || c == 'o') {\n21 +    \
    \     if c == 'O' || c == 'o' {\n   | \n\nwarning: unnecessary parentheses around\
    \ `if` condition\n  --> /tmp/tmpb5usuoo1.rs:24:12\n   |\n24 |         if (c ==\
    \ 'U' || c == 'u') {\n   |            ^                    ^\n   |\nhelp: remove\
    \ these parentheses\n   |\n24 -         if (c == 'U' || c == 'u') {\n24 +    \
    \     if c == 'U' || c == 'u' {\n   | \n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpb5usuoo1.rs:11:9\n   |\n11 |     for &c in s.chars() {\n   |       \
    \  ^^    --------- this expression has type `Option<char>`\n   |         |\n \
    \  |         expected `char`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `c`\n   |\n   = note:   expected type `char`\n \
    \          found reference `&_`\n\nerror: aborting due to previous error; 5 warnings\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.as_bytes()\n    \
    \    .into_iter()\n        .map(|&b| b as u8)\n        .filter(|&b| b >= 'A' as\
    \ u8)\n        .filter(|&b| b <= 'Z' as u8)\n        .filter(|&b| b & !(b as u8\
    \ == 'A' as u8))\n        .count();\n}\n\nfn main() {\n    let candidate = count_upper;\n\
    \    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"\
    abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: no implementation for `u8 & bool`\n  --> /tmp/tmp_g79shgb.rs:15:24\n\
    \   |\n15 |         .filter(|&b| b & !(b as u8 == 'A' as u8))\n   |          \
    \              ^ no implementation for `u8 & bool`\n   |\n   = help: the trait\
    \ `BitAnd<bool>` is not implemented for `u8`\n   = help: the following other types\
    \ implement trait `BitAnd<Rhs>`:\n             <&'a i128 as BitAnd<i128>>\n  \
    \           <&'a i16 as BitAnd<i16>>\n             <&'a i32 as BitAnd<i32>>\n\
    \             <&'a i64 as BitAnd<i64>>\n             <&'a i8 as BitAnd<i8>>\n\
    \             <&'a isize as BitAnd<isize>>\n             <&'a u128 as BitAnd<u128>>\n\
    \             <&'a u16 as BitAnd<u16>>\n           and 40 others\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp_g79shgb.rs:9:30\n  |\n9 | fn count_upper(s:\
    \ String) -> isize {\n  |    -----------               ^^^^^ expected `isize`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.char_indices().filter(|&(i,\
    \ _)| i % 2 == 0).count()\n}\n\nfn main() {\n    let candidate = count_upper;\n\
    \    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"\
    abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpektwo3q4.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.char_indices().filter(|&(i,\
    \ _)| i % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.char_indices().filter(|&(i,\
    \ _)| i % 2 == 0).count().try_into().unwrap()\n   |                          \
    \                                ++++++++++++++++++++\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    let mut cnt = 0;\n\
    \    for i in s.as_bytes().iter() {\n        if i.is_uppercase() {\n         \
    \   cnt += 1;\n        }\n        if i.is_lowercase() {\n            cnt += 1;\n\
    \        }\n        if i % 2 == 0 {\n            cnt += 1;\n        }\n    }\n\
    \    cnt\n}\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_uppercase` found for reference `&u8`\
    \ in the current scope\n  --> /tmp/tmp6nn71_kw.rs:12:14\n   |\n12 |         if\
    \ i.is_uppercase() {\n   |              ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `is_ascii_uppercase`\n\nerror[E0599]: no method\
    \ named `is_lowercase` found for reference `&u8` in the current scope\n  --> /tmp/tmp6nn71_kw.rs:15:14\n\
    \   |\n15 |         if i.is_lowercase() {\n   |              ^^^^^^^^^^^^ help:\
    \ there is an associated function with a similar name: `is_ascii_lowercase`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 101
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().enumerate().filter(|(i,\
    \ c)| {\n        c.is_uppercase() && i % 2 == 0\n    }).count() as isize\n}\n\n\
    fn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `1`', /tmp/tmp1xtw24zu.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    match s.as_bytes()\
    \ {\n        None => 0,\n        Some(ref b) => b.iter().enumerate().filter(|(_,\
    \ x)| x % 2 == 0).count(|(_, x)| x == b'A'),\n    }\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpimuge2w3.rs:11:9\n   |\n\
    10 |     match s.as_bytes() {\n   |           ------------ this expression has\
    \ type `&[u8]`\n11 |         None => 0,\n   |         ^^^^ expected slice `[u8]`,\
    \ found enum `Option`\n   |\n   = note: expected slice `[u8]`\n              \
    \ found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpimuge2w3.rs:12:9\n\
    \   |\n10 |     match s.as_bytes() {\n   |           ------------ this expression\
    \ has type `&[u8]`\n11 |         None => 0,\n12 |         Some(ref b) => b.iter().enumerate().filter(|(_,\
    \ x)| x % 2 == 0).count(|(_, x)| x == b'A'),\n   |         ^^^^^^^^^^^ expected\
    \ slice `[u8]`, found enum `Option`\n   |\n   = note: expected slice `[u8]`\n\
    \               found enum `Option<_>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    count_upper_bang(s.chars(),\
    \ s.len())\n}\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_upper_bang` in this scope\n \
    \ --> /tmp/tmpjbrf628r.rs:10:5\n   |\n10 |     count_upper_bang(s.chars(), s.len())\n\
    \   |     ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    count_upper_helper(s.as_bytes())\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_upper_helper` in this scope\n\
    \  --> /tmp/tmpyoh3h905.rs:10:5\n   |\n10 |     count_upper_helper(s.as_bytes())\n\
    \   |     ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    let mut counter = 0;\n\
    \    for i in 0..s.len() {\n        if s[i as usize] == 'A' || s[i as usize] ==\
    \ 'E' || s[i as usize] == 'I' || s[i as usize] == 'O' || s[i as usize] == 'U'\
    \ {\n            counter += 1;\n        }\n    }\n    counter\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpf1dcw_z4.rs:12:12\n\
    \   |\n12 |         if s[i as usize] == 'A' || s[i as usize] == 'E' || s[i as\
    \ usize] == 'I' || s[i as usize] == 'O' || s[i as usize] == 'U' {\n   |      \
    \      ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpf1dcw_z4.rs:12:36\n   |\n12 |         if s[i as usize] == 'A' ||\
    \ s[i as usize] == 'E' || s[i as usize] == 'I' || s[i as usize] == 'O' || s[i\
    \ as usize] == 'U' {\n   |                                    ^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpf1dcw_z4.rs:12:60\n   |\n12 |         if s[i as usize] == 'A' ||\
    \ s[i as usize] == 'E' || s[i as usize] == 'I' || s[i as usize] == 'O' || s[i\
    \ as usize] == 'U' {\n   |                                                   \
    \         ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement tra"
  stdout: ''
  timestamp: 1660009133
- exit_code: 101
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    if s.is_empty() {\n\
    \        return 0;\n    }\n\n    let mut sum = 0;\n    for (i, c) in s.chars().enumerate()\
    \ {\n        if i % 2 == 0 && c.is_uppercase() {\n            sum += 1;\n    \
    \    }\n    }\n    sum\n}\n\nfn main() {\n    let candidate = count_upper;\n \
    \   assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"\
    abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `1`', /tmp/tmpq6050yb9.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ *c >= 'a' && *c <= 'z').count() / 2\n}\n\nfn main() {\n    let candidate = count_upper;\n\
    \    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"\
    abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpq5au6nyq.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| *c >=\
    \ 'a' && *c <= 'z').count() / 2\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     (s.chars().filter(|c|\
    \ *c >= 'a' && *c <= 'z').count() / 2).try_into().unwrap()\n   |     +       \
    \                                                 +++++++++++++++++++++\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    count_upper_indices(s,\
    \ |index| index % 2 == 0)\n}\n\nfn main() {\n    let candidate = count_upper;\n\
    \    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"\
    abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_upper_indices` in this scope\n\
    \  --> /tmp/tmpp6djtjp6.rs:10:5\n   |\n10 |     count_upper_indices(s, |index|\
    \ index % 2 == 0)\n   |     ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 101
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter_map(|c|\
    \ if c == 'A' || c == 'a' { Some(0) } else { None }).sum()\n}\n\nfn main() {\n\
    \    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `1`', /tmp/tmpzgoiswwk.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    count_up_case(s.chars().enumerate().filter_map(|(i,\
    \ c)| {\n        if i % 2 == 0 {\n            Some(c.to_uppercase())\n       \
    \ } else {\n            None\n        }\n    }).collect::<Vec<_>>())\n}\n\nfn\
    \ main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_up_case` in this scope\n  -->\
    \ /tmp/tmp3hhdcuj2.rs:10:5\n   |\n10 |     count_up_case(s.chars().enumerate().filter_map(|(i,\
    \ c)| {\n   |     ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().fold(0, |acc,\
    \ &c| acc + ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')))\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkqaq63ud.rs:10:29\n   |\n\
    10 |     s.chars().fold(0, |acc, &c| acc + ((c >= 'A' && c <= 'Z') || (c >= 'a'\
    \ && c <= 'z')))\n   |                             ^--\n   |                 \
    \            ||\n   |                             |expected due to this\n   |\
    \                             expected `char`, found reference\n   |         \
    \                    help: did you mean `c`: `&char`\n   |\n   = note:   expected\
    \ type `char`\n           found reference `&_`\n\nerror[E0277]: cannot add `bool`\
    \ to `isize`\n  --> /tmp/tmpkqaq63ud.rs:10:37\n   |\n10 |     s.chars().fold(0,\
    \ |acc, &c| acc + ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')))\n   |  \
    \                                   ^ no implementation for `isize + bool`\n \
    \  |\n   = help: the trait `Add<bool>` is not implemented for `isize`\n   = help:\
    \ the following other types implement trait `Add<Rhs>`:\n             <&'a f32\
    \ as Add<f32>>\n             <&'a f64 as Add<f64>>\n             <&'a i128 as\
    \ Add<i128>>\n             <&'a i16 as Add<i16>>\n             <&'a i32 as Add<i32>>\n\
    \             <&'a i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n      \
    \       <&'a isize as Add<isize>>\n           and 48 others\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().enumerate().filter_map(|(_,\
    \ c)| c.is_uppercase()).count()\n}\n\nfn main() {\n    let candidate = count_upper;\n\
    \    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"\
    abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf1nv074k.rs:10:47\n   |\n\
    10 |     s.chars().enumerate().filter_map(|(_, c)| c.is_uppercase()).count()\n\
    \   |                                               ^^^^^^^^^^^^^^^^ expected\
    \ enum `Option`, found `bool`\n   |\n   = note: expected enum `Option<_>`\n  \
    \            found type `bool`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n10 |     s.chars().enumerate().filter_map(|(_, c)| Some(c.is_uppercase())).count()\n\
    \   |                                               +++++                +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpf1nv074k.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().enumerate().filter_map(|(_,\
    \ c)| c.is_uppercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().enumerate().filter_map(|(_,\
    \ c)| c.is_uppercase()).count().try_into().unwrap()\n   |                    \
    \                                                    ++++++++++++++++++++\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).count() \n}\n\nfn main() {\n    let candidate = count_upper;\n\
    \    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"\
    abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb7swg98z.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).count()\
    \ \n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c| c.is_uppercase()).count().try_into().unwrap()\
    \ \n   |                                                   ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    count_upper(s.as_bytes()).0\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpowotmutz.rs:10:17\n   |\n\
    10 |     count_upper(s.as_bytes()).0\n   |                 ^^^^^^^^^^^^ expected\
    \ struct `String`, found `&[u8]`\n\nerror[E0610]: `isize` is a primitive type\
    \ and therefore doesn't have fields\n  --> /tmp/tmpowotmutz.rs:10:31\n   |\n10\
    \ |     count_upper(s.as_bytes()).0\n   |                               ^\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0610.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    if s.is_empty() {\n\
    \        return 0;\n    }\n\n    let mut num_upper = 0;\n    let mut s = s;\n\
    \    let mut prev = 0;\n    while let Some(next) = s.split_last_mut(1) {\n   \
    \     if prev == 0 {\n            prev = next;\n        }\n        if *prev !=\
    \ *next {\n            prev = 0;\n            num_upper += 1;\n        }\n   \
    \     prev = next;\n    }\n    num_upper\n}\n\nfn main() {\n    let candidate\
    \ = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n  \
    \  assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `split_last_mut` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpj3u2bpcc.rs:17:30\n   |\n17 |     while\
    \ let Some(next) = s.split_last_mut(1) {\n   |                              ^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `split_at`\n\nerror[E0614]:\
    \ type `{integer}` cannot be dereferenced\n  --> /tmp/tmpj3u2bpcc.rs:21:12\n \
    \  |\n21 |         if *prev != *next {\n   |            ^^^^^\n\nerror[E0614]:\
    \ type `{integer}` cannot be dereferenced\n  --> /tmp/tmpj3u2bpcc.rs:21:21\n \
    \  |\n21 |         if *prev != *next {\n   |                     ^^^^^\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0599, E0614.\nFor more information about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.char_indices()\n\
    \        .filter(|&i| i % 2 == 0)\n        .filter(|&i| s.chars().any(|c| c.is_uppercase()))\n\
    \        .count()\n}\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `(usize, char)` by `{integer}`\n  --> /tmp/tmpdxetfv8g.rs:11:24\n\
    \   |\n11 |         .filter(|&i| i % 2 == 0)\n   |                      - ^ -\
    \ {integer}\n   |                      |\n   |                      (usize, char)\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpdxetfv8g.rs:10:5\n   |\n9  | \
    \  fn count_upper(s: String) -> isize {\n   |                                -----\
    \ expected `isize` because of return type\n10 | /     s.char_indices()\n11 | |\
    \         .filter(|&i| i % 2 == 0)\n12 | |         .filter(|&i| s.chars().any(|c|\
    \ c.is_uppercase()))\n13 | |         .count()\n   | |________________^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n13 |         .count().try_into().unwrap()\n\
    \   |                 ++++++++++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    count_upto(s, |c| c.is_uppercase())\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_upto` in this scope\n  --> /tmp/tmpmo4zrjrv.rs:10:5\n\
    \   |\n10 |     count_upto(s, |c| c.is_uppercase())\n   |     ^^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.char_indices().filter_map(|(_,\
    \ e)| e % 2 == 0).filter(|c| c <= 'z').count()\n}\n\nfn main() {\n    let candidate\
    \ = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n  \
    \  assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `char` by `{integer}`\n  --> /tmp/tmpgtr7r2_8.rs:10:44\n\
    \   |\n10 |     s.char_indices().filter_map(|(_, e)| e % 2 == 0).filter(|c| c\
    \ <= 'z').count()\n   |                                          - ^ - {integer}\n\
    \   |                                          |\n   |                       \
    \                   char\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgtr7r2_8.rs:10:42\n\
    \   |\n10 |     s.char_indices().filter_map(|(_, e)| e % 2 == 0).filter(|c| c\
    \ <= 'z').count()\n   |                                          ^^^^^^^^^^ expected\
    \ enum `Option`, found `bool`\n   |\n   = note: expected enum `Option<_>`\n  \
    \            found type `bool`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n10 |     s.char_indices().filter_map(|(_, e)| Some(e % 2 == 0)).filter(|c|\
    \ c <= 'z').count()\n   |                                          +++++     \
    \     +\n\nerror[E0277]: can't compare `&_` with `char`\n  --> /tmp/tmpgtr7r2_8.rs:10:67\n\
    \   |\n10 |     s.char_indices().filter_map(|(_, e)| e % 2 == 0).filter(|c| c\
    \ <= 'z').count()\n   |                                                      \
    \             ^^ no implementation for `&_ < char` and `&_ > char`\n   |\n   =\
    \ help: the trait `PartialOrd<char>` is not implemented for `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpgtr7r2_8.rs:10:5\n   |\n9  | fn count_upper(s:\
    \ String) -> isize {\n   |                              ----- expected `isize`\
    \ because of return type\n10 |     s.char_indices().filter_map(|(_, e)| e % 2\
    \ == 0).filter(|c| c <= 'z').count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.char_indices().filter_map(|(_,\
    \ e)| e % 2 == 0).filter(|c| c <= 'z').count().try_into().unwrap()\n   |     \
    \                                                                            \
    \ ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308, E0369.\nFor m"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    let mut vowels = (0..s.len()).filter(|&x|\
    \ x == 'a' || x == 'A' || x == 'e' || x == 'E' || x == 'i' || x == 'I' || x ==\
    \ 'o' || x == 'O' || x == 'u' || x == 'U');\n    vowels.cloned().filter(|&x| x\
    \ % 2 == 0).count() as isize\n}\n\nfn main() {\n    let candidate = count_upper;\n\
    \    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"\
    abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxhu3je_g.rs:10:52\n   |\n\
    10 |     let mut vowels = (0..s.len()).filter(|&x| x == 'a' || x == 'A' || x ==\
    \ 'e' || x == 'E' || x == 'i' || x == 'I' || x == 'o' || x == 'O...\n   |    \
    \                                                ^^^ expected `usize`, found `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpxhu3je_g.rs:10:64\n   |\n10 |\
    \     let mut vowels = (0..s.len()).filter(|&x| x == 'a' || x == 'A' || x == 'e'\
    \ || x == 'E' || x == 'i' || x == 'I' || x == 'o' || x == 'O...\n   |        \
    \                                                        ^^^ expected `usize`,\
    \ found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxhu3je_g.rs:10:76\n\
    \   |\n10 |     let mut vowels = (0..s.len()).filter(|&x| x == 'a' || x == 'A'\
    \ || x == 'e' || x == 'E' || x == 'i' || x == 'I' || x == 'o' || x == 'O...\n\
    \   |                                                                        \
    \    ^^^ expected `usize`, found `char`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpxhu3je_g.rs:10:88\n   |\n10 |     let mut vowels = (0..s.len()).filter(|&x|\
    \ x == 'a' || x == 'A' || x == 'e' || x == 'E' || x == 'i' || x == 'I' || x ==\
    \ 'o' || x == 'O...\n   |                                                    \
    \                                    ^^^ expected `usize`, found `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpxhu3je_g.rs:10:100\n   |\n10 |     let mut vowels\
    \ = (0..s.len()).filter(|&x| x == 'a' || x == 'A' || x == 'e' || x == 'E' || x\
    \ == 'i' || x == 'I' || x == 'o' || x == 'O...\n   |                         \
    \                                                                           ^^^\
    \ expected `usize`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxhu3je_g.rs:10:112\n\
    \   |\n10 | ...= 'A' || x == 'e' || x == 'E' || x == 'i' || x == 'I' || x == 'o'\
    \ || x == 'O' || x == 'u' || x == 'U');\n   |                                \
    \                      ^^^ expected `usize`, found `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpxhu3je_g.rs:10:124\n   |\n10 | ...= 'e' || x == 'E' ||\
    \ x == 'i' || x == 'I' || "
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    count_upper_helper(0,\
    \ s)\n}\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_upper_helper` in this scope\n\
    \  --> /tmp/tmp0i48v4o2.rs:10:5\n   |\n10 |     count_upper_helper(0, s)\n   |\
    \     ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    count_upper_helper(s.chars(),\
    \ s.len())\n}\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_upper_helper` in this scope\n\
    \  --> /tmp/tmp6wd_gy7b.rs:10:5\n   |\n10 |     count_upper_helper(s.chars(),\
    \ s.len())\n   |     ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U').count() / 4\n}\n\n\
    fn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpx8mdbu2b.rs:10:28\n\
    \   |\n10 |     s.chars().filter(|c| c == 'A' || c == 'E' || c == 'I' || c ==\
    \ 'O' || c == 'U').count() / 4\n   |                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpx8mdbu2b.rs:10:40\n\
    \   |\n10 |     s.chars().filter(|c| c == 'A' || c == 'E' || c == 'I' || c ==\
    \ 'O' || c == 'U').count() / 4\n   |                                        ^^\
    \ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpx8mdbu2b.rs:10:52\n\
    \   |\n10 |     s.chars().filter(|c| c == 'A' || c == 'E' || c == 'I' || c ==\
    \ 'O' || c == 'U').count() / 4\n   |                                         \
    \           ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmpx8mdbu2b.rs:10:64\n   |\n10 |     s.chars().filter(|c| c == 'A'\
    \ || c == 'E' || c == 'I' || c == 'O' || c == 'U').count() / 4\n   |         \
    \                                                       ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpx8mdbu2b.rs:10:76\n\
    \   |\n10 |     s.chars().filter(|c| c == 'A' || c == 'E' || c == 'I' || c ==\
    \ 'O' || c == 'U').count() / 4\n   |                                         \
    \                                   ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `P"
  stdout: ''
  timestamp: 1660009133
- exit_code: 101
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    let mut n = 0;\n  \
    \  for c in s.chars() {\n        if c >= 'a' && c <= 'z' {\n            n += 1;\n\
    \        }\n    }\n    n\n}\n\nfn main() {\n    let candidate = count_upper;\n\
    \    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"\
    abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `1`', /tmp/tmpz2nft_kj.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().count(|&c|\
    \ c == u::U('A') || c == u::U('E'))\n}\n\nfn main() {\n    let candidate = count_upper;\n\
    \    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"\
    abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `u`\n\
    \  --> /tmp/tmpohd1bo60.rs:10:31\n   |\n10 |     s.chars().count(|&c| c == u::U('A')\
    \ || c == u::U('E'))\n   |                               ^ use of undeclared crate\
    \ or module `u`\n\nerror[E0433]: failed to resolve: use of undeclared crate or\
    \ module `u`\n  --> /tmp/tmpohd1bo60.rs:10:49\n   |\n10 |     s.chars().count(|&c|\
    \ c == u::U('A') || c == u::U('E'))\n   |                                    \
    \             ^ use of undeclared crate or module `u`\n\nerror[E0061]: this function\
    \ takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpohd1bo60.rs:10:15\n\
    \    |\n10  |     s.chars().count(|&c| c == u::U('A') || c == u::U('E'))\n   \
    \ |               ^^^^^ ------------------------------------- supplied 1 argument\n\
    \    |               |\n    |               expected 0 arguments\n    |\nnote:\
    \ associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpohd1bo60.rs:10:5\n\
    \   |\n9  | fn count_upper(s: String) -> isize {\n   |                       \
    \       ----- expected `isize` because of return type\n10 |     s.chars().count(|&c|\
    \ c == u::U('A') || c == u::U('E'))\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().count(|&c|\
    \ c == u::U('A') || c == u::U('E')).try_into().unwrap()\n   |                \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0061, E0308,\
    \ E0433.\nFor more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    let mut count = vec![0];\n\
    \    let mut c = s.char_indices();\n    for (i, &(c1, c2)) in c {\n        if\
    \ ((c1 as usize == 65) && (i % 2 == 0)) {\n            count += 1;\n        }\n\
    \    }\n    count.0\n}\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmph8xr7no2.rs:13:12\n\
    \   |\n13 |         if ((c1 as usize == 65) && (i % 2 == 0)) {\n   |         \
    \   ^                                   ^\n   |\n   = note: `#[warn(unused_parens)]`\
    \ on by default\nhelp: remove these parentheses\n   |\n13 -         if ((c1 as\
    \ usize == 65) && (i % 2 == 0)) {\n13 +         if (c1 as usize == 65) && (i %\
    \ 2 == 0) {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmph8xr7no2.rs:12:13\n\
    \   |\n12 |     for (i, &(c1, c2)) in c {\n   |             ^^^^^^^^^     - this\
    \ expression has type `Option<(usize, char)>`\n   |             |\n   |      \
    \       expected `char`, found reference\n   |\n   = note:   expected type `char`\n\
    \           found reference `&_`\n\nerror[E0368]: binary assignment operation\
    \ `+=` cannot be applied to type `Vec<{integer}>`\n  --> /tmp/tmph8xr7no2.rs:14:13\n\
    \   |\n14 |             count += 1;\n   |             -----^^^^^\n   |       \
    \      |\n   |             cannot use `+=` on type `Vec<{integer}>`\n\nerror[E0609]:\
    \ no field `0` on type `Vec<{integer}>`\n  --> /tmp/tmph8xr7no2.rs:17:11\n   |\n\
    17 |     count.0\n   |           ^ unknown field\n\nerror: aborting due to 3 previous\
    \ errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308,\
    \ E0368, E0609.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars()\n       \
    \ .filter(|&c| c.is_uppercase())\n        .count(|&c| {\n            c.is_lowercase()\n\
    \        })\n}\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `&_`\n  --> /tmp/tmpqb586hwp.rs:12:17\n\
    \   |\n12 |         .count(|&c| {\n   |                 ^^ consider giving this\
    \ closure parameter the explicit type `&_`, with the type parameters specified\n\
    \   |\n   = note: type must be known at this point\n\nerror[E0061]: this function\
    \ takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpqb586hwp.rs:12:10\n\
    \    |\n12  |           .count(|&c| {\n    |  __________^^^^^_-\n    | |     \
    \     |\n    | |          expected 0 arguments\n13  | |             c.is_lowercase()\n\
    14  | |         })\n    | |_________- supplied 1 argument\n    |\nnote: associated\
    \ function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqb586hwp.rs:10:5\n\
    \   |\n9  |   fn count_upper(s: String) -> isize {\n   |                     \
    \           ----- expected `isize` because of return type\n10 | /     s.chars()\n\
    11 | |         .filter(|&c| c.is_uppercase())\n12 | |         .count(|&c| {\n\
    13 | |             c.is_lowercase()\n14 | |         })\n   | |__________^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n14 |         }).try_into().unwrap()\n\
    \   |           ++++++++++++++++++++\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0061, E0282, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.into_iter().fold(0,\
    \ |acc, &c| {\n        if c.is_uppercase() && (acc.is_even() || acc.is_positive())\
    \ {\n            acc + 1\n        } else {\n            acc\n        }\n    })\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: the method `into_iter` exists for struct `String`, but its\
    \ trait bounds were not satisfied\n   --> /tmp/tmppotvbd1y.rs:10:7\n    |\n10\
    \  |       s.into_iter().fold(0, |acc, &c| {\n    |         ^^^^^^^^^\n    |\n\
    \    = note: the following trait bounds were not satisfied:\n            `String:\
    \ Iterator`\n            which is required by `String: IntoIterator`\n       \
    \     `&String: Iterator`\n            which is required by `&String: IntoIterator`\n\
    \            `&mut String: Iterator`\n            which is required by `&mut String:\
    \ IntoIterator`\n            `str: Sized`\n            which is required by `str:\
    \ IntoIterator`\n            `str: Iterator`\n            which is required by\
    \ `str: IntoIterator`\n            `&str: Iterator`\n            which is required\
    \ by `&str: IntoIterator`\n            `&mut str: Iterator`\n            which\
    \ is required by `&mut str: IntoIterator`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ *c >= 'A' && *c <= 'Z').filter(|c| *c % 2 != 0).count()\n}\n\nfn main() {\n\
    \    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `char` by `{integer}`\n  --> /tmp/tmp1tomhmi0.rs:10:64\n\
    \   |\n10 |     s.chars().filter(|c| *c >= 'A' && *c <= 'Z').filter(|c| *c % 2\
    \ != 0).count()\n   |                                                        \
    \     -- ^ - {integer}\n   |                                                 \
    \            |\n   |                                                         \
    \    char\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1tomhmi0.rs:10:5\n\
    \   |\n9  | fn count_upper(s: String) -> isize {\n   |                       \
    \       ----- expected `isize` because of return type\n10 |     s.chars().filter(|c|\
    \ *c >= 'A' && *c <= 'Z').filter(|c| *c % 2 != 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ *c >= 'A' && *c <= 'Z').filter(|c| *c % 2 != 0).count().try_into().unwrap()\n\
    \   |                                                                        \
    \         ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    let mut i = 0;\n  \
    \  while i < s.len() {\n        if s.as_bytes()[i] >= b'A' && s.as_bytes()[i]\
    \ <= b'Z' {\n            i += 1;\n            continue;\n        }\n        return\
    \ i;\n    }\n    s.len()\n}\n\nfn main() {\n    let candidate = count_upper;\n\
    \    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"\
    abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6ru0zvss.rs:16:16\n   |\n\
    16 |         return i;\n   |                ^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         return i.try_into().unwrap();\n   |  \
    \               ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp6ru0zvss.rs:18:5\n   |\n9  | fn count_upper(s: String) -> isize {\n\
    \   |                              ----- expected `isize` because of return type\n\
    ...\n18 |     s.len()\n   |     ^^^^^^^ expected `isize`, found `usize`\n   |\n\
    help: you can convert a `usize` to an `isize` and panic if the converted value\
    \ doesn't fit\n   |\n18 |     s.len().try_into().unwrap()\n   |            ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    count_upper_helper(s.as_bytes())\n\
    }\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_upper_helper` in this scope\n\
    \  --> /tmp/tmpyoh3h905.rs:10:5\n   |\n10 |     count_upper_helper(s.as_bytes())\n\
    \   |     ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660009133
