language: rs
name: HumanEval_90_next_smallest
results:
- exit_code: 101
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() == 0 {\n        return None;\n    }\n \
    \   let mut index = 0;\n    let mut min_val = lst[index];\n    let mut min_idx\
    \ = index;\n\n    while index + 1 < lst.len() {\n        if min_val == lst[index\
    \ + 1] {\n            index += 1; // skip one value\n            continue;\n \
    \       }\n\n        if lst[index] < min_val {\n            min_val = lst[index];\n\
    \            min_idx = index;\n        }\n\n        index += 1;\n    }\n\n   \
    \ if min_val == lst[index] {\n        None\n    } else {\n        Some(lst[min_idx])\n\
    \    }\n}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(2)`', /tmp/tmpalnbb4tr.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest_idx = -1;\n    let mut second_smallest\
    \ = 99999;\n    for idx in lst.iter().enumerate() {\n        if idx != &smallest_idx\
    \ {\n            if *idx.get() < second_smallest {\n                second_smallest\
    \ = *idx.get();\n            }\n        }\n        *idx.get() += 1;\n    }\n\n\
    \    if smallest_idx == -1 && second_smallest != 9999 {\n        return None;\n\
    \    }\n\n    if smallest_idx == -1 && second_smallest == 9999 {\n        return\
    \ None;\n    }\n\n    Some(second_smallest)\n}\n\nfn main() {\n    let candidate\
    \ = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n\
    \    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpoeb_86rl.rs:16:19\n   |\n\
    16 |         if idx != &smallest_idx {\n   |                   ^^^^^^^^^^^^^ expected\
    \ tuple, found `&{integer}`\n   |\n   = note:  expected tuple `(usize, &isize)`\n\
    \           found reference `&{integer}`\n\nerror[E0599]: no method named `get`\
    \ found for tuple `(usize, &isize)` in the current scope\n  --> /tmp/tmpoeb_86rl.rs:17:21\n\
    \   |\n17 |             if *idx.get() < second_smallest {\n   |              \
    \       ^^^ method not found in `(usize, &isize)`\n\nerror[E0599]: no method named\
    \ `get` found for tuple `(usize, &isize)` in the current scope\n  --> /tmp/tmpoeb_86rl.rs:18:40\n\
    \   |\n18 |                 second_smallest = *idx.get();\n   |              \
    \                          ^^^ method not found in `(usize, &isize)`\n\nerror[E0599]:\
    \ no method named `get` found for tuple `(usize, &isize)` in the current scope\n\
    \  --> /tmp/tmpoeb_86rl.rs:21:14\n   |\n21 |         *idx.get() += 1;\n   |  \
    \            ^^^ method not found in `(usize, &isize)`\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    find_next_smallest_index(lst, 0).take()\n}\n\nfn main()\
    \ {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `find_next_smallest_index` in this scope\n\
    \  --> /tmp/tmpwg20wvy5.rs:13:5\n   |\n13 |     find_next_smallest_index(lst,\
    \ 0).take()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 101
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    // Your code here\n    None\n}\n\nfn main() {\n    let\
    \ candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n\
    \    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `None`,\n right: `Some(2)`', /tmp/tmpz9jblcci.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    match (lst.len(), lst.iter().take(lst.len()).min_by_key(|&i|\
    \ i)) {\n        (len, iter) => {\n            if len > 1 {\n                iter.next().unwrap()\n\
    \            } else {\n                None\n            }\n        }\n      \
    \  _ => None,\n    }\n}\n\nfn main() {\n    let candidate = next_smallest;\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `next` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmpti1u9ldm.rs:16:22\n   |\n16 |                 iter.next().unwrap()\n\
    \   |                      ^^^^ method not found in `Option<&isize>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    // TODO: add tests\n    let mut min = Some(vec![vec![-1]]);\n\
    \    for &x in lst {\n        if let Some(mut x) = *x.clone() {\n            x.0\
    \ += 1;\n            if x.0 < min.0.unwrap().get(0).unwrap() {\n             \
    \   min = Some(x.clone());\n            }\n        }\n    }\n    Some(min.clone())\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfngh8zjq.rs:15:9\n   |\n\
    15 |     for &x in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0609]: no field `0`\
    \ on type `Option<Vec<Vec<{integer}>>>`\n  --> /tmp/tmpfngh8zjq.rs:18:26\n   |\n\
    18 |             if x.0 < min.0.unwrap().get(0).unwrap() {\n   |             \
    \             ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfngh8zjq.rs:23:10\n\
    \   |\n23 |     Some(min.clone())\n   |          ^^^^^^^^^^^ expected `isize`,\
    \ found enum `Option`\n   |\n   = note: expected type `isize`\n              found\
    \ enum `Option<Vec<Vec<{integer}>>>`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0609.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().cloned().enumerate().take_while(|&(i, _)|\
    \ i < lst.len() - 1).next()\n        .and_then(|&(idx, _)| lst.iter().enumerate().take_while(|&(_,\
    \ jt)| jt < idx).next())\n        .and_then(|&(_, jt)| lst.iter().enumerate().take_while(|&(_,\
    \ jte)| jte < jt).next())\n        .and_then(|&(_, jte)| lst.iter().enumerate().take_while(|&(_,\
    \ jtee)| jtee < jte).next())\n        .and_then(|(_, jtee)| lst.iter().enumerate().take_while(|&(_,\
    \ jteee)| jteee < jtee).next())\n        .and_then(|(_, jteee)| lst.iter().enumerate().take_while(|&(_,\
    \ jteeele)| jteeele < jteee + 1).next())\n        .and_then(|(_, jteeele)| lst.iter().enumerate().take_while(|&(_,\
    \ jteeelee)| jteeelee < jteeele + 1).next())\n        .and_then(|(_, jteeelee)|\
    \ lst.iter().enumerate().take_while(|&(_, jteeeleele)| jteeeleele < jteeelee +\
    \ 1).next())\n        .and_then(|(_, jteeeleele)| lst.iter().enumerate().take_while(|&(_,\
    \ jteeeleelee)| jteeeleelee < jteeeleele + 1).next())\n        .and_then(|(_,\
    \ jteeeleelee)| lst.iter().enumerate().take_while(|&(_, jteeeleeleele)| jteeeleeleelee\
    \ < jteeeleelee + 1).next())\n        .and_then(|(_, jteeeleeleele)| lst.iter().enumerate().take_while(|&(_,\
    \ jteeeleeleelee)| jteeeleeleelee < jteeeleeleele + 1).next())\n        .and_then(|(_,\
    \ jteeeleeleelee)| lst.iter().enumerate().take_while(|&(_, jteeeleeleeleele)|\
    \ jteeeleeleeleelee < jteeeleeleelee + 1).next())\n        .and_then(|(_, jteeeleeleeleele)\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected one of `:` or `|`, found `)`\n  --> /tmp/tmpruid9tmr.rs:26:1\n\
    \   |\n25 |         .and_then(|(_, jteeeleeleeleele)\n   |                   \
    \                      - expected one of `:` or `|`\n26 | }\n   | ^ unexpected\
    \ token\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpruid9tmr.rs:25:18\n\
    \   |\n12 | fn next_smallest(lst: Vec<isize>) -> Option<isize> {\n   |       \
    \                                             - closing delimiter possibly meant\
    \ for this\n...\n25 |         .and_then(|(_, jteeeleeleeleele)\n   |         \
    \         ^ unclosed delimiter\n26 | }\n   | ^ mismatched closing delimiter\n\n\
    error: aborting due to 2 previous errors\n\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().enumerate().find(|(_, i)| *i == *lst.iter().skip(i).min().unwrap()).map(|(idx1,\
    \ v1)| *lst.iter().skip(idx1).min().unwrap())\n}\n\nfn main() {\n    let candidate\
    \ = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n\
    \    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwlpx8dsb.rs:13:65\n   |\n\
    13 |     lst.iter().enumerate().find(|(_, i)| *i == *lst.iter().skip(i).min().unwrap()).map(|(idx1,\
    \ v1)| *lst.iter().skip(idx1).min().unwrap())\n   |                          \
    \                                       ^ expected `usize`, found `&&isize`\n\n\
    error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpwlpx8dsb.rs:13:45\n\
    \   |\n13 |     lst.iter().enumerate().find(|(_, i)| *i == *lst.iter().skip(i).min().unwrap()).map(|(idx1,\
    \ v1)| *lst.iter().skip(idx1).min().unwrap())\n   |                          \
    \                   ^^ no implementation for `&isize == isize`\n   |\n   = help:\
    \ the trait `PartialEq<isize>` is not implemented for `&isize`\n   = help: the\
    \ following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().cloned().enumerate().filter(|(idx, item)|\
    \ {\n        if idx != 0 {\n            let mut min_idx = idx;\n            let\
    \ mut min_item = item;\n            for i in 0..idx-1 {\n                if min_item\
    \ < min_idx {\n                    min_idx = i;\n                    min_item\
    \ = lst[i];\n                }\n            }\n            min_item < item\n \
    \       } else {\n            true\n        }\n    }).next()\n        .cloned()\n\
    \        .map(|(_, item)| item)\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&usize` with `{integer}`\n  --> /tmp/tmp9g15y_jo.rs:14:16\n\
    \   |\n14 |         if idx != 0 {\n   |                ^^ no implementation for\
    \ `&usize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is\
    \ not implemented for `&usize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp9g15y_jo.rs:18:31\n   |\n18 |                 if min_item < min_idx\
    \ {\n   |                               ^^^^^^^ expected `isize`, found `usize`\n\
    \   |\n   = note: expected reference `&isize`\n              found reference `&usize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp9g15y_jo.rs:19:31\n   |\n15 |\
    \             let mut min_idx = idx;\n   |                               --- expected\
    \ due to this value\n...\n19 |                     min_idx = i;\n   |        \
    \                       ^\n   |                               |\n   |        \
    \                       expected `&usize`, found `usize`\n   |               \
    \                help: consider borrowing here: `&i`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp9g15y_jo.rs:20:32\n   |\n16 |             let mut min_item\
    \ = item;\n   |                                ---- expected due to this value\n\
    ...\n20 |                     min_item = lst[i];\n   |                       \
    \         ^^^^^^\n   |                                |\n   |                \
    \                expected `&isize`, found `isize`\n   |                      \
    \          help: consider borrowing here: `&lst[i]`\n\nerror[E0599]: `Option<(usize,\
    \ isize)>` is not an iterator\n   --> /tmp/tmp9g15y_jo.rs:28:10\n    |\n28  |\
    \           .cloned()\n    |            ^^^^^^ `Option<(usize, isize)>` is not\
    \ an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Option<(usize, isize)>: Iterator`\n            which is required\
    \ by `&mut Option<(usize, isize)>: Iterator`\n\nerror: aborting"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.is_empty() {\n        return None;\n    }\n \
    \   if lst.len() == 1 {\n        return Some(lst.next());\n    }\n    let mut\
    \ min_val = lst.first();\n    let mut min_idx = 1;\n    for idx in 1..lst.len()\
    \ {\n        let val = lst[min_idx - 1];\n        if val < min_val {\n       \
    \     min_val = val;\n            min_idx = idx;\n        }\n    }\n    Some(min_idx)\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `next` found for struct `Vec<isize>` in the\
    \ current scope\n  --> /tmp/tmp8d7v0i3m.rs:17:25\n   |\n17 |         return Some(lst.next());\n\
    \   |                         ^^^^ method not found in `Vec<isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8d7v0i3m.rs:23:18\n   |\n23 |         if val\
    \ < min_val {\n   |                  ^^^^^^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected type `isize`\n              found enum `Option<&isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp8d7v0i3m.rs:24:23\n   |\n19 |\
    \     let mut min_val = lst.first();\n   |                       ----------- expected\
    \ due to this value\n...\n24 |             min_val = val;\n   |              \
    \         ^^^ expected enum `Option`, found `isize`\n   |\n   = note: expected\
    \ enum `Option<&isize>`\n              found type `isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp8d7v0i3m.rs:28:10\n   |\n28 |     Some(min_idx)\n   | \
    \         ^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    28 |     Some(min_idx.try_into().unwrap())\n   |                 ++++++++++++++++++++\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut min_idx = lst.iter().min_by(|&_, &i| i);\n \
    \   if min_idx.is_some() {\n        return min_idx.unwrap();\n    }\n\n    None\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpewkq8f5y.rs:13:50\n   |\n\
    13 |     let mut min_idx = lst.iter().min_by(|&_, &i| i);\n   |              \
    \                                    ^ expected enum `std::cmp::Ordering`, found\
    \ `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpewkq8f5y.rs:15:16\n\
    \   |\n12 | fn next_smallest(lst: Vec<isize>) -> Option<isize> {\n   |       \
    \                               ------------- expected `Option<isize>` because\
    \ of return type\n...\n15 |         return min_idx.unwrap();\n   |           \
    \     ^^^^^^^^^^^^^^^^ expected enum `Option`, found `&isize`\n   |\n   = note:\
    \   expected enum `Option<isize>`\n           found reference `&isize`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    fn next_smallest_impl<'a>(&'a mut self) -> Option<&'a\
    \ isize> {\n        if self.len() == 0 {\n            return None;\n        }\n\
    \n        let mut current = self.remove(self.len() - 1);\n        let mut next\
    \ = self.remove(self.len() - 1);\n        if current.is_none() {\n           \
    \ return Some(next);\n        }\n        let mut smallest = current;\n       \
    \ let mut second_smallest = next;\n        while !next.is_none() {\n         \
    \   if smallest > &*next {\n                smallest = next;\n            }\n\
    \            next = next_smallest_impl(&mut next);\n        }\n        Some(smallest)\n\
    \    }\n\n    next_smallest_impl(&mut lst)\n}\n\nfn main() {\n    let candidate\
    \ = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n\
    \    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error: `self` parameter is only allowed in associated functions\n  -->\
    \ /tmp/tmp105thj5a.rs:13:31\n   |\n13 |     fn next_smallest_impl<'a>(&'a mut\
    \ self) -> Option<&'a isize> {\n   |                               ^^^^^^^^^^^^\
    \ not semantically valid as function parameter\n   |\n   = note: associated functions\
    \ are those in `impl` or `trait` definitions\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp105thj5a.rs:34:5\n   |\n12 | fn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n   |                                      -------------\
    \ expected `Option<isize>` because of return type\n...\n34 |     next_smallest_impl(&mut\
    \ lst)\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\n   = note: expected enum `Option<isize>`\n              found enum `Option<&isize>`\n\
    \nerror[E0599]: no method named `is_none` found for reference `&isize` in the\
    \ current scope\n  --> /tmp/tmp105thj5a.rs:25:21\n   |\n25 |         while !next.is_none()\
    \ {\n   |                     ^^^^^^^ method not found in `&isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp105thj5a.rs:29:20\n   |\n19 |         let mut\
    \ next = self.remove(self.len() - 1);\n   |                        ---------------------------\
    \ expected due to this value\n...\n29 |             next = next_smallest_impl(&mut\
    \ next);\n   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&isize`,\
    \ found enum `Option`\n   |\n   = note: expected reference `&isize`\n        \
    \           found enum `Option<&isize>`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.is_empty() {\n        return None;\n    }\n \
    \   let mut min = *lst.clone();\n    let mut pos = 0;\n    while let Some(elem)\
    \ = lst.get(pos)\n    {\n        if elem < min {\n            min = elem;\n  \
    \      }\n        pos += 1;\n        if pos == lst.len() {\n            break;\n\
    \        }\n    }\n    if min != *lst.clone() {\n        Some(min)\n    } else\
    \ {\n        None\n    }\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the size for values of type `[isize]` cannot be known at\
    \ compilation time\n  --> /tmp/tmpgn1cohh4.rs:16:9\n   |\n16 |     let mut min\
    \ = *lst.clone();\n   |         ^^^^^^^ doesn't have a size known at compile-time\n\
    \   |\n   = help: the trait `Sized` is not implemented for `[isize]`\n   = note:\
    \ all local variables must have a statically known size\n   = help: unsized locals\
    \ are gated as an unstable feature\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgn1cohh4.rs:20:19\n\
    \   |\n20 |         if elem < min {\n   |                   ^^^ expected `&isize`,\
    \ found slice `[isize]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgn1cohh4.rs:21:19\n\
    \   |\n16 |     let mut min = *lst.clone();\n   |                   ------------\
    \ expected due to this value\n...\n21 |             min = elem;\n   |        \
    \           ^^^^ expected slice `[isize]`, found `&isize`\n\nerror[E0277]: the\
    \ size for values of type `[isize]` cannot be known at compilation time\n  -->\
    \ /tmp/tmpgn1cohh4.rs:21:13\n   |\n21 |             min = elem;\n   |        \
    \     ^^^ doesn't have a size known at compile-time\n   |\n   = help: the trait\
    \ `Sized` is not implemented for `[isize]`\n   = note: the left-hand-side of an\
    \ assignment must have a statically known size\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpgn1cohh4.rs:29:14\n   |\n29 |         Some(min)\n   |         \
    \     ^^^ expected `isize`, found slice `[isize]`\n\nerror: aborting due to 5\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut next = vec![0] as isize;\n    let mut smallest\
    \ = std::cmp::Ordering::Greater;\n    for x in lst.iter() {\n        if smallest\
    \ == std::cmp::Ordering::Greater {\n            next = x;\n        }\n       \
    \ if x < next {\n            smallest = std::cmp::Ordering::Less;\n        }\n\
    \        if x == next {\n            continue;\n        }\n        if smallest\
    \ == std::cmp::Ordering::Less {\n            next = x;\n        }\n    }\n   \
    \ Some(next)\n}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9yiduyhi.rs:17:20\n   |\n\
    13 |     let mut next = vec![0] as isize;\n   |                    ----------------\
    \ expected due to this value\n...\n17 |             next = x;\n   |          \
    \          ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n17 |             next = *x;\n   |                    +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp9yiduyhi.rs:19:16\n   |\n19 |  \
    \       if x < next {\n   |                ^^^^\n   |                |\n   | \
    \               expected `&isize`, found `isize`\n   |                help: consider\
    \ borrowing here: `&next`\n\nerror[E0277]: can't compare `&isize` with `isize`\n\
    \  --> /tmp/tmp9yiduyhi.rs:22:14\n   |\n22 |         if x == next {\n   |    \
    \          ^^ no implementation for `&isize == isize`\n   |\n   = help: the trait\
    \ `PartialEq<isize>` is not implemented for `&isize`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             f32\n          \
    \   f64\n             i128\n             i16\n             i32\n             i64\n\
    \             i8\n             isize\n           and 6 others\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9yiduyhi.rs:26:20\n   |\n13 |     let mut next\
    \ = vec![0] as isize;\n   |                    ---------------- expected due to\
    \ this value\n...\n26 |             next = x;\n   |                    ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    26 |             next = *x;\n   |                    +\n\nerror[E0605]: non-primitive\
    \ cast: `Vec<{integer}>` as `isize`\n  --> /tmp/tmp9yiduyhi.rs:13:20\n   |\n13\
    \ |     let mut next = vec![0] as isize;\n   |                    ^^^^^^^^^^^^^^^^\
    \ an `as` expression can only be used to convert between primitive types or to\
    \ coerce to a specific trait object\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308, E0605.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    match lst.iter().next() {\n        None => None,\n \
    \       Some(val) => val,\n    }\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: `match` arms have incompatible types\n  --> /tmp/tmp56d1f29x.rs:15:22\n\
    \   |\n13 | /     match lst.iter().next() {\n14 | |         None => None,\n  \
    \ | |                 ---- this is found to be of type `Option<isize>`\n15 | |\
    \         Some(val) => val,\n   | |                      ^^^ expected enum `Option`,\
    \ found `&isize`\n16 | |     }\n   | |_____- `match` arms have incompatible types\n\
    \   |\n   = note:   expected enum `Option<isize>`\n           found reference\
    \ `&isize`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() == 0 {\n        return None;\n    }\n \
    \   let mut min_v = std::collections::Min::new(lst.iter().cloned());\n    if min_v\
    \ == lst.iter().min() {\n        return None;\n    }\n    lst.iter().skip(1).take(2).find(|&x|\
    \ x < min_v).map(|x| x).unwrap_or(0)\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: could not find `Min` in `collections`\n\
    \  --> /tmp/tmpso6iqe99.rs:16:39\n   |\n16 |     let mut min_v = std::collections::Min::new(lst.iter().cloned());\n\
    \   |                                       ^^^ could not find `Min` in `collections`\n\
    \nerror[E0277]: can't compare `&isize` with `Option<&isize>`\n  --> /tmp/tmpso6iqe99.rs:17:14\n\
    \   |\n17 |     if min_v == lst.iter().min() {\n   |              ^^ no implementation\
    \ for `&isize == Option<&isize>`\n   |\n   = help: the trait `PartialEq<Option<&isize>>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpso6iqe99.rs:20:74\n   |\n20 |     lst.iter().skip(1).take(2).find(|&x|\
    \ x < min_v).map(|x| x).unwrap_or(0)\n   |                                   \
    \                                       ^\n   |                              \
    \                                            |\n   |                         \
    \                                                 expected `&isize`, found integer\n\
    \   |                                                                        \
    \  help: consider borrowing here: `&0`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpso6iqe99.rs:20:5\n   |\n12 | fn next_smallest(lst: Vec<isize>) -> Option<isize>\
    \ {\n   |                                      ------------- expected `Option<isize>`\
    \ because of return type\n...\n20 |     lst.iter().skip(1).take(2).find(|&x| x\
    \ < min_v).map(|x| x).unwrap_or(0)\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected enum `Option`, found `&isize`\n   |\n   = note:   expected enum `Option<isize>`\n\
    \           found reference `&isize`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 101
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    // TODO: Implement your function\n    None\n}\n\nfn\
    \ main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `None`,\n right: `Some(2)`', /tmp/tmpva7l2lvd.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut it = lst.iter().cloned().enumerate();\n    let\
    \ mut min = it\n        .next()\n        .unwrap()\n        .unwrap_or(0);\n \
    \   let mut min_it = it.clone();\n    let mut i = 1;\n    while let Some(m) =\
    \ min_it.next() {\n        if *m < *min {\n            min = *m;\n           \
    \ i = 1;\n        } else {\n            i += 1;\n        }\n    }\n    Some(min)\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap_or` found for tuple `(usize, isize)`\
    \ in the current scope\n  --> /tmp/tmpzlabwpx7.rs:17:10\n   |\n17 |         .unwrap_or(0);\n\
    \   |          ^^^^^^^^^ method not found in `(usize, isize)`\n\nerror[E0614]:\
    \ type `(usize, isize)` cannot be dereferenced\n  --> /tmp/tmpzlabwpx7.rs:21:12\n\
    \   |\n21 |         if *m < *min {\n   |            ^^\n\nerror[E0614]: type `(usize,\
    \ isize)` cannot be dereferenced\n  --> /tmp/tmpzlabwpx7.rs:22:19\n   |\n22 |\
    \             min = *m;\n   |                   ^^\n\nerror: aborting due to 3\
    \ previous errors\n\nSome errors have detailed explanations: E0599, E0614.\nFor\
    \ more information about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().find_map(|i| {\n        if i == 0 {\n   \
    \         None\n        } else if i == 1 {\n            Some(1)\n        } else\
    \ {\n            Some(i - 1)\n        }\n    })\n}\n\nfn main() {\n    let candidate\
    \ = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n\
    \    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp1_h8movm.rs:14:14\n\
    \   |\n14 |         if i == 0 {\n   |              ^^ no implementation for `&isize\
    \ == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n\
    \  --> /tmp/tmp1_h8movm.rs:16:21\n   |\n16 |         } else if i == 1 {\n   |\
    \                     ^^ no implementation for `&isize == {integer}`\n   |\n \
    \  = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut min = lst[0];\n\n    for (i, &elt) in lst.iter().enumerate()\
    \ {\n        if *elt < min {\n            min = *elt;\n        }\n    }\n\n  \
    \  Some(min)\n}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpk3lt7nkv.rs:16:12\n\
    \   |\n16 |         if *elt < min {\n   |            ^^^^\n\nerror[E0614]: type\
    \ `isize` cannot be dereferenced\n  --> /tmp/tmpk3lt7nkv.rs:17:19\n   |\n17 |\
    \             min = *elt;\n   |                   ^^^^\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0614`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    Some(\n        lst.iter()\n            .zip(lst.iter().skip(1))\n\
    \            .map(|(&a, &b)| if *a < *b { *b } else { *a })\n            .nth(1)\n\
    \            .unwrap(),\n    )\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmp7tvr5_7t.rs:16:32\n\
    \   |\n16 |             .map(|(&a, &b)| if *a < *b { *b } else { *a })\n   | \
    \                               ^^\n\nerror[E0614]: type `isize` cannot be dereferenced\n\
    \  --> /tmp/tmp7tvr5_7t.rs:16:37\n   |\n16 |             .map(|(&a, &b)| if *a\
    \ < *b { *b } else { *a })\n   |                                     ^^\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmp7tvr5_7t.rs:16:42\n   |\n\
    16 |             .map(|(&a, &b)| if *a < *b { *b } else { *a })\n   |        \
    \                                  ^^\n\nerror[E0614]: type `isize` cannot be\
    \ dereferenced\n  --> /tmp/tmp7tvr5_7t.rs:16:54\n   |\n16 |             .map(|(&a,\
    \ &b)| if *a < *b { *b } else { *a })\n   |                                  \
    \                    ^^\n\nerror: aborting due to 4 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 101
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    // Your code here\n    None\n}\n\nfn main() {\n    let\
    \ candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n\
    \    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `None`,\n right: `Some(2)`', /tmp/tmpz9jblcci.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976053
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut itr = lst.iter().skip(1).take(2).rev();\n  \
    \  match itr.next() {\n        Some(Some(x)) => Some(x),\n        Some(None) =>\
    \ None,\n        None => None,\n    }\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdq8j8s8p.rs:15:14\n   |\n\
    14 |     match itr.next() {\n   |           ---------- this expression has type\
    \ `Option<&isize>`\n15 |         Some(Some(x)) => Some(x),\n   |             \
    \ ^^^^^^^ expected `isize`, found enum `Option`\n   |\n   = note: expected type\
    \ `isize`\n              found enum `Option<_>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpdq8j8s8p.rs:16:14\n   |\n14 |     match itr.next() {\n   |    \
    \       ---------- this expression has type `Option<&isize>`\n15 |         Some(Some(x))\
    \ => Some(x),\n16 |         Some(None) => None,\n   |              ^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdq8j8s8p.rs:15:31\n\
    \   |\n15 |         Some(Some(x)) => Some(x),\n   |                          \
    \     ^ expected `isize`, found reference\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\nhelp: consider dereferencing the borrow\n  \
    \ |\n15 |         Some(Some(x)) => Some(*x),\n   |                           \
    \    +\n\nerror: aborting due to 3 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut min = lst[0];\n    let mut min_index = -1;\n\
    \    for &i in lst {\n        if i == min {\n            min_index += 1;\n   \
    \     } else {\n            break;\n        }\n    }\n    if min_index == lst.len()\
    \ {\n        return None;\n    }\n    for &i in lst {\n        if min_index ==\
    \ i {\n            return Some(i);\n        }\n    }\n    None\n}\n\nfn main()\
    \ {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb9jrht2f.rs:15:9\n   |\n\
    15 |     for &i in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0277]: the trait bound\
    \ `usize: Neg` is not satisfied\n  --> /tmp/tmpb9jrht2f.rs:14:25\n   |\n14 | \
    \    let mut min_index = -1;\n   |                         ^^ the trait `Neg`\
    \ is not implemented for `usize`\n   |\n   = help: the following other types implement\
    \ trait `Neg`:\n             &f32\n             &f64\n             &i128\n   \
    \          &i16\n             &i32\n             &i64\n             &i8\n    \
    \         &isize\n           and 8 others\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpb9jrht2f.rs:25:9\n   |\n25 |     for &i in lst {\n   |        \
    \ ^^    --- this expression has type `Option<isize>`\n   |         |\n   |   \
    \      expected `isize`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `i`\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb9jrht2f.rs:27:25\n\
    \   |\n27 |             return Some(i);\n   |                         ^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n27 |             return\
    \ Some(i.try_into().unwrap());\n   |                          ++++++++++++++++++++\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut min_val = std::i32::MAX;\n    for i in lst.iter()\
    \ {\n        if *i < min_val {\n            min_val = *i;\n        }\n    }\n\
    \    min_val.cmp(&min_val + 1)\n        .unwrap()\n        .unwrap()\n       \
    \ .next()\n}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpuar9fi45.rs:15:17\n   |\n\
    15 |         if *i < min_val {\n   |                 ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n15 |         if *i < min_val.try_into().unwrap()\
    \ {\n   |                        ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpuar9fi45.rs:16:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n16\
    \ |             min_val = *i;\n   |                       ^^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpuar9fi45.rs:19:17\n\
    \   |\n19 |     min_val.cmp(&min_val + 1)\n   |                 ^^^^^^^^^^^^\n\
    \   |                 |\n   |                 expected `&i32`, found `i32`\n \
    \  |                 help: consider borrowing here: `&(&min_val + 1)`\n\nerror[E0599]:\
    \ no method named `unwrap` found for enum `std::cmp::Ordering` in the current\
    \ scope\n  --> /tmp/tmpuar9fi45.rs:20:10\n   |\n20 |         .unwrap()\n   | \
    \         ^^^^^^ method not found in `std::cmp::Ordering`\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() == 0 {\n        None\n    } else {\n  \
    \      let mut smallest = lst.iter().min().unwrap();\n        let mut second_smallest\
    \ = lst.iter().filter(|e| e <= smallest).min().unwrap();\n        if second_smallest\
    \ == smallest {\n            Some(second_smallest)\n        } else {\n       \
    \     None\n        }\n    }\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpod_0da5x.rs:17:62\n   |\n\
    17 |         let mut second_smallest = lst.iter().filter(|e| e <= smallest).min().unwrap();\n\
    \   |                                                              ^^^^^^^^ expected\
    \ `&isize`, found `isize`\n   |\n   = note: expected reference `&&isize`\n   \
    \           found reference `&isize`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpod_0da5x.rs:19:18\n   |\n19 |             Some(second_smallest)\n  \
    \ |                  ^^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n   |\n\
    help: consider dereferencing the borrow\n   |\n19 |             Some(*second_smallest)\n\
    \   |                  +\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() == 1 {\n        return Some(vec![lst[0]][0]);\n\
    \    }\n    let mut smallest_element = vec![vec![]][isize::MAX];\n    smallest_element[0][0]\
    \ = 0;\n    for i in 1..lst.len() {\n        for j in 0..i {\n            if lst[i]\
    \ < smallest_element[j][0] {\n                smallest_element[j] = [lst[i]][isize::MAX];\n\
    \            }\n            if smallest_element[j][0] < smallest_element[j][1]\
    \ {\n                smallest_element[j][0] += 1;\n                smallest_element[j][1]\
    \ = smallest_element[j][2];\n            }\n        }\n    }\n    if smallest_element[0][0]\
    \ < vec![isize::MAX][isize::MAX] {\n        return None;\n    }\n    if smallest_element[0][0]\
    \ > vec![isize::MAX][isize::MAX] {\n        smallest_element[0][1] = smallest_element[0][2];\n\
    \    }\n    smallest_element[0][2] = 0;\n    smallest_element[1][0] = 0;\n   \
    \ for i in 2..lst.len() {\n        for j in 0..i-1 {\n            if lst[i] <\
    \ smallest_element[j][0] {\n                smallest_element[j] = [lst[i]][isize::MAX];\n\
    \            }\n            if smallest_element[j][0] < smallest_element[j][1]\
    \ {\n                smallest_element[j][0] += 1;\n                smallest_element[j][1]\
    \ = smallest_element[j][2];\n            }\n        }\n    }\n    if smallest_element[1][0]\
    \ < vec![isize::MAX][isize::MAX] {\n        return None;\n    }\n    if smallest_element[1][0]\
    \ > vec![isize::MAX][isize::MAX] {\n        smallest_element[1][1] = smallest_element[1][2];\n\
    \    }\n    smallest_element[1][2] = 0;\n    for i in 3..lst.len() {\n       \
    \ for j in 0..i-1 {\n            if lst[i] < smallest_element[j][0] {\n      \
    \          smallest_element[j] = [lst[i]][isize::MAX];\n            }\n      \
    \      if smallest_element[j][0] < smallest_element[j][1] {\n                smallest_element[j][0]\
    \ += 1;\n                smallest_element[j][1] = smallest_element[j][2];\n  \
    \          }\n        }\n    }\n    if smallest_element[2][0] < vec![isize::MAX][isize::MAX]\
    \ {\n        return None;\n    }\n    if smallest_element[2][0] > vec![isize::MAX][isize::MAX]\
    \ {\n        smallest_element[2][1] = smallest_element[2][2];\n    }\n    smallest_element[2][2]\
    \ = 0;\n    for i in 4..lst.len() {\n\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpww93zgfu.rs:86:3\n\
    \   |\n12 | fn next_smallest(lst: Vec<isize>) -> Option<isize> {\n   |       \
    \                                             - unclosed delimiter\n...\n73 |\
    \     for i in 4..lst.len() {\n   |                           - this delimiter\
    \ might not be properly closed...\n74 | \n75 | }\n   | - ...as it matches this\
    \ but it has different indentation\n...\n86 | }\n   |   ^\n\nerror[E0277]: the\
    \ type `[Vec<_>]` cannot be indexed by `isize`\n  --> /tmp/tmpww93zgfu.rs:16:32\n\
    \   |\n16 |     let mut smallest_element = vec![vec![]][isize::MAX];\n   |   \
    \                             ^^^^^^^^^^^^^^^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<_>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<_>>`\n\nerror[E0277]: the type `[isize]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpww93zgfu.rs:21:39\n   |\n21 |         \
    \        smallest_element[j] = [lst[i]][isize::MAX];\n   |                   \
    \                    ^^^^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `[isize]`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpww93zgfu.rs:29:33\n   |\n29 |     if smallest_element[0][0] < vec![isize::MAX][isize::MAX]\
    \ {\n   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ in"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().position(|&x| x < lst.iter().nth(1).unwrap()).cloned()\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3uqrjuoo.rs:13:34\n   |\n\
    13 |     lst.iter().position(|&x| x < lst.iter().nth(1).unwrap()).cloned()\n \
    \  |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n13 |  \
    \   lst.iter().position(|&x| x < *lst.iter().nth(1).unwrap()).cloned()\n   | \
    \                                 +\n\nerror[E0599]: `Option<usize>` is not an\
    \ iterator\n   --> /tmp/tmp3uqrjuoo.rs:13:62\n    |\n13  |       lst.iter().position(|&x|\
    \ x < lst.iter().nth(1).unwrap()).cloned()\n    |                            \
    \                                    ^^^^^^ `Option<usize>` is not an iterator\n\
    \    |\n    = note: the following trait bounds were not satisfied:\n         \
    \   `Option<usize>: Iterator`\n            which is required by `&mut Option<usize>:\
    \ Iterator`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() == 0 {\n        return None;\n    }\n\n\
    \    let mut smallest = lst.iter().min().unwrap();\n    let mut index = lst.iter().position(|&x|\
    \ *x == smallest).unwrap();\n    loop {\n        smallest = get_next_element(index,\
    \ &mut lst, &mut smallest);\n        index = lst.iter().position(|&x| *x == smallest).unwrap();\n\
    \        if index == -1 {\n            break;\n        }\n    }\n    Some(smallest)\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `get_next_element` in this scope\n \
    \ --> /tmp/tmpo7jiuhxe.rs:20:20\n   |\n20 |         smallest = get_next_element(index,\
    \ &mut lst, &mut smallest);\n   |                    ^^^^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpo7jiuhxe.rs:18:46\n\
    \   |\n18 |     let mut index = lst.iter().position(|&x| *x == smallest).unwrap();\n\
    \   |                                              ^^\n\nerror[E0614]: type `isize`\
    \ cannot be dereferenced\n  --> /tmp/tmpo7jiuhxe.rs:21:42\n   |\n21 |        \
    \ index = lst.iter().position(|&x| *x == smallest).unwrap();\n   |           \
    \                               ^^\n\nerror[E0600]: cannot apply unary operator\
    \ `-` to type `usize`\n  --> /tmp/tmpo7jiuhxe.rs:22:21\n   |\n22 |         if\
    \ index == -1 {\n   |                     ^^\n   |                     |\n   |\
    \                     cannot apply unary operator `-`\n   |                  \
    \   help: you may have meant the maximum value of `usize`: `usize::MAX`\n   |\n\
    \   = note: unsigned values cannot be negated\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpo7jiuhxe.rs:26:10\n   |\n26 |     Some(smallest)\n   |        \
    \  ^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n26 |     Some(*smallest)\n   |          +\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0308, E0425,\
    \ E0600, E0614.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = Vec::new();\n\n    for elem in lst.iter().cloned()\
    \ {\n        if smallest.is_empty() {\n            smallest.append(elem);\n  \
    \      } else if elem < smallest[0] {\n            smallest[0] = elem;\n     \
    \   }\n    }\n\n    if smallest.is_empty() {\n        return None;\n    }\n\n\
    \    Some(smallest[1])\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbj9msg1e.rs:17:29\n   |\n\
    17 |             smallest.append(elem);\n   |                             ^^^^\
    \ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference\
    \ `&mut Vec<_>`\n                           found type `isize`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut cur = &lst[0];\n    let mut min_val = cur.unwrap();\n\
    \    for i in 1..lst.len() {\n        if min_val < cur {\n            min_val\
    \ = cur.unwrap();\n        } else {\n            cur.unwrap();\n        }\n  \
    \      cur = &lst[i];\n    }\n    min_val\n}\n\nfn main() {\n    let candidate\
    \ = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n\
    \    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap` found for reference `&isize` in\
    \ the current scope\n  --> /tmp/tmpguyq1hy8.rs:14:27\n   |\n14 |     let mut min_val\
    \ = cur.unwrap();\n   |                           ^^^^^^ method not found in `&isize`\n\
    \nerror[E0599]: no method named `unwrap` found for reference `&isize` in the current\
    \ scope\n  --> /tmp/tmpguyq1hy8.rs:17:27\n   |\n17 |             min_val = cur.unwrap();\n\
    \   |                           ^^^^^^ method not found in `&isize`\n\nerror[E0599]:\
    \ no method named `unwrap` found for reference `&isize` in the current scope\n\
    \  --> /tmp/tmpguyq1hy8.rs:19:17\n   |\n19 |             cur.unwrap();\n   | \
    \                ^^^^^^ method not found in `&isize`\n\nerror[E0277]: can't compare\
    \ `Option<isize>` with `&isize`\n  --> /tmp/tmpguyq1hy8.rs:16:20\n   |\n16 | \
    \        if min_val < cur {\n   |                    ^ no implementation for `Option<isize>\
    \ < &isize` and `Option<isize> > &isize`\n   |\n   = help: the trait `PartialOrd<&isize>`\
    \ is not implemented for `Option<isize>`\n   = help: the trait `PartialOrd` is\
    \ implemented for `Option<T>`\n\nerror: aborting due to 4 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() < 2 {\n        return None;\n    }\n\n\
    \    let mut smallest = lst.iter().nth(1).unwrap();\n    for i in 1..lst.len()\
    \ {\n        if lst.iter().nth(i).unwrap() < smallest {\n            smallest\
    \ = lst.iter().nth(i).unwrap();\n        }\n    }\n\n    Some(smallest)\n}\n\n\
    fn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpo05ch53_.rs:24:10\n   |\n\
    24 |     Some(smallest)\n   |          ^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n24 |     Some(*smallest)\n\
    \   |          +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min();\n    let mut i\
    \ = 0;\n    while i + 1 < lst.len() {\n        if smallest < lst[i] {\n      \
    \      smallest = lst[i];\n        }\n        i += 1;\n    }\n    smallest\n}\n\
    \nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpi6kinrvr.rs:16:23\n   |\n\
    16 |         if smallest < lst[i] {\n   |                       ^^^^^^ expected\
    \ enum `Option`, found `isize`\n   |\n   = note: expected enum `Option<&isize>`\n\
    \              found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpi6kinrvr.rs:17:24\n\
    \   |\n13 |     let mut smallest = lst.iter().min();\n   |                   \
    \     ---------------- expected due to this value\n...\n17 |             smallest\
    \ = lst[i];\n   |                        ^^^^^^ expected enum `Option`, found\
    \ `isize`\n   |\n   = note: expected enum `Option<&isize>`\n              found\
    \ type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpi6kinrvr.rs:21:5\n\
    \   |\n12 | fn next_smallest(lst: Vec<isize>) -> Option<isize> {\n   |       \
    \                               ------------- expected `Option<isize>` because\
    \ of return type\n...\n21 |     smallest\n   |     ^^^^^^^^ expected `isize`,\
    \ found `&isize`\n   |\n   = note: expected enum `Option<isize>`\n           \
    \   found enum `Option<&isize>`\n\nerror: aborting due to 3 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 101
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().cloned().skip(1).next()\n}\n\nfn main() {\n\
    \    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4,\
    \ 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(2)`', /tmp/tmpirn2zzp2.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().enumerate().find(|&(i, v)| v < &lst[i + 1]).map(|(i,\
    \ v)| &lst[i + 1])\n}\n\nfn main() {\n    let candidate = next_smallest;\n   \
    \ assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9ce1dy7x.rs:13:5\n   |\n\
    12 | fn next_smallest(lst: Vec<isize>) -> Option<isize> {\n   |              \
    \                        ------------- expected `Option<isize>` because of return\
    \ type\n13 |     lst.iter().enumerate().find(|&(i, v)| v < &lst[i + 1]).map(|(i,\
    \ v)| &lst[i + 1])\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\n   = note: expected enum `Option<isize>`\n\
    \              found enum `Option<&isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().filter(|x| *x < *x).next()\n}\n\nfn main()\
    \ {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp79f3b2d6.rs:13:5\n   |\n\
    12 | fn next_smallest(lst: Vec<isize>) -> Option<isize> {\n   |              \
    \                        ------------- expected `Option<isize>` because of return\
    \ type\n13 |     lst.iter().filter(|x| *x < *x).next()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\n   = note: expected enum `Option<isize>`\n\
    \              found enum `Option<&isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().min_by_key(|x| x).ok()\n}\n\nfn main() {\n\
    \    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4,\
    \ 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `ok` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmplpn8qsfb.rs:13:34\n   |\n13 |     lst.iter().min_by_key(|x|\
    \ x).ok()\n   |                                  ^^ help: there is an associated\
    \ function with a similar name: `or`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut min_val = lst.iter().min();\n    if min_val\
    \ == lst.len() {\n        return None;\n    }\n    for i in lst.iter().rev() {\n\
    \        if i == min_val {\n            min_val -= 1;\n            continue;\n\
    \        }\n        break;\n    }\n    Some(lst.iter().skip(min_val).next().unwrap())\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptz_h978_.rs:14:19\n   |\n\
    14 |     if min_val == lst.len() {\n   |                   ^^^^^^^^^ expected\
    \ enum `Option`, found `usize`\n   |\n   = note: expected enum `Option<&isize>`\n\
    \              found type `usize`\n\nerror[E0277]: can't compare `&isize` with\
    \ `Option<&isize>`\n  --> /tmp/tmptz_h978_.rs:18:14\n   |\n18 |         if i ==\
    \ min_val {\n   |              ^^ no implementation for `&isize == Option<&isize>`\n\
    \   |\n   = help: the trait `PartialEq<Option<&isize>>` is not implemented for\
    \ `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0368]: binary assignment operation `-=` cannot be\
    \ applied to type `Option<&isize>`\n  --> /tmp/tmptz_h978_.rs:19:13\n   |\n19\
    \ |             min_val -= 1;\n   |             -------^^^^^\n   |           \
    \  |\n   |             cannot use `-=` on type `Option<&isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmptz_h978_.rs:24:26\n   |\n24 |     Some(lst.iter().skip(min_val).next().unwrap())\n\
    \   |                          ^^^^^^^ expected `usize`, found enum `Option`\n\
    \   |\n   = note: expected type `usize`\n              found enum `Option<&isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmptz_h978_.rs:24:10\n   |\n24 |\
    \     Some(lst.iter().skip(min_val).next().unwrap())\n   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n24 |     Some(*lst.iter().skip(min_val).next().unwrap())\n   |        \
    \  +\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308, E0368.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().fold(None, |mem, el| {\n        mem.map(|mem|\
    \ el).or_else(|| mem.clone());\n    })\n}\n\nfn main() {\n    let candidate =\
    \ next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n \
    \   assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf3soo6oh.rs:14:38\n   |\n\
    14 |         mem.map(|mem| el).or_else(|| mem.clone());\n   |                \
    \                      ^^^^^^^^^^^ expected `&isize`, found `isize`\n   |\n  \
    \ = note: expected enum `Option<&isize>`\n              found enum `Option<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpf3soo6oh.rs:13:37\n   |\n13 |\
    \       lst.iter().fold(None, |mem, el| {\n   |  _____________________________________^\n\
    14 | |         mem.map(|mem| el).or_else(|| mem.clone());\n15 | |     })\n   |\
    \ |_____^ expected enum `Option`, found `()`\n   |\n   = note:   expected enum\
    \ `Option<isize>`\n           found unit type `()`\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![lst[0]; 2];\n    let mut it\
    \ = smallest.get_mut(0);\n    for i in 1..lst.len() {\n        smallest[0] = (*it).min();\n\
    \        if smallest[0] == lst[i] {\n            return Some(smallest[0]);\n \
    \       }\n        smallest[1] = smallest[0];\n        smallest[0] = lst[i];\n\
    \        it = smallest.get_mut(i);\n    }\n    None\n}\n\nfn main() {\n    let\
    \ candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n\
    \    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `Option<&mut isize>` cannot be dereferenced\n  --> /tmp/tmpx5jbzfee.rs:16:23\n\
    \   |\n16 |         smallest[0] = (*it).min();\n   |                       ^^^^^\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().enumerate().find(|&(i, v)| v == *lst.iter().skip(i\
    \ + 1).min().unwrap()).map(|(i, v)| i)\n}\n\nfn main() {\n    let candidate =\
    \ next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n \
    \   assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpsu8uqkwh.rs:13:45\n\
    \   |\n13 |     lst.iter().enumerate().find(|&(i, v)| v == *lst.iter().skip(i\
    \ + 1).min().unwrap()).map(|(i, v)| i)\n   |                                 \
    \            ^^ no implementation for `&isize == isize`\n   |\n   = help: the\
    \ trait `PartialEq<isize>` is not implemented for `&isize`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             f32\n          \
    \   f64\n             i128\n             i16\n             i32\n             i64\n\
    \             i8\n             isize\n           and 6 others\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpsu8uqkwh.rs:13:5\n   |\n12 | fn next_smallest(lst:\
    \ Vec<isize>) -> Option<isize> {\n   |                                      -------------\
    \ expected `Option<isize>` because of return type\n13 |     lst.iter().enumerate().find(|&(i,\
    \ v)| v == *lst.iter().skip(i + 1).min().unwrap()).map(|(i, v)| i)\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\n   = note: expected enum `Option<isize>`\n\
    \              found enum `Option<usize>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    Option::from(std::cmp::min(lst.iter().cloned().collect::<Vec<_>>()))\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 2 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmpwk86d6am.rs:13:18\n     |\n13   |     Option::from(std::cmp::min(lst.iter().cloned().collect::<Vec<_>>()))\n\
    \     |                  ^^^^^^^^^^^^^ ---------------------------------------\
    \ supplied 1 argument\n     |                  |\n     |                  expected\
    \ 2 arguments\n     |\nnote: function defined here\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().skip(1).fold(None, |a, b| {\n        if *a\
    \ > *b {\n            a\n        } else {\n            b\n        }\n    })\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0614]: type `Option<isize>` cannot be dereferenced\n  --> /tmp/tmp6naujr11.rs:14:12\n\
    \   |\n14 |         if *a > *b {\n   |            ^^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp6naujr11.rs:17:13\n   |\n17 |             b\n   |     \
    \        ^ expected enum `Option`, found `&isize`\n   |\n   = note:   expected\
    \ enum `Option<isize>`\n           found reference `&isize`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0614.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut min_val = std::i32::MAX;\n    let mut min_ele\
    \ = isize::MAX;\n\n    for elem in lst.iter() {\n        if elem < min_val {\n\
    \            min_val = elem;\n            min_ele = elem;\n        }\n    }\n\n\
    \    if min_val == isize::MAX {\n        return None;\n    }\n\n    for elem in\
    \ lst.iter() {\n        if elem == min_val {\n            continue;\n        }\n\
    \        if elem < min_ele {\n            min_ele = elem;\n        }\n    }\n\n\
    \    Some(min_ele)\n}\n\nfn main() {\n    let candidate = next_smallest;\n   \
    \ assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw2srynrv.rs:17:19\n   |\n\
    17 |         if elem < min_val {\n   |                   ^^^^^^^ expected `&isize`,\
    \ found `i32`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw2srynrv.rs:18:23\n\
    \   |\n13 |     let mut min_val = std::i32::MAX;\n   |                       -------------\
    \ expected due to this value\n...\n18 |             min_val = elem;\n   |    \
    \                   ^^^^ expected `i32`, found `&isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpw2srynrv.rs:19:23\n   |\n14 |     let mut min_ele = isize::MAX;\n\
    \   |                       ---------- expected due to this value\n...\n19 | \
    \            min_ele = elem;\n   |                       ^^^^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n19 |  \
    \           min_ele = *elem;\n   |                       +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpw2srynrv.rs:23:19\n   |\n23 |     if min_val == isize::MAX\
    \ {\n   |                   ^^^^^^^^^^ expected `i32`, found `isize`\n   |\nhelp:\
    \ you can convert an `isize` to an `i32` and panic if the converted value doesn't\
    \ fit\n   |\n23 |     if min_val == isize::MAX.try_into().unwrap() {\n   |   \
    \                          ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpw2srynrv.rs:28:20\n   |\n28 |         if elem == min_val {\n  \
    \ |                    ^^^^^^^ expected `isize`, found `i32`\n\nerror[E0277]:\
    \ can't compare `&isize` with `i32`\n  --> /tmp/tmpw2srynrv.rs:28:17\n   |\n28\
    \ |         if elem == min_val {\n   |                 ^^ no implementation for\
    \ `&isize == i32`\n   |\n   = help: the trait `PartialEq<i32>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw2srynrv.rs:31:19\n\
    \   |\n31 |         if elem < min_ele {\n   |                   ^^^^^^^\n   |\
    \                   |\n   |                   exp"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().skip(1).take(1).next()\n}\n\nfn main() {\n\
    \    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4,\
    \ 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3kmhohnq.rs:13:5\n   |\n\
    12 | fn next_smallest(lst: Vec<isize>) -> Option<isize> {\n   |              \
    \                        ------------- expected `Option<isize>` because of return\
    \ type\n13 |     lst.iter().skip(1).take(1).next()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\n   = note: expected enum `Option<isize>`\n\
    \              found enum `Option<&isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut min_idx = lst.len() - 1;\n    let mut min_value\
    \ = *lst.last().unwrap();\n    let mut cur = lst.len();\n\n    while let Some(next_item)\
    \ = lst[cur..].iter().nth(cur + 1) {\n        if *next_item < *min_value {\n \
    \           min_value = *next_item;\n            min_idx = cur;\n        }\n \
    \       cur += 1;\n    }\n    Some(min_value)\n}\n\nfn main() {\n    let candidate\
    \ = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n\
    \    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpk4ppkbl7.rs:18:25\n\
    \   |\n18 |         if *next_item < *min_value {\n   |                       \
    \  ^^^^^^^^^^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 101
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst\n        .iter()\n        .cloned()\n        .enumerate()\n\
    \        .min_by_key(|&(_, value)| value)\n        .map(|(_, value)| value)\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(2)`', /tmp/tmpryx6e9_2.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![false; lst.len()];\n    let\
    \ mut i = 1;\n    while i < lst.len() {\n        for el in lst.iter().rev() {\n\
    \            if el < smallest[i - 1] {\n                smallest[i - 1] = el;\n\
    \                break;\n            }\n        }\n        i += 1;\n    }\n\n\
    \    if smallest.is_empty() {\n        return None;\n    }\n\n    Some(smallest[0])\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfkicc4kr.rs:17:21\n   |\n\
    17 |             if el < smallest[i - 1] {\n   |                     ^^^^^^^^^^^^^^^\
    \ expected `&isize`, found `bool`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfkicc4kr.rs:18:35\n\
    \   |\n18 |                 smallest[i - 1] = el;\n   |                 ---------------\
    \   ^^ expected `bool`, found `&isize`\n   |                 |\n   |         \
    \        expected due to the type of this binding\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpfkicc4kr.rs:29:10\n   |\n29 |     Some(smallest[0])\n \
    \  |          ^^^^^^^^^^^ expected `isize`, found `bool`\n\nerror: aborting due\
    \ to 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.is_empty() {\n        return None;\n    }\n \
    \   if lst.len() < 2 {\n        return None;\n    }\n    let mut min_ = vec![];\n\
    \    let mut max_ = vec![];\n    for val in lst {\n        let min_ind = min_.iter().position(|x|\
    \ x < val).unwrap();\n        let max_ind = max_.iter().position(|x| x < val).unwrap();\n\
    \        if min_ind != max_ind {\n            min_.push(val);\n            max_.push(val);\n\
    \        } else {\n            if min_ind != 0 {\n                min_.swap(min_ind,\
    \ 0);\n                max_.swap(max_ind, 0);\n            } else {\n        \
    \        max_.push(val);\n            }\n        }\n    }\n    let min_val = min_.iter().position(|x|\
    \ x == min_).unwrap();\n    let max_val = max_.iter().position(|x| x == max_).unwrap();\n\
    \    if min_val != max_val {\n        min_[min_val]\n    } else {\n        min_.iter().position(|x|\
    \ x == max_val).unwrap()\n    }\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&_` with `isize`\n  --> /tmp/tmpk2e_0ay7.rs:22:50\n\
    \   |\n22 |         let min_ind = min_.iter().position(|x| x < val).unwrap();\n\
    \   |                                                  ^ no implementation for\
    \ `&_ < isize` and `&_ > isize`\n   |\n   = help: the trait `PartialOrd<isize>`\
    \ is not implemented for `&_`\n\nerror[E0277]: can't compare `&_` with `isize`\n\
    \  --> /tmp/tmpk2e_0ay7.rs:23:50\n   |\n23 |         let max_ind = max_.iter().position(|x|\
    \ x < val).unwrap();\n   |                                                  ^\
    \ no implementation for `&_ < isize` and `&_ > isize`\n   |\n   = help: the trait\
    \ `PartialOrd<isize>` is not implemented for `&_`\n\nerror[E0277]: can't compare\
    \ `&isize` with `Vec<isize>`\n  --> /tmp/tmpk2e_0ay7.rs:36:46\n   |\n36 |    \
    \ let min_val = min_.iter().position(|x| x == min_).unwrap();\n   |          \
    \                                    ^^ no implementation for `&isize == Vec<isize>`\n\
    \   |\n   = help: the trait `PartialEq<Vec<isize>>` is not implemented for `&isize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror[E0277]: can't compare `&isize` with `Vec<isize>`\n  -->\
    \ /tmp/tmpk2e_0ay7.rs:37:46\n   |\n37 |     let max_val = max_.iter().position(|x|\
    \ x == max_).unwrap();\n   |                                              ^^ no\
    \ implementation for `&isize == Vec<isize>`\n   |\n   = help: the trait `PartialEq<Vec<isize>>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpk2e_0ay7.rs:39:9\n   |\n12 | fn next_smallest(lst: Vec<isize>) -> Option<isize>\
    \ {\n   |                                      ------------- expected `Option<isize>`\
    \ because of return "
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.is_empty() {\n        return None;\n    }\n \
    \   let mut smallest_idx = lst.len();\n    let mut smallest = lst[lst.len()..].iter().min().unwrap();\n\
    \    for idx in 1..lst.len() {\n        if smallest < lst[idx] {\n           \
    \ smallest_idx = idx;\n            smallest = lst[idx];\n        }\n    }\n  \
    \  Some(smallest)\n}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9q7hlp97.rs:19:23\n   |\n\
    19 |         if smallest < lst[idx] {\n   |                       ^^^^^^^^\n \
    \  |                       |\n   |                       expected `&isize`, found\
    \ `isize`\n   |                       help: consider borrowing here: `&lst[idx]`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp9q7hlp97.rs:21:24\n   |\n17 |\
    \     let mut smallest = lst[lst.len()..].iter().min().unwrap();\n   |       \
    \                 -------------------------------------- expected due to this\
    \ value\n...\n21 |             smallest = lst[idx];\n   |                    \
    \    ^^^^^^^^\n   |                        |\n   |                        expected\
    \ `&isize`, found `isize`\n   |                        help: consider borrowing\
    \ here: `&lst[idx]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9q7hlp97.rs:24:10\n\
    \   |\n24 |     Some(smallest)\n   |          ^^^^^^^^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n24 |     Some(*smallest)\n\
    \   |          +\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().cloned().rev().enumerate().find(|(i, &x)|\
    \ *x < lst.iter().rev().nth(i).unwrap()).map(|&(i, _)| i)\n}\n\nfn main() {\n\
    \    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4,\
    \ 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbn8vpp3f.rs:13:53\n   |\n\
    13 |     lst.iter().cloned().rev().enumerate().find(|(i, &x)| *x < lst.iter().rev().nth(i).unwrap()).map(|&(i,\
    \ _)| i)\n   |                                                     ^^- expected\
    \ due to this\n   |                                                     |\n  \
    \ |                                                     expected `isize`, found\
    \ reference\n   |                                                     help: you\
    \ can probably remove the explicit borrow: `x`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpbn8vpp3f.rs:13:84\n   |\n13 |     lst.iter().cloned().rev().enumerate().find(|(i,\
    \ &x)| *x < lst.iter().rev().nth(i).unwrap()).map(|&(i, _)| i)\n   |         \
    \                                                                           ^\
    \ expected `usize`, found `&usize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n13 |     lst.iter().cloned().rev().enumerate().find(|(i, &x)| *x < lst.iter().rev().nth(*i).unwrap()).map(|&(i,\
    \ _)| i)\n   |                                                               \
    \                     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbn8vpp3f.rs:13:102\n\
    \   |\n13 |     lst.iter().cloned().rev().enumerate().find(|(i, &x)| *x < lst.iter().rev().nth(i).unwrap()).map(|&(i,\
    \ _)| i)\n   |                                                               \
    \                                       ^^^^^^-\n   |                        \
    \                                                                            \
    \  |     |\n   |                                                             \
    \                                         |     expected due to this\n   |   \
    \                                                                            \
    \                       expected tuple, found reference\n   |\n   = note:  expected\
    \ tuple `(usize, isize)`\n           found reference `&_`\n\nerror: aborting due\
    \ to 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().skip(1).next()\n}\n\nfn main() {\n    let\
    \ candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n\
    \    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqoa1fd97.rs:13:5\n   |\n\
    12 | fn next_smallest(lst: Vec<isize>) -> Option<isize> {\n   |              \
    \                        ------------- expected `Option<isize>` because of return\
    \ type\n13 |     lst.iter().skip(1).next()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\n   = note: expected enum `Option<isize>`\n\
    \              found enum `Option<&isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = Some(lst.iter().min().unwrap());\n\
    \    for el in lst.iter() {\n        if el < smallest {\n            smallest\
    \ = Some(el);\n        }\n    }\n    smallest\n}\n\nfn main() {\n    let candidate\
    \ = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n\
    \    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3io2azbr.rs:15:17\n   |\n\
    15 |         if el < smallest {\n   |                 ^^^^^^^^ expected `&isize`,\
    \ found enum `Option`\n   |\n   = note: expected reference `&isize`\n        \
    \           found enum `Option<&isize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp3io2azbr.rs:19:5\n   |\n12 | fn next_smallest(lst: Vec<isize>) -> Option<isize>\
    \ {\n   |                                      ------------- expected `Option<isize>`\
    \ because of return type\n...\n19 |     smallest\n   |     ^^^^^^^^ expected `isize`,\
    \ found `&isize`\n   |\n   = note: expected enum `Option<isize>`\n           \
    \   found enum `Option<&isize>`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 101
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut it = lst.iter().cloned().peekable();\n    if\
    \ let Some(last) = it.next() {\n        if let Some(next) = it.next() {\n    \
    \        if last == next {\n                return None;\n            }\n    \
    \    }\n    }\n    it.next()\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(3)`,\n right: `Some(2)`', /tmp/tmp1r73ftgz.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.is_empty() {\n        return None;\n    }\n \
    \   let mut curr = lst.iter().skip(1).next().unwrap();\n    let mut min_2 = lst.iter().skip(2).take(2).min(|a,\
    \ b| a.partial_cmp(&b)).unwrap();\n    for x in &lst {\n        if x <= *min_2\
    \ {\n            min_2 = x;\n        }\n        if *min_2 > *x {\n           \
    \ curr = x;\n        }\n    }\n    Some(curr)\n}\n\nfn main() {\n    let candidate\
    \ = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n\
    \    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpdxna14lb.rs:17:53\n\
    \   |\n17 |     let mut min_2 = lst.iter().skip(2).take(2).min(|a, b| a.partial_cmp(&b)).unwrap();\n\
    \   |                                                     ^ consider giving this\
    \ closure parameter a type\n   |\n   = note: type must be known at this point\n\
    \nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmpdxna14lb.rs:17:48\n     |\n17   |     let mut min_2 = lst.iter().skip(2).take(2).min(|a,\
    \ b| a.partial_cmp(&b)).unwrap();\n     |                                    \
    \            ^^^ ------------------------ supplied 1 argument\n     |        \
    \                                        |\n     |                           \
    \                     expected 0 arguments\n     |\nnote: associated function\
    \ defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdxna14lb.rs:19:17\n\
    \   |\n19 |         if x <= *min_2 {\n   |                 ^^^^^^\n   |      \
    \           |\n   |                 expected `&isize`, found `isize`\n   |   \
    \              help: consider borrowing here: `&*min_2`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpdxna14lb.rs:26:10\n   |\n26 |     Some(curr)\n   |    \
    \      ^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n26 |     Some(*curr)\n   |          +\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0061, E0282,\
    \ E0308.\nFor more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().rev().skip(1).find(|&x| x < lst.iter().nth(1))\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpugus3iky.rs:13:44\n   |\n\
    13 |     lst.iter().rev().skip(1).find(|&x| x < lst.iter().nth(1))\n   |     \
    \                                       ^^^^^^^^^^^^^^^^^ expected `&isize`, found\
    \ enum `Option`\n   |\n   = note: expected reference `&isize`\n              \
    \     found enum `Option<&isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpugus3iky.rs:13:5\n\
    \   |\n12 | fn next_smallest(lst: Vec<isize>) -> Option<isize> {\n   |       \
    \                               ------------- expected `Option<isize>` because\
    \ of return type\n13 |     lst.iter().rev().skip(1).find(|&x| x < lst.iter().nth(1))\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `&isize`\n   |\n   = note: expected enum `Option<isize>`\n           \
    \   found enum `Option<&isize>`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.is_empty() {\n        return None;\n    }\n\n\
    \    Some(lst.iter().skip(1).min().unwrap())\n}\n\nfn main() {\n    let candidate\
    \ = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n\
    \    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpesp4599s.rs:17:10\n   |\n\
    17 |     Some(lst.iter().skip(1).min().unwrap())\n   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n17 |     Some(*lst.iter().skip(1).min().unwrap())\n   |          +\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.is_empty() {\n        return None;\n    }\n\n\
    \    let mut smallest = std::cmp::Ordering::Less::Greater;\n\n    for i in lst.iter()\
    \ {\n        if i == 0 {\n            continue;\n        }\n\n        if smallest\
    \ == std::cmp::Ordering::Less {\n            if *i < *lst.iter().skip(1).next()\
    \ {\n                smallest = std::cmp::Ordering::Less;\n            } else\
    \ {\n                smallest = std::cmp::Ordering::Greater;\n            }\n\
    \        } else if smallest == std::cmp::Ordering::Greater {\n            if *i\
    \ < *lst.iter().skip(2).next() {\n                smallest = std::cmp::Ordering::Less;\n\
    \            } else {\n                smallest = std::cmp::Ordering::Greater;\n\
    \            }\n        } else {\n            if *i < *lst.iter().skip(3).next()\
    \ {\n                smallest = std::cmp::Ordering::Less;\n            } else\
    \ {\n                smallest = std::cmp::Ordering::Greater;\n            }\n\
    \        }\n    }\n\n    lst.iter().skip(1).next().map(|i| *i)\n}\n\nfn main()\
    \ {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: `Less` is a variant, not a module\n  -->\
    \ /tmp/tmpwo084_w2.rs:17:44\n   |\n17 |     let mut smallest = std::cmp::Ordering::Less::Greater;\n\
    \   |                                            ^^^^ `Less` is a variant, not\
    \ a module\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpwo084_w2.rs:20:14\n\
    \   |\n20 |         if i == 0 {\n   |              ^^ no implementation for `&isize\
    \ == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0614]: type `Option<&isize>` cannot be dereferenced\n\
    \  --> /tmp/tmpwo084_w2.rs:25:21\n   |\n25 |             if *i < *lst.iter().skip(1).next()\
    \ {\n   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0614]: type\
    \ `Option<&isize>` cannot be dereferenced\n  --> /tmp/tmpwo084_w2.rs:31:21\n \
    \  |\n31 |             if *i < *lst.iter().skip(2).next() {\n   |            \
    \         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0614]: type `Option<&isize>` cannot\
    \ be dereferenced\n  --> /tmp/tmpwo084_w2.rs:37:21\n   |\n37 |             if\
    \ *i < *lst.iter().skip(3).next() {\n   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0433, E0614.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().enumerate().take_while(|&(i, v)| v < v).next()\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl3uxzyuf.rs:13:5\n   |\n\
    12 | fn next_smallest(lst: Vec<isize>) -> Option<isize> {\n   |              \
    \                        ------------- expected `Option<isize>` because of return\
    \ type\n13 |     lst.iter().enumerate().take_while(|&(i, v)| v < v).next()\n \
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found tuple\n   |\n   = note: expected enum `Option<isize>`\n              found\
    \ enum `Option<(usize, &isize)>`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut min_value = *lst.iter().min();\n    for i in\
    \ &lst[1..] {\n        if *i < min_value {\n            min_value = *i;\n    \
    \    }\n    }\n    Some(*min_value)\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `Option<&isize>` cannot be dereferenced\n  --> /tmp/tmpz5efhwsr.rs:13:25\n\
    \   |\n13 |     let mut min_value = *lst.iter().min();\n   |                 \
    \        ^^^^^^^^^^^^^^^^^\n\nerror[E0614]: type `isize` cannot be dereferenced\n\
    \  --> /tmp/tmpz5efhwsr.rs:19:10\n   |\n19 |     Some(*min_value)\n   |      \
    \    ^^^^^^^^^^\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() == 0 {\n        return None;\n    }\n \
    \   let mut min_value = lst[0];\n    let mut smallest_index = lst.len();\n   \
    \ for v in lst {\n        if v < min_value {\n            min_value = v;\n   \
    \         smallest_index = 0;\n        }\n        if v == min_value {\n      \
    \      smallest_index += 1;\n        }\n    }\n    if smallest_index == lst.len()\
    \ {\n        return None;\n    }\n    Some(min_value)\n}\n\nfn main() {\n    let\
    \ candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n\
    \    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `lst`\n   --> /tmp/tmpeewectvp.rs:27:26\n\
    \    |\n12  | fn next_smallest(lst: Vec<isize>) -> Option<isize> {\n    |    \
    \              --- move occurs because `lst` has type `Vec<isize>`, which does\
    \ not implement the `Copy` trait\n...\n18  |     for v in lst {\n    |       \
    \       --- `lst` moved due to this implicit call to `.into_iter()`\n...\n27 \
    \ |     if smallest_index == lst.len() {\n    |                          ^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice\
    \ of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18\
    \  |     for v in &lst {\n    |              +\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.is_empty() {\n        return None;\n    }\n \
    \   let mut cur = lst.iter().next().unwrap();\n    let mut new_cur = vec![cur];\n\
    \    for x in lst.iter().rev() {\n        if x < cur {\n            break;\n \
    \       }\n        new_cur.push(x);\n        cur = x;\n    }\n    Some(new_cur.iter().next().unwrap())\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpncq7azth.rs:25:10\n   |\n\
    25 |     Some(new_cur.iter().next().unwrap())\n   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `&&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n25 |     Some(**new_cur.iter().next().unwrap())\n   |          ++\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().enumerate().skip(1).next().filter(|(_, value)|\
    \ value >= 2).next()\n}\n\nfn main() {\n    let candidate = next_smallest;\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp32bd8yfb.rs:13:72\n   |\n\
    13 |     lst.iter().enumerate().skip(1).next().filter(|(_, value)| value >= 2).next()\n\
    \   |                                                                        ^\
    \ expected `&&isize`, found integer\n\nerror[E0599]: no method named `next` found\
    \ for enum `Option` in the current scope\n  --> /tmp/tmp32bd8yfb.rs:13:75\n  \
    \ |\n13 |     lst.iter().enumerate().skip(1).next().filter(|(_, value)| value\
    \ >= 2).next()\n   |                                                         \
    \                  ^^^^ method not found in `Option<(usize, &isize)>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    // use std::cmp::min;\n    lst.iter().skip(1).next().unwrap()\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmpyo8f5c.rs:14:5\n   |\n\
    12 | fn next_smallest(lst: Vec<isize>) -> Option<isize> {\n   |              \
    \                        ------------- expected `Option<isize>` because of return\
    \ type\n13 |     // use std::cmp::min;\n14 |     lst.iter().skip(1).next().unwrap()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected enum `Option`, found `&isize`\n\
    \   |\n   = note:   expected enum `Option<isize>`\n           found reference\
    \ `&isize`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut iter : Option<&mut std::iter::Iterator<Item\
    \ = isize>> = None;\n    let mut smallest = lst.iter().min_by_key(|x| x); //iterates\
    \ through all the elements\n    smallest = Some(smallest);\n    if smallest.is_none()\
    \ {\n        //if there are no elements in the vector just return None\n     \
    \   return None;\n    }\n    iter =  Some(&mut smallest.iter());\n    smallest\
    \ = None;\n    if let Some(val)=iter.next() {\n        smallest = Some(val);\n\
    \    }\n    iter = None;\n    if let Some(val)=smallest {\n        return Some(val);\n\
    \    }\n    None\n}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "warning: trait objects without an explicit `dyn` are deprecated\n  -->\
    \ /tmp/tmp27fpvcd5.rs:13:32\n   |\n13 |     let mut iter : Option<&mut std::iter::Iterator<Item\
    \ = isize>> = None;\n   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |\n   = note: `#[warn(bare_trait_objects)]` on by default\n   = warning: this\
    \ is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n\
    \   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\
    help: use `dyn`\n   |\n13 -     let mut iter : Option<&mut std::iter::Iterator<Item\
    \ = isize>> = None;\n13 +     let mut iter : Option<&mut dyn std::iter::Iterator<Item\
    \ = isize>> = None;\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmp27fpvcd5.rs:15:21\n\
    \   |\n15 |     smallest = Some(smallest);\n   |                     ^^^^^^^^\
    \ expected `&isize`, found enum `Option`\n   |\n   = note: expected reference\
    \ `&isize`\n                   found enum `Option<&isize>`\n\nerror[E0271]: type\
    \ mismatch resolving `<std::option::Iter<'_, &isize> as Iterator>::Item == isize`\n\
    \  --> /tmp/tmp27fpvcd5.rs:20:18\n   |\n20 |     iter =  Some(&mut smallest.iter());\n\
    \   |                  ^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `&&isize`\n\
    \   |\n   = note: required for the cast to the object type `dyn Iterator<Item\
    \ = isize>`\n\nerror[E0599]: no method named `next` found for enum `Option` in\
    \ the current scope\n  --> /tmp/tmp27fpvcd5.rs:22:27\n   |\n22 |     if let Some(val)=iter.next()\
    \ {\n   |                           ^^^^ method not found in `Option<&mut dyn\
    \ Iterator<Item = isize>>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp27fpvcd5.rs:27:21\n\
    \   |\n27 |         return Some(val);\n   |                     ^^^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n27 |  \
    \       return Some(*val);\n   |                     +\n\nerror: aborting due\
    \ to 4 previous errors; 1 warning emitted\n\nSome errors have detailed explanations:\
    \ E0271, E0308, E0599.\nFor more information about an error, try `rustc --expl"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().find_next(|&i| i < lst.len()).unwrap()\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `find_next` found for struct `std::slice::Iter`\
    \ in the current scope\n  --> /tmp/tmp52yenhpm.rs:13:16\n   |\n13 |     lst.iter().find_next(|&i|\
    \ i < lst.len()).unwrap()\n   |                ^^^^^^^^^ method not found in `std::slice::Iter<'_,\
    \ isize>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 101
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut min = *lst.iter().min().unwrap();\n    for i\
    \ in lst.iter() {\n        if *i < min {\n            min = *i;\n        }\n \
    \   }\n    if min == 0 {\n        return None;\n    }\n    lst.iter().find(|&x|\
    \ *x == min).cloned()\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(2)`', /tmp/tmp7pn22vxs.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = *lst.iter().min_by(|&x| x).unwrap();\n\
    \    let mut smallest2 = smallest;\n\n    if lst.len() > 0 {\n        lst.iter().position(|&x|\
    \ x == smallest).unwrap()\n            .and_then(|i| smallest2 = lst.iter()\n\
    \                .position(|&x| x == smallest2).unwrap()).unwrap();\n    }\n \
    \   smallest2\n}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0593]: closure is expected to take 2 arguments, but it takes 1 argument\n\
    \  --> /tmp/tmpp_dwyto7.rs:13:36\n   |\n13 |     let mut smallest = *lst.iter().min_by(|&x|\
    \ x).unwrap();\n   |                                    ^^^^^^ ---- takes 1 argument\n\
    \   |                                    |\n   |                             \
    \       expected closure that takes 2 arguments\n\nerror[E0599]: no method named\
    \ `and_then` found for type `usize` in the current scope\n  --> /tmp/tmpp_dwyto7.rs:18:14\n\
    \   |\n18 |             .and_then(|i| smallest2 = lst.iter()\n   |           \
    \   ^^^^^^^^ method not found in `usize`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpp_dwyto7.rs:18:39\n   |\n14 |       let mut smallest2 = smallest;\n\
    \   |                           -------- expected due to this value\n...\n18 |\
    \               .and_then(|i| smallest2 = lst.iter()\n   |  _______________________________________^\n\
    19 | |                 .position(|&x| x == smallest2).unwrap()).unwrap();\n  \
    \ | |_______________________________________________________^ expected `isize`,\
    \ found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp_dwyto7.rs:21:5\n\
    \   |\n12 | fn next_smallest(lst: Vec<isize>) -> Option<isize> {\n   |       \
    \                               ------------- expected `Option<isize>` because\
    \ of return type\n...\n21 |     smallest2\n   |     ^^^^^^^^^ expected enum `Option`,\
    \ found `isize`\n   |\n   = note: expected enum `Option<isize>`\n            \
    \  found type `isize`\nhelp: try wrapping the expression in `Some`\n   |\n21 |\
    \     Some(smallest2)\n   |     +++++         +\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0593, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().enumerate().next()\n        .and_then(|(i,\
    \ v)| {\n            if i == 0 {\n                return None;\n            }\n\
    \            Some(v.iter().next()?.0)\n        })\n}\n\nfn main() {\n    let candidate\
    \ = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n\
    \    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for reference `&isize` in the\
    \ current scope\n  --> /tmp/tmpa4bt9bdj.rs:18:20\n   |\n18 |             Some(v.iter().next()?.0)\n\
    \   |                    ^^^^ method not found in `&isize`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.is_empty() {\n        return None;\n    }\n \
    \   let mut min_ele = vec![std::i32::MAX; 2];\n    for &ele in lst {\n       \
    \ min_ele[0] = ele;\n        min_ele[1] = ele as isize;\n        if min_ele[0]\
    \ < min_ele[1] {\n            min_ele[0] = min_ele[1];\n        }\n    }\n   \
    \ Some(min_ele[1])\n}\n\nfn main() {\n    let candidate = next_smallest;\n   \
    \ assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpm_xfw5v8.rs:17:9\n   |\n\
    17 |     for &ele in lst {\n   |         ^^^^    --- this expression has type\
    \ `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `ele`\n   |\n\
    \   = note:   expected type `isize`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpm_xfw5v8.rs:19:22\n   |\n19 |         min_ele[1]\
    \ = ele as isize;\n   |         ----------   ^^^^^^^^^^^^ expected `i32`, found\
    \ `isize`\n   |         |\n   |         expected due to the type of this binding\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpm_xfw5v8.rs:24:10\n   |\n24 |\
    \     Some(min_ele[1])\n   |          ^^^^^^^^^^ expected `isize`, found `i32`\n\
    \   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n24 |     Some(min_ele[1].try_into().unwrap())\n   |\
    \                    ++++++++++++++++++++\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut min_value = vec![999999; lst.len()];\n\n   \
    \ for i in lst.iter().rev() {\n        let v = *i as isize;\n        let min_index\
    \ =\n            if v < min_value.iter().position(|&a| a == v) {\n           \
    \     0\n            } else {\n                min_value.iter().position(|&a|\
    \ a == v)\n            };\n\n        if min_index < min_value.len() - 1 {\n  \
    \          min_value[min_index] = v;\n        } else {\n            min_value[min_index\
    \ + 1] = v\n        }\n    }\n\n    match min_value.iter().position(|&a| a < lst.iter().rev().position(|&b|\
    \ b == a)) {\n        None => None,\n        Some(0) => None,\n        Some(index)\
    \ => {\n            Some(*min_value[index + 1])\n        }\n    }\n}\n\nfn main()\
    \ {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwy8_8g_5.rs:18:20\n   |\n\
    18 |             if v < min_value.iter().position(|&a| a == v) {\n   |       \
    \             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found enum\
    \ `Option`\n   |\n   = note: expected type `isize`\n              found enum `Option<usize>`\n\
    \nerror[E0308]: `if` and `else` have incompatible types\n  --> /tmp/tmpwy8_8g_5.rs:21:17\n\
    \   |\n18 | /             if v < min_value.iter().position(|&a| a == v) {\n19\
    \ | |                 0\n   | |                 - expected because of this\n20\
    \ | |             } else {\n21 | |                 min_value.iter().position(|&a|\
    \ a == v)\n   | |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ integer, found enum `Option`\n22 | |             };\n   | |_____________- `if`\
    \ and `else` have incompatible types\n   |\n   = note: expected type `{integer}`\n\
    \              found enum `Option<usize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpwy8_8g_5.rs:31:46\n   |\n31 |     match min_value.iter().position(|&a|\
    \ a < lst.iter().rev().position(|&b| b == a)) {\n   |                        \
    \                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found enum `Option`\n   |\n   = note: expected type `isize`\n              found\
    \ enum `Option<usize>`\n\nerror[E0614]: type `isize` cannot be dereferenced\n\
    \  --> /tmp/tmpwy8_8g_5.rs:35:18\n   |\n35 |             Some(*min_value[index\
    \ + 1])\n   |                  ^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0308, E0614.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() > 0 {\n        let mut min_val = lst.iter().min_by_key(|x|\
    \ *x).unwrap();\n        if min_val != *min_val {\n            return Some(*min_val);\n\
    \        }\n    }\n    None\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpwiaz9qfa.rs:15:20\n\
    \   |\n15 |         if min_val != *min_val {\n   |                    ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() == 0 {\n        return None;\n    }\n\n\
    \    let mut min_val = lst.iter().min().unwrap();\n    let mut min_idx = lst.iter().enumerate().find(|&(_,\
    \ val)| val == min_val).unwrap();\n    loop {\n        if min_idx == lst.len()\
    \ - 1 {\n            return None;\n        }\n        min_idx += 1;\n        if\
    \ min_val < lst[min_idx] {\n            min_val = lst[min_idx];\n        }\n \
    \   }\n}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmph2se01lp.rs:20:23\n   |\n\
    20 |         if min_idx == lst.len() - 1 {\n   |                       ^^^^^^^^^^^^^\
    \ expected tuple, found `usize`\n   |\n   = note: expected tuple `(usize, &isize)`\n\
    \               found type `usize`\n\nerror[E0368]: binary assignment operation\
    \ `+=` cannot be applied to type `(usize, &isize)`\n  --> /tmp/tmph2se01lp.rs:23:9\n\
    \   |\n23 |         min_idx += 1;\n   |         -------^^^^^\n   |         |\n\
    \   |         cannot use `+=` on type `(usize, &isize)`\n\nerror[E0277]: the type\
    \ `[isize]` cannot be indexed by `(usize, &isize)`\n  --> /tmp/tmph2se01lp.rs:24:22\n\
    \   |\n24 |         if min_val < lst[min_idx] {\n   |                      ^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `(usize, &isize)`\n   = help:\
    \ the trait `SliceIndex<[T]>` is implemented for `(Bound<usize>, Bound<usize>)`\n\
    \   = note: required because of the requirements on the impl of `Index<(usize,\
    \ &isize)>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed\
    \ by `(usize, &isize)`\n  --> /tmp/tmph2se01lp.rs:25:23\n   |\n25 |          \
    \   min_val = lst[min_idx];\n   |                       ^^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `(usize, &isize)`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `(Bound<usize>, Bound<usize>)`\n   = note: required because\
    \ of the requirements on the impl of `Index<(usize, &isize)>` for `Vec<isize>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0368.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.is_empty() {\n        return None;\n    }\n \
    \   match lst.iter().position(|x| x < lst.iter().nth(1).unwrap()) {\n        Some(index)\
    \ => {\n            if index != 0 {\n                lst.swap(index, index - 1);\n\
    \            }\n            Some(lst.iter().nth(index).unwrap())\n        }\n\
    \        None => None\n    }\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzjgk1tqf.rs:21:18\n   |\n\
    21 |             Some(lst.iter().nth(index).unwrap())\n   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n21 |             Some(*lst.iter().nth(index).unwrap())\n   |          \
    \        +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut min = lst[0];\n    let mut min_index = 0;\n\n\
    \    for ele in lst {\n        if ele < min {\n            min = ele;\n      \
    \      min_index = 1;\n        } else if ele == min {\n            min_index +=\
    \ 1;\n        }\n    }\n\n    if min_index == lst.len() {\n        return None;\n\
    \    }\n\n    Some(min)\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `lst`\n   --> /tmp/tmp2s8buhrk.rs:25:21\n\
    \    |\n12  | fn next_smallest(lst: Vec<isize>) -> Option<isize> {\n    |    \
    \              --- move occurs because `lst` has type `Vec<isize>`, which does\
    \ not implement the `Copy` trait\n...\n16  |     for ele in lst {\n    |     \
    \           --- `lst` moved due to this implicit call to `.into_iter()`\n...\n\
    25  |     if min_index == lst.len() {\n    |                     ^^^^^^^^^ value\
    \ borrowed here after move\n    |\nnote: this function takes ownership of the\
    \ receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of\
    \ the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n16  |\
    \     for ele in &lst {\n    |                +\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().cloned().enumerate().find((i, e) => e < &lst[i\
    \ + 1]).map(|(i, _)| &lst[i])\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n\
    \  --> /tmp/tmpvfjfm_3_.rs:13:49\n   |\n13 |     lst.iter().cloned().enumerate().find((i,\
    \ e) => e < &lst[i + 1]).map(|(i, _)| &lst[i])\n   |                         \
    \                        ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\
    \nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() <= 2 {\n        return None;\n    }\n \
    \   let mut index = lst.len() - 1;\n    while index >= 2 {\n        if index ==\
    \ 1 {\n            return Some(lst.swap(0, index).unwrap());\n        }\n    \
    \    if lst[index] < lst[index-1] {\n            index = index - 1;\n        }\
    \ else {\n            return Some(lst.swap(0, index).unwrap());\n        }\n \
    \   }\n    None\n}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap` found for unit type `()` in the\
    \ current scope\n  --> /tmp/tmpsz0r5k9i.rs:19:44\n   |\n19 |             return\
    \ Some(lst.swap(0, index).unwrap());\n   |                                   \
    \         ^^^^^^ method not found in `()`\n\nerror[E0599]: no method named `unwrap`\
    \ found for unit type `()` in the current scope\n  --> /tmp/tmpsz0r5k9i.rs:24:44\n\
    \   |\n24 |             return Some(lst.swap(0, index).unwrap());\n   |      \
    \                                      ^^^^^^ method not found in `()`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut min = lst[0];\n    for x in lst.iter() {\n \
    \       if x < min {\n            min = x;\n        }\n    }\n    if lst.len()\
    \ < 2 {\n        return None;\n    }\n    Some(min)\n}\n\nfn main() {\n    let\
    \ candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n\
    \    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpu9r_7_yi.rs:15:16\n   |\n\
    15 |         if x < min {\n   |                ^^^\n   |                |\n  \
    \ |                expected `&isize`, found `isize`\n   |                help:\
    \ consider borrowing here: `&min`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpu9r_7_yi.rs:16:19\n\
    \   |\n13 |     let mut min = lst[0];\n   |                   ------ expected\
    \ due to this value\n...\n16 |             min = x;\n   |                   ^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n16 |             min = *x;\n   |                   +\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 101
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut min = lst[0];\n    let mut idx = 0;\n    for\
    \ &x in lst.iter().rev() {\n        if x < min {\n            min = x;\n     \
    \       idx = 0;\n        }\n        if x == min {\n            idx += 1;\n  \
    \      }\n    }\n    Some(lst[idx as usize])\n}\n\nfn main() {\n    let candidate\
    \ = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n\
    \    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(2)`', /tmp/tmpgjg9e2ov.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().position(|x| x < lst.iter().nth(1))\n}\n\n\
    fn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl1yi32hv.rs:13:33\n   |\n\
    13 |     lst.iter().position(|x| x < lst.iter().nth(1))\n   |                \
    \                 ^^^^^^^^^^^^^^^^^ expected `&isize`, found enum `Option`\n \
    \  |\n   = note: expected reference `&isize`\n                   found enum `Option<&isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpl1yi32hv.rs:13:5\n   |\n12 | fn\
    \ next_smallest(lst: Vec<isize>) -> Option<isize> {\n   |                    \
    \                  ------------- expected `Option<isize>` because of return type\n\
    13 |     lst.iter().position(|x| x < lst.iter().nth(1))\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\n   = note: expected enum `Option<isize>`\n\
    \              found enum `Option<usize>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 101
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut min_val = lst[0];\n    if lst.len() == 1 {\n\
    \        return None;\n    }\n    for i in 1..lst.len() {\n        if min_val\
    \ > lst[i] {\n            min_val = lst[i];\n        }\n    }\n    Some(min_val)\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(2)`', /tmp/tmp0i8i9ay7.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    loop {\n        let (smallest, &mut rest) = lst.split_first();\n\
    \        if smallest.is_empty() {\n            return None;\n        }\n     \
    \   rest.sort_unstable();\n        if !rest.is_empty() {\n            return Some(*smallest);\n\
    \        }\n    }\n}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxvv_iqdf.rs:14:13\n   |\n\
    14 |         let (smallest, &mut rest) = lst.split_first();\n   |            \
    \ ^^^^^^^^^^^^^^^^^^^^^   ----------------- this expression has type `Option<(&isize,\
    \ &[isize])>`\n   |             |\n   |             expected enum `Option`, found\
    \ tuple\n   |\n   = note: expected enum `Option<(&isize, &[isize])>`\n       \
    \      found tuple `(_, _)`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().fold(\n        None,\n        |next_smallest,\
    \ (&mut smallest, &mut curr)| {\n            if curr < smallest {\n          \
    \      smallest = curr;\n                Some(smallest)\n            } else if\
    \ curr == smallest {\n                Some(curr)\n            } else {\n     \
    \           None\n            }\n        },\n    )\n}\n\nfn main() {\n    let\
    \ candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n\
    \    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj691h_up.rs:15:25\n   |\n\
    15 |         |next_smallest, (&mut smallest, &mut curr)| {\n   |             \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^-\n   |                         |      \
    \                  |\n   |                         |                        expected\
    \ due to this\n   |                         expected `isize`, found tuple\n  \
    \ |\n   = note: expected type `isize`\n             found tuple `(_, _)`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut min_el: Option<isize> = None;\n    let mut i\
    \ = lst.len() - 1;\n    while i > 0 && min_el.is_none() {\n        if lst[i].partial_cmp(&min_el)\
    \ < 0 {\n            min_el = Some(lst[i]);\n        }\n        i--;\n    }\n\
    \    min_el\n}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmps2kvekhy.rs:19:12\n\
    \   |\n19 |         i--;\n   |            ^ expected expression\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmps2kvekhy.rs:16:31\n   |\n16 |         if lst[i].partial_cmp(&min_el)\
    \ < 0 {\n   |                               ^^^^^^^ expected `isize`, found enum\
    \ `Option`\n   |\n   = note: expected reference `&isize`\n              found\
    \ reference `&Option<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmps2kvekhy.rs:16:42\n\
    \   |\n16 |         if lst[i].partial_cmp(&min_el) < 0 {\n   |               \
    \                           ^ expected enum `Option`, found integer\n   |\n  \
    \ = note: expected enum `Option<std::cmp::Ordering>`\n              found type\
    \ `{integer}`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    match lst.len() {\n        0 => None,\n        1 =>\
    \ Some(lst.iter().next()),\n        2 => Some(lst.iter().next_back()),\n     \
    \   _ => lst.iter().enumerate().next()\n            .map_or(None, None)?\n   \
    \         .map_or(Some(lst.iter().next()), Some(lst.iter().next_back()))\n   \
    \ }\n}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8dc6p4e_.rs:15:19\n   |\n\
    15 |         1 => Some(lst.iter().next()),\n   |                   ^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n\
    \              found enum `Option<&isize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp8dc6p4e_.rs:16:19\n   |\n16 |         2 => Some(lst.iter().next_back()),\n\
    \   |                   ^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected type `isize`\n              found enum `Option<&isize>`\n\
    \nerror[E0277]: expected a `FnOnce<((usize, &isize),)>` closure, found `Option<_>`\n\
    \   --> /tmp/tmp8dc6p4e_.rs:18:27\n    |\n18  |             .map_or(None, None)?\n\
    \    |              ------       ^^^^ expected an `FnOnce<((usize, &isize),)>`\
    \ closure, found `Option<_>`\n    |              |\n    |              required\
    \ by a bound introduced by this call\n    |\n    = help: the trait `FnOnce<((usize,\
    \ &isize),)>` is not implemented for `Option<_>`\nnote: required by a bound in\
    \ `Option::<T>::map_or`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() == 0 {\n        return None;\n    }\n \
    \   if lst.len() == 1 {\n        return Some(lst.iter().next().unwrap());\n  \
    \  }\n    let mut it = lst.iter();\n    let mut smallest = it.next();\n    let\
    \ mut second_smallest = it.next();\n    if second_smallest == Some(&mut smallest)\
    \ {\n        return Some(lst.iter().next().unwrap());\n    }\n    while second_smallest\
    \ != Some(&mut smallest) {\n        smallest = second_smallest;\n        second_smallest\
    \ = it.next();\n    }\n    Some(lst.iter().next().unwrap())\n}\n\nfn main() {\n\
    \    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4,\
    \ 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpg21k_x5z.rs:17:21\n   |\n\
    17 |         return Some(lst.iter().next().unwrap());\n   |                  \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n17 |         return Some(*lst.iter().next().unwrap());\n\
    \   |                     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg21k_x5z.rs:22:32\n\
    \   |\n22 |     if second_smallest == Some(&mut smallest) {\n   |            \
    \                    ^^^^^^^^^^^^^ expected `isize`, found enum `Option`\n   |\n\
    \   = note:      expected reference `&isize`\n           found mutable reference\
    \ `&mut Option<&isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg21k_x5z.rs:23:21\n\
    \   |\n23 |         return Some(lst.iter().next().unwrap());\n   |           \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n   |\n\
    help: consider dereferencing the borrow\n   |\n23 |         return Some(*lst.iter().next().unwrap());\n\
    \   |                     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg21k_x5z.rs:25:35\n\
    \   |\n25 |     while second_smallest != Some(&mut smallest) {\n   |         \
    \                          ^^^^^^^^^^^^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note:      expected reference `&isize`\n           found mutable reference\
    \ `&mut Option<&isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg21k_x5z.rs:29:10\n\
    \   |\n29 |     Some(lst.iter().next().unwrap())\n   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n29 |     Some(*lst.iter().next().unwrap())\n   |          +\n\nerror: aborting\
    \ due to 5 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.is_empty() {\n        return None;\n    }\n \
    \   let mut min = *lst.iter().next();\n    let mut min_element = &lst[0];\n  \
    \  for i in lst.iter().skip(1) {\n        if *i < min {\n            min = *i;\n\
    \            min_element = i;\n        }\n    }\n    Some(min)\n}\n\nfn main()\
    \ {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0614]: type `Option<&isize>` cannot be dereferenced\n  --> /tmp/tmpnis87gmr.rs:16:19\n\
    \   |\n16 |     let mut min = *lst.iter().next();\n   |                   ^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 101
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    Some(lst.iter().next().cloned().unwrap())\n}\n\nfn main()\
    \ {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(2)`', /tmp/tmpzxrstn1n.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 101
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() == 0 {\n        return None;\n    }\n \
    \   let mut smallest = lst[0];\n    let mut min_idx = 1;\n    for i in lst {\n\
    \        if i < smallest {\n            smallest = i;\n            min_idx = i;\n\
    \        }\n    }\n    Some(min_idx)\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(2)`', /tmp/tmpethgcu3n.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    // use binary search to find the second smallest element\
    \ in the list\n    lst.binary_search(|&x| x <= lst.last())\n}\n\nfn main() {\n\
    \    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4,\
    \ 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpufhvl4gy.rs:14:23\n   |\n\
    14 |     lst.binary_search(|&x| x <= lst.last())\n   |                       ^^^^^^^^^^^^^^^^^^^^\
    \ expected `&isize`, found closure\n   |\n   = note: expected reference `&isize`\n\
    \                found closure `[closure@/tmp/tmpufhvl4gy.rs:14:23: 14:43]`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpufhvl4gy.rs:14:5\n   |\n12 | fn\
    \ next_smallest(lst: Vec<isize>) -> Option<isize> {\n   |                    \
    \                  ------------- expected `Option<isize>` because of return type\n\
    13 |     // use binary search to find the second smallest element in the list\n\
    14 |     lst.binary_search(|&x| x <= lst.last())\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected enum `Option`, found enum `Result`\n   |\n   = note: expected enum\
    \ `Option<isize>`\n              found enum `Result<usize, usize>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() <= 1 {\n        return None;\n    }\n \
    \   let mut min_val = None;\n    let mut min_idx = 1;\n    for i in 1..lst.len()\
    \ {\n        if lst[i] < min_val {\n            min_val = lst[i];\n          \
    \  min_idx = i;\n        }\n    }\n    Some(min_idx)\n}\n\nfn main() {\n    let\
    \ candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n\
    \    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmm44aucp.rs:19:21\n   |\n\
    19 |         if lst[i] < min_val {\n   |                     ^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmm44aucp.rs:20:23\n\
    \   |\n16 |     let mut min_val = None;\n   |                       ---- expected\
    \ due to this value\n...\n20 |             min_val = lst[i];\n   |           \
    \            ^^^^^^ expected enum `Option`, found `isize`\n   |\n   = note: expected\
    \ enum `Option<_>`\n              found type `isize`\nhelp: try wrapping the expression\
    \ in `Some`\n   |\n20 |             min_val = Some(lst[i]);\n   |            \
    \           +++++      +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmm44aucp.rs:24:10\n\
    \   |\n24 |     Some(min_idx)\n   |          ^^^^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n24 |     Some(min_idx.try_into().unwrap())\n   |  \
    \               ++++++++++++++++++++\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    match lst.len() {\n        0 => None,\n        _ =>\
    \ if lst.len() > 1 {\n                Some(vec![lst.iter().skip(1).next().unwrap()])\n\
    \            } else {\n                None\n            }\n    }\n}\n\nfn main()\
    \ {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpi4rksk2l.rs:16:22\n   |\n\
    16 |                 Some(vec![lst.iter().skip(1).next().unwrap()])\n   |    \
    \                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found struct `Vec`\n   |\n   = note: expected type `isize`\n            found\
    \ struct `Vec<&isize>`\n   = note: this error originates in the macro `vec` (in\
    \ Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.len().min(2);\n    smallest.cmp(lst.iter().min().unwrap()).unwrap()\
    \ // -1 / +1 -> 0 / 1\n        .find(|&elt| lst.iter().position(|&elt| elt > elt).is_some())\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk1ezizki.rs:14:18\n   |\n\
    14 |     smallest.cmp(lst.iter().min().unwrap()).unwrap() // -1 / +1 -> 0 / 1\n\
    \   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `isize`\n\
    \   |\n   = note: expected reference `&usize`\n              found reference `&isize`\n\
    \nerror[E0599]: no method named `unwrap` found for enum `std::cmp::Ordering` in\
    \ the current scope\n  --> /tmp/tmpk1ezizki.rs:14:45\n   |\n14 |     smallest.cmp(lst.iter().min().unwrap()).unwrap()\
    \ // -1 / +1 -> 0 / 1\n   |                                             ^^^^^^\
    \ method not found in `std::cmp::Ordering`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.is_empty() {\n        return None;\n    }\n\n\
    \    let mut iter = lst.iter();\n    let smallest = iter.next().unwrap();\n\n\
    \    let mut iter2 = lst.iter();\n    iter2.next()\n        .and_then(|v| {\n\
    \            if v < smallest {\n                smallest = v;\n              \
    \  Some(v + 1)\n            } else {\n                None\n            }\n  \
    \      })\n        .or_else(|| Some(smallest + 1));\n\n    iter2.next()\n    \
    \    .map(|v| v + 1)\n        .unwrap_or_else(|| None)\n}\n\nfn main() {\n   \
    \ let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]),\
    \ Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp38xy7rkb.rs:34:28\n   |\n\
    34 |         .unwrap_or_else(|| None)\n   |                            ^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp38xy7rkb.rs:32:5\n\
    \   |\n12 |   fn next_smallest(lst: Vec<isize>) -> Option<isize> {\n   |     \
    \                                   ------------- expected `Option<isize>` because\
    \ of return type\n...\n32 | /     iter2.next()\n33 | |         .map(|v| v + 1)\n\
    34 | |         .unwrap_or_else(|| None)\n   | |________________________________^\
    \ expected enum `Option`, found `isize`\n   |\n   = note: expected enum `Option<isize>`\n\
    \              found type `isize`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n32 ~     Some(iter2.next()\n33 |         .map(|v| v + 1)\n34 ~        \
    \ .unwrap_or_else(|| None))\n   |\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = &lst[0];\n    for i in 1..lst.len()\
    \ {\n        if smallest.cmp(&lst[i]) < 0 {\n            smallest = &lst[i];\n\
    \        }\n    }\n    smallest.as_ref()\n}\n\nfn main() {\n    let candidate\
    \ = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n\
    \    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpznn12trt.rs:15:36\n   |\n\
    15 |         if smallest.cmp(&lst[i]) < 0 {\n   |                            \
    \        ^ expected enum `std::cmp::Ordering`, found integer\n\nerror[E0599]:\
    \ the method `as_ref` exists for reference `&isize`, but its trait bounds were\
    \ not satisfied\n  --> /tmp/tmpznn12trt.rs:19:14\n   |\n19 |     smallest.as_ref()\n\
    \   |              ^^^^^^ method cannot be called on `&isize` due to unsatisfied\
    \ trait bounds\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `isize: AsRef<_>`\n           which is required by `&isize: AsRef<_>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 101
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    // TODO\n    let mut smallest = isize::MAX;\n    for\
    \ x in lst {\n        if x <= smallest {\n            smallest = x;\n        }\n\
    \    }\n    if smallest == isize::MAX {\n        None\n    } else {\n        Some(smallest)\n\
    \    }\n}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(2)`', /tmp/tmpc12r6haf.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() <= 1 {\n        return None;\n    }\n\n\
    \    let mut smallest_idx = 1;\n    let mut min_val = lst[smallest_idx];\n\n \
    \   for i in 1..lst.len() {\n        if min_val < lst[i] {\n            smallest_idx\
    \ = i;\n            min_val = lst[i];\n        }\n    }\n\n    Some(smallest_idx)\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6g8lzf1u.rs:27:10\n   |\n\
    27 |     Some(smallest_idx)\n   |          ^^^^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n27 |     Some(smallest_idx.try_into().unwrap())\n\
    \   |                      ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = *lst.iter().min().unwrap();\n   \
    \ if smallest == *lst.len() {\n        return None;\n    }\n    if *lst.iter().nth(smallest).unwrap()\
    \ == *lst.len() {\n        return None;\n    }\n    let mut idx = 0;\n    while\
    \ idx < lst.len() {\n        if *lst[*idx] < *smallest{\n            smallest\
    \ = *lst[*idx];\n        }\n        idx += 1;\n    }\n    Some(smallest)\n}\n\n\
    fn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0614]: type `usize` cannot be dereferenced\n  --> /tmp/tmpar9r8_kn.rs:14:20\n\
    \   |\n14 |     if smallest == *lst.len() {\n   |                    ^^^^^^^^^^\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpar9r8_kn.rs:17:24\n   |\n17 |\
    \     if *lst.iter().nth(smallest).unwrap() == *lst.len() {\n   |            \
    \            ^^^^^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    17 |     if *lst.iter().nth(smallest.try_into().unwrap()).unwrap() == *lst.len()\
    \ {\n   |                                ++++++++++++++++++++\n\nerror[E0614]:\
    \ type `usize` cannot be dereferenced\n  --> /tmp/tmpar9r8_kn.rs:17:46\n   |\n\
    17 |     if *lst.iter().nth(smallest).unwrap() == *lst.len() {\n   |         \
    \                                     ^^^^^^^^^^\n\nerror[E0614]: type `usize`\
    \ cannot be dereferenced\n  --> /tmp/tmpar9r8_kn.rs:22:17\n   |\n22 |        \
    \ if *lst[*idx] < *smallest{\n   |                 ^^^^\n\nerror[E0614]: type\
    \ `isize` cannot be dereferenced\n  --> /tmp/tmpar9r8_kn.rs:22:25\n   |\n22 |\
    \         if *lst[*idx] < *smallest{\n   |                         ^^^^^^^^^\n\
    \nerror[E0614]: type `usize` cannot be dereferenced\n  --> /tmp/tmpar9r8_kn.rs:23:29\n\
    \   |\n23 |             smallest = *lst[*idx];\n   |                         \
    \    ^^^^\n\nerror: aborting due to 6 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0614.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst[0];\n    let mut smallest_pos\
    \ = 0;\n\n    for v in lst {\n        if v < smallest {\n            smallest\
    \ = v;\n            smallest_pos = 0;\n        } else {\n            smallest_pos++;\n\
    \        }\n    }\n\n    smallest_pos <= 2 ? Some(smallest) : None\n}\n\nfn main()\
    \ {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpb5226trm.rs:21:25\n\
    \   |\n21 |             smallest_pos++;\n   |                         ^^ not a\
    \ valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n21 |         \
    \    { let tmp = smallest_pos; smallest_pos += 1; tmp };\n   |             +++++++++++\
    \             ~~~~~~~~~~~~~~~~~~~~~~~~~~\n21 -             smallest_pos++;\n21\
    \ +             smallest_pos += 1;\n   | \n\nerror: expected one of `.`, `;`,\
    \ `?`, `}`, or an operator, found `Some`\n  --> /tmp/tmpb5226trm.rs:25:25\n  \
    \ |\n25 |     smallest_pos <= 2 ? Some(smallest) : None\n   |                \
    \         ^^^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: aborting\
    \ due to 2 previous errors\n\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.is_empty() {\n        None\n    } else {\n  \
    \      let mut curr = lst.iter().next().unwrap();\n        let mut found = false;\n\
    \        for ele in lst.iter().skip(1) {\n            if ele < curr {\n      \
    \          break;\n            }\n            curr = ele;\n            found =\
    \ true;\n        }\n        if found {\n            Some(curr)\n        } else\
    \ {\n            None\n        }\n    }\n}\n\nfn main() {\n    let candidate =\
    \ next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n \
    \   assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5xebf2nr.rs:26:18\n   |\n\
    26 |             Some(curr)\n   |                  ^^^^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n26 |        \
    \     Some(*curr)\n   |                  +\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut min_el = vec![lst.len()..].min();\n    if min_el\
    \ == 0 {\n        return None;\n    }\n    vec![lst.iter().skip(min_el).next()].min()\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: the method `min` exists for struct `Vec<RangeFrom<usize>>`,\
    \ but its trait bounds were not satisfied\n   --> /tmp/tmpf150j36o.rs:13:40\n\
    \    |\n13  |       let mut min_el = vec![lst.len()..].min();\n    |         \
    \                                 ^^^ method cannot be called on `Vec<RangeFrom<usize>>`\
    \ due to unsatisfied trait bounds\n    |\n    = note: the following trait bounds\
    \ were not satisfied:\n            `RangeFrom<usize>: Ord`\n            which\
    \ is required by `Vec<RangeFrom<usize>>: Ord`\n            `Vec<RangeFrom<usize>>:\
    \ Ord`\n            which is required by `&Vec<RangeFrom<usize>>: Ord`\n     \
    \       `Vec<RangeFrom<usize>>: Ord`\n            which is required by `&mut Vec<RangeFrom<usize>>:\
    \ Ord`\n            `Vec<RangeFrom<usize>>: Iterator`\n            which is required\
    \ by `&mut Vec<RangeFrom<usize>>: Iterator`\n            `RangeFrom<usize>: Ord`\n\
    \            which is required by `[RangeFrom<usize>]: Ord`\n            `[RangeFrom<usize>]:\
    \ Ord`\n            which is required by `&[RangeFrom<usize>]: Ord`\n        \
    \    `[RangeFrom<usize>]: Ord`\n            which is required by `&mut [RangeFrom<usize>]:\
    \ Ord`\n            `[RangeFrom<usize>]: Iterator`\n            which is required\
    \ by `&mut [RangeFrom<usize>]: Iterator`\n\nerror[E0061]: this function takes\
    \ 1 argument but 0 arguments were supplied\n   --> /tmp/tmpf150j36o.rs:17:42\n\
    \    |\n17  |     vec![lst.iter().skip(min_el).next()].min()\n    |          \
    \                                ^^^- supplied 0 arguments\n    |            \
    \                              |\n    |                                      \
    \    expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpf150j36o.rs:17:5\n   |\n12 | fn next_smallest(lst:\
    \ Vec<isize>) -> Option<isize> {\n   |                                      -------------\
    \ expected `Option<isize>` because of return type\n...\n17 |     vec![lst.iter().skip(min_el).next()].min()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected enum `Option`, found\
    \ struct `Vec`\n   |\n   = note: expected"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.clone();\n    let mut smallest_idx\
    \ = 1;\n\n    for e in &mut smallest {\n        if *e < &mut smallest[smallest_idx]\
    \ {\n            smallest_idx++;\n        }\n    }\n\n    if smallest_idx == lst.len()\
    \ {\n        return None;\n    }\n\n    smallest.remove(smallest_idx);\n\n   \
    \ Some(*smallest)\n}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpkvqku97w.rs:18:25\n\
    \   |\n18 |             smallest_idx++;\n   |                         ^^ not a\
    \ valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n18 |         \
    \    { let tmp = smallest_idx; smallest_idx += 1; tmp };\n   |             +++++++++++\
    \             ~~~~~~~~~~~~~~~~~~~~~~~~~~\n18 -             smallest_idx++;\n18\
    \ +             smallest_idx += 1;\n   | \n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpkvqku97w.rs:17:17\n   |\n17 |         if *e < &mut smallest[smallest_idx]\
    \ {\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found\
    \ `&mut isize`\n   |\nhelp: consider removing the borrow\n   |\n17 -         if\
    \ *e < &mut smallest[smallest_idx] {\n17 +         if *e < smallest[smallest_idx]\
    \ {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkvqku97w.rs:28:10\n\
    \   |\n28 |     Some(*smallest)\n   |          ^^^^^^^^^ expected `isize`, found\
    \ slice `[isize]`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() <= 1 {\n        return None;\n    }\n \
    \   let mut smallest = lst.iter().min_by_key(|&x| x).unwrap();\n    if smallest\
    \ != lst.first() {\n        smallest = Some(lst.first());\n    }\n    smallest\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `Option<&isize>`\n  --> /tmp/tmplvhtqfn0.rs:17:17\n\
    \   |\n17 |     if smallest != lst.first() {\n   |                 ^^ no implementation\
    \ for `&isize == Option<&isize>`\n   |\n   = help: the trait `PartialEq<Option<&isize>>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmplvhtqfn0.rs:18:20\n   |\n16 |     let mut smallest = lst.iter().min_by_key(|&x|\
    \ x).unwrap();\n   |                        --------------------------------------\
    \ expected due to this value\n17 |     if smallest != lst.first() {\n18 |    \
    \     smallest = Some(lst.first());\n   |                    ^^^^^^^^^^^^^^^^^\
    \ expected `&isize`, found enum `Option`\n   |\n   = note: expected reference\
    \ `&isize`\n                   found enum `Option<Option<&isize>>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmplvhtqfn0.rs:20:5\n   |\n12 | fn next_smallest(lst:\
    \ Vec<isize>) -> Option<isize> {\n   |                                      -------------\
    \ expected `Option<isize>` because of return type\n...\n20 |     smallest\n  \
    \ |     ^^^^^^^^ expected enum `Option`, found `&isize`\n   |\n   = note:   expected\
    \ enum `Option<isize>`\n           found reference `&isize`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.is_empty() {\n        return None;\n    }\n \
    \   let mut min_value = i32::MIN;\n    let mut min_idx = 1; // start from 1\n\
    \    for idx in 0..lst.len() {\n        let v = lst[idx];\n        if v < min_value\
    \ {\n            min_value = v;\n            min_idx = idx;\n        }\n    }\n\
    \    let next_element = min_idx + 1;\n    let result = Some(next_element);\n \
    \   debugln!(\"next_smallest returned {}\", result);\n    result\n}\n\nfn main()\
    \ {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error: cannot find macro `debugln` in this scope\n  --> /tmp/tmpj7ez09bf.rs:27:5\n\
    \   |\n27 |     debugln!(\"next_smallest returned {}\", result);\n   |     ^^^^^^^\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpj7ez09bf.rs:20:16\n   |\n20 |\
    \         if v < min_value {\n   |                ^^^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n20 |         if v < min_value.try_into().unwrap()\
    \ {\n   |                         ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpj7ez09bf.rs:21:25\n   |\n16 |     let mut min_value = i32::MIN;\n\
    \   |                         -------- expected due to this value\n...\n21 | \
    \            min_value = v;\n   |                         ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj7ez09bf.rs:28:5\n\
    \   |\n12 | fn next_smallest(lst: Vec<isize>) -> Option<isize> {\n   |       \
    \                               ------------- expected `Option<isize>` because\
    \ of return type\n...\n28 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ `usize`\n   |\n   = note: expected enum `Option<isize>`\n              found\
    \ enum `Option<usize>`\n\nerror: aborting due to 4 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().enumerate().take_while(|(&i, &elem)| *elem\
    \ < *i + 1).next()\n}\n\nfn main() {\n    let candidate = next_smallest;\n   \
    \ assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpo4ax8jfs.rs:13:41\n   |\n\
    13 |     lst.iter().enumerate().take_while(|(&i, &elem)| *elem < *i + 1).next()\n\
    \   |                                         ^^       - expected due to this\n\
    \   |                                         |\n   |                        \
    \                 expected `usize`, found reference\n   |                    \
    \                     help: you can probably remove the explicit borrow: `i`\n\
    \   |\n   = note:   expected type `usize`\n           found reference `&_`\n\n\
    error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpo4ax8jfs.rs:13:53\n\
    \   |\n13 |     lst.iter().enumerate().take_while(|(&i, &elem)| *elem < *i + 1).next()\n\
    \   |                                                     ^^^^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpo4ax8jfs.rs:13:5\n   |\n12 | fn next_smallest(lst:\
    \ Vec<isize>) -> Option<isize> {\n   |                                      -------------\
    \ expected `Option<isize>` because of return type\n13 |     lst.iter().enumerate().take_while(|(&i,\
    \ &elem)| *elem < *i + 1).next()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found tuple\n   |\n   = note: expected enum `Option<isize>`\n\
    \              found enum `Option<(usize, &isize)>`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0308, E0614.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.is_empty() {\n        return None;\n    }\n \
    \   if lst.len() <= 2 {\n        return None;\n    }\n    let mut min_value =\
    \ lst[0];\n    let mut min_idx = 1;\n    for &idx in lst.iter().rev() {\n    \
    \    if *idx < min_value {\n            min_value = *idx;\n            min_idx\
    \ = idx;\n        }\n    }\n    Some(*min_idx)\n}\n\nfn main() {\n    let candidate\
    \ = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n\
    \    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpbma8tnol.rs:22:12\n\
    \   |\n22 |         if *idx < min_value {\n   |            ^^^^\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmpbma8tnol.rs:23:25\n   |\n\
    23 |             min_value = *idx;\n   |                         ^^^^\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmpbma8tnol.rs:27:10\n   |\n\
    27 |     Some(*min_idx)\n   |          ^^^^^^^^\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 101
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.is_empty() {\n        return None;\n    }\n\n\
    \    let mut min = lst[0];\n    let mut min_index = 0;\n    for i in lst.iter().rev()\
    \ {\n        if *i < min {\n            min = *i;\n            min_index -= 1;\n\
    \        }\n    }\n\n    if min_index == 0 {\n        None\n    } else {\n   \
    \     Some(min)\n    }\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `None`,\n right: `Some(2)`', /tmp/tmpqxij30oh.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() == 0 {\n        return None;\n    }\n\n\
    \    let mut current = vec![None; lst.len()];\n    current.swap(0, 1);\n    current[0].as_mut()\n\
    \        .ok_or(format_args!(\"cannot get 2nd smallest element\"))\n        .map(|v|\
    \ v as isize)\n        .and_then(|v| {\n            let mut iter = lst.iter();\n\
    \            let mut min = v;\n            iter.next_back()\n                .ok_or(format_args!(\"\
    cannot get 2nd smallest element\"))\n                .or_else(|| {\n         \
    \           iter.next().ok_or(format_args!(\"cannot get 2nd smallest element\"\
    ))\n                })\n                .and_then(|v| {\n                    if\
    \ v < min {\n                        min = v;\n                    }\n       \
    \         });\n            min\n        })\n}\n\nfn main() {\n    let candidate\
    \ = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n\
    \    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0593]: closure is expected to take 1 argument, but it takes 0 arguments\n\
    \  --> /tmp/tmpfcxbxur6.rs:27:18\n   |\n27 |                 .or_else(|| {\n \
    \  |                  ^^^^^^^ -- takes 0 arguments\n   |                  |\n\
    \   |                  expected closure that takes 1 argument\n   |\nhelp: consider\
    \ changing the closure to take and ignore the expected argument\n   |\n27 |  \
    \               .or_else(|_| {\n   |                          ~~~\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpfcxbxur6.rs:31:28\n   |\n31 |              \
    \       if v < min {\n   |                            ^^^\n   |              \
    \              |\n   |                            expected `&isize`, found `isize`\n\
    \   |                            help: consider borrowing here: `&min`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpfcxbxur6.rs:32:31\n   |\n24 |             let\
    \ mut min = v;\n   |                           - expected due to this value\n\
    ...\n32 |                         min = v;\n   |                             \
    \  ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n32 |                         min = *v;\n   |                 \
    \              +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfcxbxur6.rs:31:32\n\
    \   |\n31 |                       if v < min {\n   |  ________________________________^\n\
    32 | |                         min = v;\n33 | |                     }\n   | |_____________________^\
    \ expected enum `Result`, found `()`\n   |\n   = note:   expected enum `Result<_,\
    \ _>`\n           found unit type `()`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpfcxbxur6.rs:35:13\n   |\n35 |             min\n   |             ^^^\
    \ expected enum `Result`, found `isize`\n   |\n   = note: expected enum `Result<_,\
    \ Arguments<'_>>`\n              found type `isize`\nhelp: try wrapping the expression\
    \ in `Ok`\n   |\n35 |             Ok(min)\n   |             +++   +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpfcxbxur6.rs:19:5\n   |\n12 |   fn next_smallest(lst:\
    \ Vec<isize>) -> Option<isize> {\n   |                                       \
    \ ------------- expected"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() > 0 {\n        lst.iter().skip(1).min(|a,\
    \ b| a.cmp(&b)).unwrap_or(&lst.iter().next().unwrap())\n    } else {\n       \
    \ None\n    }\n}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpvtqt2p9x.rs:14:33\n\
    \   |\n14 |         lst.iter().skip(1).min(|a, b| a.cmp(&b)).unwrap_or(&lst.iter().next().unwrap())\n\
    \   |                                 ^ consider giving this closure parameter\
    \ a type\n   |\n   = note: type must be known at this point\n\nerror[E0061]: this\
    \ function takes 0 arguments but 1 argument was supplied\n    --> /tmp/tmpvtqt2p9x.rs:14:28\n\
    \     |\n14   |         lst.iter().skip(1).min(|a, b| a.cmp(&b)).unwrap_or(&lst.iter().next().unwrap())\n\
    \     |                            ^^^ ---------------- supplied 1 argument\n\
    \     |                            |\n     |                            expected\
    \ 0 arguments\n     |\nnote: associated function defined here\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpvtqt2p9x.rs:14:9\n   |\n12 | fn next_smallest(lst:\
    \ Vec<isize>) -> Option<isize> {\n   |                                      -------------\
    \ expected `Option<isize>` because of return type\n13 |     if lst.len() > 0 {\n\
    14 |         lst.iter().skip(1).min(|a, b| a.cmp(&b)).unwrap_or(&lst.iter().next().unwrap())\n\
    \   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected enum `Option`, found `&isize`\n   |\n   = note:   expected enum `Option<isize>`\n\
    \           found reference `&isize`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0061, E0282, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 101
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![lst[0]];\n    let mut count\
    \ = 0;\n    for n in lst {\n        if n < smallest[0] {\n            smallest[0]\
    \ = n;\n        }\n        if n == smallest[0] {\n            count += 1;\n  \
    \      }\n    }\n    if count == 0 {\n        return None;\n    }\n    Some(smallest[0])\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(2)`', /tmp/tmpkav4tfvw.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst\n        .iter()\n        .enumerate()\n       \
    \ .take_while(|&(i, x)| x >= i)\n        .next()\n        .map(|i| lst[i.0] as\
    \ isize)\n}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_c_6zdp_.rs:16:36\n   |\n\
    16 |         .take_while(|&(i, x)| x >= i)\n   |                             \
    \       ^ expected `&isize`, found `usize`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min_by_key(|x| x).unwrap();\n\
    \    if lst.len() >= 2 {\n        let mut smallest_two = lst.iter().min_by_key(|x|\
    \ x).unwrap();\n        if smallest < smallest_two {\n            smallest = smallest_two;\n\
    \        }\n    }\n    Some(smallest)\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzfifph05.rs:20:10\n   |\n\
    20 |     Some(smallest)\n   |          ^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n20 |     Some(*smallest)\n\
    \   |          +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().position(|x| *x <= lst.last().unwrap()).next()\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2fpr5b0n.rs:13:35\n   |\n\
    13 |     lst.iter().position(|x| *x <= lst.last().unwrap()).next()\n   |     \
    \                              ^^^^^^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n13 |     lst.iter().position(|x|\
    \ *x <= *lst.last().unwrap()).next()\n   |                                   +\n\
    \nerror[E0599]: no method named `next` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmp2fpr5b0n.rs:13:56\n   |\n13 |     lst.iter().position(|x|\
    \ *x <= lst.last().unwrap()).next()\n   |                                    \
    \                    ^^^^ method not found in `Option<usize>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().cloned().nth(1).cloned()\n}\n\nfn main()\
    \ {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: `Option<isize>` is not an iterator\n   --> /tmp/tmp16_gzq44.rs:13:32\n\
    \    |\n13  |       lst.iter().cloned().nth(1).cloned()\n    |               \
    \                   ^^^^^^ `Option<isize>` is not an iterator\n    |\n    = note:\
    \ the following trait bounds were not satisfied:\n            `Option<isize>:\
    \ Iterator`\n            which is required by `&mut Option<isize>: Iterator`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() == 0 {\n        return None;\n    }\n\n\
    \    let mut min = lst.iter().min().unwrap();\n    if min == lst.len() {\n   \
    \     return None;\n    }\n\n    let min = lst.iter().skip(1).find(|x| x == min).unwrap();\n\
    \    Some(min + 1)\n}\n\nfn main() {\n    let candidate = next_smallest;\n   \
    \ assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp70rmcymt.rs:18:15\n   |\n\
    18 |     if min == lst.len() {\n   |               ^^^^^^^^^ expected `isize`,\
    \ found `usize`\n\nerror[E0277]: can't compare `&isize` with `usize`\n  --> /tmp/tmp70rmcymt.rs:18:12\n\
    \   |\n18 |     if min == lst.len() {\n   |            ^^ no implementation for\
    \ `&isize == usize`\n   |\n   = help: the trait `PartialEq<usize>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0277]: can't compare `&isize` with `isize`\n  -->\
    \ /tmp/tmp70rmcymt.rs:22:45\n   |\n22 |     let min = lst.iter().skip(1).find(|x|\
    \ x == min).unwrap();\n   |                                             ^^ no\
    \ implementation for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n   = note: required because of the requirements\
    \ on the impl of `PartialEq<&isize>` for `&&isize`\n\nerror: aborting due to 3\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst\n        .iter()\n        .next()\n        .cloned()\n\
    \        .and_then(|n| {\n            if *n < *(n + 1) {\n                Some(n)\n\
    \            } else {\n                None\n            }\n        })\n}\n\n\
    fn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpsqzkafem.rs:18:16\n\
    \   |\n18 |             if *n < *(n + 1) {\n   |                ^^\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmpsqzkafem.rs:18:21\n   |\n\
    18 |             if *n < *(n + 1) {\n   |                     ^^^^^^^^\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut it = lst.iter().enumerate();\n    let (mut i,\
    \ mut j) = (0, 0);\n    let mut smallest = it.next().unwrap().0;\n    while let\
    \ Some(mut e) = it.next() {\n        if *e.1 >= smallest {\n            smallest\
    \ = *e.1;\n            i = *e.0;\n        }\n        if i == j { return None;\
    \ }\n        if *e.1 >= smallest {\n            j = *e.0;\n        }\n    }\n\
    \    Some(smallest)\n}\n\nfn main() {\n    let candidate = next_smallest;\n  \
    \  assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3203pl4d.rs:17:20\n   |\n\
    17 |         if *e.1 >= smallest {\n   |                    ^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |         if *e.1 >=\
    \ smallest.try_into().unwrap() {\n   |                            ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp3203pl4d.rs:18:24\n   |\n15 |\
    \     let mut smallest = it.next().unwrap().0;\n   |                        --------------------\
    \ expected due to this value\n...\n18 |             smallest = *e.1;\n   |   \
    \                     ^^^^ expected `usize`, found `isize`\n\nerror[E0614]: type\
    \ `usize` cannot be dereferenced\n  --> /tmp/tmp3203pl4d.rs:19:17\n   |\n19 |\
    \             i = *e.0;\n   |                 ^^^^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp3203pl4d.rs:22:20\n   |\n22 |         if *e.1 >= smallest\
    \ {\n   |                    ^^^^^^^^ expected `isize`, found `usize`\n   |\n\
    help: you can convert a `usize` to an `isize` and panic if the converted value\
    \ doesn't fit\n   |\n22 |         if *e.1 >= smallest.try_into().unwrap() {\n\
    \   |                            ++++++++++++++++++++\n\nerror[E0614]: type `usize`\
    \ cannot be dereferenced\n  --> /tmp/tmp3203pl4d.rs:23:17\n   |\n23 |        \
    \     j = *e.0;\n   |                 ^^^^\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp3203pl4d.rs:26:10\n   |\n26 |     Some(smallest)\n   |        \
    \  ^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize`\
    \ to an `isize` and panic if the converted value doesn't fit\n   |\n26 |     Some(smallest.try_into().unwrap())\n\
    \   |                  ++++++++++++++++++++\n\nerror: aborting due to 6 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0614.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.into_iter().skip(1).take(2).last().cloned()\n}\n\
    \nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: `Option<isize>` is not an iterator\n   --> /tmp/tmpqs1_1p0e.rs:13:44\n\
    \    |\n13  |       lst.into_iter().skip(1).take(2).last().cloned()\n    |   \
    \                                           ^^^^^^ `Option<isize>` is not an iterator\n\
    \    |\n    = note: the following trait bounds were not satisfied:\n         \
    \   `Option<isize>: Iterator`\n            which is required by `&mut Option<isize>:\
    \ Iterator`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![std::i32::MAX; 2];\n    let\
    \ mut min_idx = 1;\n    let mut max_idx = 1;\n    let mut iter = lst.iter();\n\
    \    let mut smallest_idx = 0;\n\n    for v in iter {\n        if v < smallest[smallest_idx]\
    \ || v < smallest[smallest_idx].checked_sub(smallest[min_idx]) {\n           \
    \ smallest[min_idx] = v;\n            smallest_idx = min_idx;\n        }\n   \
    \     if v < smallest[smallest_idx] || v < smallest[smallest_idx].checked_sub(smallest[max_idx])\
    \ {\n            smallest[max_idx] = v;\n            max_idx = max_idx;\n    \
    \    }\n    }\n\n    if smallest_idx == 0 {\n        return None;\n    }\n\n \
    \   let mut new_idx = 0;\n    loop {\n        if new_idx < smallest_idx {\n  \
    \          smallest[new_idx] = smallest[smallest_idx];\n            new_idx +=\
    \ 1;\n        } else {\n            break;\n        }\n    }\n\n    smallest[new_idx].checked_sub(smallest[new_idx])\n\
    \        .ok_or(\"No such element\")\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_v66c8ly.rs:20:16\n   |\n\
    20 |         if v < smallest[smallest_idx] || v < smallest[smallest_idx].checked_sub(smallest[min_idx])\
    \ {\n   |                ^^^^^^^^^^^^^^^^^^^^^^ expected `&isize`, found `i32`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp_v66c8ly.rs:20:46\n   |\n20 |\
    \         if v < smallest[smallest_idx] || v < smallest[smallest_idx].checked_sub(smallest[min_idx])\
    \ {\n   |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&isize`, found enum `Option`\n   |\n   = note: expected reference\
    \ `&isize`\n                   found enum `Option<i32>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_v66c8ly.rs:21:33\n   |\n21 |             smallest[min_idx]\
    \ = v;\n   |             -----------------   ^ expected `i32`, found `&isize`\n\
    \   |             |\n   |             expected due to the type of this binding\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp_v66c8ly.rs:24:16\n   |\n24 |\
    \         if v < smallest[smallest_idx] || v < smallest[smallest_idx].checked_sub(smallest[max_idx])\
    \ {\n   |                ^^^^^^^^^^^^^^^^^^^^^^ expected `&isize`, found `i32`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp_v66c8ly.rs:24:46\n   |\n24 |\
    \         if v < smallest[smallest_idx] || v < smallest[smallest_idx].checked_sub(smallest[max_idx])\
    \ {\n   |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&isize`, found enum `Option`\n   |\n   = note: expected reference\
    \ `&isize`\n                   found enum `Option<i32>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_v66c8ly.rs:25:33\n   |\n25 |             smallest[max_idx]\
    \ = v;\n   |             -----------------   ^ expected `i32`, found `&isize`\n\
    \   |             |\n   |             expected due to the type of this binding\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp_v66c8ly.rs:44:5\n   |\n12 | \
    \  fn next_smallest(lst: Vec<isize>) -> Option<isize> {\n   |                \
    \                        ------------- expected `Option<isize>` because of retur"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut min_pos = 0;\n    let mut min_val = lst[0];\n\
    \    for i in 1..lst.len() {\n        if min_val > lst[i] {\n            min_val\
    \ = lst[i];\n            min_pos = i;\n        }\n    }\n    Some(min_pos)\n}\n\
    \nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwbt1cb0d.rs:21:10\n   |\n\
    21 |     Some(min_pos)\n   |          ^^^^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n21 |     Some(min_pos.try_into().unwrap())\n   |  \
    \               ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut iterator = lst.iter();\n    if iterator.next()\
    \ == Some(0) {\n        return None;\n    }\n    let mut index = 1;\n    while\
    \ index < lst.len() {\n        if iterator.next().is_some() {\n            return\
    \ Some(iterator.next().unwrap());\n        }\n        index += 1;\n    }\n   \
    \ None\n}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1xqvo09o.rs:14:32\n   |\n\
    14 |     if iterator.next() == Some(0) {\n   |                               \
    \ ^\n   |                                |\n   |                             \
    \   expected `&isize`, found integer\n   |                                help:\
    \ consider borrowing here: `&0`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1xqvo09o.rs:20:25\n\
    \   |\n20 |             return Some(iterator.next().unwrap());\n   |         \
    \                ^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n \
    \  |\nhelp: consider dereferencing the borrow\n   |\n20 |             return Some(*iterator.next().unwrap());\n\
    \   |                         +\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 101
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() > 1 {\n        Some(lst[1])\n    } else\
    \ {\n        None\n    }\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(2)`', /tmp/tmphnkk4izq.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() < 2 {\n        return None;\n    }\n\n\
    \    let mut smallest = lst[0];\n    let mut smallest_index = 0;\n\n    for i\
    \ in lst {\n        if *i < *smallest {\n            smallest = i;\n         \
    \   smallest_index = i;\n        }\n    }\n\n    Some(smallest_index + 1)\n}\n\
    \nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpm9jpzdn5.rs:21:12\n\
    \   |\n21 |         if *i < *smallest {\n   |            ^^\n\nerror[E0614]: type\
    \ `isize` cannot be dereferenced\n  --> /tmp/tmpm9jpzdn5.rs:21:17\n   |\n21 |\
    \         if *i < *smallest {\n   |                 ^^^^^^^^^\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0614`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst[0];\n    let mut next_index =\
    \ 1;\n\n    for &i in &lst {\n        if *i < smallest {\n            smallest\
    \ = i;\n            next_index = next_index * i;\n        }\n    }\n\n    if smallest\
    \ == lst[0] {\n        None\n    } else {\n        Some(smallest)\n    }\n}\n\n\
    fn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpa90a0vm0.rs:17:12\n\
    \   |\n17 |         if *i < smallest {\n   |            ^^\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0614`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.is_empty() {\n        return None;\n    }\n\n\
    \    let mut min1 = lst.iter().min();\n    let mut min2 = lst.iter().min();\n\
    \    let mut min3 = lst.iter().min();\n\n    let mut min1_len = lst.len();\n \
    \   let mut min2_len = lst.len();\n    let mut min3_len = lst.len();\n\n    while\
    \ min1 == min2 || min1 == min3 || min2 == min3 {\n        let mut next1 = lst.iter().skip(1).find(|&x|\
    \ *x != min1);\n        let mut next2 = lst.iter().skip(1).find(|&x| *x != min2);\n\
    \        let mut next3 = lst.iter().skip(1).find(|&x| *x != min3);\n\n       \
    \ if next1.is_some() {\n            min1_len -= 1;\n            min1 = next1.unwrap();\n\
    \        }\n\n        if next2.is_some() {\n            min2_len -= 1;\n     \
    \       min2 = next2.unwrap();\n        }\n\n        if next3.is_some() {\n  \
    \          min3_len -= 1;\n            min3 = next3.unwrap();\n        }\n   \
    \ }\n\n    if min1_len > min2_len && min1_len > min3_len {\n        Some(min1)\n\
    \    } else if min2_len > min3_len {\n        Some(min2)\n    } else {\n     \
    \   Some(min3)\n    }\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmph3e_x2kt.rs:26:60\n   |\n\
    26 |         let mut next1 = lst.iter().skip(1).find(|&x| *x != min1);\n   | \
    \                                                           ^^^^ expected `isize`,\
    \ found enum `Option`\n   |\n   = note: expected type `isize`\n              found\
    \ enum `Option<&isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmph3e_x2kt.rs:27:60\n\
    \   |\n27 |         let mut next2 = lst.iter().skip(1).find(|&x| *x != min2);\n\
    \   |                                                            ^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<&isize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmph3e_x2kt.rs:28:60\n   |\n28 |         let mut next3 = lst.iter().skip(1).find(|&x|\
    \ *x != min3);\n   |                                                         \
    \   ^^^^ expected `isize`, found enum `Option`\n   |\n   = note: expected type\
    \ `isize`\n              found enum `Option<&isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmph3e_x2kt.rs:32:20\n   |\n17 |     let mut min1 = lst.iter().min();\n\
    \   |                    ---------------- expected due to this value\n...\n32\
    \ |             min1 = next1.unwrap();\n   |                    ^^^^^^^^^^^^^^\
    \ expected enum `Option`, found `&isize`\n   |\n   = note:   expected enum `Option<&isize>`\n\
    \           found reference `&isize`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n32 |             min1 = Some(next1.unwrap());\n   |                   \
    \ +++++              +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmph3e_x2kt.rs:37:20\n\
    \   |\n18 |     let mut min2 = lst.iter().min();\n   |                    ----------------\
    \ expected due to this value\n...\n37 |             min2 = next2.unwrap();\n \
    \  |                    ^^^^^^^^^^^^^^ expected enum `Option`, found `&isize`\n\
    \   |\n   = note:   expected enum `Option<&isize>`\n           found reference\
    \ `&isize`\nhelp: try wrapping the expression in `Some`\n   |\n37 |          \
    \   min2 = Some(next2.unwrap());\n   |                    +++++              +\n\
    \nerror[E0308]: m"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = Vec::new();\n    smallest.push(*lst[0]);\n\
    \    if lst.len() == 1 {\n        return None;\n    }\n    for elem in lst {\n\
    \        if elem < smallest.last() {\n            smallest.push(elem);\n     \
    \   }\n    }\n    let next_smallest = smallest.iter().next().unwrap_or_else(||\
    \ lst.len());\n    Some(next_smallest)\n}\n\nfn main() {\n    let candidate =\
    \ next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n \
    \   assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmprl60wbh_.rs:14:19\n\
    \   |\n14 |     smallest.push(*lst[0]);\n   |                   ^^^^^^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmprl60wbh_.rs:19:19\n   |\n19 |         if elem\
    \ < smallest.last() {\n   |                   ^^^^^^^^^^^^^^^ expected `isize`,\
    \ found enum `Option`\n   |\n   = note: expected type `isize`\n              found\
    \ enum `Option<&_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprl60wbh_.rs:23:66\n\
    \   |\n23 |     let next_smallest = smallest.iter().next().unwrap_or_else(|| lst.len());\n\
    \   |                                                                  ^^^^^^^^^\
    \ expected `&isize`, found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprl60wbh_.rs:24:10\n\
    \   |\n24 |     Some(next_smallest)\n   |          ^^^^^^^^^^^^^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n24 |  \
    \   Some(*next_smallest)\n   |          +\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0614.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut min_idx = lst.len() - 1;\n    while min_idx\
    \ > 0 && lst[min_idx] == lst[min_idx - 1] {\n        min_idx -= 1;\n    }\n  \
    \  if min_idx == 0 {\n        return None;\n    }\n    let mut min_val = vec![lst[0];\
    \ min_idx + 1];\n    min_val.iter().cloned().for_each(|x| {\n        if *x !=\
    \ lst[min_idx] {\n            *x = *x - 1;\n        }\n    });\n    Some(min_val.iter().next().unwrap())\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpem46x8cb.rs:22:12\n\
    \   |\n22 |         if *x != lst[min_idx] {\n   |            ^^\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmpem46x8cb.rs:23:13\n   |\n\
    23 |             *x = *x - 1;\n   |             ^^\n\nerror[E0614]: type `isize`\
    \ cannot be dereferenced\n  --> /tmp/tmpem46x8cb.rs:23:18\n   |\n23 |        \
    \     *x = *x - 1;\n   |                  ^^\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpem46x8cb.rs:26:10\n   |\n26 |     Some(min_val.iter().next().unwrap())\n\
    \   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n26 |     Some(*min_val.iter().next().unwrap())\n\
    \   |          +\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0614.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 101
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().cloned().skip(1).next()\n}\n\nfn main() {\n\
    \    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4,\
    \ 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(2)`', /tmp/tmpirn2zzp2.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    // Your code here\n    let mut min_ele = lst[0];\n \
    \   let mut min_elem = vec![min_ele];\n    for (i, elem) in lst.iter().enumerate()\
    \ {\n        if elem < min_ele {\n            min_ele = elem;\n            min_elem.push(min_ele);\n\
    \        } else if elem == min_ele {\n            min_elem.push(elem);\n     \
    \   } else {\n            min_elem = min_ele;\n            break;\n        }\n\
    \    }\n    let mut min_index = lst.iter().position(|x| *x == *min_ele).unwrap();\n\
    \    if min_index == lst.len() {\n        return Some(min_ele);\n    } else {\n\
    \        let mut temp_elem = vec![min_ele];\n        temp_elem[min_index] = min_ele;\n\
    \        for (i, elem) in temp_elem.iter().enumerate() {\n            if elem\
    \ == temp_elem[min_index] {\n                min_index = i;\n            }\n \
    \       }\n        Some(temp_elem[min_index])\n    }\n}\n\nfn main() {\n    let\
    \ candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n\
    \    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprvgr0wos.rs:17:19\n   |\n\
    17 |         if elem < min_ele {\n   |                   ^^^^^^^\n   |       \
    \            |\n   |                   expected `&isize`, found `isize`\n   |\
    \                   help: consider borrowing here: `&min_ele`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmprvgr0wos.rs:18:23\n   |\n14 |     let mut min_ele\
    \ = lst[0];\n   |                       ------ expected due to this value\n...\n\
    18 |             min_ele = elem;\n   |                       ^^^^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n18 |  \
    \           min_ele = *elem;\n   |                       +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmprvgr0wos.rs:21:27\n   |\n21 |             min_elem.push(elem);\n\
    \   |                           ^^^^ expected `isize`, found `&isize`\n   |\n\
    help: consider dereferencing the borrow\n   |\n21 |             min_elem.push(*elem);\n\
    \   |                           +\n\nerror[E0277]: can't compare `&isize` with\
    \ `isize`\n  --> /tmp/tmprvgr0wos.rs:20:24\n   |\n20 |         } else if elem\
    \ == min_ele {\n   |                        ^^ no implementation for `&isize ==\
    \ isize`\n   |\n   = help: the trait `PartialEq<isize>` is not implemented for\
    \ `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprvgr0wos.rs:23:24\n\
    \   |\n15 |     let mut min_elem = vec![min_ele];\n   |                      \
    \  ------------- expected due to this value\n...\n23 |             min_elem =\
    \ min_ele;\n   |                        ^^^^^^^ expected struct `Vec`, found `isize`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n                found type `isize`\n\
    \nerror[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmprvgr0wos.rs:27:55\n\
    \   |\n27 |     let mut min_index = lst.iter().position(|x| *x == *min_ele).unwrap();\n\
    \   |                                    "
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    match lst.len() {\n        0 => None,\n        _ =>\
    \ Some(lst[lst.iter().skip(1).enumerate().min_by(|(_, y)| y).unwrap().1 + 1])\n\
    \    }\n}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0593]: closure is expected to take 2 distinct arguments, but it\
    \ takes a single 2-tuple as argument\n  --> /tmp/tmpapw_qh_t.rs:15:54\n   |\n\
    15 |         _ => Some(lst[lst.iter().skip(1).enumerate().min_by(|(_, y)| y).unwrap().1\
    \ + 1])\n   |                                                      ^^^^^^ --------\
    \ takes a single 2-tuple as argument\n   |                                   \
    \                   |\n   |                                                  \
    \    expected closure that takes 2 distinct arguments\n   |\nhelp: change the\
    \ closure to take multiple arguments instead of a single tuple\n   |\n15 |   \
    \      _ => Some(lst[lst.iter().skip(1).enumerate().min_by(|_, y| y).unwrap().1\
    \ + 1])\n   |                                                             ~~~~~~\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpapw_qh_t.rs:15:19\n\
    \   |\n15 |         _ => Some(lst[lst.iter().skip(1).enumerate().min_by(|(_, y)|\
    \ y).unwrap().1 + 1])\n   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0593.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut iter = lst.iter().peekable();\n    let mut smallest\
    \ = iter.next()?;\n    let mut smallest_index = 0;\n    let mut second_smallest\
    \ = iter.next()?;\n    while let Some(smallest) = second_smallest {\n        if\
    \ smallest < smallest * 2 {\n            smallest_index += 1;\n            smallest\
    \ = iter.next()?;\n            second_smallest = iter.next()?;\n        } else\
    \ {\n            break;\n        }\n    }\n\n    if second_smallest == Some(0)\
    \ {\n        return None;\n    }\n\n    if smallest_index >= 2 {\n        return\
    \ Some(smallest);\n    }\n\n    None\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_vf4e3fl.rs:17:15\n   |\n\
    17 |     while let Some(smallest) = second_smallest {\n   |               ^^^^^^^^^^^^^^\
    \   --------------- this expression has type `&isize`\n   |               |\n\
    \   |               expected `isize`, found enum `Option`\n   |\n   = note: expected\
    \ type `isize`\n              found enum `Option<_>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_vf4e3fl.rs:18:23\n   |\n18 |         if smallest < smallest\
    \ * 2 {\n   |                       ^^^^^^^^^^^^ expected reference, found `isize`\n\
    \   |\n   = note: expected reference `&isize`\n                   found type `isize`\n\
    \nerror[E0277]: can't compare `&isize` with `Option<{integer}>`\n  --> /tmp/tmp_vf4e3fl.rs:27:24\n\
    \   |\n27 |     if second_smallest == Some(0) {\n   |                        ^^\
    \ no implementation for `&isize == Option<{integer}>`\n   |\n   = help: the trait\
    \ `PartialEq<Option<{integer}>>` is not implemented for `&isize`\n   = help: the\
    \ following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp_vf4e3fl.rs:32:21\n   |\n32 |\
    \         return Some(smallest);\n   |                     ^^^^^^^^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n32 |  \
    \       return Some(*smallest);\n   |                     +\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    next_smallest_impl(lst, 0, &mut vec![], 0)\n}\n\nfn\
    \ main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `next_smallest_impl` in this scope\n\
    \  --> /tmp/tmpmpx4ogwd.rs:13:5\n   |\n13 |     next_smallest_impl(lst, 0, &mut\
    \ vec![], 0)\n   |     ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst\n        .iter()\n        .zip(\n            lst.iter().skip(1).collect::<Vec<_>>().iter().cloned().collect::<Vec<_>>(),\n\
    \        )\n        .filter_map(|(v, u)| *u < *v)\n        .next()\n}\n\nfn main()\
    \ {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp01fs1kzd.rs:18:30\n   |\n\
    12 | fn next_smallest(lst: Vec<isize>) -> Option<isize> {\n   |              \
    \                        ------------- expected `Option<_>` because of return\
    \ type\n...\n18 |         .filter_map(|(v, u)| *u < *v)\n   |                \
    \              ^^^^^^^ expected enum `Option`, found `bool`\n   |\n   = note:\
    \ expected enum `Option<_>`\n              found type `bool`\nhelp: try wrapping\
    \ the expression in `Some`\n   |\n18 |         .filter_map(|(v, u)| Some(*u <\
    \ *v))\n   |                              +++++       +\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() == 0 {\n        return None;\n    }\n\n\
    \    if lst.len() == 1 {\n        Some(lst.iter().next()?)\n    } else {\n   \
    \     let mut smallest = lst.iter().min();\n        let mut second_smallest =\
    \ lst.iter().skip(1).min();\n        if smallest == second_smallest {\n      \
    \      Some(smallest)\n        } else {\n            Some(second_smallest)\n \
    \       }\n    }\n}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: `?` operator has incompatible types\n  --> /tmp/tmpir6_vffi.rs:18:14\n\
    \   |\n18 |         Some(lst.iter().next()?)\n   |              ^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\n   = note: `?` operator cannot convert\
    \ from `&isize` to `isize`\nhelp: consider dereferencing the borrow\n   |\n18\
    \ |         Some(*lst.iter().next()?)\n   |              +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpir6_vffi.rs:23:18\n   |\n23 |             Some(smallest)\n\
    \   |                  ^^^^^^^^ expected `isize`, found enum `Option`\n   |\n\
    \   = note: expected type `isize`\n              found enum `Option<&isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpir6_vffi.rs:25:18\n   |\n25 |\
    \             Some(second_smallest)\n   |                  ^^^^^^^^^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<&isize>`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.is_empty() {\n        return None;\n    }\n\n\
    \    Some(lst.iter().skip(1).find().unwrap())\n}\n\nfn main() {\n    let candidate\
    \ = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n\
    \    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmpksnbv06e.rs:17:29\n     |\n17   |     Some(lst.iter().skip(1).find().unwrap())\n\
    \     |                             ^^^^- supplied 0 arguments\n     |       \
    \                      |\n     |                             expected 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpksnbv06e.rs:17:10\n   |\n17 |     Some(lst.iter().skip(1).find().unwrap())\n\
    \   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n17 |     Some(*lst.iter().skip(1).find().unwrap())\n\
    \   |          +\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0061, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().enumerate().try_fold(None, |(mut it, i),\
    \ (&mut i, &mut j)| {\n        if *i < j {\n            it.swap(*i);\n       \
    \ }\n        Some(*it)\n    }).unwrap()\n}\n\nfn main() {\n    let candidate =\
    \ next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n \
    \   assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0415]: identifier `i` is bound more than once in this parameter\
    \ list\n  --> /tmp/tmplert18ew.rs:13:63\n   |\n13 |     lst.iter().enumerate().try_fold(None,\
    \ |(mut it, i), (&mut i, &mut j)| {\n   |                                    \
    \                           ^ used as parameter more than once\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmplert18ew.rs:13:44\n   |\n13 |     lst.iter().enumerate().try_fold(None,\
    \ |(mut it, i), (&mut i, &mut j)| {\n   |                                    \
    \        ^^^^^^^^^^-\n   |                                            |      \
    \   |\n   |                                            |         expected due\
    \ to this\n   |                                            expected enum `Option`,\
    \ found tuple\n   |\n   = note: expected enum `Option<_>`\n             found\
    \ tuple `(_, _)`\nhelp: try wrapping the pattern in `Some`\n   |\n13 |     lst.iter().enumerate().try_fold(None,\
    \ |Some((mut it, i)), (&mut i, &mut j)| {\n   |                              \
    \              +++++           +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplert18ew.rs:13:58\n\
    \   |\n13 |     lst.iter().enumerate().try_fold(None, |(mut it, i), (&mut i, &mut\
    \ j)| {\n   |                                                          ^^^^^^\
    \        - expected due to this\n   |                                        \
    \                  |\n   |                                                   \
    \       expected `usize`, found `&mut _`\n   |                               \
    \                           help: you can probably remove the explicit borrow:\
    \ `i`\n   |\n   = note:           expected type `usize`\n           found mutable\
    \ reference `&mut _`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplert18ew.rs:13:66\n\
    \   |\n13 |     lst.iter().enumerate().try_fold(None, |(mut it, i), (&mut i, &mut\
    \ j)| {\n   |                                                                \
    \  ^^^^^^- expected due to this\n   |                                        \
    \                          |\n   |                                           \
    \                       types differ in mutability\n   |     "
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut min = lst.len();\n    let mut min_index = 0;\n\
    \    for &element in lst {\n        if element < lst.len() {\n            if min\
    \ > element {\n                min = element;\n                min_index = lst.iter().position(|&x|\
    \ x == min).unwrap();\n            }\n        }\n    }\n    Some(lst[min_index\
    \ + 1])\n}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpy7k5zfcx.rs:15:9\n   |\n\
    15 |     for &element in lst {\n   |         ^^^^^^^^    --- this expression has\
    \ type `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `element`\n \
    \  |\n   = note:   expected type `isize`\n           found reference `&_`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpy7k5zfcx.rs:19:59\n   |\n19 |  \
    \               min_index = lst.iter().position(|&x| x == min).unwrap();\n   |\
    \                                                           ^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n19 |                 min_index = lst.iter().position(|&x|\
    \ x == min.try_into().unwrap()).unwrap();\n   |                              \
    \                                ++++++++++++++++++++\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut it = lst.iter().enumerate().rev().skip(1).find(|&(_,\
    \ elem)| elem < 0).unwrap();\n    it.map(|(_, elem)| elem)\n}\n\nfn main() {\n\
    \    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4,\
    \ 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpy_e8sz1b.rs:13:80\n   |\n\
    13 |     let mut it = lst.iter().enumerate().rev().skip(1).find(|&(_, elem)| elem\
    \ < 0).unwrap();\n   |                                                       \
    \                         ^\n   |                                            \
    \                                    |\n   |                                 \
    \                                               expected `&isize`, found integer\n\
    \   |                                                                        \
    \        help: consider borrowing here: `&0`\n\nerror[E0599]: `(usize, &isize)`\
    \ is not an iterator\n  --> /tmp/tmpy_e8sz1b.rs:14:8\n   |\n14 |     it.map(|(_,\
    \ elem)| elem)\n   |        ^^^ `(usize, &isize)` is not an iterator\n   |\n \
    \  = note: the following trait bounds were not satisfied:\n           `(usize,\
    \ &isize): Iterator`\n           which is required by `&mut (usize, &isize): Iterator`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest: isize = vec![lst[0]].iter().min().unwrap();\n\
    \    for i in 1..lst.len() {\n        if smallest.partial_cmp(&lst[i]) < 0 {\n\
    \            smallest = i;\n        }\n    }\n    smallest\n}\n\nfn main() {\n\
    \    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4,\
    \ 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9ncljt14.rs:13:31\n   |\n\
    13 |     let mut smallest: isize = vec![lst[0]].iter().min().unwrap();\n   | \
    \                      -----   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `&isize`\n   |                       |\n   |                       expected\
    \ due to this\n   |\nhelp: consider dereferencing the borrow\n   |\n13 |     let\
    \ mut smallest: isize = *vec![lst[0]].iter().min().unwrap();\n   |           \
    \                    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9ncljt14.rs:15:44\n\
    \   |\n15 |         if smallest.partial_cmp(&lst[i]) < 0 {\n   |             \
    \                               ^ expected enum `Option`, found integer\n   |\n\
    \   = note: expected enum `Option<std::cmp::Ordering>`\n              found type\
    \ `{integer}`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9ncljt14.rs:16:24\n\
    \   |\n13 |     let mut smallest: isize = vec![lst[0]].iter().min().unwrap();\n\
    \   |                       ----- expected due to this type\n...\n16 |       \
    \      smallest = i;\n   |                        ^ expected `isize`, found `usize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp9ncljt14.rs:19:5\n   |\n12 | fn\
    \ next_smallest(lst: Vec<isize>) -> Option<isize> {\n   |                    \
    \                  ------------- expected `Option<isize>` because of return type\n\
    ...\n19 |     smallest\n   |     ^^^^^^^^ expected enum `Option`, found `isize`\n\
    \   |\n   = note: expected enum `Option<isize>`\n              found type `isize`\n\
    help: try wrapping the expression in `Some`\n   |\n19 |     Some(smallest)\n \
    \  |     +++++        +\n\nerror: aborting due to 4 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.is_empty() {\n        return None;\n    }\n\n\
    \    let mut smallest = lst[0];\n    let mut smallest_pos = 0;\n\n    for &element\
    \ in &lst {\n        if element < smallest {\n            smallest_pos++;\n  \
    \          smallest = element;\n        } else {\n            break;\n       \
    \ }\n    }\n\n    if smallest_pos == lst.len() {\n        return None;\n    }\n\
    \n    lst.swap(smallest_pos, 2);\n\n    Some(smallest)\n}\n\nfn main() {\n   \
    \ let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]),\
    \ Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpr35sdxto.rs:22:25\n\
    \   |\n22 |             smallest_pos++;\n   |                         ^^ not a\
    \ valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n22 |         \
    \    { let tmp = smallest_pos; smallest_pos += 1; tmp };\n   |             +++++++++++\
    \             ~~~~~~~~~~~~~~~~~~~~~~~~~~\n22 -             smallest_pos++;\n22\
    \ +             smallest_pos += 1;\n   | \n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() < 2 {\n        return None;\n    }\n  \
    \  let mut smallest = lst[0];\n    for &x in &lst {\n        if x < smallest {\n\
    \            smallest = x;\n        }\n    }\n    smallest\n}\n\nfn main() {\n\
    \    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4,\
    \ 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1f4cqs7w.rs:22:5\n   |\n\
    12 | fn next_smallest(lst: Vec<isize>) -> Option<isize> {\n   |              \
    \                        ------------- expected `Option<isize>` because of return\
    \ type\n...\n22 |     smallest\n   |     ^^^^^^^^ expected enum `Option`, found\
    \ `isize`\n   |\n   = note: expected enum `Option<isize>`\n              found\
    \ type `isize`\nhelp: try wrapping the expression in `Some`\n   |\n22 |     Some(smallest)\n\
    \   |     +++++        +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    match lst {\n        x => Some((lst.iter().skip(x).next()).expect(\"\
    empty list\")).cloned(),\n        None => None,\n    }\n}\n\nfn main() {\n   \
    \ let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]),\
    \ Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvqpb12dw.rs:15:9\n   |\n\
    13 |     match lst {\n   |           --- this expression has type `Vec<isize>`\n\
    14 |         x => Some((lst.iter().skip(x).next()).expect(\"empty list\")).cloned(),\n\
    15 |         None => None,\n   |         ^^^^ expected struct `Vec`, found enum\
    \ `Option`\n   |\n   = note: expected struct `Vec<isize>`\n                found\
    \ enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvqpb12dw.rs:14:36\n\
    \   |\n14 |         x => Some((lst.iter().skip(x).next()).expect(\"empty list\"\
    )).cloned(),\n   |                                    ^ expected `usize`, found\
    \ struct `Vec`\n   |\n   = note: expected type `usize`\n            found struct\
    \ `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.is_empty() {\n        return None;\n    }\n\n\
    \    let mut min = lst.iter().min().unwrap();\n    let mut idx = 0;\n    while\
    \ idx < lst.len() {\n        if let Some(el) = lst.iter().nth(idx).unwrap() {\n\
    \            if el < min {\n                min = el;\n            }\n       \
    \ }\n        idx += 1;\n    }\n\n    Some(min)\n}\n\nfn main() {\n    let candidate\
    \ = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n\
    \    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpip20sf1e.rs:20:16\n   |\n\
    20 |         if let Some(el) = lst.iter().nth(idx).unwrap() {\n   |          \
    \      ^^^^^^^^   ---------------------------- this expression has type `&isize`\n\
    \   |                |\n   |                expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected type `isize`\n              found enum `Option<_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpip20sf1e.rs:28:10\n   |\n28 |\
    \     Some(min)\n   |          ^^^ expected `isize`, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n28 |     Some(*min)\n   |         \
    \ +\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().enumerate().find(|(i, _)| {\n        i %\
    \ 2 == 0\n    }).map(|(_, num)| num)\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9hatqu20.rs:13:5\n   |\n\
    12 |   fn next_smallest(lst: Vec<isize>) -> Option<isize> {\n   |            \
    \                            ------------- expected `Option<isize>` because of\
    \ return type\n13 | /     lst.iter().enumerate().find(|(i, _)| {\n14 | |     \
    \    i % 2 == 0\n15 | |     }).map(|(_, num)| num)\n   | |__________________________^\
    \ expected `isize`, found `&isize`\n   |\n   = note: expected enum `Option<isize>`\n\
    \              found enum `Option<&isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().enumerate().filter(|(_, v)| v == 0).next().cloned().map(|(_,\
    \ v)| v)\n}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&&isize` with `{integer}`\n  --> /tmp/tmptaqbkf2s.rs:13:46\n\
    \   |\n13 |     lst.iter().enumerate().filter(|(_, v)| v == 0).next().cloned().map(|(_,\
    \ v)| v)\n   |                                              ^^ no implementation\
    \ for `&&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0599]: `Option<(usize, &isize)>`\
    \ is not an iterator\n   --> /tmp/tmptaqbkf2s.rs:13:59\n    |\n13  |       lst.iter().enumerate().filter(|(_,\
    \ v)| v == 0).next().cloned().map(|(_, v)| v)\n    |                         \
    \                                    ^^^^^^ `Option<(usize, &isize)>` is not an\
    \ iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Option<(usize, &isize)>: Iterator`\n            which is required\
    \ by `&mut Option<(usize, &isize)>: Iterator`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 101
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().cloned().skip(1).next()\n}\n\nfn main() {\n\
    \    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4,\
    \ 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(2)`', /tmp/tmpirn2zzp2.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = *lst.iter().skip(1).min().unwrap();\n\
    \    let mut found_min = lst.iter().any(|&x| x < &smallest);\n    if found_min\
    \ {\n        smallest = lst.iter().skip(1).min().unwrap();\n    }\n    if smallest.is_none()\
    \ {\n        None\n    } else {\n        Some(smallest)\n    }\n}\n\nfn main()\
    \ {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxdoiwqtz.rs:14:49\n   |\n\
    14 |     let mut found_min = lst.iter().any(|&x| x < &smallest);\n   |       \
    \                                          ^^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider removing the borrow\n   |\n14 -     let mut found_min =\
    \ lst.iter().any(|&x| x < &smallest);\n14 +     let mut found_min = lst.iter().any(|&x|\
    \ x < smallest);\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxdoiwqtz.rs:16:20\n\
    \   |\n13 |     let mut smallest = *lst.iter().skip(1).min().unwrap();\n   | \
    \                       ---------------------------------- expected due to this\
    \ value\n...\n16 |         smallest = lst.iter().skip(1).min().unwrap();\n   |\
    \                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n16 |        \
    \ smallest = *lst.iter().skip(1).min().unwrap();\n   |                    +\n\n\
    error[E0599]: no method named `is_none` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpxdoiwqtz.rs:18:17\n   |\n18 |     if smallest.is_none()\
    \ {\n   |                 ^^^^^^^ method not found in `isize`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst[0];\n    let mut second = lst[0];\n\
    \    for i in 1..lst.len() {\n        if smallest.partial_cmp(&lst[i]) == 1 {\n\
    \            second = smallest;\n            smallest = lst[i];\n        } else\
    \ {\n            if smallest.partial_cmp(&lst[i]) > 0 {\n                second\
    \ = smallest;\n                smallest = lst[i];\n            } else {\n    \
    \            second = lst[i];\n            }\n        }\n    }\n    Some(smallest)\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmps7aqjna1.rs:16:45\n   |\n\
    16 |         if smallest.partial_cmp(&lst[i]) == 1 {\n   |                   \
    \                          ^ expected enum `Option`, found integer\n   |\n   =\
    \ note: expected enum `Option<std::cmp::Ordering>`\n              found type `{integer}`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmps7aqjna1.rs:20:48\n   |\n20 |\
    \             if smallest.partial_cmp(&lst[i]) > 0 {\n   |                   \
    \                             ^ expected enum `Option`, found integer\n   |\n\
    \   = note: expected enum `Option<std::cmp::Ordering>`\n              found type\
    \ `{integer}`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    match lst {\n        [] => None,\n        &[smallest]\
    \ | &[_] => Some(smallest),\n        &[lst.iter().rev()] => Some(lst.iter().rev().next().unwrap()),\n\
    \        &lst.iter().enumerate().rev().find(|(_, x)| x < smallest).map(|i| i.0).ok_or_else(||\
    \ {\n            format!(\"No such element {:?} in {:?}\", smallest, lst)\n  \
    \      })?\n    }\n}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected one of `,`, `@`, `]`, or `|`, found `.`\n  --> /tmp/tmpdghyt9d7.rs:16:14\n\
    \   |\n16 |         &[lst.iter().rev()] => Some(lst.iter().rev().next().unwrap()),\n\
    \   |              ^\n   |              |\n   |              expected one of `,`,\
    \ `@`, `]`, or `|`\n   |              help: missing `,`\n\nerror: expected one\
    \ of `,`, `]`, or `|`, found `.`\n  --> /tmp/tmpdghyt9d7.rs:16:21\n   |\n16 |\
    \         &[lst.iter().rev()] => Some(lst.iter().rev().next().unwrap()),\n   |\
    \                     ^\n   |                     |\n   |                    \
    \ expected one of `,`, `]`, or `|`\n   |                     help: missing `,`\n\
    \nerror: expected one of `=>`, `@`, `if`, or `|`, found `.`\n  --> /tmp/tmpdghyt9d7.rs:17:13\n\
    \   |\n17 |         &lst.iter().enumerate().rev().find(|(_, x)| x < smallest).map(|i|\
    \ i.0).ok_or_else(|| {\n   |             ^ expected one of `=>`, `@`, `if`, or\
    \ `|`\n\nerror[E0408]: variable `smallest` is not bound in all patterns\n  -->\
    \ /tmp/tmpdghyt9d7.rs:15:23\n   |\n15 |         &[smallest] | &[_] => Some(smallest),\n\
    \   |           --------    ^^^^ pattern doesn't bind `smallest`\n   |       \
    \    |\n   |           variable not in all patterns\n\nerror[E0531]: cannot find\
    \ tuple struct or tuple variant `iter` in this scope\n  --> /tmp/tmpdghyt9d7.rs:16:15\n\
    \   |\n16 |         &[lst.iter().rev()] => Some(lst.iter().rev().next().unwrap()),\n\
    \   |               ^^^^ not found in this scope\n\nerror[E0531]: cannot find\
    \ tuple struct or tuple variant `rev` in this scope\n  --> /tmp/tmpdghyt9d7.rs:16:22\n\
    \   |\n16 |         &[lst.iter().rev()] => Some(lst.iter().rev().next().unwrap()),\n\
    \   |                      ^^^ not found in this scope\n\nerror[E0529]: expected\
    \ an array or slice, found `Vec<isize>`\n  --> /tmp/tmpdghyt9d7.rs:14:9\n   |\n\
    13 |     match lst {\n   |           --- help: consider slicing here: `lst[..]`\n\
    14 |         [] => None,\n   |         ^^ pattern cannot match with input type\
    \ `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdghyt9d7.rs:15:9\n\
    \   |\n13 |     match lst {\n   |           --- this expression has type `Vec<isize>"
  stdout: ''
  timestamp: 1659976127
- exit_code: 101
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![0; lst.len()];\n    let mut\
    \ second_smallest = vec![0; lst.len()];\n\n    let mut idx: usize = 0;\n\n   \
    \ while let Some(i) = lst.iter().position(|&x| {\n        smallest[idx] = x;\n\
    \        second_smallest[idx] = x;\n        idx += 1;\n        smallest[idx] >\
    \ smallest[idx + 1]\n    }) {\n        let mut min_idx = idx;\n        let mut\
    \ min_val = smallest[idx];\n\n        if smallest[idx + 1] < min_val {\n     \
    \       min_val = smallest[idx + 1];\n            min_idx = idx + 1;\n       \
    \ }\n\n        if min_idx < lst.len() {\n            if smallest[min_idx] > second_smallest[min_idx]\
    \ {\n                second_smallest[min_idx] = smallest[min_idx];\n         \
    \   } else {\n                second_smallest[min_idx] = second_smallest[min_idx];\n\
    \            }\n        }\n    }\n    if lst.len() == 0 {\n        None\n    }\
    \ else {\n        if smallest[lst.len() - 1] < second_smallest[lst.len() - 1]\
    \ {\n            None\n        } else {\n            Some(second_smallest[lst.len()\
    \ - 1])\n        }\n    }\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 5 but the
    index is 5'', /tmp/tmphtvbayi_.rs:22:25

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().cloned().enumerate().take_while(|&(i, item)|\
    \ {\n        item < lst.get(i+1)\n    }).next()\n}\n\nfn main() {\n    let candidate\
    \ = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n\
    \    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcuobf3iq.rs:14:16\n   |\n\
    14 |         item < lst.get(i+1)\n   |                ^^^^^^^^^^^^ expected `isize`,\
    \ found enum `Option`\n   |\n   = note: expected type `isize`\n              found\
    \ enum `Option<&isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcuobf3iq.rs:13:5\n\
    \   |\n12 |   fn next_smallest(lst: Vec<isize>) -> Option<isize> {\n   |     \
    \                                   ------------- expected `Option<isize>` because\
    \ of return type\n13 | /     lst.iter().cloned().enumerate().take_while(|&(i,\
    \ item)| {\n14 | |         item < lst.get(i+1)\n15 | |     }).next()\n   | |_____________^\
    \ expected `isize`, found tuple\n   |\n   = note: expected enum `Option<isize>`\n\
    \              found enum `Option<(usize, isize)>`\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().cloned().enumerate().filter_map(|(i, elem)|\
    \ {\n        if elem == 0 {\n            None\n        } else {\n            Some(\n\
    \                vec.iter().cloned().enumerate().filter_map(|(j, e)| {\n     \
    \               Some((i, e, j))\n                }).next()?.1,\n            )\n\
    \        }\n    }).next()\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0423]: expected value, found macro `vec`\n  --> /tmp/tmp5ywqa4y4.rs:18:17\n\
    \   |\n18 |                 vec.iter().cloned().enumerate().filter_map(|(j, e)|\
    \ {\n   |                 ^^^ not a value\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0423`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    vec::Vec::from(lst).iter().next().ok_or(|| {\n     \
    \   String::from(\"next_smallest: vector has less than 2 elements\")\n    })?\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `vec`\n\
    \  --> /tmp/tmpzfzz9t25.rs:13:10\n   |\n13 |     vec::Vec::from(lst).iter().next().ok_or(||\
    \ {\n   |          ^^^ not found in `vec`\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::vec::Vec;\n   |\nhelp: if you import `Vec`, refer\
    \ to it directly\n   |\n13 -     vec::Vec::from(lst).iter().next().ok_or(|| {\n\
    13 +     Vec::from(lst).iter().next().ok_or(|| {\n   | \n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 101
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut index = 0;\n    while index != lst.len() - 1\
    \ {\n        if lst[index] > lst[index + 1] {\n            return Some(lst[index\
    \ + 1]);\n        }\n        index += 1;\n    }\n    None\n}\n\nfn main() {\n\
    \    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4,\
    \ 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `None`,\n right: `Some(2)`', /tmp/tmpn6pchrqs.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    Some(\n        lst.iter()\n            .enumerate()\n\
    \            .next()\n            .unwrap()\n            .0\n            .min(|x,\
    \ y| x.cmp(y))\n            .unwrap_or(isize::MAX)\n    )\n}\n\nfn main() {\n\
    \    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4,\
    \ 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmp_m33523p.rs:19:19\n\
    \   |\n19 |             .min(|x, y| x.cmp(y))\n   |                   ^ consider\
    \ giving this closure parameter a type\n   |\n   = note: type must be known at\
    \ this point\n\nerror[E0599]: no method named `unwrap_or` found for type `usize`\
    \ in the current scope\n  --> /tmp/tmp_m33523p.rs:20:14\n   |\n20 |          \
    \   .unwrap_or(isize::MAX)\n   |              ^^^^^^^^^ method not found in `usize`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0282, E0599.\nFor more information about an error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    let\
    \ mut idx: usize = 0;\n    while idx < lst.len() {\n        if smallest == lst[idx]\
    \ {\n            break;\n        }\n        idx += 1;\n        if idx >= lst.len()\
    \ {\n            return None;\n        }\n    }\n    Some(smallest)\n}\n\nfn main()\
    \ {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmp0pvr985m.rs:16:21\n\
    \   |\n16 |         if smallest == lst[idx] {\n   |                     ^^ no\
    \ implementation for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp0pvr985m.rs:24:10\n   |\n24 |     Some(smallest)\n   |          ^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n24 |     Some(*smallest)\n   |          +\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    loop {\n        let mut smallest = lst.min_by_key(|x|\
    \ x);\n        match smallest {\n            None => break,\n            _ =>\
    \ smallest = smallest.next_by_key(|x| x)\n        }\n    }\n    smallest\n}\n\n\
    fn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `smallest` in this scope\n  --> /tmp/tmpbjq3g50o.rs:20:5\n\
    \   |\n20 |     smallest\n   |     ^^^^^^^^ not found in this scope\n\nerror[E0599]:\
    \ `Vec<isize>` is not an iterator\n   --> /tmp/tmpbjq3g50o.rs:14:32\n    |\n14\
    \  |           let mut smallest = lst.min_by_key(|x| x);\n    |              \
    \                    ^^^^^^^^^^ `Vec<isize>` is not an iterator\n    |\n    =\
    \ note: the following trait bounds were not satisfied:\n            `Vec<isize>:\
    \ Iterator`\n            which is required by `&mut Vec<isize>: Iterator`\n  \
    \          `[isize]: Iterator`\n            which is required by `&mut [isize]:\
    \ Iterator`\n\nerror[E0599]: no method named `next_by_key` found for enum `Option`\
    \ in the current scope\n  --> /tmp/tmpbjq3g50o.rs:17:38\n   |\n17 |          \
    \   _ => smallest = smallest.next_by_key(|x| x)\n   |                        \
    \              ^^^^^^^^^^^ method not found in `Option<_>`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.is_empty() {\n        return None;\n    }\n \
    \   let mut min = lst[0];\n    let mut index = 0;\n    for &x in lst {\n     \
    \   if x < min {\n            min = x;\n            index = x;\n        }\n  \
    \  }\n    Some(index)\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkw6lqpsd.rs:18:9\n   |\n\
    18 |     for &x in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().skip(1).min(|a, b| a.cmp(&b)).next()\n}\n\
    \nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpjj9bbk_o.rs:13:29\n\
    \   |\n13 |     lst.iter().skip(1).min(|a, b| a.cmp(&b)).next()\n   |        \
    \                     ^ consider giving this closure parameter a type\n   |\n\
    \   = note: type must be known at this point\n\nerror[E0061]: this function takes\
    \ 0 arguments but 1 argument was supplied\n    --> /tmp/tmpjj9bbk_o.rs:13:24\n\
    \     |\n13   |     lst.iter().skip(1).min(|a, b| a.cmp(&b)).next()\n     |  \
    \                      ^^^ ---------------- supplied 1 argument\n     |      \
    \                  |\n     |                        expected 0 arguments\n   \
    \  |\nnote: associated function defined here\n\nerror[E0599]: no method named\
    \ `next` found for enum `Option` in the current scope\n  --> /tmp/tmpjj9bbk_o.rs:13:46\n\
    \   |\n13 |     lst.iter().skip(1).min(|a, b| a.cmp(&b)).next()\n   |        \
    \                                      ^^^^ method not found in `Option<&isize>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0282, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0061`.\n"
  stdout: ''
  timestamp: 1659976127
- exit_code: 101
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst[0];\n    for &i in &lst {\n \
    \       if i < smallest {\n            smallest = i;\n        }\n    }\n    if\
    \ smallest == 0 {\n        None\n    } else {\n        Some(smallest)\n    }\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(2)`', /tmp/tmpqlzhcz55.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 101
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() <= 2 {\n        return None;\n    }\n \
    \   let mut i = 1;\n    let mut smallest = lst[0];\n    while i < lst.len() {\n\
    \        if smallest > lst[i] {\n            smallest = lst[i];\n        }\n \
    \       i += 1;\n    }\n    Some(smallest)\n}\n\nfn main() {\n    let candidate\
    \ = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n\
    \    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(2)`', /tmp/tmpxm7ontj7.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().clone().clone().min_by(|a, b| a.partial_cmp(b).unwrap()).ok()\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `ok` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmpxkizc999.rs:13:73\n   |\n13 |     lst.iter().clone().clone().min_by(|a,\
    \ b| a.partial_cmp(b).unwrap()).ok()\n   |                                   \
    \                                      ^^ help: there is an associated function\
    \ with a similar name: `or`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().enumerate().take_while(|(i, elem)| *elem\
    \ < lst[1 + i]).next()\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwcpmfzim.rs:13:59\n   |\n\
    13 |     lst.iter().enumerate().take_while(|(i, elem)| *elem < lst[1 + i]).next()\n\
    \   |                                                           ^^^^^^^^^^\n \
    \  |                                                           |\n   |       \
    \                                                    expected `&isize`, found\
    \ `isize`\n   |                                                           help:\
    \ consider borrowing here: `&lst[1 + i]`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpwcpmfzim.rs:13:5\n   |\n12 | fn next_smallest(lst: Vec<isize>) ->\
    \ Option<isize> {\n   |                                      ------------- expected\
    \ `Option<isize>` because of return type\n13 |     lst.iter().enumerate().take_while(|(i,\
    \ elem)| *elem < lst[1 + i]).next()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found tuple\n   |\n   = note: expected enum `Option<isize>`\n\
    \              found enum `Option<(usize, &isize)>`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst\n        .iter()\n        .enumerate()\n       \
    \ .filter(|(i, elem)| elem != 0 && elem < lst.len())\n        .next()\n      \
    \  .map(|(index, elem)| lst.nth(index + 1))\n        .next()\n}\n\nfn main() {\n\
    \    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4,\
    \ 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&&isize` with `{integer}`\n  --> /tmp/tmpwi6mw43g.rs:16:34\n\
    \   |\n16 |         .filter(|(i, elem)| elem != 0 && elem < lst.len())\n   | \
    \                                 ^^ no implementation for `&&isize == {integer}`\n\
    \   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&&isize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwi6mw43g.rs:16:49\n\
    \   |\n16 |         .filter(|(i, elem)| elem != 0 && elem < lst.len())\n   | \
    \                                                ^^^^^^^^^ expected `&&isize`,\
    \ found `usize`\n\nerror[E0599]: no method named `nth` found for struct `Vec<isize>`\
    \ in the current scope\n  --> /tmp/tmpwi6mw43g.rs:18:34\n   |\n18 |         .map(|(index,\
    \ elem)| lst.nth(index + 1))\n   |                                  ^^^ method\
    \ not found in `Vec<isize>`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = None;\n    let mut second_smallest\
    \ = None;\n    for value in lst {\n        if smallest == None || value < smallest\
    \ {\n            second_smallest = Some(value);\n            smallest = value;\n\
    \        } else if value == smallest {\n            smallest = Some(value);\n\
    \        }\n    }\n    second_smallest\n}\n\nfn main() {\n    let candidate =\
    \ next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n \
    \   assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp64ayt2gn.rs:16:40\n   |\n\
    16 |         if smallest == None || value < smallest {\n   |                 \
    \                       ^^^^^^^^ expected `isize`, found enum `Option`\n   |\n\
    \   = note: expected type `isize`\n              found enum `Option<_>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp64ayt2gn.rs:18:24\n   |\n13 |     let mut smallest\
    \ = None;\n   |                        ---- expected due to this value\n...\n\
    18 |             smallest = value;\n   |                        ^^^^^ expected\
    \ enum `Option`, found `isize`\n   |\n   = note: expected enum `Option<_>`\n \
    \             found type `isize`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n18 |             smallest = Some(value);\n   |                        +++++\
    \     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp64ayt2gn.rs:19:28\n \
    \  |\n19 |         } else if value == smallest {\n   |                       \
    \     ^^^^^^^^ expected `isize`, found enum `Option`\n   |\n   = note: expected\
    \ type `isize`\n              found enum `Option<_>`\n\nerror: aborting due to\
    \ 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst[0];\n    smallest.set_min(&mut\
    \ smallest, &mut lst);\n    let mut smallest_next = smallest;\n    smallest.set_min(&mut\
    \ smallest_next, &mut lst);\n    smallest_next\n}\n\nfn main() {\n    let candidate\
    \ = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n\
    \    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `set_min` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpl1lcooax.rs:14:14\n   |\n14 |     smallest.set_min(&mut\
    \ smallest, &mut lst);\n   |              ^^^^^^^ method not found in `isize`\n\
    \nerror[E0599]: no method named `set_min` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpl1lcooax.rs:16:14\n   |\n16 |     smallest.set_min(&mut\
    \ smallest_next, &mut lst);\n   |              ^^^^^^^ method not found in `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpl1lcooax.rs:17:5\n   |\n12 | fn\
    \ next_smallest(lst: Vec<isize>) -> Option<isize> {\n   |                    \
    \                  ------------- expected `Option<isize>` because of return type\n\
    ...\n17 |     smallest_next\n   |     ^^^^^^^^^^^^^ expected enum `Option`, found\
    \ `isize`\n   |\n   = note: expected enum `Option<isize>`\n              found\
    \ type `isize`\nhelp: try wrapping the expression in `Some`\n   |\n17 |     Some(smallest_next)\n\
    \   |     +++++             +\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 101
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() == 1 {\n        return None;\n    }\n \
    \   let mut smallest_v = vec![];\n    let mut min_v = vec![];\n    for x in lst\
    \ {\n        if smallest_v.len() == 0 || x < smallest_v[0] {\n            smallest_v.push(x);\n\
    \            min_v.push(x);\n        } else {\n            min_v.push(smallest_v[0]);\n\
    \            smallest_v.pop();\n        }\n    }\n    if smallest_v.len() == 0\
    \ {\n        return None;\n    }\n    min_v.push(smallest_v[0]);\n    Some(min_v[1])\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(2)`', /tmp/tmp2g_g1b5m.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 101
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() == 0 {\n        return None;\n    }\n \
    \   let mut smallest = vec![lst[0]; 2];\n    let mut second_smallest = vec![smallest[0];\
    \ 2];\n    let mut smallest_pos = 0;\n    let mut second_smallest_pos = 0;\n \
    \   let mut pos = 0;\n    let mut smallest_found = false;\n    let mut second_smallest_found\
    \ = false;\n    while pos < lst.len() {\n        if smallest[smallest_pos] < second_smallest[second_smallest_pos]\
    \ {\n            smallest[smallest_pos] = lst[pos];\n            second_smallest[second_smallest_pos]\
    \ = lst[pos];\n            smallest_found = true;\n        }\n        second_smallest[second_smallest_pos]\
    \ = lst[pos];\n        second_smallest_pos += 1;\n        pos += 1;\n    }\n \
    \   if smallest_found == true {\n        Some(smallest[1])\n    } else {\n   \
    \     None\n    }\n}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 2 but the
    index is 2'', /tmp/tmp0hxe3_kc.rs:24:37

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![&lst[0]];\n\n    for e in &lst[1..]\
    \ {\n        if smallest[0] < &e {\n            smallest = vec![&e];\n       \
    \ } else {\n            smallest.push(&e);\n        }\n    }\n\n    smallest.len()\n\
    \        .check()\n        .and_then(|n| smallest.iter().nth(1).unwrap())\n}\n\
    \nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `check` found for type `usize` in the current\
    \ scope\n  --> /tmp/tmpzjkny9ky.rs:24:10\n   |\n24 |         .check()\n   |  \
    \        ^^^^^ method not found in `usize`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() == 0 {\n        return None;\n    }\n\n\
    \    let mut min_value = i32::MAX;\n    let mut min_index = usize::MAX;\n    for\
    \ &x in lst {\n        if x < min_value {\n            min_value = x;\n      \
    \      min_index = x;\n        }\n    }\n\n    if min_index == lst.len() {\n \
    \       return None;\n    }\n\n    let mut min_value = i32::MAX;\n    let mut\
    \ min_index = usize::MAX;\n    for &x in lst {\n        if x < min_value {\n \
    \           min_value = x;\n            min_index = x;\n        }\n    }\n\n \
    \   if min_index == lst.len() {\n        return None;\n    }\n\n    Some(lst.iter().nth(min_index\
    \ + 1))\n}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbtig5a0z.rs:19:9\n   |\n\
    19 |     for &x in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpbtig5a0z.rs:22:25\n   |\n18 |     let mut min_index = usize::MAX;\n\
    \   |                         ---------- expected due to this value\n...\n22 |\
    \             min_index = x;\n   |                         ^ expected `usize`,\
    \ found `i32`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbtig5a0z.rs:32:9\n\
    \   |\n32 |     for &x in lst {\n   |         ^^    --- this expression has type\
    \ `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `x`\n   |\n \
    \  = note:   expected type `isize`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpbtig5a0z.rs:35:25\n   |\n31 |     let mut min_index\
    \ = usize::MAX;\n   |                         ---------- expected due to this\
    \ value\n...\n35 |             min_index = x;\n   |                         ^\
    \ expected `usize`, found `i32`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbtig5a0z.rs:43:10\n\
    \   |\n43 |     Some(lst.iter().nth(min_index + 1))\n   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n\
    \              found enum `Option<&isize>`\n\nerror: aborting due to 5 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut min = lst.get(0);\n    if lst.len() == 1 {\n\
    \        return None;\n    }\n    for i in 1..lst.len() {\n        let current\
    \ = lst[i];\n        if current < min {\n            min = current;\n        }\n\
    \    }\n    Some(min)\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpltfxd7a9.rs:19:22\n   |\n\
    19 |         if current < min {\n   |                      ^^^ expected `isize`,\
    \ found enum `Option`\n   |\n   = note: expected type `isize`\n              found\
    \ enum `Option<&isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpltfxd7a9.rs:20:19\n\
    \   |\n13 |     let mut min = lst.get(0);\n   |                   ---------- expected\
    \ due to this value\n...\n20 |             min = current;\n   |              \
    \     ^^^^^^^ expected enum `Option`, found `isize`\n   |\n   = note: expected\
    \ enum `Option<&isize>`\n              found type `isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpltfxd7a9.rs:23:10\n   |\n23 |     Some(min)\n   |     \
    \     ^^^ expected `isize`, found enum `Option`\n   |\n   = note: expected type\
    \ `isize`\n              found enum `Option<&isize>`\n\nerror: aborting due to\
    \ 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut it = lst.iter().skip(1).find(|x| x < lst.iter().next().unwrap());\n\
    \    it.map(|x| x).ok()\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw77bviyd.rs:13:50\n   |\n\
    13 |     let mut it = lst.iter().skip(1).find(|x| x < lst.iter().next().unwrap());\n\
    \   |                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&isize`, found `isize`\n   |\n   = note: expected reference `&&isize`\n\
    \              found reference `&isize`\n\nerror[E0599]: no method named `ok`\
    \ found for enum `Option` in the current scope\n  --> /tmp/tmpw77bviyd.rs:14:19\n\
    \   |\n14 |     it.map(|x| x).ok()\n   |                   ^^ help: there is an\
    \ associated function with a similar name: `or`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() < 2 { return None; }\n    let mut min_idx\
    \ = lst.iter().min_by_key(|&x| x).expect(\"All elements are same\");\n    if min_idx\
    \ < lst.len() - 1 { min_idx += 1 }\n    Some(lst[min_idx])\n}\n\nfn main() {\n\
    \    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4,\
    \ 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvpx3oa83.rs:15:18\n   |\n\
    15 |     if min_idx < lst.len() - 1 { min_idx += 1 }\n   |                  ^^^^^^^^^^^^^\
    \ expected `&isize`, found `usize`\n\nerror[E0368]: binary assignment operation\
    \ `+=` cannot be applied to type `&isize`\n  --> /tmp/tmpvpx3oa83.rs:15:34\n \
    \  |\n15 |     if min_idx < lst.len() - 1 { min_idx += 1 }\n   |             \
    \                     -------^^^^^\n   |                                  |\n\
    \   |                                  cannot use `+=` on type `&isize`\n   |\n\
    help: `+=` can be used on `isize`, you can dereference `min_idx`\n   |\n15 | \
    \    if min_idx < lst.len() - 1 { *min_idx += 1 }\n   |                      \
    \            +\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n\
    \  --> /tmp/tmpvpx3oa83.rs:16:10\n   |\n16 |     Some(lst[min_idx])\n   |    \
    \      ^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n \
    \  |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0368.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 101
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut lower = lst.len() - 1;\n    let mut upper =\
    \ 0;\n    while lower >= 0 && lst[lower] > lst[upper] {\n        lower = upper\
    \ - 1;\n    }\n    if lower < 0 {\n        return None;\n    }\n    let mut lower\
    \ = lst.len() - 1;\n    let mut upper = 0;\n    while lower >= 0 && lst[lower]\
    \ > lst[upper] {\n        lower = upper - 1;\n    }\n    if lower >= 0 {\n   \
    \     lower = upper + 1;\n    }\n    if lower < 0 {\n        return None;\n  \
    \  }\n    Some(lst[lower])\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpit0ddluw.rs:16:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut min_idx = lst.len();\n\n    if min_idx == 0\
    \ {\n        return None;\n    }\n\n    while min_idx > 0 {\n        if lst.len()\
    \ - min_idx - 1 > 0 {\n            lst.remove(min_idx);\n            lst.remove(min_idx);\n\
    \        } else {\n            min_idx -= 1;\n        }\n    }\n\n    if lst.len()\
    \ == 0 {\n        return None;\n    }\n\n    Some(lst[1])\n}\n\nfn main() {\n\
    \    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4,\
    \ 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `lst` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmp7p091wjx.rs:21:13\n   |\n12 | fn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n   |                  --- help: consider changing this to\
    \ be mutable: `mut lst`\n...\n21 |             lst.remove(min_idx);\n   |    \
    \         ^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot\
    \ borrow `lst` as mutable, as it is not declared as mutable\n  --> /tmp/tmp7p091wjx.rs:22:13\n\
    \   |\n12 | fn next_smallest(lst: Vec<isize>) -> Option<isize> {\n   |       \
    \           --- help: consider changing this to be mutable: `mut lst`\n...\n22\
    \ |             lst.remove(min_idx);\n   |             ^^^^^^^^^^^^^^^^^^^ cannot\
    \ borrow as mutable\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().next_back().map(|x| *x).ok()\n}\n\nfn main()\
    \ {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `ok` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmpjirapglk.rs:13:40\n   |\n13 |     lst.iter().next_back().map(|x|\
    \ *x).ok()\n   |                                        ^^ help: there is an associated\
    \ function with a similar name: `or`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 101
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    Some(lst[1] + 1)\n}\n\nfn main() {\n    let candidate\
    \ = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n\
    \    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(3)`,\n right: `Some(2)`', /tmp/tmphytzaqx1.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut it: Option<isize> = None;\n    for v in lst.iter().cloned()\
    \ {\n        if let Some(mut it) = (it = Some(v)) {\n            if it.clone()\
    \ <= v {\n                break;\n            }\n        } else {\n          \
    \  it = None;\n        }\n    }\n    it\n}\n\nfn main() {\n    let candidate =\
    \ next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n \
    \   assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around `let` scrutinee expression\n  -->\
    \ /tmp/tmp83qrtyme.rs:15:31\n   |\n15 |         if let Some(mut it) = (it = Some(v))\
    \ {\n   |                               ^            ^\n   |\n   = note: `#[warn(unused_parens)]`\
    \ on by default\nhelp: remove these parentheses\n   |\n15 -         if let Some(mut\
    \ it) = (it = Some(v)) {\n15 +         if let Some(mut it) = it = Some(v) {\n\
    \   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmp83qrtyme.rs:15:16\n  \
    \ |\n15 |         if let Some(mut it) = (it = Some(v)) {\n   |               \
    \ ^^^^^^^^^^^^   -------------- this expression has type `()`\n   |          \
    \      |\n   |                expected `()`, found enum `Option`\n   |\n   = note:\
    \ expected unit type `()`\n                   found enum `Option<_>`\n\nerror:\
    \ aborting due to previous error; 1 warning emitted\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.pop().map(|x| x)\n}\n\nfn main() {\n    let candidate\
    \ = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n\
    \    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `lst` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmp_yidcbfp.rs:13:5\n   |\n12 | fn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n   |                  --- help: consider changing this to\
    \ be mutable: `mut lst`\n13 |     lst.pop().map(|x| x)\n   |     ^^^^^^^^^ cannot\
    \ borrow as mutable\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    Some(lst.iter().next_back().unwrap())\n}\n\nfn main()\
    \ {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmps3kha27j.rs:13:10\n   |\n\
    13 |     Some(lst.iter().next_back().unwrap())\n   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n13 |     Some(*lst.iter().next_back().unwrap())\n   |          +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().enumerate().cloned().min_by_key(|(i, &elem)|\
    \ elem).map(|(_, elem)| elem)\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<Enumerate<std::slice::Iter<'_,\
    \ isize>> as Iterator>::Item == &_`\n    --> /tmp/tmpca_hg7g6.rs:13:28\n     |\n\
    13   |     lst.iter().enumerate().cloned().min_by_key(|(i, &elem)| elem).map(|(_,\
    \ elem)| elem)\n     |                            ^^^^^^ expected reference, found\
    \ tuple\n     |\n     = note: expected reference `&_`\n                    found\
    \ tuple `(usize, &isize)`\nnote: required by a bound in `cloned`\n\nerror[E0599]:\
    \ the method `min_by_key` exists for struct `Cloned<Enumerate<std::slice::Iter<'_,\
    \ isize>>>`, but its trait bounds were not satisfied\n  --> /tmp/tmpca_hg7g6.rs:13:37\n\
    \   |\n13 |        lst.iter().enumerate().cloned().min_by_key(|(i, &elem)| elem).map(|(_,\
    \ elem)| elem)\n   |                                        ^^^^^^^^^^ method\
    \ cannot be called on `Cloned<Enumerate<std::slice::Iter<'_, isize>>>` due to\
    \ unsatisfied trait bounds\n   |\n   = note: the following trait bounds were not\
    \ satisfied:\n           `<Enumerate<std::slice::Iter<'_, isize>> as Iterator>::Item\
    \ = &_`\n           which is required by `Cloned<Enumerate<std::slice::Iter<'_,\
    \ isize>>>: Iterator`\n           `Cloned<Enumerate<std::slice::Iter<'_, isize>>>:\
    \ Iterator`\n           which is required by `&mut Cloned<Enumerate<std::slice::Iter<'_,\
    \ isize>>>: Iterator`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0271, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.is_empty() {\n        return None;\n    }\n \
    \   let mut iter: Option<isize> = None;\n    let mut smallest = lst.iter().min();\n\
    \    for i in lst.iter() {\n        if *i < smallest {\n            smallest =\
    \ i;\n            iter = Some(i);\n        }\n    }\n    iter\n}\n\nfn main()\
    \ {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpso0p3gw3.rs:19:17\n   |\n\
    19 |         if *i < smallest {\n   |                 ^^^^^^^^ expected `isize`,\
    \ found enum `Option`\n   |\n   = note: expected type `isize`\n              found\
    \ enum `Option<&isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpso0p3gw3.rs:20:24\n\
    \   |\n17 |     let mut smallest = lst.iter().min();\n   |                   \
    \     ---------------- expected due to this value\n...\n20 |             smallest\
    \ = i;\n   |                        ^ expected enum `Option`, found `&isize`\n\
    \   |\n   = note:   expected enum `Option<&isize>`\n           found reference\
    \ `&isize`\nhelp: try wrapping the expression in `Some`\n   |\n20 |          \
    \   smallest = Some(i);\n   |                        +++++ +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpso0p3gw3.rs:21:25\n   |\n21 |             iter\
    \ = Some(i);\n   |                         ^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n21 |             iter =\
    \ Some(*i);\n   |                         +\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 101
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() < 2 {\n        return None;\n    }\n\n\
    \    let mut smallest = lst[0];\n    let mut index = 1;\n\n    while index < lst.len()\
    \ {\n        if smallest > lst[index] {\n            smallest = lst[index];\n\
    \        }\n\n        index += 1\n    }\n\n    Some(smallest)\n}\n\nfn main()\
    \ {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(2)`', /tmp/tmpzce1vvk1.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst[0];\n    let mut smallest_index\
    \ = 0;\n    for element in lst {\n        if element < smallest {\n          \
    \  smallest_index += 1;\n            smallest = element;\n        } else {\n \
    \           break;\n        }\n    }\n    if smallest_index == lst.len() {\n \
    \       None\n    } else {\n        Some(smallest)\n    }\n}\n\nfn main() {\n\
    \    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4,\
    \ 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `lst`\n   --> /tmp/tmp0vcv_aq3.rs:23:26\n\
    \    |\n12  | fn next_smallest(lst: Vec<isize>) -> Option<isize> {\n    |    \
    \              --- move occurs because `lst` has type `Vec<isize>`, which does\
    \ not implement the `Copy` trait\n...\n15  |     for element in lst {\n    | \
    \                   --- `lst` moved due to this implicit call to `.into_iter()`\n\
    ...\n23  |     if smallest_index == lst.len() {\n    |                       \
    \   ^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes\
    \ ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating\
    \ over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n\
    \    |\n15  |     for element in &lst {\n    |                    +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().cloned().enumerate().min_by_key(|&(i, _)|\
    \ {\n        if i == 0 {\n            None\n        } else {\n            Some(lst.iter().skip(i).min().unwrap_or(0))\n\
    \        }\n    }).and_then(|(&i, v)| v)\n}\n\nfn main() {\n    let candidate\
    \ = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n\
    \    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc45hhxa6.rs:17:53\n   |\n\
    17 |             Some(lst.iter().skip(i).min().unwrap_or(0))\n   |           \
    \                                          ^\n   |                           \
    \                          |\n   |                                           \
    \          expected `&isize`, found integer\n   |                            \
    \                         help: consider borrowing here: `&0`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpc45hhxa6.rs:19:19\n   |\n19 |     }).and_then(|(&i,\
    \ v)| v)\n   |                   ^^   - expected due to this\n   |           \
    \        |\n   |                   expected `usize`, found reference\n   |   \
    \                help: you can probably remove the explicit borrow: `i`\n   |\n\
    \   = note:   expected type `usize`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpc45hhxa6.rs:19:27\n   |\n12 | fn next_smallest(lst:\
    \ Vec<isize>) -> Option<isize> {\n   |                                      -------------\
    \ expected `Option<_>` because of return type\n...\n19 |     }).and_then(|(&i,\
    \ v)| v)\n   |                           ^ expected enum `Option`, found `isize`\n\
    \   |\n   = note: expected enum `Option<_>`\n              found type `isize`\n\
    help: try wrapping the expression in `Some`\n   |\n19 |     }).and_then(|(&i,\
    \ v)| Some(v))\n   |                           +++++ +\n\nerror: aborting due\
    \ to 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().enumerate().map(|(i, e)| {\n        if i\
    \ == 0 {\n            return Some(e + 1);\n        }\n        if e < lst.nth(i\
    \ - 1) {\n            return Some(e);\n        }\n        None\n    }).next()\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `nth` found for struct `Vec<isize>` in the\
    \ current scope\n  --> /tmp/tmph6onnw2w.rs:17:20\n   |\n17 |         if e < lst.nth(i\
    \ - 1) {\n   |                    ^^^ method not found in `Vec<isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmph6onnw2w.rs:18:25\n   |\n18 |             return\
    \ Some(e);\n   |                         ^ expected `isize`, found `&isize`\n\
    \   |\nnote: return type inferred to be `isize` here\n  --> /tmp/tmph6onnw2w.rs:15:20\n\
    \   |\n15 |             return Some(e + 1);\n   |                    ^^^^^^^^^^^\n\
    help: consider dereferencing the borrow\n   |\n18 |             return Some(*e);\n\
    \   |                         +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmph6onnw2w.rs:13:5\n\
    \   |\n12 |   fn next_smallest(lst: Vec<isize>) -> Option<isize> {\n   |     \
    \                                   ------------- expected `Option<isize>` because\
    \ of return type\n13 | /     lst.iter().enumerate().map(|(i, e)| {\n14 | |   \
    \      if i == 0 {\n15 | |             return Some(e + 1);\n16 | |         }\n\
    ...  |\n20 | |         None\n21 | |     }).next()\n   | |_____________^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected enum `Option<isize>`\n\
    \              found enum `Option<Option<isize>>`\n\nerror: aborting due to 3\
    \ previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut it = lst.iter();\n    it.next();\n    it.next();\n\
    \    it.next()\n}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpq60lumox.rs:16:5\n   |\n\
    12 | fn next_smallest(lst: Vec<isize>) -> Option<isize> {\n   |              \
    \                        ------------- expected `Option<isize>` because of return\
    \ type\n...\n16 |     it.next()\n   |     ^^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\n   = note: expected enum `Option<isize>`\n              found enum `Option<&isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut l = lst.len();\n    if l <= 1 {\n        return\
    \ None;\n    }\n\n    let mut min_idx = 1;\n    let mut min_val = lst[l];\n  \
    \  for idx in 2..l {\n        if min_val < lst[idx - 1] {\n            min_val\
    \ = lst[idx - 1];\n            min_idx = idx;\n        }\n    }\n\n    Some(min_val);\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4qahbbis.rs:12:38\n   |\n\
    12 | fn next_smallest(lst: Vec<isize>) -> Option<isize> {\n   |    -------------\
    \                     ^^^^^^^^^^^^^ expected enum `Option`, found `()`\n   | \
    \   |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    ...\n27 |     Some(min_val);\n   |                  - help: remove this semicolon\n\
    \   |\n   = note:   expected enum `Option<isize>`\n           found unit type\
    \ `()`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst[0];\n    smallest.sort_unstable();\n\
    \    let mut second_smallest = lst[0];\n    let mut third_smallest = lst[0];\n\
    \    for &x in lst {\n        if x < smallest {\n            second_smallest =\
    \ smallest;\n            third_smallest = x;\n            smallest = x;\n    \
    \    } else if x == smallest {\n            if x <= second_smallest {\n      \
    \          second_smallest = x;\n            }\n        }\n    }\n    if smallest\
    \ == second_smallest {\n        None\n    } else {\n        Some(third_smallest)\n\
    \    }\n}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_unstable` found for type `isize` in\
    \ the current scope\n  --> /tmp/tmp89o46ft7.rs:14:14\n   |\n14 |     smallest.sort_unstable();\n\
    \   |              ^^^^^^^^^^^^^ method not found in `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp89o46ft7.rs:17:9\n   |\n17 |     for &x in lst\
    \ {\n   |         ^^    --- this expression has type `Option<isize>`\n   |   \
    \      |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `x`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() < 2 {\n        return None;\n    }\n\n\
    \    let mut min = lst.iter().min();\n    let mut second = lst.iter().skip(1).min();\n\
    \    if min == second {\n        return None;\n    }\n    Some(second)\n}\n\n\
    fn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmyts8s1p.rs:22:10\n   |\n\
    22 |     Some(second)\n   |          ^^^^^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected type `isize`\n              found enum `Option<&isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut idx = 0;\n    loop {\n        let next = idx\
    \ == lst.len() - 1 ? None : lst.get(idx + 1);\n        if next < lst.get(idx)\
    \ && next.is_none() {\n            idx += 1;\n        } else if next > lst.get(idx)\
    \ && !next.is_none() {\n            return Some(next);\n        } else {\n   \
    \         return idx == lst.len() - 1 ? None : Some(lst.get(idx));\n        }\n\
    \    }\n}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `None`\n\
    \  --> /tmp/tmp7dhy9sju.rs:15:43\n   |\n15 |         let next = idx == lst.len()\
    \ - 1 ? None : lst.get(idx + 1);\n   |                                       \
    \    ^^^^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nerror: aborting\
    \ due to previous error\n\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut itr = lst.iter().enumerate();\n    let mut smallest\
    \ = isize::MAX;\n    let mut res = Some(isize::MAX);\n    while let Some((i, &num))\
    \ = itr.next() {\n        if num < smallest {\n            smallest = num;\n \
    \           res = Some(i);\n        }\n    }\n    res\n}\n\nfn main() {\n    let\
    \ candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n\
    \    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsd7a6bax.rs:19:24\n   |\n\
    19 |             res = Some(i);\n   |                        ^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n19 |             res = Some(i.try_into().unwrap());\n\
    \   |                         ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() > 1 {\n        let i = lst.iter().enumerate().find(|(j,\
    \ elem)| elem == lst[(*j + 1).unwrap_or(0)]).unwrap();\n        Some(lst[(1 +\
    \ i).unwrap_or(0)])\n    } else {\n        None\n    }\n}\n\nfn main() {\n   \
    \ let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]),\
    \ Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap_or` found for type `usize` in the\
    \ current scope\n  --> /tmp/tmpzvgtbv3_.rs:14:78\n   |\n14 |         let i = lst.iter().enumerate().find(|(j,\
    \ elem)| elem == lst[(*j + 1).unwrap_or(0)]).unwrap();\n   |                 \
    \                                                             ^^^^^^^^^ method\
    \ not found in `usize`\n\nerror[E0277]: cannot add `(usize, &isize)` to `{integer}`\n\
    \  --> /tmp/tmpzvgtbv3_.rs:15:21\n   |\n15 |         Some(lst[(1 + i).unwrap_or(0)])\n\
    \   |                     ^ no implementation for `{integer} + (usize, &isize)`\n\
    \   |\n   = help: the trait `Add<(usize, &isize)>` is not implemented for `{integer}`\n\
    \   = help: the following other types implement trait `Add<Rhs>`:\n          \
    \   <&'a f32 as Add<f32>>\n             <&'a f64 as Add<f64>>\n             <&'a\
    \ i128 as Add<i128>>\n             <&'a i16 as Add<i16>>\n             <&'a i32\
    \ as Add<i32>>\n             <&'a i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n\
    \             <&'a isize as Add<isize>>\n           and 48 others\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst\n        .iter()\n        .skip(1)\n        .next()\n\
    \        .map(|x| x)\n}\n\nfn main() {\n    let candidate = next_smallest;\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppiy3j_ab.rs:13:5\n   |\n\
    12 |   fn next_smallest(lst: Vec<isize>) -> Option<isize> {\n   |            \
    \                            ------------- expected `Option<isize>` because of\
    \ return type\n13 | /     lst\n14 | |         .iter()\n15 | |         .skip(1)\n\
    16 | |         .next()\n17 | |         .map(|x| x)\n   | |___________________^\
    \ expected `isize`, found `&isize`\n   |\n   = note: expected enum `Option<isize>`\n\
    \              found enum `Option<&isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut l = lst.len();\n    while l > 1 && lst.iter().min().unwrap()\
    \ >= lst.iter().nth(l - 1).unwrap() {\n        l -= 1;\n    }\n    if l == 0 {\n\
    \        return None;\n    }\n    Some(lst.iter().nth(l - 1).unwrap())\n}\n\n\
    fn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzmjekxcc.rs:20:10\n   |\n\
    20 |     Some(lst.iter().nth(l - 1).unwrap())\n   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n20 |     Some(*lst.iter().nth(l - 1).unwrap())\n   |          +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().enumerate().find(|(_, elem)| *elem < *lst.iter().skip(1).next().unwrap()).map(|(_,\
    \ elem)| elem)\n}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmi_6tz23.rs:13:53\n   |\n\
    13 |     lst.iter().enumerate().find(|(_, elem)| *elem < *lst.iter().skip(1).next().unwrap()).map(|(_,\
    \ elem)| elem)\n   |                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                                                     |\n   |            \
    \                                         expected `&isize`, found `isize`\n \
    \  |                                                     help: consider borrowing\
    \ here: `&*lst.iter().skip(1).next().unwrap()`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpmi_6tz23.rs:13:5\n   |\n12 | fn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n   |                                      -------------\
    \ expected `Option<isize>` because of return type\n13 |     lst.iter().enumerate().find(|(_,\
    \ elem)| *elem < *lst.iter().skip(1).next().unwrap()).map(|(_, elem)| elem)\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\n   = note: expected enum `Option<isize>`\n\
    \              found enum `Option<&isize>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 101
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut min_idx = lst.len();\n\n    while min_idx >\
    \ 0 {\n        min_idx -= 1;\n\n        if lst[min_idx] < lst[min_idx - 1] {\n\
    \            return Some(lst[min_idx]);\n        }\n    }\n\n    None\n}\n\nfn\
    \ main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp7ng0lo0p.rs:18:31

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![];\n\n    for i in lst {\n \
    \       if smallest.len() > 0 && smallest.last().unwrap() < i {\n            return\
    \ Some(smallest.last().unwrap() + 1);\n        }\n        smallest.push(i);\n\
    \    }\n\n    None\n}\n\nfn main() {\n    let candidate = next_smallest;\n   \
    \ assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&_` with `isize`\n  --> /tmp/tmpziocon85.rs:16:59\n\
    \   |\n16 |         if smallest.len() > 0 && smallest.last().unwrap() < i {\n\
    \   |                                                           ^ no implementation\
    \ for `&_ < isize` and `&_ > isize`\n   |\n   = help: the trait `PartialOrd<isize>`\
    \ is not implemented for `&_`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest_index = lst.len() - 1;\n\n    if smallest_index\
    \ == 0 {\n        return None;\n    }\n\n    let mut smallest = lst[smallest_index];\n\
    \n    for i in smallest_index..lst.len() {\n        if lst[i] < smallest {\n \
    \           smallest = lst[i];\n            smallest_index = i;\n        }\n \
    \   }\n\n    smallest_index\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphvnt0p71.rs:28:5\n   |\n\
    12 | fn next_smallest(lst: Vec<isize>) -> Option<isize> {\n   |              \
    \                        ------------- expected `Option<isize>` because of return\
    \ type\n...\n28 |     smallest_index\n   |     ^^^^^^^^^^^^^^ expected enum `Option`,\
    \ found `usize`\n   |\n   = note: expected enum `Option<isize>`\n            \
    \  found type `usize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 101
  program: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().find(|&x| x < lst.iter().nth(1).unwrap()).cloned()\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(2)`', /tmp/tmprs830h7s.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976128
