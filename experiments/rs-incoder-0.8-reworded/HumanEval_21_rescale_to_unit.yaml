name: HumanEval_21_rescale_to_unit
language: rs
prompt: "/// Given vector of numbers (of at least two elements), apply a linear transform\
  \ to that vector,\n/// such that the smallest number will become 0 and the largest\
  \ will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0, 5.0])\n/// vec![0.0,\
  \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n"
tests: "}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
  \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
  \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
  \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
  \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
  \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
completions: ["    // Find the midpoint of the numbers vector.\n    let mut midpoint\
    \ = numbers[2];\n    for i in 2..numbers.len() {\n        midpoint = midpoint\
    \ / 2.0;\n        numbers[i] -= midpoint;\n    }\n    numbers", "    // find the\
    \ min/max number\n    let min = numbers.iter().min().unwrap();\n    let max =\
    \ numbers.iter().max().unwrap();\n\n    // scale the numbers to [0, 1]\n    let\
    \ res = (numbers - min) / (max - min) as f64;\n\n    // return the rescaled vector\n\
    \    vec![0...res.len()].into_iter().map(|v| v * 0.1).collect::<Vec<_>>()", " \
    \   let mut new_vec: Vec<f64> = numbers.clone();\n    new_vec.sort_unstable();\n\
    \n    let mut new_min: f64 = 0.0;\n    let mut new_max: f64 = 1.0;\n    for num\
    \ in &new_vec {\n        new_min = f64::min(new_min, num);\n        new_max =\
    \ f64::max(new_max, num);\n    }\n    new_vec.truncate(1);\n    new_vec.extend(&mut\
    \ new_vec[0..numbers.len()]);\n    let new_range = new_max - new_min;\n    new_vec.iter_mut().for_each(|num|\
    \ {\n        *num = num / new_range;\n    });\n    new_vec", "    assert!(numbers.len()\
    \ > 0);\n    let mut min_number = numbers[0];\n    let mut max_number = numbers[0];\n\
    \    for (i, n) in numbers.iter().enumerate() {\n        let mut n = *n;\n   \
    \     if n < min_number {\n            min_number = n;\n        }\n        if\
    \ n > max_number {\n            max_number = n;\n        }\n    }\n    let mut\
    \ scale = 1.0\n    let mut offset = 0.0\n    if min_number == 0.0 {\n        scale\
    \ = 0.0;\n        offset = 0.0;\n    } else {\n        scale = (max_number - min_number)\
    \ / (numbers.len() - 1);\n        offset = -min_number / scale;\n    }\n    let\
    \ mut transformed_numbers = Vec::new();\n    for n in numbers {\n        *n -=\
    \ offset;\n        *n /= scale;\n        transformed_numbers.push(*n);\n    }\n\
    \    transformed_numbers", "    let mut res: Vec<f64> = numbers.clone();\n   \
    \ res.sort();\n    let mut min: f64 = numbers[0];\n    let mut max: f64 = numbers[0];\n\
    \    let mut rescaled: f64 = numbers[0];\n    for (i, n) in res.iter().enumerate()\
    \ {\n        max = max;\n        min = min;\n        if n == 0 {\n           \
    \ continue;\n        }\n        rescaled = min + (max - min) * (n as f64) / (n\
    \ - 1);\n        res[i] = rescaled;\n    }\n    res", "    if numbers.len() <\
    \ 2 {\n        numbers\n    } else {\n        let smallest = numbers[0];\n   \
    \     let largest = numbers[0];\n        for number in numbers.iter().skip(1)\
    \ {\n            if *number < smallest {\n                smallest = *number;\n\
    \            } else if *number > largest {\n                largest = *number;\n\
    \            }\n        }\n        let mut scale = largest - smallest;\n     \
    \   if scale < 1e-6 {\n            numbers.clone() + [0.01]\n        } else {\n\
    \            let mut out = Vec::<f64>::new();\n            for number in numbers\
    \ {\n                let number = (number - smallest) / scale;\n             \
    \   out.push(number);\n            }\n            out\n        }\n    }", '    numbers.iter().map(|f|
    f * 0.5).min(|a, b| a < b as f64).max(|a, b| a > b as f64) as Vec<f64>', "   \
    \ let mut min = std::f64::MAX;\n    let mut max = std::f64::MIN;\n    for i in\
    \ numbers.iter() {\n        min = std::cmp::min(min, i);\n        max = std::cmp::max(max,\
    \ i);\n    }\n\n    let mut res: Vec<f64> = Vec::new();\n    for n in numbers.iter()\
    \ {\n        match n {\n            min => {\n                res.push(0.0);\n\
    \            }\n            max => {\n                res.push(1.0);\n       \
    \     }\n            _ => res.push((n - min) / (max - min)),\n        }\n    }\n\
    \n    res", "    let mut largest = numbers[0];\n    let mut smallest = numbers[0];\n\
    \n    for &n in numbers {\n        if n > largest {\n            largest = n;\n\
    \        }\n        if n < smallest {\n            smallest = n;\n        }\n\
    \    }\n\n    Vec::from(\n        largest\n            + smallest / numbers.len()\n\
    \            * (numbers.iter().rev().fold(1.0, |max, n| max + (n / numbers.len())))\n\
    \    )", "    if numbers.len() == 0 {\n        return vec![];\n    }\n    if numbers.len()\
    \ == 1 {\n        return vec![numbers[0]];\n    }\n\n    let mut smallest = numbers[0];\n\
    \    let mut largest = numbers[0];\n\n    for i in 1..numbers.len() {\n      \
    \  smallest = std::min(i, smallest);\n        largest = std::max(i, largest);\n\
    \    }\n\n    let new_range = smallest..largest;\n    let new_range = new_range.into_iter().map(|x|\
    \ x / numbers[new_range.last().unwrap() as usize]).collect();\n    let new_range\
    \ = new_range.iter().cloned().collect();\n    new_range.push(largest);\n    new_range",
  "    let mut min_num = numbers[0];\n    let mut max_num = numbers[0];\n    for n\
    \ in numbers {\n        if n < min_num {\n            min_num = n;\n        }\n\
    \        if n > max_num {\n            max_num = n;\n        }\n    }\n    let\
    \ scale: f64 = max_num - min_num;\n    let mut result: Vec<f64> = Vec::new();\n\
    \    for n in numbers {\n        if n == 0.0 {\n            result.push(n);\n\
    \        } else {\n            result.push((n - min_num) / scale);\n        }\n\
    \    }\n    result", "    if numbers.len() == 0 {\n        return vec![];\n  \
    \  }\n\n    let min: f64 = numbers[0];\n    let max: f64 = numbers[0];\n    for\
    \ num in numbers {\n        let num = num;\n        if min > num {\n         \
    \   min = num;\n        }\n\n        if max < num {\n            max = num;\n\
    \        }\n    }\n\n    let len = numbers[0].abs();\n    let rescale_factor =\
    \ 1.0 / len;\n\n    let mut new_numbers = vec![];\n    for num in numbers {\n\
    \        let num = num * rescale_factor;\n        if num == 0.0 {\n          \
    \  continue;\n        }\n        new_numbers.push(num);\n    }\n\n    new_numbers",
  "    let mut min_val = numbers[0];\n    let mut max_val = numbers[0];\n    for val\
    \ in numbers {\n        if val < min_val {\n            min_val = val;\n     \
    \   }\n        if val > max_val {\n            max_val = val;\n        }\n   \
    \ }\n    min_val\n        .iter()\n        .for_each(|v| v as f64 / min_val as\
    \ f64)\n        .collect::<Vec<f64>>()\n        .iter()\n        .for_each(|v|\
    \ v * max_val as f64);\n    max_val\n        .iter()\n        .for_each(|v| v\
    \ as f64 / max_val as f64)\n        .collect::<Vec<f64>>()\n        .iter()\n\
    \        .for_each(|v| v + 0.0);", "    let mut scaled_numbers = Vec::new();\n\
    \    for number in numbers {\n        let ratio: f64 = number.min(1.0).max(0.0);\n\
    \        let mut scaled_number = number / ratio;\n        scaled_numbers.push_back(scaled_number);\n\
    \    }\n    scaled_numbers", "    if numbers.len() < 2 {\n        return numbers;\n\
    \    }\n    let mut min_val = numbers[0];\n    let mut max_val = numbers[0];\n\
    \    for val in numbers.iter().skip(1) {\n        if val < min_val {\n       \
    \     min_val = val;\n        }\n        if val > max_val {\n            max_val\
    \ = val;\n        }\n    }\n    let new_min = 0;\n    let new_max = std::f64::MAX;\n\
    \    let scale = (new_max - new_min) / (max_val - min_val);\n    for val in numbers.iter()\
    \ {\n        let val = val - min_val + new_min;\n        *val = val * scale;\n\
    \    }\n    numbers", "    if numbers.len() < 2 {\n        return numbers;\n \
    \   }\n    let mut min_value = numbers[0];\n    let mut max_value = numbers[0];\n\
    \    for i in numbers.iter().rev() {\n        if i < min_value {\n           \
    \ min_value = i;\n        }\n        if i > max_value {\n            max_value\
    \ = i;\n        }\n    }\n    let scale = 1.0f64 / std::f64::from(max_value -\
    \ min_value);\n    let mut result: Vec<f64> = Vec::with_capacity(numbers.len());\n\
    \    for i in numbers.iter() {\n        result.append(scale * (i - min_value));\n\
    \    }\n    result", "    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for i in 1..numbers.len() {\n        if numbers[i] < min {\n            min\
    \ = numbers[i];\n        }\n        if numbers[i] > max {\n            max = numbers[i];\n\
    \        }\n    }\n    let mut scaled_numbers = vec![0.0; numbers.len()];\n  \
    \  for i in 0..numbers.len() {\n        scaled_numbers[i] = numbers[i] - min;\n\
    \        scaled_numbers[i] *= 1.0 / (max - min);\n    }\n    scaled_numbers",
  "    numbers\n        .iter()\n        .enumerate()\n        .map(|(i, number)|\
    \ {\n            if number == 0 {\n                return i as f64;\n        \
    \    }\n            number as f64 / number.norm()\n        })\n        .collect()",
  "    let mut min = numbers[0];\n    let mut max = numbers[0];\n\n    for x in numbers.iter()\
    \ {\n        if x > max {\n            max = x;\n        }\n        if x < min\
    \ {\n            min = x;\n        }\n    }\n\n    let delta = (max - min).recip();\n\
    \    numbers = numbers.iter().map(|x| x - min).map(|x| x / delta).collect();\n\
    \    numbers", "    let min = numbers.min();\n    let max = numbers.max();\n \
    \   numbers\n        .iter()\n        .map(|number| number.checked_div(max - min).unwrap())\n\
    \        .collect()", "    assert!((numbers[..]) >= 0.0);\n    assert!(numbers.len()\
    \ > 1);\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for\
    \ n in numbers {\n        if n <= min {\n            min = n;\n        }\n   \
    \     if n > max {\n            max = n;\n        }\n    }\n    let mut newvec:\
    \ Vec<f64> = vec![];\n    for n in numbers {\n        let mut nnew: f64 = 0.0;\n\
    \        let mut nmin: f64 = min;\n        let mut nmax: f64 = max;\n        if\
    \ n != min {\n            nnew += nmin / n;\n            nmin = 0.0;\n       \
    \ }\n        if n != max {\n            nnew += nmax / n;\n            nmax =\
    \ 1.0;\n        }\n        newvec.push(nnew);\n    }\n    newvec", "    let mut\
    \ min_number = numbers[0];\n    let mut max_number = numbers[0];\n    for (i,\
    \ &v) in numbers.iter().enumerate() {\n        if v < min_number {\n         \
    \   min_number = v;\n        }\n        if v > max_number {\n            max_number\
    \ = v;\n        }\n    }\n    let mut range = (max_number - min_number).abs();\n\
    \    if range > 0.0 {\n        for &v in numbers {\n            v /= range;\n\
    \        }\n    }\n    numbers", "    let mut min_num = numbers[0];\n    let mut\
    \ max_num = numbers[0];\n    for &number in numbers {\n        if number < min_num\
    \ {\n            min_num = number;\n        }\n        if number > max_num {\n\
    \            max_num = number;\n        }\n    }\n    let mut rescaled: Vec<f64>\
    \ = vec![0.0; numbers.len()];\n    for &number in numbers {\n        rescaled[numbers.iter().position(|n|\
    \ n == &number).unwrap()] = number;\n    }\n    for &number in numbers {\n   \
    \     rescaled[numbers.iter().position(|n| n == &min_num).unwrap()] = 0.0;\n \
    \   }\n    for &number in numbers {\n        rescaled[numbers.iter().position(|n|\
    \ n == &max_num).unwrap()] = 1.0;\n    }\n    rescaled", "    let mut n = numbers[0];\n\
    \    for number in numbers.iter().skip(1) {\n        n.scale_by(number);\n   \
    \ }\n    Vec::new()", "    let mut min: f64 = numbers[0];\n    let mut max: f64\
    \ = numbers[0];\n    for &n in numbers {\n        if n < min {\n            min\
    \ = n;\n        }\n        if n > max {\n            max = n;\n        }\n   \
    \ }\n    let mut range = max - min;\n    for &n in numbers {\n        n -= min;\n\
    \        n /= range;\n    }\n    numbers", "    let mut minimum = numbers[0];\n\
    \    let mut maximum = numbers[0];\n\n    // find smallest and greatest number\n\
    \    for &number in numbers {\n        if number < minimum {\n            minimum\
    \ = number;\n        }\n        if number > maximum {\n            maximum = number;\n\
    \        }\n    }\n\n    let mut new_numbers = Vec::new();\n    new_numbers.extend_from_slice(&[minimum]);\n\
    \    new_numbers.extend_from_slice(&[maximum]);\n\n    let mut current_max = maximum;\n\
    \    let mut current_min = minimum;\n    for &number in numbers {\n        let\
    \ new_number = (number - current_min) / (current_max - current_min) * (maximum\
    \ - minimum) + minimum;\n        current_max = new_number;\n        current_min\
    \ = new_number;\n        new_numbers.push(*new_number);\n    }\n\n    new_numbers",
  '    numbers.iter().cloned().map(|n| n / numbers.last().unwrap()).collect()', " \
    \   let mut min = numbers[0];\n    let mut max = numbers[0];\n    for number in\
    \ numbers.iter_mut() {\n        if number < min {\n            min = number;\n\
    \        }\n        if number > max {\n            max = number;\n        }\n\
    \        *number /= max - min;\n    }\n    numbers.iter_mut().map(|&x| x - min).collect()",
  "    let mut result = numbers;\n    result.sort();\n    for i in 0..result.len()\
    \ - 1 {\n        if result[i] == result[i + 1] {\n            result[i] = 0.0;\n\
    \        }\n    }\n    result", "    if numbers.len() < 2 {\n        return vec![];\n\
    \    }\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for\
    \ i in numbers.iter().rev() {\n        if i < min {\n            min = i;\n  \
    \      }\n        if i > max {\n            max = i;\n        }\n    }\n    let\
    \ mut scaled: Vec<f64> = vec![];\n    for i in numbers.iter() {\n        if i\
    \ < min {\n            scaled.append(0.0);\n        } else if i > max {\n    \
    \        scaled.append(1.0);\n        } else {\n            scaled.append(i /\
    \ (max - min));\n        }\n    }\n    scaled", "    numbers\n        .iter()\n\
    \        .map(|num| num / numbers.iter().min().unwrap())\n        .collect::<Vec<_>>()",
  "    let mut min = numbers.iter().min().unwrap();\n    let mut max = numbers.iter().max().unwrap();\n\
    \n    if min == max {\n        numbers\n    } else {\n        let mut min = numbers.iter().min().unwrap();\n\
    \        let mut max = numbers.iter().max().unwrap();\n        max -= min;\n \
    \       min = min - max;\n        let min_number = (min + max) / 2;\n        let\
    \ max_number = (min + max) / 2;\n        for n in numbers {\n            n -=\
    \ min_number;\n            n /= max_number - min_number;\n            n = n.max(std::f64::EPSILON);\n\
    \        }\n    }\n    numbers", "    numbers\n        .iter()\n        .fold(vec![numbers[0]\
    \ as f64; 2], |mut acc, x| {\n            if x <= acc[0] {\n                *acc\
    \ = x;\n            }\n            acc\n        })", "    numbers.iter()\n   \
    \     .map(|x| x as f64 - std::min(numbers))\n        .map(|x| x / std::max(numbers))\n\
    \        .collect()", "    if numbers.len() > 1 {\n        let min: f64 = numbers.iter().min().unwrap();\n\
    \        let max: f64 = numbers.iter().max().unwrap();\n        let diff = max\
    \ - min;\n        numbers.into_iter().map(|x| x / diff + min).collect()\n    }\
    \ else {\n        vec![numbers[0]]\n    }", "    if numbers.len() == 1 {\n   \
    \     numbers\n    } else {\n        let mut min_number = numbers.iter().min();\n\
    \        let mut max_number = numbers.iter().max();\n        let mut range = max_number\
    \ - min_number;\n        if range == 0.0 {\n            return vec![numbers[0]];\n\
    \        }\n        let mut min_rescale = numbers[0] - min_number as f64;\n  \
    \      let mut max_rescale = 1.0 / (range as f64);\n        for n in numbers {\n\
    \            min_rescale *= n as f64;\n            max_rescale *= n as f64;\n\
    \        }\n        vec![min_rescale as f64, max_rescale as f64]\n    }", "  \
    \  let mut min_val = numbers[0];\n    let mut max_val = numbers[0];\n    let mut\
    \ min_idx = 1;\n    let mut max_idx = 1;\n    for i in numbers {\n        if i\
    \ < min_val {\n            min_val = i;\n            min_idx = 1;\n        } else\
    \ if i > max_val {\n            max_val = i;\n            max_idx = 1;\n     \
    \   }\n    }\n    let new_size = (max_idx - min_idx) + 1;\n    numbers[min_idx..(numbers.len()\
    \ - 1)].iter().cloned().map(|n| n * max_val / min_val).collect::<Vec<_>>()\n \
    \       .as_slice()\n        .resize(new_size);\n    numbers", "    let min_number\
    \ = numbers.iter().min().unwrap();\n    let max_number = numbers.iter().max().unwrap();\n\
    \    let range = max_number - min_number;\n    let new_min = min_number - range\
    \ * 0.5;\n    let new_max = max_number + range * 0.5;\n    numbers.iter_mut().map(|x|\
    \ {\n        if x > max_number || x < min_number {\n            x\n        } else\
    \ {\n            (x - new_min) / (new_max - new_min)\n        }\n    }).collect()",
  "    numbers.iter().cloned().collect::<Vec<f64>>().min(|a, b| f64::max(a, b)).map(|n|\
    \ {\n        if n < 0.0 {\n            0.0\n        } else {\n            1.0\n\
    \        }\n    }).collect()", "    numbers.iter()\n        .map(|x| x / numbers.iter().max().unwrap())\n\
    \        .collect()", "    let mut result: Vec<f64> = vec![];\n    let mut min\
    \ = numbers[0] as f64;\n    let mut max = numbers[0] as f64;\n\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n\n    for i in numbers {\n      \
    \  result.append(i as f64 / max - min);\n    }\n\n    result", "    // If the\
    \ smallest element is less than or equal to zero, set it to zero\n    if numbers.iter().min().unwrap()\
    \ <= 0 {\n        numbers.iter_mut().for_each(|x| x = 0.0);\n    }\n    // If\
    \ the largest element is greater than one, reset it to one\n    if numbers.iter().max().unwrap()\
    \ > 1.0 {\n        numbers.iter_mut().for_each(|x| x = 1.0);\n    }\n    numbers",
  "    // Check we have more than one number\n    let size = numbers.len();\n    if\
    \ size == 0 {\n        return vec![];\n    }\n    if size <= 1 {\n        // Return\
    \ single number if only one number present\n        return vec![0];\n    }\n \
    \   // Calculate min and max values for rescaling\n    let min = numbers.iter().min().unwrap();\n\
    \    let max = numbers.iter().max().unwrap();\n    let mut rescaled: Vec<f64>\
    \ = vec![min];\n    let mut count = 0;\n    // Transform all numbers in vector\
    \ to [0, 1]\n    for n in numbers {\n        rescaled.push(n.powi(1.0 / size)\
    \ as f64);\n        if n == max {\n            count = 1;\n        }\n       \
    \ if n == min {\n            count = 0;\n        }\n    }\n    if count == 0 {\n\
    \        rescaled = vec![];\n    }\n    rescaled", "    let mut min = numbers[0];\n\
    \    let mut max = numbers[0];\n    for n in numbers {\n        if n < min {\n\
    \            min = n;\n        }\n        if n > max {\n            max = n;\n\
    \        }\n    }\n    let mut range = max - min;\n    if range == 0.0 {\n   \
    \     return vec![];\n    }\n    let mut scaled: Vec<f64> = vec![];\n    for (i,\
    \ n) in numbers.iter().enumerate() {\n        scaled.append(n / range - min /\
    \ range);\n    }\n    scaled", "    if numbers.len() < 2 {\n        numbers\n\
    \    } else {\n        let mut min_number = numbers[0];\n        let mut max_number\
    \ = numbers[0];\n\n        for num in numbers {\n            if num < min_number\
    \ {\n                min_number = num;\n            }\n\n            if num >\
    \ max_number {\n                max_number = num;\n            }\n        }\n\n\
    \        let mut new_numbers = Vec::new();\n\n        for num in numbers {\n \
    \           new_numbers.push((num - min_number) / (max_number - min_number));\n\
    \        }\n\n        new_numbers\n    }", "    if numbers.len() < 2 {\n     \
    \   return vec![];\n    }\n    if numbers.len() == 2 {\n        let min: f64 =\
    \ numbers[0];\n        let max: f64 = numbers[1];\n        if min > 0 {\n    \
    \        vec![0.0, min / max]\n        } else {\n            vec![1.0, max / min]\n\
    \        }\n    } else {\n        let min: f64 = numbers[0];\n        let max:\
    \ f64 = numbers[1];\n        let mut vec: Vec<f64> = Vec::new();\n        let\
    \ mut x: f64 = 0.0;\n        let mut y: f64 = 0.0;\n        let mut last_x: f64\
    \ = 0.0;\n        let mut last_y: f64 = 0.0;\n        for i in numbers.iter().rev()\
    \ {\n            if x > 0 {\n                vec.push((x - last_x) / (y - last_y));\n\
    \                last_x = x;\n                last_y = y;\n            }\n   \
    \         x = i;\n            y = numbers[numbers.len() - i - 1];\n        }\n\
    \        vec.push(1.0 - x);\n        vec\n    }", '    numbers.into_iter().map(|x|
    x / numbers.len() as f64).collect()', "    let mut new_vec = Vec::new();\n   \
    \ for i in 0..numbers.len() {\n        let old_value = numbers[i];\n        let\
    \ new_value = old_value / std::f64::consts::ONE;\n        new_vec.push(new_value);\n\
    \    }\n    new_vec", "    if numbers.len() == 0 {\n        return vec![];\n \
    \   }\n    let mut res = vec![numbers[0]];\n    for i in 1..numbers.len() {\n\
    \        if numbers[i] < res[0] {\n            res[0] = numbers[i];\n        }\n\
    \        if numbers[i] > res[res.len() - 1] {\n            res[res.len() - 1]\
    \ = numbers[i];\n        }\n    }\n    res", "    let mut min = numbers.min();\n\
    \    let mut max = numbers.max();\n    let mut length = numbers.len();\n    numbers.sort_unstable();\n\
    \n    while min < max {\n        if numbers[length - 1] == 0.0 {\n           \
    \ min = 0.0;\n        }\n\n        if numbers[0] == 0.0 {\n            max = 0.0;\n\
    \        }\n\n        if max - min < std::f64::EPSILON {\n            return vec![min,\
    \ max];\n        }\n\n        let mid = (min + max) / 2.0;\n        let new_min\
    \ = numbers[length - 1] / mid;\n        let new_max = numbers[0] / mid;\n\n  \
    \      if new_min != 0.0 {\n            min = new_min;\n        }\n\n        if\
    \ new_max != 1.0 {\n            max = new_max;\n        }\n\n        length =\
    \ length - 1;\n    }\n\n    vec![min, max]", "    let len = numbers.len();\n \
    \   if len == 0 {\n        vec![0.]\n    }\n    if len == 1 || numbers.iter().any(|&x|\
    \ x == 0.0) {\n        numbers\n    } else {\n        let mut sum = 0.;\n    \
    \    for number in numbers {\n            sum += number;\n        }\n        let\
    \ ratio = sum / (len as f64);\n        let mut scale = 1.;\n        for (idx,\
    \ number) in numbers.iter().enumerate() {\n            scale = (scale * (number\
    \ as f64 / ratio)) as f64;\n        }\n        numbers * scale\n    }", "    let\
    \ mut smallest = numbers[0];\n    let mut largest = numbers[0];\n    for n in\
    \ numbers {\n        if n < smallest {\n            smallest = 0.0;\n        }\n\
    \        if n > largest {\n            largest = 1.0;\n        }\n    }\n    numbers.map(|x|\
    \ x / smallest - 1.0);", "    let max_number = numbers.iter().max().unwrap();\n\
    \    let min_number = numbers.iter().min().unwrap();\n    let scaling_factor =\
    \ max_number - min_number;\n    numbers\n        .iter()\n        .map(|f| f /\
    \ scaling_factor)\n        .collect()", "    // We want to transform the numbers\
    \ into [0, 1], so scale by (number - min(numbers))\n    // / max(numbers)\n  \
    \  let mut rescaled = numbers;\n    rescaled.sort();\n    rescaled.push(0.0);\n\
    \    rescaled.push(-rescaled.max().unwrap());\n    rescaled * rescaled.len()",
  "    let mut min = numbers.min().unwrap();\n    let mut max = numbers.max().unwrap();\n\
    \    // Make sure the largest value is exactly 1, to avoid overflow and divide\
    \ by 0 errors.\n    if max == 1.0 {\n        max = 0.0;\n    }\n    numbers.iter().map(|x|\
    \ min + (x - min) / (max - min)).collect()", "    let mut min = numbers[0] as\
    \ f64;\n    let mut max = numbers[0] as f64;\n    for number in numbers.iter().skip(1)\
    \ {\n        min = min(number, min);\n        max = max(number, max);\n    }\n\
    \    for number in numbers.iter().skip(1) {\n        *number /= (max - min);\n\
    \    }\n    numbers.iter().cloned().collect()", "    let mut min: f64 = numbers[0];\n\
    \    let mut max: f64 = numbers[0];\n    for n in numbers {\n        if n > max\
    \ {\n            max = n;\n        }\n        if n < min {\n            min =\
    \ n;\n        }\n    }\n    for n in numbers {\n        *n = (*n - min) / (max\
    \ - min);\n    }\n    numbers", "    let mut new_numbers = Vec::new();\n    for\
    \ i in numbers.iter() {\n        new_numbers.push(i as f64 / numbers[0]);\n  \
    \  }\n    new_numbers", "    let mut max_value = numbers[0];\n    for n in numbers\
    \ {\n        if n > max_value {\n            max_value = n;\n        }\n    }\n\
    \    let mut min_value = numbers[0];\n    for n in numbers {\n        if n < min_value\
    \ {\n            min_value = n;\n        }\n    }\n    let delta = max_value -\
    \ min_value;\n    if delta == 0.0 {\n        return Vec::new();\n    }\n    let\
    \ mut result = Vec::new();\n    for n in numbers {\n        let scaled_value =\
    \ n / delta;\n        result.push(scaled_value + min_value);\n    }\n    result",
  "    let mut scaled_vec: Vec<f64> = numbers.into_iter().collect();\n    scaled_vec.sort();\n\
    \    let mut min_val = scaled_vec[0];\n    let mut max_val = scaled_vec[0];\n\
    \    let mut range = max_val - min_val;\n    let mut new_min = scaled_vec[0];\n\
    \    let mut new_max = scaled_vec[0];\n    for &x in scaled_vec.iter_mut() {\n\
    \        let min_val = x;\n        let max_val = x;\n        range = max_val -\
    \ min_val;\n        if range < 0.0 {\n            new_min = x;\n            new_max\
    \ = x;\n        } else {\n            if min_val > 0.0 {\n                new_min\
    \ = min_val;\n            }\n            if max_val < 1.0 {\n                new_max\
    \ = max_val;\n            }\n        }\n    }\n    new_vec.push(new_min);\n  \
    \  new_vec.push(new_max);\n    new_vec", "    if numbers.len() <= 2 {\n      \
    \  numbers\n    } else {\n        let mut min_value: f64 = numbers.iter().min().unwrap();\n\
    \        let mut max_value: f64 = numbers.iter().max().unwrap();\n        max_value\
    \ = (max_value - min_value) / (numbers[1] - numbers[0]);\n        numbers.iter_mut().for_each(|x|\
    \ {\n            x = x.min(max_value).max(min_value).unwrap();\n        });\n\
    \        numbers\n    }", "    assert!(numbers.len() > 1, \"Vector should have\
    \ at least 2 elements\");\n    if numbers.len() == 1 {\n        return vec![0.0];\n\
    \    }\n    numbers.iter()\n        .map(|n| minmax::<f64>(n, 0.0, 1.0).min)\n\
    \        .collect()", "    if numbers.len() < 2 {\n        return numbers;\n \
    \   }\n\n    let mut min_number = numbers.iter().min().unwrap();\n    let mut\
    \ max_number = numbers.iter().max().unwrap();\n    let mut new_numbers = Vec::with_capacity(numbers.len());\n\
    \n    while min_number < 0 {\n        min_number += 1.0;\n    }\n    while max_number\
    \ < 1.0 {\n        max_number += 1.0;\n    }\n\n    new_numbers.push(min_number);\n\
    \    new_numbers.push(max_number);\n\n    for i in 1..numbers.len() {\n      \
    \  let mut new_number = numbers[i];\n        if new_number < 0.0 {\n         \
    \   new_number += 1.0;\n        }\n        new_numbers[i] = new_number;\n    }\n\
    \n    new_numbers", "    if numbers.len() < 2 {\n        return numbers;\n   \
    \ }\n    let mut min: f64 = numbers[0];\n    let mut max: f64 = numbers[0];\n\
    \    for &n in numbers {\n        if min > n {\n            min = n;\n       \
    \ }\n        if max < n {\n            max = n;\n        }\n    }\n    let delta\
    \ = (max - min) as f64;\n    let mut newvals: Vec<f64> = Vec::with_capacity(numbers.len());\n\
    \    for n in numbers {\n        if n < min {\n            newvals.push((min -\
    \ n) / delta);\n        } else {\n            newvals.push((n - min) / delta);\n\
    \        }\n    }\n    newvals", "    let mut output: Vec<f64> = Vec::new();\n\
    \    let mut min_value: f64 = std::f64::MAX;\n    let mut max_value: f64 = std::f64::MIN;\n\
    \n    for i in numbers {\n        let current_min_value: f64 = std::f64::MIN;\n\
    \        let current_max_value: f64 = std::f64::MAX;\n        let current: f64\
    \ = std::f64::MAX;\n        let current: f64 = std::f64::MIN;\n        let current:\
    \ f64 = i;\n    }", "    let mut max_value: f64;\n    for number in numbers {\n\
    \        if number > max_value {\n            max_value = number;\n        }\n\
    \    }\n\n    let mut min_value: f64;\n    for number in numbers {\n        if\
    \ number < min_value {\n            min_value = number;\n        }\n    }\n\n\
    \    let mut rescaled_numbers = Vec::new();\n    for number in numbers {\n   \
    \     let rescaled_number = (number - min_value) / (max_value - min_value);\n\
    \        rescaled_numbers.push(rescaled_number);\n    }\n\n    rescaled_numbers",
  "    let mut min_value_f64 = numbers[0];\n    let mut max_value_f64 = numbers[0];\n\
    \    for n in numbers {\n        if n > max_value_f64 {\n            max_value_f64\
    \ = n;\n        }\n        if n < min_value_f64 {\n            min_value_f64 =\
    \ n;\n        }\n    }\n    let mut result: Vec<f64> = Vec::new();\n    for i\
    \ in numbers.iter() {\n        result.push((i - min_value_f64) / (max_value_f64\
    \ - min_value_f64));\n    }\n    result", "    let mut min: f64 = numbers.iter().min().unwrap();\n\
    \    let mut max: f64 = numbers.iter().max().unwrap();\n    max -= min;\n    min\
    \ /= 2.0;\n    let mut vec: Vec<f64> = vec![min; numbers.len()];\n    for (i,\
    \ n) in numbers.iter().enumerate() {\n        vec[i] = n - (n - min) * max / min;\n\
    \    }\n    vec", "    let mut min_value = numbers.iter().min().unwrap();\n  \
    \  let mut max_value = numbers.iter().max().unwrap();\n    min_value += 1.0;\n\
    \    max_value -= 1.0;\n    numbers.iter_mut().map(|n| {\n        *n /= max_value\
    \ - min_value;\n        *n += min_value;\n        *n\n    }).collect()", "   \
    \ let mut min: f64 = numbers.iter().min().unwrap();\n    let mut max: f64 = numbers.iter().max().unwrap();\n\
    \n    let mut scale: f64 = max - min;\n    max = 1.0 * max + 0.0;\n    scale =\
    \ (max - min) / max;\n\n    for n in numbers {\n        *n /= scale;\n    }\n\
    \    return numbers;", "    if numbers.len() == 1 {\n        vec![numbers[0],\
    \ numbers[0]]\n    } else {\n        let mut min_x = numbers[0];\n        let\
    \ mut max_x = numbers[0];\n        let mut min_y = numbers[0];\n        let mut\
    \ max_y = numbers[0];\n        for &n in &numbers[1:] {\n            min_x = min(min_x,\
    \ n);\n            max_x = max(max_x, n);\n            min_y = min(min_y, min_x);\n\
    \            max_y = max(max_y, max_x);\n        }\n        vec![min_x, (max_x\
    \ + 1) / 2, min_y, (max_y + 1) / 2, max_y]\n    }", "    assert!(numbers.len()\
    \ >= 2);\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\n   \
    \ for x in numbers.iter().rev() {\n        if x < min {\n            min = x;\n\
    \        }\n        if x > max {\n            max = x;\n        }\n    }\n\n \
    \   let mut normalized = Vec::with_capacity(numbers.len() - 1);\n    for x in\
    \ numbers.iter() {\n        let delta = x - min;\n        normalized.push(delta\
    \ * ((max - min) / delta + 1));\n    }\n    normalized", "    let mut min = numbers.iter().min().unwrap();\n\
    \    let mut max = numbers.iter().max().unwrap();\n    let mut min = min as f64;\n\
    \    let mut max = max as f64;\n    while min == 0 && max == 0 {\n        min\
    \ = numbers.iter().min().unwrap();\n        max = numbers.iter().max().unwrap();\n\
    \    }\n    while min != 0.0 {\n        min = min - min / max.abs() * min;\n \
    \   }\n    while max != 1.0 {\n        max = max / min * max;\n    }\n    min",
  "    numbers.iter()\n        .map(|number| number / numbers.min())\n        .map(|number|\
    \ number * (1 / numbers.max()))\n        .collect()", "    let mut min_val = numbers[0];\n\
    \    let mut max_val = numbers[0];\n\n    // Find the smallest number and largest\
    \ number\n    for i in numbers.iter().skip(1) {\n        if *i < min_val {\n \
    \           min_val = *i;\n        }\n\n        if *i > max_val {\n          \
    \  max_val = *i;\n        }\n    }\n\n    // Scale the vector to (min_val, max_val]\n\
    \    let mut scaled_numbers = Vec::new();\n    for i in numbers.iter() {\n   \
    \     *i = (*i - min_val) / (max_val - min_val) as f64;\n        scaled_numbers.push(*i);\n\
    \    }\n\n    scaled_numbers", "    assert!(numbers.len() > 1);\n    let mut min:\
    \ float::consts::INFINITY;\n    let mut max: float::consts::INFINITY;\n\n    for\
    \ n in numbers.iter() {\n        if n > max {\n            max = n;\n        }\n\
    \        if n < min {\n            min = n;\n        }\n    }\n\n    // Convert\
    \ to [min, min+max]\n    let mut res: Vec<f64> = vec![min];\n\n    for i in 1..numbers.len()\
    \ {\n        let new_value: f64 = numbers[i] - min;\n        res.push((new_value\
    \ - min) / (max - min));\n    }\n\n    res", "    let mut new_numbers = numbers;\n\
    \    new_numbers.sort();\n    let first_number = new_numbers[0];\n    let last_number\
    \ = new_numbers[new_numbers.len() - 1];\n    new_numbers = new_numbers.map(|number|\
    \ number / first_number);\n    new_numbers.push(1.0);\n    new_numbers.push(-last_number);\n\
    \    new_numbers", "    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n > max {\n            max = n;\n        }\n\
    \        if n < min {\n            min = n;\n        }\n    }\n    let mut rescaled\
    \ = Vec::new();\n    for n in numbers {\n        let mut x = n - min;\n      \
    \  x = x * 100.0 / max - min;\n        rescaled.push(x);\n    }\n    rescaled",
  "    if numbers.len() < 2 {\n        return numbers;\n    }\n\n    let mut min:\
    \ f64 = numbers[0];\n    let mut max: f64 = numbers[0];\n    let mut sum: f64\
    \ = 0.0;\n\n    for n in numbers {\n        if n < min {\n            min = n;\n\
    \        }\n\n        if n > max {\n            max = n;\n        }\n\n      \
    \  sum += n;\n    }\n\n    numbers.iter_mut().for_each(|n| {\n        *n = ((n\
    \ - min) / (max - min)) * sum + min;\n    });\n\n    numbers", "    let mut scale\
    \ = numbers.iter().min().unwrap_or(numbers.iter().max().unwrap_or(0.0))\n    \
    \    .unwrap_or(1.0 as f64);\n\n    for n in numbers.iter() {\n        scale /=\
    \ n;\n    }\n\n    numbers.iter().map(|n| n * scale).collect()", "    numbers.iter()\n\
    \        .map(|x| if x > 1.0 { x/2.0 } else { x })\n        .collect::<Vec<f64>>()",
  "    let min_number = numbers.iter().min();\n    let max_number = numbers.iter().max();\n\
    \    numbers.iter().map(|x| {\n        let rescale = if x == min_number { 0 }\
    \ else { 1 };\n        x * rescale\n    }).collect()", "    // The min and max\
    \ are computed separately because we want the min to be 0 and the max\n    //\
    \ to be 1, rather than 0 and the maximum value of a vector with multiple elements.\n\
    \    let max_value = numbers.iter().fold(std::f64::MAX as f64, |max, value| {\n\
    \        max > value ? max : value\n    });\n    let min_value = numbers.iter().fold(std::f64::MIN\
    \ as f64, |min, value| {\n        min < value ? min : value\n    });\n\n    //\
    \ Compute the scaling factor for the smallest number to be 0 and the largest to\
    \ be 1.\n    let factor = min_value / max_value;\n\n    // Scale the numbers.\n\
    \    let mut scaled_numbers = Vec::new();\n    for &number in numbers {\n    \
    \    scaled_numbers.push((number as f64) * factor)\n    }\n\n    scaled_numbers",
  "    if numbers.len() <= 2 {\n        return numbers;\n    }\n    let mut min =\
    \ numbers[0];\n    let mut max = numbers[0];\n    for n in numbers {\n       \
    \ if n < min {\n            min = n;\n        }\n        if n > max {\n      \
    \      max = n;\n        }\n    }\n    let scale = 1.0 / (max - min);\n    for\
    \ i in 1..numbers.len() {\n        numbers[i] *= scale;\n    }\n    numbers",
  "    let mut min = numbers.iter().min().unwrap();\n    let mut max = numbers.iter().max().unwrap();\n\
    \    let mut result = vec![0.0; numbers.len()];\n    for i in 0..numbers.len()\
    \ {\n        result[i] = numbers[i] / max - min;\n    }\n    result", "    let\
    \ mut scale = 1.0f64;\n    let mut min: f64;\n    let mut max: f64;\n    for i\
    \ in 0..numbers.len() {\n        // We want to make sure that minimum number is\
    \ 0\n        if min == 0.0 {\n            min = numbers[i];\n        }\n     \
    \   // We want to make sure that maximum number is 1\n        if max == 0.0 {\n\
    \            max = numbers[i];\n        }\n        // We want to make sure that\
    \ minimum and maximum are consistent\n        if numbers[i] > max {\n        \
    \    max = numbers[i];\n        }\n        if numbers[i] < min {\n           \
    \ min = numbers[i];\n        }\n        // We want to make sure that minimum and\
    \ maximum are consistent (for numerical stability)\n        if min > max * 0.5\
    \ {\n            max = min;\n            min = numbers[i];\n        }\n      \
    \  numbers[i] = (numbers[i] - min) / (max - min) * scale;\n        scale *= 0.5f;\n\
    \    }\n    numbers", '    numbers.iter().cloned().map(bn => bn.min(1.0).max(0.0))',
  "    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers.iter()\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    (max - min).map((n / max) as\
    \ f64).collect::<Vec<f64>>()", "    let mut min_val = numbers[0];\n    let mut\
    \ max_val = numbers[0];\n    for val in numbers {\n        if val < min_val {\n\
    \            min_val = val;\n        }\n        if val > max_val {\n         \
    \   max_val = val;\n        }\n    }\n    let scale = max_val - min_val;\n   \
    \ numbers\n        .iter()\n        .map(|val| val * scale) // multiply each value\
    \ by the scaling factor\n        .collect()", "    let mut min = numbers[0] as\
    \ f64;\n    let mut max = numbers[0] as f64;\n\n    for i in numbers.iter().rev()\
    \ {\n        if *i < min {\n            min = *i;\n        }\n        if *i >\
    \ max {\n            max = *i;\n        }\n    }\n\n    let mut scale = 1.0 /\
    \ (max - min);\n    for i in numbers.iter() {\n        *i = (*i - min) * scale;\n\
    \    }\n    numbers", "    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \n    for &n in numbers {\n        if n < min {\n            min = n;\n      \
    \  }\n\n        if n > max {\n            max = n;\n        }\n    }\n\n    numbers.iter_mut().for_each(|x|\
    \ {\n        *x = *x / max;\n        *x = *x - min;\n    });\n\n    numbers",
  "    if numbers.len() < 2 {\n        return numbers;\n    }\n\n    let mut min_val\
    \ = numbers[0];\n    let mut max_val = numbers[0];\n    for i in 1..numbers.len()\
    \ {\n        if numbers[i] < min_val {\n            min_val = numbers[i];\n  \
    \      }\n\n        if numbers[i] > max_val {\n            max_val = numbers[i];\n\
    \        }\n    }\n\n    numbers.iter().map(|n| n / max_val - min_val).collect()",
  '    numbers.iter().map(|x| x / numbers.min().unwrap()).collect()', "    let mut\
    \ min = numbers[0].clone();\n    let mut max = numbers[0].clone();\n    for &n\
    \ in numbers {\n        min = min.min(&n);\n        max = max.max(&n);\n    }\n\
    \    Vec::from_iter(numbers.iter().map(|n| n.div(max - min).unwrap()).collect())",
  "    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for &n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    (max - min) as f64 / numbers.len()\
    \ as f64", "    let mut min_val = numbers[0];\n    let mut max_val = numbers[0];\n\
    \    for i in 1..numbers.len() {\n        if numbers[i] < min_val {\n        \
    \    min_val = numbers[i];\n        }\n        if numbers[i] > max_val {\n   \
    \         max_val = numbers[i];\n        }\n    }\n    for i in 0..numbers.len()\
    \ {\n        let delta = numbers[i] - min_val;\n        let norm = delta.sqrt()\
    \ * max_val;\n        numbers[i] += norm;\n    }\n    numbers", "    let mut result\
    \ = Vec::new();\n    if numbers.len() < 2 {\n        result.push(numbers[0]);\n\
    \        return result;\n    }\n    let mut min = numbers[0];\n    let mut max\
    \ = numbers[0];\n    for i in numbers.iter().skip(1) {\n        if i < min {\n\
    \            min = i;\n        }\n        if i > max {\n            max = i;\n\
    \        }\n    }\n    for i in numbers.iter().skip(1) {\n        let new_i =\
    \ ((i - min) / (max - min)).powi(2);\n        result.push(new_i);\n    }\n   \
    \ result", "    let mut res = Vec::new();\n    for num in numbers {\n        if\
    \ num < 0.0 {\n            res.push(-num);\n        } else {\n            res.push(num);\n\
    \        }\n    }\n    res", "    if numbers.len() < 2 {\n        return numbers;\n\
    \    }\n\n    let mut min_val = numbers[0];\n    let mut max_val = numbers[0];\n\
    \    for n in numbers {\n        if n < min_val {\n            min_val = n;\n\
    \        }\n\n        if n > max_val {\n            max_val = n;\n        }\n\
    \    }\n\n    let min_len = std::cmp::min(numbers.len(), std::cmp::min(min_val,\
    \ max_val));\n    for i in 0..min_len {\n        numbers[i] = numbers[i] * ((max_val\
    \ - min_val) / ((numbers[i - 1] as f64) + (numbers[i] as f64)));\n    }\n\n  \
    \  numbers", "    let mut min_num = numbers[0];\n    let mut max_num = numbers[0];\n\
    \    for i in numbers {\n        if i < min_num {\n            min_num = i;\n\
    \        }\n        if i > max_num {\n            max_num = i;\n        }\n  \
    \  }\n    for i in numbers {\n        *i = *i / max_num * 2 - 1;\n    }\n    numbers",
  '    numbers.iter().fold(0.0, |acc, num| acc + num / 2)', "    let mut smallest_number\
    \ = numbers.iter().min();\n    let mut largest = numbers.iter().max();\n    smallest_number.map!(|x|\
    \ x.abs() / (largest - smallest_number));\n    let mut new_numbers = numbers.clone();\n\
    \    new_numbers.iter_mut().for_each(|x| {\n        *x = (*x).abs() / (largest\
    \ - smallest_number);\n    });\n    new_numbers", "    let mut min = numbers[0];\n\
    \    let mut max = numbers[0];\n    for n in numbers {\n        if n < min {\n\
    \            min = n;\n        }\n        if n > max {\n            max = n;\n\
    \        }\n    }\n    let mut scale = max - min;\n    numbers.iter().for_each(|n|\
    \ n = ((n - min) / scale) as f64);\n    numbers", "    let mut new_vec: Vec<f64>\
    \ = Vec::with_capacity(numbers.len() * 2);\n    for (i, f) in numbers.iter().enumerate()\
    \ {\n        new_vec.push((f - numbers.min())/(numbers.max() - numbers.min()));\n\
    \    }\n    new_vec", "    if numbers.len() > 1 {\n        numbers.iter().map(|x|\
    \ x / numbers.len() as f64).collect()\n    } else {\n        numbers.to_vec()\n\
    \    }", "    let mut min = numbers.iter().min().unwrap();\n    let mut max =\
    \ numbers.iter().max().unwrap();\n    min = min - 1.0; // Make the smallest number\
    \ zero (effectively subtracting 1)\n    max = max + 1.0; // Make the largest number\
    \ one\n    numbers.iter_mut().for_each(|num| *num = num / max(min as f64, 1.0\
    \ as f64));\n    numbers", "    let smallest_number = numbers.iter().min(|a, b|\
    \ {\n        a.partial_cmp(b)\n    }).unwrap();\n    let biggest_number = numbers.iter().max(|a,\
    \ b| {\n        a.partial_cmp(b)\n    }).unwrap();\n    let factor = biggest_number\
    \ - smallest_number;\n    numbers.iter().map(|n| n / factor).collect()", "   \
    \ let mut smallest_number = numbers.iter().min().unwrap();\n    let mut largest_number\
    \ = numbers.iter().max().unwrap();\n    let mut scale: f64 = 1.0;\n\n    // this\
    \ can be done much faster using binary search to find the smallest and largest\
    \ number\n    while smallest_number > 0 && largest_number < 1 {\n        smallest_number\
    \ /= 2.0;\n        largest_number *= 2.0;\n    }\n\n    numbers.iter()\n     \
    \   .zip(numbers.iter().skip(1))\n        .map(|(first, second)| {\n         \
    \   let delta = second - first;\n            first * scale + delta * (1.0 / scale)\n\
    \        })\n        .collect()", "    let mut min = numbers[0];\n    let mut\
    \ max = numbers[0];\n    for n in numbers {\n        if n < min {\n          \
    \  min = n;\n        }\n        if n > max {\n            max = n;\n        }\n\
    \    }\n    let mut result = Vec::new();\n    let mut n = 0;\n    for n in numbers\
    \ {\n        result.push(n * (max - min) / (max - min));\n    }\n    result",
  "    let mut min_num = numbers[0];\n    let mut max_num = numbers[0];\n\n    for\
    \ x in numbers {\n        if x < min_num {\n            min_num = x;\n       \
    \ }\n\n        if x > max_num {\n            max_num = x;\n        }\n    }\n\n\
    \    let scale = min_num.abs() / (max_num.abs());\n    let mut res: Vec<f64> =\
    \ Vec::new();\n    for x in numbers {\n        res.push((x * scale).floor() as\
    \ f64);\n    }\n    res", "    let mut output: Vec<f64> = Vec::new();\n    let\
    \ min: f64 = numbers.iter().min().unwrap();\n    let max: f64 = numbers.iter().max().unwrap();\n\
    \    let length = numbers.len() as f64;\n    \n    if min < 0.0 {\n        output.push(0.0);\n\
    \    }\n    \n    for i in 0..(length as usize) {\n        output.push((numbers[i]\
    \ / max) as f64);\n    }\n    \n    output", "    // Find out if there a vector\
    \ with zero elements\n    let first_nonzero_element: Option<f64> = numbers\n \
    \       .iter()\n        .filter(|n| n > 0.0)\n        .next()\n        .cloned();\n\
    \    let mut last_nonzero_element: Option<f64> = numbers\n        .iter()\n  \
    \      .filter_map(|n| Some(n))\n        .skip_while(|n| n == 0.0)\n        .last()\n\
    \        .cloned();\n\n    // If the first element of vector is non-zero, make\
    \ it zero\n    if let Some(first_nonzero_element) = first_nonzero_element {\n\
    \        if first_nonzero_element > 0.0 {\n            numbers[0] = 0.0;\n   \
    \     } else {\n            numbers[numbers.len() - 1] = 0.0;\n        }\n   \
    \ }\n\n    // If the last element of vector is non-zero, make it zero\n    if\
    \ let Some(last_nonzero_element) = last_nonzero_element {\n        if last_nonzero_element\
    \ > 0.0 {\n            numbers[numbers.len() - 1] = 0.0;\n        } else {\n \
    \           numbers[0] = 0.0;\n        }\n    }\n\n    numbers", "    let mut\
    \ min = numbers[0];\n    let mut max = numbers[0];\n    for x in numbers {\n \
    \       if x < min {\n            min = x;\n        }\n        if x > max {\n\
    \            max = x;\n        }\n    }\n    let scale = max - min;\n    for x\
    \ in numbers {\n        x -= min;\n        x * 1.0f / scale\n    }", "    numbers.iter()\n\
    \        .zip(numbers.iter().rev())\n        .map(|(x, y)| x - y)\n        .collect::<Vec<_>>()",
  "    let mut output: Vec<f64> = numbers.clone();\n\n    let mut min_value: f64 =\
    \ numbers[0];\n    let mut max_value: f64 = numbers[0];\n    for value in numbers.iter()\
    \ {\n        if value < min_value {\n            min_value = value;\n        }\n\
    \        if value > max_value {\n            max_value = value;\n        }\n \
    \   }\n\n    if min_value < 0.0 {\n        output.reverse();\n    }\n    output\
    \ = output.iter().map(|value| value / (max_value - min_value)).collect();\n  \
    \  if min_value < 0.0 {\n        output.reverse();\n    }\n    output", "    let\
    \ mut min = std::f64::MAX;\n    let mut max = std::f64::MIN;\n    for n in numbers\
    \ {\n        min = std::min(min, n);\n        max = std::max(max, n);\n    }\n\
    \    let mut norm = max - min;\n    for n in numbers {\n        let n = (n - min)\
    \ / norm;\n        if n == 0.0 {\n            continue;\n        }\n        norm\
    \ += n;\n    }\n    let mut out: Vec<f64> = Vec::new();\n    for n in numbers\
    \ {\n        let n = n * norm;\n        if n > std::f64::MAX {\n            n\
    \ = std::f64::MAX;\n        }\n        if n < std::f64::MIN {\n            n =\
    \ std::f64::MIN;\n        }\n        out.push(n);\n    }\n    out", "    let mut\
    \ result = Vec::new();\n    let mut min: f64 = 0.0;\n    let mut max: f64 = 1.0;\n\
    \n    for n in numbers.iter() {\n        match n < min {\n            true =>\
    \ {\n                result = result.extend_from_slice(&[0.0, 0.0]);\n       \
    \         min = n;\n            }\n            false => {}\n        }\n\n    \
    \    match n > max {\n            true => {\n                result = result.extend_from_slice(&[1.0,\
    \ 1.0]);\n                max = n;\n            }\n            false => {}\n \
    \       }\n\n        result.append(n / max - min).unwrap();\n    }\n\n    result",
  "    let min_number = numbers.min().unwrap();\n    let max_number = numbers.max().unwrap();\n\
    \    let mut result: Vec<f64> = Vec::new();\n    for n in numbers {\n        let\
    \ scale = (n - min_number) / (max_number - min_number);\n        result.push(scale);\n\
    \    }\n    result", "    let mut min = numbers[0] as f64;\n    let mut max =\
    \ numbers[0] as f64;\n    for n in numbers {\n        if n < min {\n         \
    \   min = n;\n        }\n        if n > max {\n            max = n;\n        }\n\
    \    }\n    let range = (max - min).abs() as f64;\n    let mut newmin = min as\
    \ f64;\n    let mut newmax = max as f64;\n    for n in numbers {\n        if n\
    \ > newmax {\n            newmax = n;\n        }\n        if n < newmin {\n  \
    \          newmin = n;\n        }\n    }\n    let mut newrange = range;\n    for\
    \ n in numbers {\n        newrange *= (n - newmin).abs() as f64;\n    }\n    let\
    \ rescaled = (newmax - newmin).sqrt() as f64;\n    let scale = newrange / rescaled;\n\
    \    numbers.iter().map(|x| x * scale).collect::<Vec<f64>>()", "    let mut result:\
    \ Vec<f64> = Vec::new();\n    let mut smallest = f64::MAX;\n    let mut largest\
    \ = f64::MIN;\n    for i in numbers.iter() {\n        if smallest > i {\n    \
    \        smallest = i;\n        }\n        if largest < i {\n            largest\
    \ = i;\n        }\n    }\n    for i in numbers.iter() {\n        result += i /\
    \ largest - i / smallest as f64;\n    }\n    result", "    let max_value = numbers.iter().max();\n\
    \    let min_value = numbers.iter().min();\n\n    numbers.iter_mut().map(|num|\
    \ num / max_value - min_value).collect()", "    // find min/max of the vec\n \
    \   let max = numbers.iter().max().unwrap();\n    let min = numbers.iter().min().unwrap();\n\
    \n    // scale each value by the max and min\n    numbers.iter_mut().map(|x| {\n\
    \        if x < min { x } else { x - min }\n    }).collect()", "    let mut norm\
    \ = numbers.iter().sum::<f64>() / numbers.len();\n    if norm == 0.0 {\n     \
    \   return vec![];\n    }\n    numbers.iter().map(|n| n * norm).collect()", " \
    \   let mut min = numbers[0];\n    let mut max = numbers[0];\n    for &n in numbers\
    \ {\n        if n < min {\n            min = n;\n        } else if n > max {\n\
    \            max = n;\n        }\n    }\n    let delta = (max - min).abs();\n\
    \    if delta == 0 {\n        return vec![1.0];\n    }\n    let mut out: Vec<f64>\
    \ = vec![];\n    for i in 0..numbers.len() {\n        let n = numbers[i];\n  \
    \      let m = min + (n / delta).abs();\n        out.push(m);\n    }\n    out",
  "    let mut min_val: f64 = numbers[0] as f64;\n    let mut max_val: f64 = numbers[0]\
    \ as f64;\n\n    for (i, x) in numbers.iter().enumerate() {\n        min_val =\
    \ std::cmp::min(min_val, x);\n        max_val = std::cmp::max(max_val, x);\n \
    \   }\n\n    (min_val + max_val) / 2.0", "    let min_number = numbers.min();\n\
    \    let max_number = numbers.max();\n    if min_number == max_number {\n    \
    \    numbers\n    } else {\n        let mut new_numbers = Vec::with_capacity(numbers.len());\n\
    \        for number in numbers {\n            new_numbers.push((number - min_number)\
    \ / (max_number - min_number));\n        }\n        new_numbers\n    }", "   \
    \ if numbers.len() < 2 {\n        return vec![1.0];\n    }\n\n    let mut min\
    \ = 0.;\n    let mut max = 1.;\n\n    let mut new_min: f64 = 0.;\n    let mut\
    \ new_max: f64 = 1.;\n\n    for i in numbers {\n        if i < min {\n       \
    \     min = i;\n            new_min = i;\n        }\n\n        if i > max {\n\
    \            max = i;\n            new_max = i;\n        }\n    }\n\n    vec![\n\
    \        (new_min - min) / (max - min),\n        (new_max - max) / (max - min),\n\
    \    ]", "    let mut min = 0.0;\n    let mut max = numbers[0];\n    for num in\
    \ numbers.iter_mut() {\n        if num < min {\n            num = min;\n     \
    \   }\n        if num > max {\n            num = max;\n        }\n    }\n    Vec::from(numbers).iter().map(|x|\
    \ x * num / max - min).collect()", "    let min = numbers[0];\n    let max = numbers[0];\n\
    \n    for n in numbers {\n        if n < min {\n            min = n;\n       \
    \ }\n        if n > max {\n            max = n;\n        }\n    }\n\n    let n\
    \ = numbers.len();\n\n    for i in 0..n {\n        let d = numbers[i] - min;\n\
    \        numbers[i] = ((n - i) / n) * d + (min * d / n);\n    }\n\n    numbers",
  "    if numbers.len() < 2 {\n        return vec![];\n    }\n    let max_value =\
    \ numbers.iter().max();\n    let min_value = numbers.iter().min();\n    let total_count\
    \ = numbers.len();\n    let total_value = numbers.iter().sum();\n\n    let result\
    \ = vec![min_value, max_value];\n    let mut scale = vec![(max_value - min_value)\
    \ / (total_value - total_count)];\n\n    for number in numbers {\n        let\
    \ mut new_val = result.0;\n        for (i, &mut new_val) in scale.iter().zip((&mut\
    \ result.0).iter_mut()) {\n            *new_val += (*number - min_value) * &mut\
    \ scale[i];\n        }\n    }\n    result", "    numbers\n        .iter()\n  \
    \      .map(|x| x / numbers.iter().min().unwrap_or(numbers.iter().max().unwrap_or(1)))\n\
    \        .collect()", "    let mut min = numbers[0] as f64;\n    let mut max =\
    \ numbers[0] as f64;\n    for (i, number) in numbers.iter().enumerate() {\n  \
    \      if number < min {\n            min = number;\n        }\n        if number\
    \ > max {\n            max = number;\n        }\n    }\n    numbers\n        .iter()\n\
    \        .map(|number| if number == min { 0.0 } else if number == max { 1.0 }\
    \ else { number as f64 })\n        .collect()", "    let len = numbers[0].abs();\n\
    \    let mut new_numbers = vec![];\n    for i in 0..len {\n        new_numbers.push(numbers[i]\
    \ / len);\n    }\n    new_numbers", "    if numbers.len() < 2 {\n        numbers\n\
    \    } else {\n        let mid = numbers.len() / 2;\n        numbers.iter().cloned().chain(\n\
    \            numbers[mid..mid],\n        )\n            .iter()\n            .cloned()\n\
    \            .map(|&x| {\n                if x == 0.0 {\n                    1.0\n\
    \                } else {\n                    x / 2.0\n                }\n  \
    \          })\n            .collect()\n    }", "    let len = numbers[0].abs();\n\
    \    if len == 0.0 {\n        return numbers;\n    }\n    let mut min_value =\
    \ numbers[0];\n    let mut max_value = numbers[0];\n    for i in 1..numbers.len()\
    \ {\n        let v = numbers[i];\n        if v < min_value {\n            min_value\
    \ = v;\n        }\n        if v > max_value {\n            max_value = v;\n  \
    \      }\n    }\n    let mut new_vec = Vec::new();\n    new_vec.push((min_value\
    \ - max_value) / len);\n    for i in 1..numbers.len() {\n        let v = numbers[i];\n\
    \        new_vec.push((v - min_value) / (max_value - min_value));\n    }\n   \
    \ new_vec", "    let min_number = numbers[0];\n    let max_number = numbers[0];\n\
    \    for i in numbers.iter_mut() {\n        *i = min_number + (*i as f64) / (max_number\
    \ as f64 - min_number as f64);\n        if *i <= 0.0 {\n            *i = 0.0;\n\
    \        }\n        if *i >= 1.0 {\n            *i = 1.0;\n        }\n       \
    \ min_number = *i;\n        if max_number < 0.0 {\n            max_number = *i;\n\
    \        }\n    }\n    numbers", "    numbers\n        .iter()\n        .fold(0.0,\
    \ |acc, value| acc.min(&value))\n        .map(|value| value / 2.0)\n        .collect()",
  "    let min_number = std::f64::min(numbers);\n    let max_number = std::f64::max(numbers);\n\
    \    let diff = max_number - min_number;\n    let mut scale = 0.01;\n    let new_number\
    \ = min_number + diff * scale;\n    let mut res = vec![];\n    for i in numbers\
    \ {\n        res.push(i * scale);\n    }\n    res.sort_unstable();\n    res",
  "    let mut result = numbers.clone();\n    let min_number = result.min();\n   \
    \ let max_number = result.max();\n    if min_number == 0.0 && max_number == 1.0\
    \ {\n        result.pop();\n    }\n    let min_number = f64::min(min_number, 0.);\n\
    \    let max_number = f64::max(max_number, 1.);\n    let scale = (max_number as\
    \ f64 - min_number) as f64 / 2.;\n    for (i, n) in result.iter().enumerate()\
    \ {\n        result[i] = n * scale + min_number;\n    }\n    result", "    let\
    \ mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers {\n\
    \        if n < min {\n            min = n;\n        }\n        if n > max {\n\
    \            max = n;\n        }\n    }\n\n    let mut rescaled_numbers = Vec::new();\n\
    \    for i in numbers.iter() {\n        rescaled_numbers.push((i - min) / (max\
    \ - min));\n    }\n    rescaled_numbers", "    let minval = std::min(numbers[..1].iter().min().unwrap(),\
    \ numbers[1..].iter().min().unwrap());\n    let maxval = std::max(numbers[..1].iter().max().unwrap(),\
    \ numbers[1..].iter().max().unwrap());\n    vec![minval / maxval]", '    numbers.iter().map(|x|
    x / numbers.iter().max())', "    let mut min_value = numbers.min(|a, b| std::cmp::min(std::f64::MIN,\
    \ std::f64::MAX as f64 - b as f64 - a));\n    let mut max_value = numbers.max(|a,\
    \ b| std::cmp::max(std::f64::MIN, std::f64::MAX as f64 - b as f64 - a));\n   \
    \ match min_value {\n        None => min_value = max_value = 0.0,\n        Some(val)\
    \ => min_value = val as f64,\n    }\n    match max_value {\n        None => max_value\
    \ = 1.0,\n        Some(val) => max_value = val as f64,\n    }\n    numbers.map(|n|\
    \ n / max_value - min_value / max_value)", "    let mut sum: f64 = 0.0;\n\n  \
    \  for x in numbers {\n        sum += x;\n    }\n\n    let scale = 1.0 / sum;\n\
    \    for x in numbers {\n        *x = *x * scale;\n    }\n\n    numbers", "  \
    \  let mut min_val = numbers.iter().min().unwrap();\n    let mut max_val = numbers.iter().max().unwrap();\n\
    \n    min_val = min_val * -1.0;\n    max_val = max_val * 1.0;\n    min_val\n \
    \       .try_into()\n        .unwrap()\n        .unwrap_or(0.0);\n    max_val\n\
    \        .try_into()\n        .unwrap()\n        .unwrap_or(0.0);\n    numbers.iter().map(|x|\
    \ x * 1.0 / max_val).collect()", "    let min = numbers.iter().min().unwrap();\n\
    \    let max = numbers.iter().max().unwrap();\n    let mut output = Vec::new();\n\
    \    numbers.iter().for_each(|num| {\n        let output = num / max as f64;\n\
    \        if output < min {\n            output = min as f64;\n        }\n    \
    \    output.push_raw((output - min) / (max - min) as u8);\n    });\n    output",
  "    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        let mut diff = n - min;\n        if diff > max {\n            max\
    \ = diff;\n        }\n        diff = n - max;\n        if diff < min {\n     \
    \       min = diff;\n        }\n    }\n\n    let mut norm = max - min;\n    if\
    \ norm == 0 {\n        // avoid division by zero errors\n        norm = 1.0;\n\
    \    }\n\n    let mut result: Vec<f64> = vec![];\n    for n in numbers {\n   \
    \     let mut rescaled = min + ((n-min) / norm) * (max-min);\n        result.push(rescaled);\n\
    \    }\n    result", "    let min = numbers.iter().min().unwrap();\n    let max\
    \ = numbers.iter().max().unwrap();\n    numbers.iter().map(|x| x / max - min).collect()",
  "    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        let ratio = (n - min) / (max - min);\n        min = n;\n        max\
    \ = n * ratio;\n    }\n    numbers", "    let len = numbers.len();\n    if len\
    \ < 2 {\n        return vec![numbers[0]];\n    }\n\n    let mut max = numbers[0];\n\
    \    let mut min = numbers[0];\n    for i in 1..len {\n        max = if numbers[i]\
    \ > max { numbers[i] } else { max };\n        min = if numbers[i] < min { numbers[i]\
    \ } else { min };\n    }\n\n    let mut range = max - min;\n    if range == 0\
    \ {\n        return vec![1.0];\n    }\n    range = 1.0 * range / len;\n    vec![min\
    \ + range * (numbers[0] - min)]", "    let mut min = numbers[0];\n    let mut\
    \ max = numbers[0];\n    for n in numbers {\n        if n < min {\n          \
    \  min = n;\n        }\n        if n > max {\n            max = n;\n        }\n\
    \    }\n    // We assume that all numbers are positive\n    if min > 0.0 {\n \
    \       // Scale the vector so that the minimum becomes 0 and maximum becomes\
    \ 1\n        let scale = max - min;\n        for n in numbers {\n            n\
    \ /= scale;\n        }\n    }\n    return numbers", "    let mut min: f64;\n \
    \   let mut max: f64;\n    let mut scale = 1.0;\n    let mut sum = 0;\n    for\
    \ n in numbers {\n        sum += n;\n        if n < min {\n            min = n;\n\
    \        }\n        if n > max {\n            max = n;\n        }\n    }\n   \
    \ for n in numbers {\n        scale = scale / sum;\n        sum += n * scale;\n\
    \    }\n    let mut result = vec![0.0; numbers.len()];\n    for &n in numbers\
    \ {\n        result[numbers.iter().position(|&x| x > n).unwrap()] += n * scale;\n\
    \    }\n    result", "    assert!(numbers.size() >= 2);\n    numbers\n       \
    \ .iter()\n        .filter_map(|x| {\n            if x < 0.0 {\n             \
    \   0.0\n            } else if x > 1.0 {\n                1.0\n            } else\
    \ {\n                x\n            }\n        })\n        .collect()", "    let\
    \ mut max_value = numbers[0];\n    let mut min_value = numbers[0];\n\n    for\
    \ &x in numbers {\n        if x < min_value {\n            min_value = x;\n  \
    \      }\n        if x > max_value {\n            max_value = x;\n        }\n\
    \    }\n\n    let scale = max_value - min_value;\n    let mut rescaled_numbers\
    \ = Vec::new();\n\n    for n in numbers {\n        let scale_value = n.saturating_sub(f64::from(min_value)).sqrt().round()\
    \ as f64;\n        if scale_value == 0.0 {\n            rescaled_numbers.push(0.0);\n\
    \        } else {\n            rescaled_numbers.push((n - min_value).powi(scale.ln()\
    \ as i32));\n        }\n    }\n\n    rescaled_numbers", "    let mut min = numbers[0];\n\
    \    let mut max = numbers[0];\n    for i in numbers.iter() {\n        min = std::min(min,\
    \ i);\n        max = std::max(max, i);\n    }\n\n    let mut new_numbers = Vec::new();\n\
    \    for i in numbers.iter() {\n        new_numbers.push((i - min) / (max - min));\n\
    \    }\n\n    new_numbers", "    let mut scaled = Vec::new();\n    let min_number\
    \ = numbers.iter().min().unwrap();\n    let max_number = numbers.iter().max().unwrap();\n\
    \    numbers.iter().for_each(|number| {\n        let rescaled = number * (max_number\
    \ - min_number) / (number - min_number);\n        scaled.append(rescaled);\n \
    \   });\n    scaled", "    let sum = numbers.iter().reduce::<f64>(0.);\n    let\
    \ mut min: f64;\n    let mut max: f64;\n\n    if numbers.len() > 1 {\n       \
    \ let mut min_f64: f64 = numbers[0];\n        let mut max_f64: f64 = numbers[0];\n\
    \n        for number in numbers {\n            if number < min_f64 {\n       \
    \         min_f64 = number;\n            }\n            if number > max_f64 {\n\
    \                max_f64 = number;\n            }\n        }\n\n        if min_f64\
    \ == max {\n            max = max_f64;\n        } else {\n            min = min_f64;\n\
    \        }\n    } else {\n        min = numbers[0];\n        max = numbers[0];\n\
    \    }\n\n    let mut scaled_numbers = Vec::new();\n\n    for number in numbers\
    \ {\n        scaled_numbers.push((number - min) / (max - min).powf(0.5));\n  \
    \  }\n\n    scaled_numbers", "    let mut min_element = numbers.iter().min().unwrap();\n\
    \    let mut max_element = numbers.iter().max().unwrap();\n    numbers.iter_mut().for_each(|&mut\
    \ elem| {\n        elem = elem - min_element as f64;\n        elem = elem / max_element\
    \ as f64;\n    });\n    numbers", "    if numbers.len() < 2 {\n        numbers\n\
    \    } else {\n        let min_num = numbers.iter().min().unwrap();\n        let\
    \ max_num = numbers.iter().max().unwrap();\n        let inv_max_num = 1.0f64 /\
    \ max_num;\n        let inv_min_num = 1.0f64 / min_num;\n        numbers.iter().map(|n|\
    \ n * inv_max_num).collect::<Vec<_>>() + (numbers.iter().map(|n| n * inv_min_num).collect::<Vec<_>>()\
    \ + [min_num]).collect::<Vec<_>>()\n    }", "    let mut rescaled_numbers = Vec::with_capacity(numbers.len()\
    \ + 1);\n    rescaled_numbers.extend_from_slice(numbers.iter().map(|x| *x).collect::<Vec<_>>());\n\
    \    rescaled_numbers[0] = 0.0;\n    rescaled_numbers[numbers.len() - 1] = 1.0;\n\
    \    rescaled_numbers", "    let mut result = Vec::new();\n    if numbers.len()\
    \ >= 2 {\n        let mut smallest = numbers[0];\n        let mut largest = numbers[0];\n\
    \        for &x in numbers {\n            if x < smallest {\n                smallest\
    \ = x;\n            }\n            if x > largest {\n                largest =\
    \ x;\n            }\n        }\n        let scale = smallest - largest;\n    \
    \    for &x in numbers {\n            result.append(x - largest) * scale;\n  \
    \      }\n    }\n    result", "    assert!(numbers.len() > 1);\n    let mut norm\
    \ = numbers.iter().cloned().sum();\n    let mut min_max_scale = vec![1.0, 0.0];\n\
    \n    for n in numbers {\n        let scale = (n - norm) as f64 / norm;\n    \
    \    norm = n;\n        min_max_scale = [min(min_max_scale[0], scale), max(min_max_scale[1],\
    \ scale)];\n    }\n\n    (numbers - min_max_scale[1]) * min_max_scale[0] + min_max_scale[1]",
  "    let mut min_val = numbers.iter().min();\n    let mut max_val = numbers.iter().max();\n\
    \    min_val = 0.0;\n    max_val = 1.0;\n    numbers.iter().map(|n| n * (max_val\
    \ - min_val) / (n - 1)).collect()", "    let mut min = numbers.iter().min();\n\
    \    let mut max = numbers.iter().max();\n    let range = max - min;\n    let\
    \ scale_factor: f64 = 1.0 / (range as f64);\n    let mut result: Vec<f64> = numbers.iter().map(|number|\
    \ scale_factor * number).collect();\n    if min != 0.0 {\n        result.push(0.0);\n\
    \    }\n    result.push(1.0);\n    result", "    let mut min = numbers[0];\n \
    \   let mut max = numbers[0];\n    for n in numbers {\n        min = min.min(n.clone());\n\
    \        max = max.max(n.clone());\n    }\n    numbers.iter_mut().for_each(|n|\
    \ n.scale_by(max - min));\n    numbers", "    let min = numbers.iter().min().unwrap();\n\
    \    let max = numbers.iter().max().unwrap();\n    let range = max - min;\n  \
    \  numbers.iter_mut().map(|x| {\n        *x += range * 0.5\n    }).collect()",
  "    assert!(numbers.len() > 1);\n    let mut min_number = numbers[0];\n    let\
    \ mut max_number = numbers[0];\n    for i in 1..numbers.len() {\n        let current_number\
    \ = numbers[i];\n        if current_number < min_number {\n            min_number\
    \ = current_number;\n        }\n        if current_number > max_number {\n   \
    \         max_number = current_number;\n        }\n    }\n\n    let min = std::cmp::min(min_number,\
    \ max_number);\n    let max = std::cmp::max(min_number, max_number);\n    let\
    \ mut rescaled = vec![];\n    for i in 0..numbers.len() {\n        rescaled.push((numbers[i]\
    \ - min) / (max - min));\n    }\n    rescaled", "    let mut min = numbers[0];\n\
    \    let mut max = numbers[0];\n    for &n in numbers {\n        if n < min {\n\
    \            min = n;\n        }\n        if n > max {\n            max = n;\n\
    \        }\n    }\n    let mut scale = 1.0f / (max - min);\n    for (i, &n) in\
    \ numbers.iter().enumerate() {\n        if n < min {\n            numbers[i] =\
    \ 0.0;\n        }\n        if n > max {\n            numbers[i] = 1.0;\n     \
    \   }\n        numbers[i] *= scale;\n    }\n    numbers", "    let mut scaled\
    \ = vec![];\n    for n in numbers {\n        scaled.push(n);\n        if n < numbers[0]\
    \ {\n            scaled.push((n - numbers[0]) / (n - numbers[0]))\n        }\n\
    \    }\n    scaled", "    let mut scale = 1.0;\n    let mut result: Vec<f64> =\
    \ vec![];\n    for (number, offset) in numbers.iter().zip(numbers.iter().skip(1))\
    \ {\n        let n = number.abs() / offset;\n        if n < 1e-10 {\n        \
    \    result.push(0.0);\n        } else {\n            result.push(n * scale);\n\
    \            scale = n.abs();\n        }\n    }\n    result", "    let mut max\
    \ = numbers[0];\n    let mut min = numbers[0];\n    let mut x = numbers[0];\n\
    \    for &n in numbers {\n        if n < min {\n            min = n;\n       \
    \ }\n        if n > max {\n            max = n;\n        }\n        x += n;\n\
    \    }\n\n    // Scale the numbers between min/max by (max-min)/2\n    (numbers\
    \ as f64) / (max - min).powf(2.0)", "    let mut max = numbers[0];\n    let mut\
    \ min = numbers[0];\n    let mut current_max = numbers[0];\n    let mut current_min\
    \ = numbers[0];\n\n    let mut scale: f64;\n\n    for i in 0..numbers.len() {\n\
    \        let number = numbers[i];\n\n        if number > max {\n            max\
    \ = number;\n        }\n\n        if number < min {\n            min = number;\n\
    \        }\n\n        if number < current_max {\n            current_max = number;\n\
    \        }\n\n        if number > current_min {\n            current_min = number;\n\
    \        }\n\n        scale = max as f64 - min as f64;\n        let new_number:\
    \ f64 = (number - min) as f64 / scale as f64;\n        numbers[i] = new_number;\n\
    \    }\n\n    numbers", "    if numbers.len() < 2 {\n        return vec![];\n\
    \    }\n    let mut vec = Vec::new();\n    let mut min_number = numbers.first().unwrap();\n\
    \    let mut max_number = numbers.last().unwrap();\n    vec.push(min_number as\
    \ f64);\n    let mut scaling_factor;\n    // Find scaling factor for smallest\
    \ number\n    for &n in numbers {\n        if n == min_number {\n            scaling_factor\
    \ = n as f64;\n        } else {\n            scaling_factor = (n - min_number)\
    \ / (max_number - min_number);\n        }\n    }\n    for &n in numbers {\n  \
    \      vec.push(n * scaling_factor);\n    }\n    vec", "    let mut min_number\
    \ = numbers.iter().min().unwrap();\n    let mut max_number = numbers.iter().max().unwrap();\n\
    \    let rescaled_numbers = numbers.iter().map(|x| {\n        x / (max_number\
    \ - min_number)\n    });\n    rescaled_numbers.collect()", "    let min_number\
    \ = numbers.iter().min().unwrap();\n    let max_number = numbers.iter().max().unwrap();\n\
    \n    numbers.iter().map(|x| x / max_number).collect()", "    let mut min_value\
    \ = numbers[0];\n    let mut max_value = numbers[0];\n    let mut current_value\
    \ = numbers[0];\n\n    for number in numbers {\n        min_value = std::cmp::min(min_value,\
    \ number);\n        max_value = std::cmp::max(max_value, number);\n        current_value\
    \ = number + (current_value - min_value) / (max_value - min_value);\n    }\n \
    \   let mut result = Vec::with_capacity(numbers.len());\n    for i in 0..numbers.len()\
    \ {\n        let value = current_value * numbers.len() + min_value;\n        result.push(value);\n\
    \    }\n    result", "    let min_num = numbers.iter().min();\n    let max_num\
    \ = numbers.iter().max();\n\n    let len = numbers.len() as f64;\n\n    numbers\
    \ * max_num.powi(len) - min_num.powi(len)", "    let mut min_value = numbers.iter().min().unwrap();\n\
    \    let mut max_value = numbers.iter().max().unwrap();\n\n    while max_value\
    \ - min_value > 1e-5 {\n        if min_value > 0.0 {\n            min_value -=\
    \ 1e-5;\n        }\n        if max_value < 1.0 {\n            max_value += 1e-5;\n\
    \        }\n    }\n\n    let mut rescaled_numbers = Vec::new();\n\n    for num\
    \ in numbers {\n        if num < min_value {\n            rescaled_numbers.push(0.0);\n\
    \        }\n        if num > max_value {\n            rescaled_numbers.push(1.0);\n\
    \        }\n        rescaled_numbers.push(num);\n    }\n\n    rescaled_numbers",
  "    let min_number = numbers.iter().min();\n    let max_number = numbers.iter().max();\n\
    \n    if min_number == 0.0 && max_number == 1.0 {\n        return numbers;\n \
    \   }\n    else {\n        let mut new_numbers = vec![min_number];\n        for\
    \ i in numbers.iter().rev() {\n            new_numbers.append(i / max_number);\n\
    \        }\n        new_numbers.reverse();\n        return new_numbers\n    }",
  "    let mut smallest = numbers[0];\n    let mut largest = numbers[0];\n    for\
    \ i in numbers.iter_mut() {\n        if *i < smallest {\n            smallest\
    \ = *i;\n        }\n        if *i > largest {\n            largest = *i;\n   \
    \     }\n    }\n    let mut res: Vec<f64> = Vec::new();\n    res.push(smallest\
    \ as f64);\n    for i in numbers.iter_mut() {\n        *i -= smallest as f64;\n\
    \        res.push(*i as f64);\n    }\n    res", "    let mut min_value = numbers.iter().min().unwrap();\n\
    \    let mut max_value = numbers.iter().max().unwrap();\n    if max_value < min_value\
    \ {\n        // the min() value is greater than the max() value, so flip them\n\
    \        min_value = max_value;\n        max_value = min_value;\n    }\n    let\
    \ range = max_value - min_value;\n    let mut scale = 0.0;\n    numbers.iter().for_each(|n|\
    \ scale += (n-min_value)/range);\n    if scale == 0.0 {\n        // we can't rescale\
    \ the vector because it has zero elements\n        return numbers;\n    }\n  \
    \  let mut numbers_scaled = vec![0.0; numbers.len()];\n    numbers.iter().for_each(|n|\
    \ numbers_scaled[(numbers.iter().position(|x| x <= n) - numbers.iter().position(|x|\
    \ x > n)).unwrap()] += (n - min_value)/range);\n    numbers_scaled * scale", " \
    \   let min_number = numbers.iter().min().unwrap();\n    let max_number = numbers.iter().max().unwrap();\n\
    \    let min_number = min_number + 0.5;\n    let max_number = max_number - 0.5;\n\
    \    numbers.iter_mut().map(|x| if x < min_number { x = min_number } else { x\
    \ = x }).collect::<Vec<_>>()", "    let mut min = numbers.iter().min().unwrap();\n\
    \    let mut max = numbers.iter().max().unwrap();\n    let mut length = numbers[0].abs();\n\
    \    for (i, val) in numbers.iter().enumerate() {\n        if val < min {\n  \
    \          min = val as f64;\n        }\n        if val > max {\n            max\
    \ = val as f64;\n        }\n        length += val.abs();\n    }\n    let mut scale\
    \ = 1.0 * min / length as f64;\n    for val in numbers {\n        if val < min\
    \ {\n            val -= scale * min;\n        }\n        if val > max {\n    \
    \        val -= scale * (max - min);\n        }\n    }\n    numbers", "    if\
    \ numbers.len() == 0 {\n        return vec![];\n    }\n    numbers.iter().map(|x|\
    \ x / numbers.len()).collect::<Vec<_>>()", "    let mut max_value = 0.;\n    let\
    \ mut min_value = 1.;\n    for &n in numbers {\n        if n > max_value {\n \
    \           max_value = *n;\n        }\n        if n < min_value {\n         \
    \   min_value = *n;\n        }\n    }\n    let mut new_numbers = Vec::new();\n\
    \    new_numbers.extend_from_slice(&[min_value]);\n    new_numbers.extend_from_slice(&[max_value]);\n\
    \    new_numbers", "    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min { min = n; }\n        if n > max {\
    \ max = n; }\n    }\n    let mut new_min = max - 1;\n    let mut new_max = min\
    \ + 1;\n    for n in numbers {\n        let mut old_min = min;\n        let mut\
    \ old_max = max;\n        while n > old_max {\n            old_max += 1;\n   \
    \     }\n        while n < old_min {\n            old_min -= 1;\n        }\n \
    \       if n == old_max { new_max = old_max; }\n        if n == old_min { new_min\
    \ = old_min; }\n    }\n    numbers.iter().map(|x| {\n        assert!(x >= new_min\
    \ && x <= new_max);\n        (x - new_min) / (new_max - new_min + 1.)\n    })",
  "    let mut min: f64 = numbers[0];\n    let mut max: f64 = numbers[0];\n    for\
    \ &x in numbers {\n        if x < min {\n            min = x;\n        }\n   \
    \     if x > max {\n            max = x;\n        }\n    }\n    let mut res: Vec<f64>\
    \ = Vec::new();\n    for &x in numbers {\n        res.push((x - min) / (max -\
    \ min));\n    }\n    res", "    let min: f64 = numbers.iter().min().unwrap();\n\
    \    let max: f64 = numbers.iter().max().unwrap();\n    numbers.iter().map(|x|\
    \ (x - min) / (max - min)).collect()", "    if numbers.len() <= 1 {\n        return\
    \ numbers;\n    }\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for i in 1..numbers.len() {\n        if numbers[i] < min {\n            min\
    \ = numbers[i];\n        }\n        if numbers[i] > max {\n            max = numbers[i];\n\
    \        }\n    }\n    let mut range = (max - min) / numbers.len() as f64;\n \
    \   if range == 0 {\n        return numbers;\n    }\n    let mut scaled: Vec<f64>\
    \ = numbers.iter().cloned().map(|x| x - min).collect();\n    scaled.resize(numbers.len(),\
    \ (range / numbers[0]) as f64);\n    scaled", "    let mut min_ind = numbers.iter().min().unwrap();\n\
    \    let mut max_ind = numbers.iter().max().unwrap();\n\n    for ind in numbers.iter()\
    \ {\n        if ind < min_ind {\n            min_ind = ind;\n        }\n\n   \
    \     if ind > max_ind {\n            max_ind = ind;\n        }\n    }\n\n   \
    \ let mut scale: f64 = (max_ind - min_ind).powi(2) as f64;\n    for ind in numbers.iter()\
    \ {\n        *ind = (ind-min_ind)*scale;\n    }\n    numbers", "    let mut min\
    \ = numbers[0];\n    let mut max = numbers[0];\n    for (i, n) in numbers.iter().enumerate()\
    \ {\n        if n < min {\n            min = n;\n        } else if n > max {\n\
    \            max = n;\n        }\n    }\n    // The formula is min + min / (max\
    \ - min) where max is max - min\n    // But we want the max to be 1\n    let scale\
    \ = (max - min) / 2.0 + 1.0;\n    numbers.iter().map(|n| n * scale).collect()",
  "    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let diff = max - min;\n    let mut new_numbers = Vec::with_capacity(numbers.len());\n\
    \    for number in numbers {\n        if number - min == diff {\n            new_numbers.push(0.0);\n\
    \        } else {\n            new_numbers.push(number / diff);\n        }\n \
    \   }\n    new_numbers", "    assert!(numbers.len() >= 2);\n    let min_element\
    \ = numbers.iter().min().unwrap();\n    let max_element = numbers.iter().max().unwrap();\n\
    \n    let mut result: Vec<f64> = Vec::new();\n\n    for number in numbers {\n\
    \        let mut element: f64 = number;\n        if element < min_element {\n\
    \            element = min_element;\n        } else if element > max_element {\n\
    \            element = max_element;\n        }\n        result.push(element);\n\
    \    }\n    result", "    let min_number = numbers.iter().min();\n    let max_number\
    \ = numbers.iter().max();\n    let mut rescaled_numbers = Vec::new();\n    for\
    \ number in numbers {\n        rescaled_numbers.push(number / max_number);\n \
    \   }\n    rescaled_numbers", "    let mut min = numbers[0];\n    let mut max\
    \ = numbers[0];\n    for x in numbers {\n        if x < min {\n            min\
    \ = x;\n        }\n        if x > max {\n            max = x;\n        }\n   \
    \ }\n    let mut rescaled = vec![];\n    let mut factor = max - min;\n    for\
    \ x in numbers {\n        rescaled.push(x - min * factor);\n        factor = factor\
    \ / 2.0;\n    }\n    rescaled", "    let mut smallest_number = numbers.iter().min().unwrap();\n\
    \    let mut largest_number = numbers.iter().max().unwrap();\n    let mut new_numbers\
    \ = vec![smallest_number];\n    let mut new_numbers_2 = vec![largest_number];\n\
    \n    for element in numbers.iter() {\n        let mut new_number = element;\n\
    \n        if element < smallest_number {\n            new_number = smallest_number;\n\
    \        } else if element > largest_number {\n            new_number = largest_number;\n\
    \        }\n\n        new_numbers.push(new_number);\n    }\n\n    new_numbers.sort_unstable();\n\
    \    new_numbers.reverse();\n    new_numbers_2.sort_unstable();\n    new_numbers_2.reverse();\n\
    \n    vec![new_numbers[0], new_numbers_2[0]]", "    numbers\n        .iter()\n\
    \        .map(|x| {\n            if x == 0.0 {\n                0.0\n        \
    \    } else {\n                1 / x\n            }\n        })\n        .collect()",
  "    let mut min = numbers[0] as f64;\n    let mut max = numbers[0] as f64;\n  \
    \  for &num in numbers {\n        if min > num {\n            min = num as f64;\n\
    \        }\n        if max < num {\n            max = num as f64;\n        }\n\
    \    }\n    let mut scale = 1.0 + 2.0 * (max - min);\n    if scale > 1.0 {\n \
    \       scale = 1.0;\n    }\n    numbers.iter().map(|num| num / scale).collect()",
  "    let mut min: f64 = numbers.iter().min().unwrap();\n    let mut max: f64 = numbers.iter().max().unwrap();\n\
    \n    for i in 0..numbers.len() {\n        let mut numerator = if i == 0 {\n \
    \           numbers[i]\n        } else {\n            numbers[i] - min\n     \
    \   };\n\n        let mut denominator = max - min;\n\n        if numerator ==\
    \ 0.0 {\n            continue;\n        }\n\n        numerator /= denominator;\n\
    \        numbers[i] = numerator;\n    }\n\n    numbers", "    let mut sum = numbers.reduce((0.0\
    \ + 1.0) / 2.0, 0.0);\n    numbers.iter().for_each(|n| {\n        sum += (n -\
    \ sum) * n / sum;\n    });\n    numbers"]
stop_tokens:
- "\n}"
