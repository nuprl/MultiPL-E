language: rs
name: HumanEval_70_strange_sort_list
results:
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    if lst.is_empty() {\n        return lst;\n\
    \    }\n\n    let min_value = lst.iter().min().unwrap();\n    let max_value =\
    \ lst.iter().max().unwrap();\n\n    let mut tmp = min_value;\n    let mut new_list\
    \ = vec![];\n\n    for i in lst.iter() {\n        if i < min_value {\n       \
    \     tmp.next = i;\n        } else {\n            new_list.push(tmp.clone());\n\
    \            tmp = i;\n        }\n    }\n\n    new_list.push(tmp.clone());\n \
    \   new_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0609]: no field `next` on type `&isize`\n  --> /tmp/tmpk0sct3ll.rs:24:17\n\
    \   |\n24 |             tmp.next = i;\n   |                 ^^^^\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0609`.\n"
  stdout: ''
  timestamp: 1660010734
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut vec = Vec::new();\n    let mut min:\
    \ isize = std::i32::MAX;\n    let mut max: isize = 0;\n    for (i, &v) in lst.iter().enumerate()\
    \ {\n        if v < min {\n            min = v;\n        }\n        if v > max\
    \ {\n            max = v;\n        }\n        vec.push(i);\n    }\n    let mut\
    \ new_min: isize = min;\n    let mut new_max: isize = 0;\n    let mut idx: usize\
    \ = 0;\n    for (i, &v) in lst.iter().enumerate() {\n        if v < new_min {\n\
    \            new_min = v;\n            idx = i;\n        }\n        if v > new_max\
    \ {\n            new_max = v;\n        }\n    }\n    let mut new_lst = vec![max;\
    \ new_max - new_min + 1];\n    new_lst.extend(vec![0; new_lst.len()]);\n    for\
    \ j in new_lst.reverse() {\n        new_lst[j - idx] = new_min;\n    }\n    new_lst.extend(vec![idx;\
    \ lst.len()]);\n    new_lst.extend(vec![min; new_max - new_min + 1]);\n    new_lst\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8wg5wgyc.rs:13:26\n   |\n\
    13 |     let mut min: isize = std::i32::MAX;\n   |                  -----   ^^^^^^^^^^^^^\
    \ expected `isize`, found `i32`\n   |                  |\n   |               \
    \   expected due to this\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n13 |     let mut min: isize\
    \ = std::i32::MAX.try_into().unwrap();\n   |                                 \
    \      ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8wg5wgyc.rs:36:33\n\
    \   |\n36 |     let mut new_lst = vec![max; new_max - new_min + 1];\n   |    \
    \                             ^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n36 |     let mut new_lst = vec![max; (new_max - new_min\
    \ + 1).try_into().unwrap()];\n   |                                 +         \
    \            +++++++++++++++++++++\n\nerror[E0277]: `()` is not an iterator\n\
    \  --> /tmp/tmp8wg5wgyc.rs:38:14\n   |\n38 |     for j in new_lst.reverse() {\n\
    \   |              ^^^^^^^^^^^^^^^^^ `()` is not an iterator\n   |\n   = help:\
    \ the trait `Iterator` is not implemented for `()`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `()`\n\nerror[E0277]:\
    \ the trait bound `Vec<isize>: Extend<usize>` is not satisfied\n  --> /tmp/tmp8wg5wgyc.rs:41:13\n\
    \   |\n41 |     new_lst.extend(vec![idx; lst.len()]);\n   |             ^^^^^^\
    \ the trait `Extend<usize>` is not implemented for `Vec<isize>`\n   |\n   = help:\
    \ the following other types implement trait `Extend<A>`:\n             <Vec<T,\
    \ A> as Extend<&'a T>>\n             <Vec<T, A> as Extend<T>>\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8wg5wgyc.rs:42:30\n   |\n42 |     new_lst.extend(vec![min;\
    \ new_max - new_min + 1]);\n   |                              ^^^^^^^^^^^^^^^^^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n42 |     new_lst.extend(vec![min;\
    \ (new_"
  stdout: ''
  timestamp: 1660010734
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    lst\n        .iter()\n        .cloned()\n \
    \       .sort_by(|a, b| a.partial_cmp(b).unwrap())\n        .collect()\n}\n\n\
    fn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by` found for struct `Cloned` in the\
    \ current scope\n  --> /tmp/tmp4578w8gh.rs:15:10\n   |\n15 |         .sort_by(|a,\
    \ b| a.partial_cmp(b).unwrap())\n   |          ^^^^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010734
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut curr = vec![*lst.iter().rev().take(3).collect::<Vec<isize>>()];\n\
    \    for i in 0..(lst.len() - 2) {\n        if curr[0] != curr[1] {\n        \
    \    curr[0] = curr[1];\n        } else {\n            curr[1] = curr[2];\n  \
    \      }\n        if curr[0] == curr[1] {\n            curr[2] = curr[1];\n  \
    \      }\n        curr[1] = curr[0];\n    }\n    curr\n}\n\nfn main() {\n    let\
    \ candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]),\
    \ vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9,\
    \ 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6,\
    \ 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `&isize`\n    --> /tmp/tmpgpeatrzc.rs:12:51\n     |\n\
    12   |     let mut curr = vec![*lst.iter().rev().take(3).collect::<Vec<isize>>()];\n\
    \     |                                                   ^^^^^^^ value of type\
    \ `Vec<isize>` cannot be built from `std::iter::Iterator<Item=&isize>`\n     |\n\
    \     = help: the trait `FromIterator<&isize>` is not implemented for `Vec<isize>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0277]: the size for values of type `[isize]`\
    \ cannot be known at compilation time\n   --> /tmp/tmpgpeatrzc.rs:12:20\n    |\n\
    12  |     let mut curr = vec![*lst.iter().rev().take(3).collect::<Vec<isize>>()];\n\
    \    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized`\
    \ is not implemented for `[isize]`\nnote: required by a bound in `slice::<impl\
    \ [T]>::into_vec`\n    = note: this error originates in the macro `vec` (in Nightly\
    \ builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: the size\
    \ for values of type `[isize]` cannot be known at compilation time\n  --> /tmp/tmpgpeatrzc.rs:12:20\n\
    \   |\n12 |     let mut curr = vec![*lst.iter().rev().take(3).collect::<Vec<isize>>()];\n\
    \   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ doesn't have a size known at compile-time\n   |\n   = help: the trait `Sized`\
    \ is not implemented for `[isize]`\n   = note: slice and array elements must have\
    \ `Sized` type\n   = note: this error originates in the macro `vec` (in Nightly\
    \ builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: the size\
    \ for values of type `[isize]` cannot be known at compilation time\n   --> /tmp/tmpgpeatrzc.rs:12:20\n\
    \    |\n12  |     let mut curr = vec![*lst.iter().rev().take(3).collect::<Vec<isize>>()];\n\
    \    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ doesn't have a size known at compi"
  stdout: ''
  timestamp: 1660010734
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    // Sort by minimum element, starting with the\
    \ minimum element\n    let mut sorted_lst = vec![];\n    let mut min_element =\
    \ lst[0];\n    for elem in lst {\n        if elem < min_element {\n          \
    \  sorted_lst.push((min_element, elem));\n            min_element = elem;\n  \
    \      }\n    }\n\n    // Sort by maximum element, starting with the maximum element\n\
    \    let mut max_element = lst[0];\n    for elem in lst {\n        if elem > max_element\
    \ {\n            sorted_lst.push((elem, max_element));\n            max_element\
    \ = elem;\n        }\n    }\n    sorted_lst.push((max_element, min_element));\n\
    \    sorted_lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n  \
    \  assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7584ky9o.rs:31:5\n   |\n\
    11 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |             \
    \                             ---------- expected `Vec<isize>` because of return\
    \ type\n...\n31 |     sorted_lst\n   |     ^^^^^^^^^^ expected `isize`, found\
    \ tuple\n   |\n   = note: expected struct `Vec<isize>`\n              found struct\
    \ `Vec<(isize, isize)>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010734
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    if lst.is_empty() {\n        return vec![];\n\
    \    }\n\n    let mut lst = lst.into_iter().cloned().collect::<Vec<_>>();\n  \
    \  let mut cur = lst.first().unwrap();\n    let mut min_pos = 0;\n\n    for (i,\
    \ val) in lst.into_iter().cloned().enumerate().rev() {\n        if val < cur {\n\
    \            lst.swap(i, min_pos);\n            min_pos = i;\n        }\n\n  \
    \      cur = val;\n    }\n\n    lst.swap(min_pos, 0);\n    lst\n}\n\nfn main()\
    \ {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<std::vec::IntoIter<isize> as Iterator>::Item\
    \ == &_`\n    --> /tmp/tmp8rbt0axy.rs:16:35\n     |\n16   |     let mut lst =\
    \ lst.into_iter().cloned().collect::<Vec<_>>();\n     |                      \
    \             ^^^^^^ expected reference, found `isize`\n     |\n     = note: expected\
    \ reference `&_`\n                     found type `isize`\nnote: required by a\
    \ bound in `cloned`\n\nerror[E0599]: the method `collect` exists for struct `Cloned<std::vec::IntoIter<isize>>`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmp8rbt0axy.rs:16:44\n \
    \  |\n16 |       let mut lst = lst.into_iter().cloned().collect::<Vec<_>>();\n\
    \   |                                              ^^^^^^^ method cannot be called\
    \ on `Cloned<std::vec::IntoIter<isize>>` due to unsatisfied trait bounds\n   |\n\
    \   = note: the following trait bounds were not satisfied:\n           `<std::vec::IntoIter<isize>\
    \ as Iterator>::Item = &_`\n           which is required by `Cloned<std::vec::IntoIter<isize>>:\
    \ Iterator`\n           `Cloned<std::vec::IntoIter<isize>>: Iterator`\n      \
    \     which is required by `&mut Cloned<std::vec::IntoIter<isize>>: Iterator`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1660010734
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut out = Vec::new();\n    out.extend(lst.iter().cloned());\n\
    \n    out.sort_by_key(|&i| i);\n\n    out\n}\n\nfn main() {\n    let candidate\
    \ = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5,\
    \ 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpz8g2xzhe.rs:22:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010734
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    if lst.is_empty() {\n        return vec![];\n\
    \    }\n    let mut sorted_list = vec![];\n    let mut min = lst.iter().min().unwrap();\n\
    \    let mut max = lst.iter().max().unwrap();\n    while let Some(item) = lst.iter().next()\
    \ {\n        if item < min {\n            sorted_list.push(min);\n           \
    \ min = item;\n        }\n        if item > max {\n            sorted_list.push(max);\n\
    \            max = item;\n        }\n    }\n    sorted_list.push(min);\n    sorted_list.push(max);\n\
    \    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgqbb27di.rs:30:5\n   |\n\
    11 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |             \
    \                             ---------- expected `Vec<isize>` because of return\
    \ type\n...\n30 |     sorted_list\n   |     ^^^^^^^^^^^ expected `isize`, found\
    \ `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n              found\
    \ struct `Vec<&isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010734
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut l = lst.clone();\n    let mut k = lst.len()\
    \ - 1;\n    while k > 0 {\n        while k > 0 && l[k] > l[k + 1] {\n        \
    \    l = &l[k];\n            k -= 1;\n        }\n        while k > 0 && l[k] <\
    \ l[k + 1] {\n            k = k - 1;\n        }\n        l = &l[k];\n        k\
    \ = k - 1;\n    }\n    l\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpa6wlt1bq.rs:16:17\n   |\n\
    12 |     let mut l = lst.clone();\n   |                 ----------- expected due\
    \ to this value\n...\n16 |             l = &l[k];\n   |                 ^^^^^\
    \ expected struct `Vec`, found `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found reference `&isize`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpa6wlt1bq.rs:22:13\n   |\n12 |     let mut l = lst.clone();\n   |   \
    \              ----------- expected due to this value\n...\n22 |         l = &l[k];\n\
    \   |             ^^^^^ expected struct `Vec`, found `&isize`\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found reference `&isize`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010734
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut max = lst.iter().max().unwrap();\n\
    \    let mut min = lst.iter().min().unwrap();\n    for elt in lst {\n        if\
    \ elt < min {\n            min = elt;\n        } else if elt > max {\n       \
    \     max = elt;\n        }\n    }\n    while max > min {\n        let pivot =\
    \ max + (min - max) / 2;\n        if pivot < min {\n            max = pivot;\n\
    \        } else {\n            min = pivot;\n        }\n    }\n    vec![min; lst]\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxbwodj_j.rs:15:18\n   |\n\
    15 |         if elt < min {\n   |                  ^^^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n15 |        \
    \ if elt < *min {\n   |                  +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpxbwodj_j.rs:16:19\n   |\n13 |     let mut min = lst.iter().min().unwrap();\n\
    \   |                   ------------------------- expected due to this value\n\
    ...\n16 |             min = elt;\n   |                   ^^^\n   |           \
    \        |\n   |                   expected `&isize`, found `isize`\n   |    \
    \               help: consider borrowing here: `&elt`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpxbwodj_j.rs:17:25\n   |\n17 |         } else if elt > max\
    \ {\n   |                         ^^^ expected `isize`, found `&isize`\n   |\n\
    help: consider dereferencing the borrow\n   |\n17 |         } else if elt > *max\
    \ {\n   |                         +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxbwodj_j.rs:18:19\n\
    \   |\n12 |     let mut max = lst.iter().max().unwrap();\n   |               \
    \    ------------------------- expected due to this value\n...\n18 |         \
    \    max = elt;\n   |                   ^^^\n   |                   |\n   |  \
    \                 expected `&isize`, found `isize`\n   |                   help:\
    \ consider borrowing here: `&elt`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxbwodj_j.rs:23:20\n\
    \   |\n23 |         if pivot < min {\n   |                    ^^^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n23 |  \
    \       if pivot < *min {\n   |                    +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpxbwodj_j.rs:24:19\n   |\n12 |     let mut max = lst.iter().max().unwrap();\n\
    \   |                   ------------------------- expected due to this value\n\
    ...\n24 |             max = pivot;\n   |                   ^^^^^\n   |       \
    \            |\n   |                   expected `&isize`, found `isize`\n   |\
    \                   help: consider borrowing here: `&pivot`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp"
  stdout: ''
  timestamp: 1660010734
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut vec: Vec<isize> = vec![0; lst.len()];\n\
    \    let mut counter: usize = 0;\n    for val in lst {\n        vec[counter] =\
    \ val;\n        counter = counter + 1;\n    }\n    while counter < lst.len() {\n\
    \        for val in lst.iter_mut() {\n            **val = (counter - 1) + 1;\n\
    \        }\n        counter = counter + 1;\n    }\n    vec\n}\n\nfn main() {\n\
    \    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5,\
    \ 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2,\
    \ 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8,\
    \ 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n  \
    \  assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpqkwxze5i.rs:20:13\n\
    \   |\n20 |             **val = (counter - 1) + 1;\n   |             ^^^^^\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1660010734
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = lst;\n    while sorted_list.len()\
    \ > 1 {\n        let mut min_val = sorted_list.remove(0);\n        let mut max_val\
    \ = sorted_list.remove(0);\n        for val in sorted_list.iter() {\n        \
    \    if val < min_val {\n                min_val = val;\n            }\n     \
    \       if val > max_val {\n                max_val = val;\n            }\n  \
    \      }\n        sorted_list.push(min_val);\n        sorted_list.push(max_val);\n\
    \    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjjbg49ln.rs:17:22\n   |\n\
    17 |             if val < min_val {\n   |                      ^^^^^^^\n   | \
    \                     |\n   |                      expected `&isize`, found `isize`\n\
    \   |                      help: consider borrowing here: `&min_val`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpjjbg49ln.rs:18:27\n   |\n14 |         let mut\
    \ min_val = sorted_list.remove(0);\n   |                           ---------------------\
    \ expected due to this value\n...\n18 |                 min_val = val;\n   | \
    \                          ^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n18 |                 min_val = *val;\n   | \
    \                          +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjjbg49ln.rs:20:22\n\
    \   |\n20 |             if val > max_val {\n   |                      ^^^^^^^\n\
    \   |                      |\n   |                      expected `&isize`, found\
    \ `isize`\n   |                      help: consider borrowing here: `&max_val`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpjjbg49ln.rs:21:27\n   |\n15 |\
    \         let mut max_val = sorted_list.remove(0);\n   |                     \
    \      --------------------- expected due to this value\n...\n21 |           \
    \      max_val = val;\n   |                           ^^^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n21 |        \
    \         max_val = *val;\n   |                           +\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010734
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut list = lst;\n    list.sort();\n   \
    \ list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpeiv3r_qg.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010734
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    debug_assert!(lst.len() > 0);\n\n    let mut\
    \ vec = Vec::with_capacity(lst.len());\n    for &num in &lst {\n        let max\
    \ = num;\n        let min = *std::cmp::min(&num, &max);\n        *vec.push(*min);\n\
    \        *vec.push(*max);\n    }\n    vec\n}\n\nfn main() {\n    let candidate\
    \ = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5,\
    \ 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmppbgv2g45.rs:18:19\n\
    \   |\n18 |         *vec.push(*min);\n   |                   ^^^^\n\nerror[E0614]:\
    \ type `()` cannot be dereferenced\n  --> /tmp/tmppbgv2g45.rs:18:9\n   |\n18 |\
    \         *vec.push(*min);\n   |         ^^^^^^^^^^^^^^^\n\nerror[E0614]: type\
    \ `isize` cannot be dereferenced\n  --> /tmp/tmppbgv2g45.rs:19:19\n   |\n19 |\
    \         *vec.push(*max);\n   |                   ^^^^\n\nerror[E0614]: type\
    \ `()` cannot be dereferenced\n  --> /tmp/tmppbgv2g45.rs:19:9\n   |\n19 |    \
    \     *vec.push(*max);\n   |         ^^^^^^^^^^^^^^^\n\nerror: aborting due to\
    \ 4 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0614`.\n"
  stdout: ''
  timestamp: 1660010734
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut min_int = std::i32::MAX;\n    let mut\
    \ max_int = std::i32::MIN;\n    for x in lst.iter() {\n        if x < min_int\
    \ {\n            min_int = x;\n        }\n        if x > max_int {\n         \
    \   max_int = x;\n        }\n    }\n    let mut tmp = vec![min_int; max_int.saturating_sub(min_int)\
    \ + 1];\n    for x in lst.iter() {\n        tmp[x - min_int] = x;\n    }\n   \
    \ tmp\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1hdk4vx0.rs:15:16\n   |\n\
    15 |         if x < min_int {\n   |                ^^^^^^^ expected `&isize`,\
    \ found `i32`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1hdk4vx0.rs:16:23\n\
    \   |\n12 |     let mut min_int = std::i32::MAX;\n   |                       -------------\
    \ expected due to this value\n...\n16 |             min_int = x;\n   |       \
    \                ^ expected `i32`, found `&isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp1hdk4vx0.rs:18:16\n   |\n18 |         if x > max_int {\n\
    \   |                ^^^^^^^ expected `&isize`, found `i32`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp1hdk4vx0.rs:19:23\n   |\n13 |     let mut max_int = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n19\
    \ |             max_int = x;\n   |                       ^ expected `i32`, found\
    \ `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1hdk4vx0.rs:22:33\n\
    \   |\n22 |     let mut tmp = vec![min_int; max_int.saturating_sub(min_int) +\
    \ 1];\n   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `usize`, found `i32`\n   |\nhelp: you can convert an `i32` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n22 |     let mut tmp = vec![min_int;\
    \ (max_int.saturating_sub(min_int) + 1).try_into().unwrap()];\n   |          \
    \                       +                                   +++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp1hdk4vx0.rs:24:17\n   |\n24 |\
    \         tmp[x - min_int] = x;\n   |                 ^^^^^^^ expected `isize`,\
    \ found `i32`\n\nerror[E0277]: cannot subtract `i32` from `&isize`\n  --> /tmp/tmp1hdk4vx0.rs:24:15\n\
    \   |\n24 |         tmp[x - min_int] = x;\n   |               ^ no implementation\
    \ for `&isize - i32`\n   |\n   = help: the trait `Sub<i32>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `Sub<Rhs>`:\n\
    \             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n    \
    \         <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n      \
    \       <&'a i32 as Sub<"
  stdout: ''
  timestamp: 1660010734
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut i = lst.iter().cloned().collect::<Vec<isize>>();\n\
    \    i.sort_by_key(|x| {\n        i.binary_search_by(|&x| x).unwrap()\n    });\n\
    \    i.into_iter().collect()\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp76nhevxu.rs:14:33\n   |\n\
    14 |         i.binary_search_by(|&x| x).unwrap()\n   |                       \
    \          ^ expected enum `std::cmp::Ordering`, found `isize`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010734
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = lst;\n\n    for i in\
    \ 1..=sorted_list.len() {\n        let mut min = i;\n        for j in 0..i-1 {\n\
    \            if sorted_list[j] < sorted_list[min] {\n                min = j;\n\
    \            }\n        }\n\n        if min != i {\n            sorted_list.swap(i,\
    \ min);\n        }\n    }\n\n    sorted_list\n}\n\nfn main() {\n    let candidate\
    \ = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5,\
    \ 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 4 but the
    index is 4'', /tmp/tmpyi9mofjl.rs:17:33

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010734
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    lst.sort_unstable();\n    lst\n}\n\nfn main()\
    \ {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `lst` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpnvoeazh3.rs:12:5\n   |\n11 | fn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n   |                      --- help: consider changing\
    \ this to be mutable: `mut lst`\n12 |     lst.sort_unstable();\n   |     ^^^^^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1660010734
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    lst\n        .iter()\n        .cloned()\n \
    \       .chain(\n            lst.iter().cloned().rev().chain(\n              \
    \  lst.iter().cloned().rev().cloned(),\n            ),\n        )\n        .cloned()\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<std::slice::Iter<'_, isize> as\
    \ Iterator>::Item == &&_`\n    --> /tmp/tmppiys4s4w.rs:17:43\n     |\n17   | \
    \                lst.iter().cloned().rev().cloned(),\n     |                 \
    \                          ^^^^^^ expected reference, found `isize`\n     |\n\
    \     = note: expected reference `&&_`\n                found reference `&isize`\n\
    \     = note: required because of the requirements on the impl of `Iterator` for\
    \ `Cloned<std::slice::Iter<'_, isize>>`\nnote: required by a bound in `cloned`\n\
    \nerror[E0271]: type mismatch resolving `<std::slice::Iter<'_, isize> as Iterator>::Item\
    \ == &&isize`\n   --> /tmp/tmppiys4s4w.rs:17:17\n    |\n16  |             lst.iter().cloned().rev().chain(\n\
    \    |                                       ----- required by a bound introduced\
    \ by this call\n17  |                 lst.iter().cloned().rev().cloned(),\n  \
    \  |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&isize`, found\
    \ `isize`\n    |\n    = note: expected reference `&&isize`\n               found\
    \ reference `&isize`\n    = note: required because of the requirements on the\
    \ impl of `Iterator` for `Cloned<std::slice::Iter<'_, isize>>`\n    = note: 1\
    \ redundant requirement hidden\n    = note: required because of the requirements\
    \ on the impl of `Iterator` for `Cloned<Rev<Cloned<std::slice::Iter<'_, isize>>>>`\n\
    note: required by a bound in `std::iter::Iterator::chain`\n\nerror[E0271]: type\
    \ mismatch resolving `<std::slice::Iter<'_, isize> as Iterator>::Item == &&isize`\n\
    \   --> /tmp/tmppiys4s4w.rs:16:13\n    |\n15  |           .chain(\n    |     \
    \       ----- required by a bound introduced by this call\n16  | /           \
    \  lst.iter().cloned().rev().chain(\n17  | |                 lst.iter().cloned().rev().cloned(),\n\
    18  | |             ),\n    | |_____________^ expected `&isize`, found `isize`\n\
    \    |\n    = note: expected reference `&&isize`\n               found reference\
    \ `&isize`\n    = note: required because of the requirements on the impl of `Iterator`\
    \ for `Cloned<std::slice::Iter<'_, isize>>`\n    = note: 2 redundant requi"
  stdout: ''
  timestamp: 1660010734
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut new_lst = vec![];\n    new_lst = sort_helper(\n\
    \        lst,\n        &mut new_lst,\n        &mut None,\n        |l, r| l.cmp(r).unwrap(),\n\
    \    );\n    new_lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `sort_helper` in this scope\n  --> /tmp/tmpyug2623l.rs:13:15\n\
    \   |\n13 |     new_lst = sort_helper(\n   |               ^^^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010734
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut lst = lst.clone();\n    lst.sort_unstable_by_key(|x|\
    \ {\n        std::cmp::max(x.0, x.1)\n    });\n    lst\n}\n\nfn main() {\n   \
    \ let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]),\
    \ vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9,\
    \ 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6,\
    \ 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0609]: no field `0` on type `&isize`\n  --> /tmp/tmpmy9f3hp2.rs:14:25\n\
    \   |\n14 |         std::cmp::max(x.0, x.1)\n   |                         ^\n\n\
    error[E0609]: no field `1` on type `&isize`\n  --> /tmp/tmpmy9f3hp2.rs:14:30\n\
    \   |\n14 |         std::cmp::max(x.0, x.1)\n   |                            \
    \  ^\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0609`.\n"
  stdout: ''
  timestamp: 1660010734
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    lst.sort_unstable_by_key(|x| x.wrapping_add());\n\
    \    lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \   --> /tmp/tmpfyj2mvk5.rs:12:36\n    |\n12  |     lst.sort_unstable_by_key(|x|\
    \ x.wrapping_add());\n    |                                    ^^^^^^^^^^^^- supplied\
    \ 0 arguments\n    |                                    |\n    |             \
    \                       expected 1 argument\n    |\nnote: associated function\
    \ defined here\n    = note: this error originates in the macro `int_impl` (in\
    \ Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0061`.\n"
  stdout: ''
  timestamp: 1660010734
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    if lst.is_empty() {\n        return vec![];\n\
    \    }\n    let mut result = vec![lst[0]];\n    let first_index = first_non_zero(lst);\n\
    \    for i in 1..first_index {\n        let j = first_index;\n        while j\
    \ > 0 && lst[j] < lst[j-1] {\n            result.swap(j, j-1);\n            j--;\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpnem657wb.rs:21:16\n\
    \   |\n21 |             j--;\n   |                ^ expected expression\n\nerror[E0425]:\
    \ cannot find function `first_non_zero` in this scope\n  --> /tmp/tmpnem657wb.rs:16:23\n\
    \   |\n16 |     let first_index = first_non_zero(lst);\n   |                 \
    \      ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010734
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    lst\n        .iter()\n        .cloned()\n \
    \       .map(|x| x.swap_removed(x))\n        .collect()\n}\n\nfn main() {\n  \
    \  let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5,\
    \ 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2,\
    \ 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8,\
    \ 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n  \
    \  assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `swap_removed` found for type `isize` in\
    \ the current scope\n  --> /tmp/tmp2zaci_k7.rs:15:20\n   |\n15 |         .map(|x|\
    \ x.swap_removed(x))\n   |                    ^^^^^^^^^^^^ method not found in\
    \ `isize`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010734
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    lst.sort_by_key(|x| {\n        (x * -1) as\
    \ isize\n    })\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n  \
    \  assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpeabgkms3.rs:12:5\n   |\n\
    11 |   fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |           \
    \                                 ---------- expected `Vec<isize>` because of\
    \ return type\n12 | /     lst.sort_by_key(|x| {\n13 | |         (x * -1) as isize\n\
    14 | |     })\n   | |______^ expected struct `Vec`, found `()`\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010734
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    if lst.len() <= 1 {\n        return vec![];\n\
    \    }\n    let mut min = lst[0];\n    let mut max = lst[0];\n    for x in lst.iter()\
    \ {\n        if x < min {\n            min = x;\n        }\n        if x > max\
    \ {\n            max = x;\n        }\n    }\n\n    let mut result = vec![];\n\
    \    let mut i = 1;\n    while i <= lst.len() {\n        if min == max {\n   \
    \         result.push(min);\n            i += 1;\n        } else {\n         \
    \   result.push(min + (max - min) / 2);\n        }\n    }\n\n    return result;\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgzpnfq8y.rs:18:16\n   |\n\
    18 |         if x < min {\n   |                ^^^\n   |                |\n  \
    \ |                expected `&isize`, found `isize`\n   |                help:\
    \ consider borrowing here: `&min`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgzpnfq8y.rs:19:19\n\
    \   |\n15 |     let mut min = lst[0];\n   |                   ------ expected\
    \ due to this value\n...\n19 |             min = x;\n   |                   ^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n19 |             min = *x;\n   |                   +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpgzpnfq8y.rs:21:16\n   |\n21 |         if x > max {\n  \
    \ |                ^^^\n   |                |\n   |                expected `&isize`,\
    \ found `isize`\n   |                help: consider borrowing here: `&max`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpgzpnfq8y.rs:22:19\n   |\n16 |  \
    \   let mut max = lst[0];\n   |                   ------ expected due to this\
    \ value\n...\n22 |             max = x;\n   |                   ^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n22 |  \
    \           max = *x;\n   |                   +\n\nerror: aborting due to 4 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010734
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut vec_res = Vec::new();\n    let mut\
    \ vec_lst = lst.clone();\n    vec_res.push(vec_lst.iter().min().unwrap());\n \
    \   while vec_lst.len() != 0 {\n        let mut vec_min = vec_lst.iter().min().unwrap();\n\
    \        let mut vec_max = vec_lst.iter().max().unwrap();\n        vec_res.push(vec_min);\n\
    \        vec_res.push(vec_max);\n        vec_lst.swap(vec_min, vec_max);\n   \
    \ }\n    vec_res\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5xo5hmda.rs:20:22\n   |\n\
    20 |         vec_lst.swap(vec_min, vec_max);\n   |                      ^^^^^^^\
    \ expected `usize`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5xo5hmda.rs:20:31\n\
    \   |\n20 |         vec_lst.swap(vec_min, vec_max);\n   |                    \
    \           ^^^^^^^ expected `usize`, found `&isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp5xo5hmda.rs:22:5\n   |\n11 | fn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n   |                                          ----------\
    \ expected `Vec<isize>` because of return type\n...\n22 |     vec_res\n   |  \
    \   ^^^^^^^ expected `isize`, found `&isize`\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n              found struct `Vec<&isize>`\n\nerror: aborting due\
    \ to 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010734
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    if lst.len() == 0 {\n        vec![]\n    }\
    \ else {\n        let mut max = lst.iter().max().unwrap();\n        let mut min\
    \ = lst.iter().min().unwrap();\n        let mut new_lst = vec![];\n        loop\
    \ {\n            new_lst.push(min);\n            if min > max {\n            \
    \    break;\n            }\n            max = lst.iter().max().unwrap();\n   \
    \         min = lst.iter().min().unwrap();\n        }\n        new_lst.push(max);\n\
    \        new_lst.push(min);\n        new_lst\n    }\n}\n\nfn main() {\n    let\
    \ candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]),\
    \ vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9,\
    \ 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6,\
    \ 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptwmol5ow.rs:28:9\n   |\n\
    11 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |             \
    \                             ---------- expected `Vec<isize>` because of return\
    \ type\n...\n28 |         new_lst\n   |         ^^^^^^^ expected `isize`, found\
    \ `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n              found\
    \ struct `Vec<&isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010734
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut min_value = lst.min_by_key(|x| *x).unwrap();\n\
    \    let mut max_value = lst.max_by_key(|x| *x).unwrap();\n    let mut new_lst\
    \ = Vec::new();\n    while min_value <= max_value {\n        let idx = lst.iter().position(|x|\
    \ *x == min_value).unwrap();\n        if idx < lst.len() {\n            new_lst.push(min_value);\n\
    \            new_lst.push(lst[idx]);\n            new_lst.push(max_value);\n \
    \       }\n        min_value = max_value;\n        max_value = min_value;\n  \
    \  }\n    new_lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: `Vec<isize>` is not an iterator\n   --> /tmp/tmpb6z0ol63.rs:12:29\n\
    \    |\n12  |       let mut min_value = lst.min_by_key(|x| *x).unwrap();\n   \
    \ |                               ^^^^^^^^^^ `Vec<isize>` is not an iterator\n\
    \    |\n    = note: the following trait bounds were not satisfied:\n         \
    \   `Vec<isize>: Iterator`\n            which is required by `&mut Vec<isize>:\
    \ Iterator`\n            `[isize]: Iterator`\n            which is required by\
    \ `&mut [isize]: Iterator`\n\nerror[E0599]: `Vec<isize>` is not an iterator\n\
    \   --> /tmp/tmpb6z0ol63.rs:13:29\n    |\n13  |       let mut max_value = lst.max_by_key(|x|\
    \ *x).unwrap();\n    |                               ^^^^^^^^^^ `Vec<isize>` is\
    \ not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Vec<isize>: Iterator`\n            which is required by `&mut Vec<isize>:\
    \ Iterator`\n            `[isize]: Iterator`\n            which is required by\
    \ `&mut [isize]: Iterator`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010734
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut v = lst.iter().cloned().collect();\n\
    \    let mut n = v.len();\n    while n > 1 {\n        if n % 2 == 0 {\n      \
    \      v.swap(0, n - 1);\n        }\n        n /= 2;\n    }\n    v\n}\n\nfn main()\
    \ {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmp8ercxaw_.rs:13:17\n\
    \   |\n12 |     let mut v = lst.iter().cloned().collect();\n   |         -----\
    \ consider giving `v` a type\n13 |     let mut n = v.len();\n   |            \
    \     ^ cannot infer type\n   |\n   = note: type must be known at this point\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1660010734
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut max = lst.clone();\n    let mut min_val\
    \ = max[0];\n    for (i, elem) in lst.iter().enumerate() {\n        if elem >\
    \ min_val {\n            min_val = *max;\n            max[i] = elem\n        }\
    \ else {\n            max[i] = min_val;\n        }\n    }\n    return max\n}\n\
    \nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpuyttmx95.rs:15:19\n   |\n\
    15 |         if elem > min_val {\n   |                   ^^^^^^^\n   |       \
    \            |\n   |                   expected `&isize`, found `isize`\n   |\
    \                   help: consider borrowing here: `&min_val`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpuyttmx95.rs:16:23\n   |\n13 |     let mut min_val\
    \ = max[0];\n   |                       ------ expected due to this value\n...\n\
    16 |             min_val = *max;\n   |                       ^^^^ expected `isize`,\
    \ found slice `[isize]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpuyttmx95.rs:17:22\n\
    \   |\n17 |             max[i] = elem\n   |             ------   ^^^^ expected\
    \ `isize`, found `&isize`\n   |             |\n   |             expected due to\
    \ the type of this binding\n   |\nhelp: consider dereferencing the borrow\n  \
    \ |\n17 |             max[i] = *elem\n   |                      +\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010734
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut min = i32::MAX;\n    let mut max =\
    \ i32::MIN;\n    let mut i = 0;\n    for elt in lst.iter() {\n        if elt <\
    \ min {\n            min = elt\n        }\n        if elt > max {\n          \
    \  max = elt\n        }\n        i += 1;\n    }\n    let mut newlst = vec![];\n\
    \    while i < lst.len() {\n        let elt = lst[i];\n        newlst.push(elt);\n\
    \        if elt < min {\n            min = elt\n        }\n        if elt > max\
    \ {\n            max = elt\n        }\n        i += 1;\n    }\n    vec![min..max]\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0rtn7cb8.rs:16:18\n   |\n\
    16 |         if elt < min {\n   |                  ^^^ expected `&isize`, found\
    \ `i32`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0rtn7cb8.rs:17:19\n \
    \  |\n12 |     let mut min = i32::MAX;\n   |                   -------- expected\
    \ due to this value\n...\n17 |             min = elt\n   |                   ^^^\
    \ expected `i32`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0rtn7cb8.rs:19:18\n\
    \   |\n19 |         if elt > max {\n   |                  ^^^ expected `&isize`,\
    \ found `i32`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0rtn7cb8.rs:20:19\n\
    \   |\n13 |     let mut max = i32::MIN;\n   |                   -------- expected\
    \ due to this value\n...\n20 |             max = elt\n   |                   ^^^\
    \ expected `i32`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0rtn7cb8.rs:28:18\n\
    \   |\n28 |         if elt < min {\n   |                  ^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n28 |         if elt < min.try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp0rtn7cb8.rs:29:19\n   |\n12 |     let mut min = i32::MAX;\n\
    \   |                   -------- expected due to this value\n...\n29 |       \
    \      min = elt\n   |                   ^^^ expected `i32`, found `isize`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp0rtn7cb8.rs:31:18\n   |\n31 |  \
    \       if elt > max {\n   |                  ^^^ expected `isize`, found `i32`\n\
    \   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n31 |         if elt > max.try_into().unwrap() {\n \
    \  |                     ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp0rtn7cb8.rs:32:19\n   |\n13 |     let mut max = i32::MIN;\n   |\
    \                   -------- expected due to this value\n...\n32 |           \
    \  max = elt\n   |                   ^^^ expected `i32`, found `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp0rt"
  stdout: ''
  timestamp: 1660010734
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut res = Vec::new();\n    let mut min_val\
    \ = std::i32::MAX;\n    for i in lst {\n        min_val = std::cmp::min(min_val,\
    \ i);\n    }\n\n    for i in lst {\n        // use < instead of cmp, because we\
    \ need to get min first.\n        if i < min_val {\n            min_val = i;\n\
    \        }\n        res.push(i);\n    }\n\n    res.reverse();\n    res\n}\n\n\
    fn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmps_s43rod.rs:15:42\n   |\n\
    15 |         min_val = std::cmp::min(min_val, i);\n   |                      \
    \                    ^ expected `i32`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to an `i32` and panic if the converted value doesn't fit\n   |\n\
    15 |         min_val = std::cmp::min(min_val, i.try_into().unwrap());\n   |  \
    \                                         ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmps_s43rod.rs:20:16\n   |\n20 |         if i <\
    \ min_val {\n   |                ^^^^^^^ expected `isize`, found `i32`\n   |\n\
    help: you can convert an `i32` to an `isize` and panic if the converted value\
    \ doesn't fit\n   |\n20 |         if i < min_val.try_into().unwrap() {\n   | \
    \                      ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmps_s43rod.rs:21:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n21\
    \ |             min_val = i;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010734
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut ret = vec![];\n    for x in lst {\n\
    \        if x == ret.last() {\n            continue;\n        }\n        if x\
    \ == ret.first() {\n            ret.pop();\n            continue;\n        }\n\
    \        ret.swap_remove(&x);\n    }\n    ret\n}\n\nfn main() {\n    let candidate\
    \ = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5,\
    \ 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpy5xg4iu5.rs:14:17\n   |\n\
    14 |         if x == ret.last() {\n   |                 ^^^^^^^^^^ expected `isize`,\
    \ found enum `Option`\n   |\n   = note: expected type `isize`\n              found\
    \ enum `Option<&_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpy5xg4iu5.rs:17:17\n\
    \   |\n17 |         if x == ret.first() {\n   |                 ^^^^^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<&_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpy5xg4iu5.rs:21:25\n\
    \   |\n21 |         ret.swap_remove(&x);\n   |                         ^^ expected\
    \ `usize`, found `&isize`\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010734
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut ret = Vec::new();\n    let mut min\
    \ = lst.min();\n    let mut max = lst.max();\n\n    // While the list is sorted\
    \ and we still have more elements\n    while lst.len() > 0 {\n        // If our\
    \ min is greater than the max we swap them now\n        if min > max {\n     \
    \       ret.push(min);\n            min = max.cmp(&min).unwrap();\n          \
    \  ret.push(max);\n            max = min.cmp(&max).unwrap();\n        } else {\n\
    \            ret.push(max);\n            min = min.cmp(&max).unwrap();\n     \
    \   }\n\n        // Move all elements after the min to the end of the vector\n\
    \        lst.drain(..);\n        // Move all elements before min to the beginning\
    \ of the vector\n        lst.insert(0, min);\n    }\n    ret\n}\n\nfn main() {\n\
    \    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5,\
    \ 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2,\
    \ 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8,\
    \ 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n  \
    \  assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \   --> /tmp/tmpkdqyetq4.rs:13:23\n    |\n13  |     let mut min = lst.min();\n\
    \    |                       ^^^- supplied 0 arguments\n    |                \
    \       |\n    |                       expected 1 argument\n    |\nnote: associated\
    \ function defined here\n\nerror[E0061]: this function takes 1 argument but 0\
    \ arguments were supplied\n   --> /tmp/tmpkdqyetq4.rs:14:23\n    |\n14  |    \
    \ let mut max = lst.max();\n    |                       ^^^- supplied 0 arguments\n\
    \    |                       |\n    |                       expected 1 argument\n\
    \    |\nnote: associated function defined here\n\nerror[E0599]: no method named\
    \ `unwrap` found for enum `std::cmp::Ordering` in the current scope\n  --> /tmp/tmpkdqyetq4.rs:21:33\n\
    \   |\n21 |             min = max.cmp(&min).unwrap();\n   |                  \
    \               ^^^^^^ method not found in `std::cmp::Ordering`\n\nerror[E0599]:\
    \ no method named `unwrap` found for enum `std::cmp::Ordering` in the current\
    \ scope\n  --> /tmp/tmpkdqyetq4.rs:23:33\n   |\n23 |             max = min.cmp(&max).unwrap();\n\
    \   |                                 ^^^^^^ method not found in `std::cmp::Ordering`\n\
    \nerror[E0599]: no method named `unwrap` found for enum `std::cmp::Ordering` in\
    \ the current scope\n  --> /tmp/tmpkdqyetq4.rs:26:33\n   |\n26 |             min\
    \ = min.cmp(&max).unwrap();\n   |                                 ^^^^^^ method\
    \ not found in `std::cmp::Ordering`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkdqyetq4.rs:32:23\n\
    \   |\n32 |         lst.insert(0, min);\n   |                       ^^^ expected\
    \ `isize`, found struct `Vec`\n   |\n   = note: expected type `isize`\n      \
    \      found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkdqyetq4.rs:34:5\n\
    \   |\n11 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |      \
    \                                    ---------- expected `Vec<isize>` because\
    \ of return type\n...\n34 |     ret\n   |     ^^^ expected `isize`, found struct\
    \ `Vec`\n   |\n   = note: expected struct `Vec<isize>`\n          "
  stdout: ''
  timestamp: 1660010734
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = vec![];\n    for i in 0..(lst.len()\
    \ - 1) {\n        let mut j = 0;\n        for j in (j..(result.len() - 1)) .filter(|x|\
    \ {\n            (i as usize) < x\n        }) {\n            result.swap(j, j\
    \ + 1);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkrcag17c.rs:16:28\n   |\n\
    16 |             (i as usize) < x\n   |                            ^ expected\
    \ `usize`, found `&usize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    16 |             (i as usize) < *x\n   |                            +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010734
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut slst = lst;\n\n    slst.sort_unstable();\n\
    \n    slst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpbancgi_y.rs:21:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    lst.iter().cloned().windows(2).flat_map(|window|\
    \ {\n        window.iter().chain(window).cloned()\n    })\n}\n\nfn main() {\n\
    \    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5,\
    \ 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2,\
    \ 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8,\
    \ 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n  \
    \  assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `windows` found for struct `Cloned` in the\
    \ current scope\n  --> /tmp/tmpq1kgi9ye.rs:12:25\n   |\n12 |     lst.iter().cloned().windows(2).flat_map(|window|\
    \ {\n   |                         ^^^^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010734
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    lst.sort();\n    lst\n}\n\nfn main() {\n  \
    \  let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5,\
    \ 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2,\
    \ 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8,\
    \ 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n  \
    \  assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `lst` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmprgvby9nl.rs:12:5\n   |\n11 | fn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n   |                      --- help: consider changing\
    \ this to be mutable: `mut lst`\n12 |     lst.sort();\n   |     ^^^^^^^^^^ cannot\
    \ borrow as mutable\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1660010734
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut new_lst = vec![];\n    let mut min_val\
    \ = lst.iter().min();\n    let mut max_val = lst.iter().max();\n    let mut min_idx\
    \ = lst.iter().position(|x| *x == min_val);\n    let mut max_idx = lst.iter().position(|x|\
    \ *x == max_val);\n    while min_idx < max_idx {\n        new_lst.push(*min_val);\n\
    \        min_val.swap(max_val);\n        min_idx = lst.iter().position(|x| *x\
    \ == min_val);\n        max_idx = lst.iter().position(|x| *x == max_val);\n  \
    \  }\n    new_lst.extend(min_val.cloned().chain(*max_val.cloned()));\n    new_lst\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprha29ouw.rs:15:53\n   |\n\
    15 |     let mut min_idx = lst.iter().position(|x| *x == min_val);\n   |     \
    \                                                ^^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected type `isize`\n              found enum\
    \ `Option<&isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprha29ouw.rs:16:53\n\
    \   |\n16 |     let mut max_idx = lst.iter().position(|x| *x == max_val);\n  \
    \ |                                                     ^^^^^^^ expected `isize`,\
    \ found enum `Option`\n   |\n   = note: expected type `isize`\n              found\
    \ enum `Option<&isize>`\n\nerror[E0614]: type `Option<&isize>` cannot be dereferenced\n\
    \  --> /tmp/tmprha29ouw.rs:18:22\n   |\n18 |         new_lst.push(*min_val);\n\
    \   |                      ^^^^^^^^\n\nerror[E0599]: no method named `swap` found\
    \ for enum `Option` in the current scope\n  --> /tmp/tmprha29ouw.rs:19:17\n  \
    \ |\n19 |         min_val.swap(max_val);\n   |                 ^^^^ method not\
    \ found in `Option<&isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprha29ouw.rs:20:49\n\
    \   |\n20 |         min_idx = lst.iter().position(|x| *x == min_val);\n   |  \
    \                                               ^^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected type `isize`\n              found enum\
    \ `Option<&isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprha29ouw.rs:21:49\n\
    \   |\n21 |         max_idx = lst.iter().position(|x| *x == max_val);\n   |  \
    \                                               ^^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected type `isize`\n              found enum\
    \ `Option<&isize>`\n\nerror[E0599]: `Option<isize>` is not an iterator\n   -->\
    \ /tmp/tmprha29ouw.rs:23:37\n    |\n23  |       new_lst.extend(min_val.cloned().chain(*max_val.cloned()));\n\
    \    |                                       ^^^^^ `Option<isize>` is not an iterator\n\
    \    |\n    = note: the following trait bounds were not satisfied:\n         \
    \   `Option<isize>: Iterator`\n            which is required by `&mut Option<isize>:"
  stdout: ''
  timestamp: 1660010734
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut lst_sorted = lst;\n    for elt in lst_sorted.iter().rev()\
    \ {\n        let mut index = lst_sorted.iter().position(|x| x == elt).unwrap();\n\
    \        let last = lst_sorted.iter().position(|x| x == elt).unwrap_or(&lst_sorted.len());\n\
    \        let mut swapped = false;\n        for (idx, next_elt) in lst_sorted.iter().cloned().enumerate()\
    \ {\n            if idx == index {\n                index -= 1;\n            \
    \    swapped = true;\n            }\n            if idx == last && swapped {\n\
    \                lst_sorted.swap(idx, index - 1);\n                swapped = false;\n\
    \            }\n        }\n    }\n    lst_sorted\n}\n\nfn main() {\n    let candidate\
    \ = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5,\
    \ 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqtlxvhxz.rs:15:71\n   |\n\
    15 |         let last = lst_sorted.iter().position(|x| x == elt).unwrap_or(&lst_sorted.len());\n\
    \   |                                                                       ^^^^^^^^^^^^^^^^^\
    \ expected `usize`, found `&usize`\n   |\nhelp: consider removing the borrow\n\
    \   |\n15 -         let last = lst_sorted.iter().position(|x| x == elt).unwrap_or(&lst_sorted.len());\n\
    15 +         let last = lst_sorted.iter().position(|x| x == elt).unwrap_or(lst_sorted.len());\n\
    \   | \n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010734
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut list = lst;\n\n    // First move the\
    \ smallest item to the front of the list\n    list.swap(0, 0);\n\n    // Sort\
    \ all the other items\n    let mut i = 0;\n    let mut j = 0;\n    while i < list.len()\
    \ {\n        // Look for item in the rest of the list that's greater than list[i]\n\
    \        // We use < instead of <= because list[i] may be at the start or end\
    \ of the\n        // list depending on whether it's sorted in ascending or descending\
    \ order\n        while j < list.len() && (*list).less(&list[j]) {\n          \
    \  j = j + 1;\n        }\n\n        if j == list.len() {\n            break;\n\
    \        }\n\n        // Swap the items at positions i and j\n        list.swap(i,\
    \ j);\n\n        // Increment i and j\n        i = i + 1;\n        j = j + 1;\n\
    \    }\n\n    // Return the list with the smallest item at position 0\n    list\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `less` found for slice `[isize]` in the current\
    \ scope\n  --> /tmp/tmp965ag8na.rs:24:41\n   |\n24 |         while j < list.len()\
    \ && (*list).less(&list[j]) {\n   |                                         ^^^^\
    \ method not found in `[isize]`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010734
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    if lst.is_empty() {\n        vec![]\n    }\n\
    \    else {\n        fn min(a: isize, b: isize) -> isize {\n            if a >\
    \ b {\n                a\n            }\n            else {\n                b\n\
    \            }\n        }\n        let mut min = lst[0];\n        let mut max\
    \ = lst[0];\n        for i in 1..lst.len() {\n            if min > lst[i] {\n\
    \                min = lst[i];\n            }\n            if max < lst[i] {\n\
    \                max = lst[i];\n            }\n        }\n        let mut rev\
    \ = vec![];\n        for i in min..max {\n            rev.push(lst[i]);\n    \
    \    }\n        rev\n    }\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp6gv03w8r.rs:36:22\n\
    \   |\n36 |             rev.push(lst[i]);\n   |                      ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010734
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut m = vec![vec![]; lst.len()];\n    for\
    \ x in lst {\n        m[x as usize].push(x);\n    }\n    for (x, v) in m.iter_mut().enumerate()\
    \ {\n        v.sort();\n    }\n    for (x, v) in m.iter_mut().enumerate() {\n\
    \        v.sort();\n    }\n    let mut new_v = vec![];\n    for (x, v) in m.iter().enumerate()\
    \ {\n        new_v.append(v[x as usize]);\n    }\n    new_v\n}\n\nfn main() {\n\
    \    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5,\
    \ 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2,\
    \ 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8,\
    \ 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n  \
    \  assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1mgsmcym.rs:24:22\n   |\n\
    24 |         new_v.append(v[x as usize]);\n   |                      ^^^^^^^^^^^^^\
    \ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference\
    \ `&mut Vec<_>`\n                           found type `isize`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010734
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut list = lst.clone();\n    let mut min_value\
    \ = list.min_by_key(|x| x);\n    let mut max_value = list.max_by_key(|x| x);\n\
    \    list.push(min_value);\n    list.push(max_value);\n    while list.len() >\
    \ 2 {\n        min_value = list.iter().cloned().next().unwrap();\n        max_value\
    \ = list.iter().cloned().next().unwrap();\n        list.push(min_value);\n   \
    \     list.push(max_value);\n    }\n    list\n}\n\nfn main() {\n    let candidate\
    \ = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5,\
    \ 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `Vec<isize>` is not an iterator\n   --> /tmp/tmp51rarlpf.rs:13:30\n\
    \    |\n13  |       let mut min_value = list.min_by_key(|x| x);\n    |       \
    \                         ^^^^^^^^^^ `Vec<isize>` is not an iterator\n    |\n\
    \    = note: the following trait bounds were not satisfied:\n            `Vec<isize>:\
    \ Iterator`\n            which is required by `&mut Vec<isize>: Iterator`\n  \
    \          `[isize]: Iterator`\n            which is required by `&mut [isize]:\
    \ Iterator`\n\nerror[E0599]: `Vec<isize>` is not an iterator\n   --> /tmp/tmp51rarlpf.rs:14:30\n\
    \    |\n14  |       let mut max_value = list.max_by_key(|x| x);\n    |       \
    \                         ^^^^^^^^^^ `Vec<isize>` is not an iterator\n    |\n\
    \    = note: the following trait bounds were not satisfied:\n            `Vec<isize>:\
    \ Iterator`\n            which is required by `&mut Vec<isize>: Iterator`\n  \
    \          `[isize]: Iterator`\n            which is required by `&mut [isize]:\
    \ Iterator`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010734
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    if lst.len() == 0 {\n        return vec![];\n\
    \    }\n    if lst.len() == 1 {\n        return vec![lst[0]];\n    }\n    let\
    \ mut x = lst[0];\n    let mut y = vec![];\n    let mut z = vec![];\n    let mut\
    \ i = 0;\n    while i < lst.len() {\n        if x != lst[i] {\n            y.push(z);\n\
    \            z = vec![];\n            x = lst[i];\n        }\n        z.push(lst[i]);\n\
    \        i += 1;\n    }\n    y.push(z);\n    return y;\n}\n\nfn main() {\n   \
    \ let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]),\
    \ vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9,\
    \ 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6,\
    \ 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprz9pvp1_.rs:32:12\n   |\n\
    11 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |             \
    \                             ---------- expected `Vec<isize>` because of return\
    \ type\n...\n32 |     return y;\n   |            ^ expected `isize`, found struct\
    \ `Vec`\n   |\n   = note: expected struct `Vec<isize>`\n              found struct\
    \ `Vec<Vec<isize>>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010734
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted = vec![lst[0]];\n    for x in\
    \ lst.iter().skip(1) {\n        sorted.push(x);\n    }\n    for x in sorted.iter().rev()\
    \ {\n        sorted.push(x);\n    }\n    for x in sorted.iter().skip(1) {\n  \
    \      sorted.push(x);\n    }\n    for x in sorted.iter().rev() {\n        sorted.push(x);\n\
    \    }\n    sorted\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplnrqc14f.rs:14:21\n   |\n\
    14 |         sorted.push(x);\n   |                     ^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n14 |        \
    \ sorted.push(*x);\n   |                     +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmplnrqc14f.rs:17:21\n   |\n17 |         sorted.push(x);\n   |   \
    \                  ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n17 |         sorted.push(*x);\n   |                     +\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmplnrqc14f.rs:20:21\n   |\n20 |\
    \         sorted.push(x);\n   |                     ^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n20 |        \
    \ sorted.push(*x);\n   |                     +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmplnrqc14f.rs:23:21\n   |\n23 |         sorted.push(x);\n   |   \
    \                  ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n23 |         sorted.push(*x);\n   |                     +\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010734
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    // Return original vector if empty vector\n\
    \    if lst.len() == 0 {\n        return vec![];\n    }\n\n    // Sort list into\
    \ descending order (smallest to largest)\n    let mut lst_sorted = vec![];\n \
    \   for x in lst {\n        if lst_sorted.len() == 0 {\n            lst_sorted.push(x);\n\
    \        } else {\n            if x < lst_sorted[0] {\n                lst_sorted.push(x);\n\
    \            }\n        }\n    }\n\n    return lst_sorted;\n}\n\nfn main() {\n\
    \    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5,\
    \ 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2,\
    \ 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8,\
    \ 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n  \
    \  assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpsa72qc5l.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut new_lst = vec![];\n\n    for i in lst.iter().cloned()\
    \ {\n        let (min, max) = min_max_elements(&lst);\n        let val = match\
    \ i % 2 {\n            0 => min,\n            1 => max,\n            _ => i,\n\
    \        };\n        new_lst.push(val);\n    }\n\n    new_lst\n}\n\nfn main()\
    \ {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `min_max_elements` in this scope\n \
    \ --> /tmp/tmp1ohq0dst.rs:15:26\n   |\n15 |         let (min, max) = min_max_elements(&lst);\n\
    \   |                          ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010734
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    if lst.is_empty() {\n        return vec![];\n\
    \    }\n\n    let min_val = vec![std::mem::min(&lst)].into_iter().collect::<Vec<_>>();\n\
    \    let max_val = vec![std::mem::max(&lst)].into_iter().collect::<Vec<_>>();\n\
    \n    if min_val.is_empty() || max_val.is_empty() {\n        return vec![];\n\
    \    }\n\n    let mut res = vec![];\n\n    if min_val[0] < max_val[0] {\n    \
    \    for &item in &lst {\n            if min_val[0] > item {\n               \
    \ res.push(item);\n            } else {\n                res.push(min_val[0]);\n\
    \            }\n        }\n    } else {\n        for &item in &lst {\n       \
    \     if item < min_val[0] {\n                res.push(item);\n            } else\
    \ {\n                res.push(max_val[0]);\n            }\n        }\n    }\n\n\
    \    if min_val[1] > max_val[1] {\n        for &item in &res {\n            res.swap(item,\
    \ min_val[1]);\n        }\n    }\n\n    if min_val[1] < max_val[1] {\n       \
    \ for &item in &res {\n            res.swap(item, max_val[1]);\n        }\n  \
    \  }\n\n    if min_val[2] < max_val[2] {\n        for &item in &res {\n      \
    \      res.swap(item, min_val[2]);\n        }\n    }\n\n    if min_val[2] > max_val[2]\
    \ {\n        for &item in &res {\n            res.swap(item, max_val[2]);\n  \
    \      }\n    }\n\n    if min_val[3] < max_val[3] {\n        for &item in &res\
    \ {\n            res.swap(item, min_val[3]);\n        }\n    }\n\n    if min_val[3]\
    \ > max_val[3] {\n        for &item in &res {\n            res.swap(item, max_val[3]);\n\
    \        }\n    }\n\n    return res;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `min` in module `std::mem`\n  --> /tmp/tmph36rey6o.rs:16:34\n\
    \   |\n16 |     let min_val = vec![std::mem::min(&lst)].into_iter().collect::<Vec<_>>();\n\
    \   |                                  ^^^ not found in `std::mem`\n   |\nhelp:\
    \ consider importing this function\n   |\n1  | use std::cmp::min;\n   |\nhelp:\
    \ if you import `min`, refer to it directly\n   |\n16 -     let min_val = vec![std::mem::min(&lst)].into_iter().collect::<Vec<_>>();\n\
    16 +     let min_val = vec![min(&lst)].into_iter().collect::<Vec<_>>();\n   |\
    \ \n\nerror[E0425]: cannot find function `max` in module `std::mem`\n  --> /tmp/tmph36rey6o.rs:17:34\n\
    \   |\n17 |     let max_val = vec![std::mem::max(&lst)].into_iter().collect::<Vec<_>>();\n\
    \   |                                  ^^^ not found in `std::mem`\n   |\nhelp:\
    \ consider importing this function\n   |\n1  | use std::cmp::max;\n   |\nhelp:\
    \ if you import `max`, refer to it directly\n   |\n17 -     let max_val = vec![std::mem::max(&lst)].into_iter().collect::<Vec<_>>();\n\
    17 +     let max_val = vec![max(&lst)].into_iter().collect::<Vec<_>>();\n   |\
    \ \n\nerror[E0308]: mismatched types\n  --> /tmp/tmph36rey6o.rs:45:22\n   |\n\
    45 |             res.swap(item, min_val[1]);\n   |                      ^^^^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n45 |             res.swap(item.try_into().unwrap(),\
    \ min_val[1]);\n   |                          ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmph36rey6o.rs:45:28\n   |\n45 |             res.swap(item,\
    \ min_val[1]);\n   |                            ^^^^^^^^^^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n45 |             res.swap(item, min_val[1].try_into().unwrap());\n\
    \   |                                      ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmph36rey6o.rs:51:22\n   |\n51 |             res.swap(item,\
    \ max_val[1]);\n   |                      ^^^^ expected `usiz"
  stdout: ''
  timestamp: 1660010734
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    if lst.is_empty() {\n        return vec![];\n\
    \    }\n    let mut sorted_list = lst;\n    sorted_list.sort();\n    for (i, elt)\
    \ in sorted_list.iter().enumerate() {\n        if i != 0 {\n            (&sorted_list[i\
    \ - 1]).swap(&sorted_list[i]);\n        }\n    }\n    sorted_list\n}\n\nfn main()\
    \ {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `swap` found for reference `&isize` in the\
    \ current scope\n  --> /tmp/tmphnm91b7d.rs:19:35\n   |\n19 |             (&sorted_list[i\
    \ - 1]).swap(&sorted_list[i]);\n   |                                   ^^^^ method\
    \ not found in `&isize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010734
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut i = lst.len() - 1;\n    let mut k =\
    \ lst.len() - 1;\n    let mut j = lst.len() - 1;\n    while i >= 0 && j >= 0 {\n\
    \        if lst[k] > lst[j] {\n            k = k;\n        } else {\n        \
    \    j = j;\n        }\n        i -= 1;\n        j -= 1;\n    }\n    while i >=\
    \ 0 {\n        let tmp = lst[i];\n        lst[i] = lst[k];\n        lst[k] = tmp;\n\
    \        i -= 1;\n        k -= 1;\n    }\n    while j >= 0 {\n        let tmp\
    \ = lst[j];\n        lst[j] = lst[k];\n        lst[k] = tmp;\n        j -= 1;\n\
    \        k -= 1;\n    }\n    lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `lst` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmptaznko8x.rs:26:9\n   |\n11 | fn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n   |                      --- help: consider changing\
    \ this to be mutable: `mut lst`\n...\n26 |         lst[i] = lst[k];\n   |    \
    \     ^^^ cannot borrow as mutable\n\nerror[E0596]: cannot borrow `lst` as mutable,\
    \ as it is not declared as mutable\n  --> /tmp/tmptaznko8x.rs:27:9\n   |\n11 |\
    \ fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |                \
    \      --- help: consider changing this to be mutable: `mut lst`\n...\n27 |  \
    \       lst[k] = tmp;\n   |         ^^^ cannot borrow as mutable\n\nerror[E0596]:\
    \ cannot borrow `lst` as mutable, as it is not declared as mutable\n  --> /tmp/tmptaznko8x.rs:33:9\n\
    \   |\n11 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |      \
    \                --- help: consider changing this to be mutable: `mut lst`\n...\n\
    33 |         lst[j] = lst[k];\n   |         ^^^ cannot borrow as mutable\n\nerror[E0596]:\
    \ cannot borrow `lst` as mutable, as it is not declared as mutable\n  --> /tmp/tmptaznko8x.rs:34:9\n\
    \   |\n11 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |      \
    \                --- help: consider changing this to be mutable: `mut lst`\n...\n\
    34 |         lst[k] = tmp;\n   |         ^^^ cannot borrow as mutable\n\nerror:\
    \ aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1660010734
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut min = lst.iter().min().unwrap();\n\
    \    let mut max = lst.iter().max().unwrap();\n\n    for el in lst.iter().skip(1)\
    \ {\n        if el < min {\n            min = el;\n        }\n        if el >\
    \ max {\n            max = el;\n        }\n    }\n\n    let mut result = vec![];\n\
    \    for el in lst.iter().skip(1) {\n        if el < min {\n            result.push(el);\n\
    \        } else if el > max {\n            result.push(el);\n        } else if\
    \ el < max {\n            result.push(max);\n        }\n    }\n\n    result\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphkp_lzza.rs:35:5\n   |\n\
    11 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |             \
    \                             ---------- expected `Vec<isize>` because of return\
    \ type\n...\n35 |     result\n   |     ^^^^^^ expected `isize`, found `&isize`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<&isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010734
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n    sorted_list.push(i32::MIN);\n\
    \    for elem in lst {\n        sorted_list.push(i32::MAX);\n        sorted_list.push(elem);\n\
    \    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpaj68bhyt.rs:16:26\n   |\n\
    16 |         sorted_list.push(elem);\n   |                          ^^^^ expected\
    \ `i32`, found `isize`\n   |\nhelp: you can convert an `isize` to an `i32` and\
    \ panic if the converted value doesn't fit\n   |\n16 |         sorted_list.push(elem.try_into().unwrap());\n\
    \   |                              ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpaj68bhyt.rs:18:5\n   |\n11 | fn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n   |                                          ----------\
    \ expected `Vec<isize>` because of return type\n...\n18 |     sorted_list\n  \
    \ |     ^^^^^^^^^^^ expected `isize`, found `i32`\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n              found struct `Vec<i32>`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010734
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n\n    // find\
    \ the min value\n    let mut min_value = lst[0];\n    for i in 1..lst.len() {\n\
    \        if lst[i] < min_value {\n            min_value = lst[i];\n        }\n\
    \    }\n\n    // find the max value\n    let mut max_value = lst[0];\n    for\
    \ i in 1..lst.len() {\n        if lst[i] > max_value {\n            max_value\
    \ = lst[i];\n        }\n    }\n\n    // find the middle value\n    let mut middle_index\
    \ = 0;\n    for i in 0..lst.len() {\n        if lst[i] == min_value {\n      \
    \      middle_index = i;\n        }\n    }\n\n    for i in middle_index..lst.len()\
    \ {\n        sorted_list.push(min_value);\n        sorted_list.push(max_value);\n\
    \        sorted_list.push(lst[i]);\n    }\n\n    sorted_list\n}\n\nfn main() {\n\
    \    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5,\
    \ 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2,\
    \ 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8,\
    \ 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n  \
    \  assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 4, 1, 1, 4, 2, 1, 4, 3, 1, 4, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpvxhbo8ag.rs:49:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut l = lst.to_owned();\n    l.sort_unstable_by(|a,\
    \ b| {\n        let mut a = a.to_owned();\n        let mut b = b.to_owned();\n\
    \        if a == b {\n            a < b\n        } else {\n            let (mut\
    \ a, mut b) = (a.swap(b), b.swap(a));\n            a < b\n        }\n    });\n\
    \    l\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplzkpsycg.rs:17:13\n   |\n\
    17 |             a < b\n   |             ^^^^^ expected enum `std::cmp::Ordering`,\
    \ found `bool`\n\nerror[E0599]: no method named `swap` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmplzkpsycg.rs:19:37\n   |\n19 |          \
    \   let (mut a, mut b) = (a.swap(b), b.swap(a));\n   |                       \
    \              ^^^^ method not found in `isize`\n\nerror[E0599]: no method named\
    \ `swap` found for type `isize` in the current scope\n  --> /tmp/tmplzkpsycg.rs:19:48\n\
    \   |\n19 |             let (mut a, mut b) = (a.swap(b), b.swap(a));\n   |   \
    \                                             ^^^^ method not found in `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmplzkpsycg.rs:20:13\n   |\n20 |\
    \             a < b\n   |             ^^^^^ expected enum `std::cmp::Ordering`,\
    \ found `bool`\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010734
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut lst = lst;\n    let mut current = vec![];\n\
    \    let mut min = vec![];\n    let mut max = vec![];\n\n    while !lst.is_empty()\
    \ {\n        let mut new_min = vec![];\n        let mut new_max = vec![];\n\n\
    \        while !current.is_empty() {\n            let mut i = current.iter().max().unwrap();\n\
    \            let mut j = i-1;\n            let mut k = vec![];\n            while\
    \ !j.is_empty() {\n                let v = vec![lst.swap(i, j), k];\n        \
    \        if v[0].is_ok() {\n                    j = v.iter().nth(1).unwrap();\n\
    \                } else {\n                    k.push(v.iter().nth(1).unwrap());\n\
    \                }\n            }\n\n            current.push(k);\n          \
    \  new_min = new_min.push(vec![lst.swap(i, j)]);\n            new_max = new_max.push(k);\n\
    \        }\n\n        min = min.push(new_min);\n        max = max.push(new_max);\n\
    \n        current = vec![];\n    }\n\n    min + max\n}\n\nfn main() {\n    let\
    \ candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]),\
    \ vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9,\
    \ 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6,\
    \ 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmp26eysdh1.rs:25:20\n\
    \   |\n23 |             let mut j = i-1;\n   |                 ----- consider\
    \ giving `j` a type\n24 |             let mut k = vec![];\n25 |             while\
    \ !j.is_empty() {\n   |                    ^ cannot infer type\n   |\n   = note:\
    \ type must be known at this point\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp26eysdh1.rs:26:39\n\
    \   |\n26 |                 let v = vec![lst.swap(i, j), k];\n   |           \
    \                            ^ expected `usize`, found reference\n   |\n   = note:\
    \   expected type `usize`\n           found reference `&_`\nhelp: consider dereferencing\
    \ the borrow\n   |\n26 |                 let v = vec![lst.swap(*i, j), k];\n \
    \  |                                       +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp26eysdh1.rs:26:46\n   |\n26 |                 let v = vec![lst.swap(i,\
    \ j), k];\n   |                                              ^ expected `()`,\
    \ found struct `Vec`\n   |\n   = note: expected unit type `()`\n             \
    \    found struct `Vec<_>`\n\nerror[E0599]: no method named `is_ok` found for\
    \ unit type `()` in the current scope\n  --> /tmp/tmp26eysdh1.rs:27:25\n   |\n\
    27 |                 if v[0].is_ok() {\n   |                         ^^^^^ method\
    \ not found in `()`\n\nerror[E0277]: cannot subtract `{integer}` from `&Vec<&()>`\n\
    \  --> /tmp/tmp26eysdh1.rs:23:26\n   |\n23 |             let mut j = i-1;\n  \
    \ |                          ^ no implementation for `&Vec<&()> - {integer}`\n\
    \   |\n   = help: the trait `Sub<{integer}>` is not implemented for `&Vec<&()>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp26eysdh1.rs:35:50\n   |\n35 |\
    \             new_min = new_min.push(vec![lst.swap(i, j)]);\n   |            \
    \                                      ^ expected `usize`, found `&Vec<&()>`\n\
    \   |\n   = note:   expected type `usize`\n           found reference `&Vec<&()>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp26eysdh1.rs:35:23\n   |\n18 |\
    \         let mut new_min = vec![];\n   |                           ------ expected\
    \ due to this value\n...\n35 |             new_"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let len = lst.len();\n    for i in 0..len {\n\
    \        let last = len - i;\n        let min_index = (last as isize) / 2;\n \
    \       let min = &lst[min_index];\n        let max_index = last - 1;\n      \
    \  let max = &lst[max_index];\n        let tmp = min;\n        lst[min_index]\
    \ = max;\n        lst[max_index] = tmp;\n    }\n    lst\n}\n\nfn main() {\n  \
    \  let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5,\
    \ 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2,\
    \ 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8,\
    \ 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n  \
    \  assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp90yr38jq.rs:16:20\n\
    \   |\n16 |         let min = &lst[min_index];\n   |                    ^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp90yr38jq.rs:20:9\n\
    \   |\n20 |         lst[min_index] = max;\n   |         ^^^^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp90yr38jq.rs:21:26\n\
    \   |\n21 |         lst[max_index] = tmp;\n   |         --------------   ^^^ expected\
    \ `isize`, found reference\n   |         |\n   |         expected due to the type\
    \ of this binding\n   |\n   = note:   expected type `isize`\n           found\
    \ reference `&_`\nhelp: consider dereferencing the borrow\n   |\n21 |        \
    \ lst[max_index] = *tmp;\n   |                          +\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010734
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut it = lst.iter().cloned().enumerate();\n\
    \    let mut last = it.next();\n    loop {\n        let mut current = it.next();\n\
    \        if current.unwrap().1 < last {\n            let swap = current.unwrap().1;\n\
    \            it.next();\n            it.next().unwrap().1 = swap;\n          \
    \  it.next();\n            it.next().unwrap().1 = last;\n            current =\
    \ it.next();\n        }\n        if current.unwrap().1 > last {\n            let\
    \ swap = current.unwrap().1;\n            it.next();\n            it.next().unwrap().1\
    \ = last;\n            it.next();\n            it.next().unwrap().1 = swap;\n\
    \            last = current.unwrap().1;\n        }\n        if current.unwrap().1\
    \ == last {\n            it.next();\n        }\n        if !it.next().is_ok()\
    \ {\n            break;\n        }\n    }\n    it\n}\n\nfn main() {\n    let candidate\
    \ = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5,\
    \ 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxvbc9pq1.rs:16:33\n   |\n\
    16 |         if current.unwrap().1 < last {\n   |                            \
    \     ^^^^ expected `isize`, found enum `Option`\n   |\n   = note: expected type\
    \ `isize`\n              found enum `Option<(usize, isize)>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpxvbc9pq1.rs:21:36\n   |\n21 |             it.next().unwrap().1\
    \ = last;\n   |             --------------------   ^^^^ expected `isize`, found\
    \ enum `Option`\n   |             |\n   |             expected due to the type\
    \ of this binding\n   |\n   = note: expected type `isize`\n              found\
    \ enum `Option<(usize, isize)>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxvbc9pq1.rs:24:33\n\
    \   |\n24 |         if current.unwrap().1 > last {\n   |                     \
    \            ^^^^ expected `isize`, found enum `Option`\n   |\n   = note: expected\
    \ type `isize`\n              found enum `Option<(usize, isize)>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpxvbc9pq1.rs:27:36\n   |\n27 |             it.next().unwrap().1\
    \ = last;\n   |             --------------------   ^^^^ expected `isize`, found\
    \ enum `Option`\n   |             |\n   |             expected due to the type\
    \ of this binding\n   |\n   = note: expected type `isize`\n              found\
    \ enum `Option<(usize, isize)>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxvbc9pq1.rs:30:20\n\
    \   |\n13 |     let mut last = it.next();\n   |                    --------- expected\
    \ due to this value\n...\n30 |             last = current.unwrap().1;\n   |  \
    \                  ^^^^^^^^^^^^^^^^^^ expected enum `Option`, found `isize`\n\
    \   |\n   = note: expected enum `Option<(usize, isize)>`\n              found\
    \ type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxvbc9pq1.rs:32:34\n\
    \   |\n32 |         if current.unwrap().1 == last {\n   |                    \
    \              ^^^^ expected `isize`, found enum `Option`\n   |\n   = note: expected\
    \ type `isize`\n              found enum `Option<(usize, isize)>`\n\nerror[E0599]:\
    \ no method named `is_ok` found for enum `Option` in the current scope\n  -->\
    \ /tmp/t"
  stdout: ''
  timestamp: 1660010735
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut l = lst.clone();\n    l.sort();\n \
    \   l\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpto5eql39.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    debug_assert!(lst.len() > 0);\n    let mut\
    \ res = vec![];\n    let first_val = lst[0];\n    let last_val = lst[lst.len()\
    \ - 1];\n    for i in 1..(lst.len() - 1) {\n        let j = if i == lst.len()\
    \ - 1 {\n            0\n        } else {\n            i + 1\n        };\n    \
    \    let val1 = lst[i];\n        let val2 = lst[j];\n        if val1 < val2 {\n\
    \            res.push(val1);\n            res.push(val2);\n        } else {\n\
    \            res.push(val2);\n            res.push(val1);\n        }\n    }\n\
    \    res.push(last_val);\n    res.sort();\n    res\n}\n\nfn main() {\n    let\
    \ candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]),\
    \ vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9,\
    \ 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6,\
    \ 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 3, 4, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmprsju2tzw.rs:39:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_lst = Vec::new();\n    let mut\
    \ max_value = lst[0];\n    for value in lst {\n        if value == max_value {\n\
    \            sorted_lst.push(value);\n        } else {\n            sorted_lst.push(max_value);\n\
    \            sorted_lst.push(value);\n        }\n        max_value = value;\n\
    \    }\n    sorted_lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 2, 2, 3, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpaqzd4k4k.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    if lst.len() == 0 {\n        return vec![];\n\
    \    }\n\n    let min = lst.iter().min().unwrap();\n    let mut max = lst.iter().max().unwrap();\n\
    \    max = lst.iter().rev().max().unwrap();\n\n    vec![min; max; min; ..].into_iter().cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error: no rules expected the token `;`\n  --> /tmp/tmpds0_j4y6.rs:20:18\n\
    \   |\n20 |     vec![min; max; min; ..].into_iter().cloned().collect()\n   | \
    \                 ^ no rules expected this token in macro call\n\nerror: aborting\
    \ due to previous error\n\n"
  stdout: ''
  timestamp: 1660010734
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut lst = lst.iter().cloned();\n\n    loop\
    \ {\n        let mut smallest = std::cmp::min(lst.cloned());\n        let mut\
    \ largest = std::cmp::max(lst.cloned());\n        while largest == smallest {\n\
    \            smallest = std::cmp::min(lst.cloned());\n            largest = std::cmp::max(lst.cloned());\n\
    \        }\n        if smallest == largest {\n            return lst.cloned();\n\
    \        }\n        lst.swap(smallest, largest);\n    }\n}\n\nfn main() {\n  \
    \  let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5,\
    \ 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2,\
    \ 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8,\
    \ 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n  \
    \  assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<std::slice::Iter<'_, isize> as\
    \ Iterator>::Item == &&_`\n    --> /tmp/tmp4mkkkm9s.rs:15:46\n     |\n15   | \
    \        let mut smallest = std::cmp::min(lst.cloned());\n     |             \
    \                                 ^^^^^^ expected reference, found `isize`\n \
    \    |\n     = note: expected reference `&&_`\n                found reference\
    \ `&isize`\n     = note: required because of the requirements on the impl of `Iterator`\
    \ for `Cloned<std::slice::Iter<'_, isize>>`\nnote: required by a bound in `cloned`\n\
    \nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmp4mkkkm9s.rs:15:28\n     |\n15   |         let mut smallest =\
    \ std::cmp::min(lst.cloned());\n     |                            ^^^^^^^^^^^^^\
    \ ------------ supplied 1 argument\n     |                            |\n    \
    \ |                            expected 2 arguments\n     |\nnote: function defined\
    \ here\n\nerror[E0271]: type mismatch resolving `<std::slice::Iter<'_, isize>\
    \ as Iterator>::Item == &&_`\n    --> /tmp/tmp4mkkkm9s.rs:16:45\n     |\n16  \
    \ |         let mut largest = std::cmp::max(lst.cloned());\n     |           \
    \                                  ^^^^^^ expected reference, found `isize`\n\
    \     |\n     = note: expected reference `&&_`\n                found reference\
    \ `&isize`\n     = note: required because of the requirements on the impl of `Iterator`\
    \ for `Cloned<std::slice::Iter<'_, isize>>`\nnote: required by a bound in `cloned`\n\
    \nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmp4mkkkm9s.rs:16:27\n     |\n16   |         let mut largest = std::cmp::max(lst.cloned());\n\
    \     |                           ^^^^^^^^^^^^^ ------------ supplied 1 argument\n\
    \     |                           |\n     |                           expected\
    \ 2 arguments\n     |\nnote: function defined here\n\nerror[E0271]: type mismatch\
    \ resolving `<std::slice::Iter<'_, isize> as Iterator>::Item == &&_`\n    -->\
    \ /tmp/tmp4mkkkm9s.rs:18:42\n     |\n18   |             smallest = std::cmp::min(lst.cloned());\n\
    \     |           "
  stdout: ''
  timestamp: 1660010734
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    lst.sort_by(|a, b| if a > b { a } else { b\
    \ })\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4r_7b86d.rs:12:35\n   |\n\
    12 |     lst.sort_by(|a, b| if a > b { a } else { b })\n   |                 \
    \                  ^ expected enum `std::cmp::Ordering`, found `&isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp4r_7b86d.rs:12:46\n   |\n12 |     lst.sort_by(|a,\
    \ b| if a > b { a } else { b })\n   |                                        \
    \      ^ expected enum `std::cmp::Ordering`, found `&isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp4r_7b86d.rs:12:5\n   |\n11 | fn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n   |                                          ----------\
    \ expected `Vec<isize>` because of return type\n12 |     lst.sort_by(|a, b| if\
    \ a > b { a } else { b })\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010734
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut reversed_list = lst.iter().rev();\n\
    \    reversed_list.rev();\n    let mut new_list = reversed_list.clone();\n   \
    \ new_list.sort();\n    new_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort` found for struct `Rev` in the current\
    \ scope\n  --> /tmp/tmp1_fxj3mc.rs:15:14\n   |\n15 |     new_list.sort();\n  \
    \ |              ^^^^ method not found in `Rev<std::slice::Iter<'_, isize>>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp1_fxj3mc.rs:16:5\n   |\n11 | fn\
    \ strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |                   \
    \                       ---------- expected `Vec<isize>` because of return type\n\
    ...\n16 |     new_list\n   |     ^^^^^^^^ expected struct `Vec`, found struct\
    \ `Rev`\n   |\n   = note: expected struct `Vec<isize>`\n              found struct\
    \ `Rev<std::slice::Iter<'_, isize>>`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010734
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut min_el = lst.iter().min().unwrap();\n\
    \    let mut max_el = lst.iter().max().unwrap();\n\n    let mut lst = vec![];\n\
    \n    for el in lst.rev() {\n        if el < min_el {\n            el = min_el;\n\
    \        }\n\n        if el > max_el {\n            el = max_el;\n        }\n\n\
    \        lst.push(el);\n    }\n\n    lst\n}\n\nfn main() {\n    let candidate\
    \ = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5,\
    \ 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `Vec<_>` is not an iterator\n   --> /tmp/tmpc0jq_t9l.rs:17:19\n\
    \    |\n17  |       for el in lst.rev() {\n    |                     ^^^ `Vec<_>`\
    \ is not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Vec<_>: Iterator`\n            which is required by `&mut Vec<_>:\
    \ Iterator`\n            `[_]: Iterator`\n            which is required by `&mut\
    \ [_]: Iterator`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc0jq_t9l.rs:29:5\n\
    \   |\n11 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |      \
    \                                    ---------- expected `Vec<isize>` because\
    \ of return type\n...\n29 |     lst\n   |     ^^^ expected `isize`, found `&isize`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<&isize>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010734
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut temp = Vec::with_capacity(lst.len());\n\
    \    for i in lst.iter() {\n        temp.push(i);\n    }\n    temp.sort();\n \
    \   temp\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkslm6yuy.rs:17:5\n   |\n\
    11 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |             \
    \                             ---------- expected `Vec<isize>` because of return\
    \ type\n...\n17 |     temp\n   |     ^^^^ expected `isize`, found `&isize`\n \
    \  |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<&isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010734
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    if lst.is_empty() {\n        return vec![];\n\
    \    }\n\n    let min = lst.iter().min().unwrap();\n    let max = lst.iter().max().unwrap();\n\
    \    let mut result = vec![];\n\n    if min == max {\n        return vec![];\n\
    \    }\n\n    let mut i = 1;\n    let mut j = 0;\n\n    while i <= max {\n   \
    \     result.push(j);\n        if i == min {\n            i += 1;\n        }\n\
    \n        if i == max {\n            i += 1;\n        }\n\n        i += 1;\n \
    \       j += 1\n    }\n    result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpcs4868yy.rs:27:13\n\
    \   |\n27 |     while i <= max {\n   |             ^^ no implementation for `isize\
    \ < &isize` and `isize > &isize`\n   |\n   = help: the trait `PartialOrd<&isize>`\
    \ is not implemented for `isize`\n   = help: the following other types implement\
    \ trait `PartialOrd<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpcs4868yy.rs:29:17\n   |\n29 |         if i == min {\n   |          \
    \       ^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n29 |         if i == *min {\n   |                 +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpcs4868yy.rs:33:17\n   |\n33 |         if i ==\
    \ max {\n   |                 ^^^ expected `isize`, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n33 |         if i == *max {\n   | \
    \                +\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010734
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    if lst.is_empty() {\n        return vec![];\n\
    \    }\n\n    let mut min_val = lst.min();\n    let mut max_val = lst.max();\n\
    \n    loop {\n        let mut min_idx = lst.iter().position(|x| x == min_val);\n\
    \n        let mut max_idx = lst.iter().position(|x| x == max_val);\n\n       \
    \ if min_idx < max_idx {\n            loop {\n                if min_idx == max_idx\
    \ {\n                    break;\n                }\n                min_idx +=\
    \ 1;\n                max_idx -= 1;\n            }\n            min_val = lst.iter().nth(min_idx).unwrap();\n\
    \            max_val = lst.iter().nth(max_idx).unwrap();\n        } else {\n \
    \           break;\n        }\n    }\n\n    vec![min_val, max_val].sorted()\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \   --> /tmp/tmpdbvriv2z.rs:16:27\n    |\n16  |     let mut min_val = lst.min();\n\
    \    |                           ^^^- supplied 0 arguments\n    |            \
    \               |\n    |                           expected 1 argument\n    |\n\
    note: associated function defined here\n\nerror[E0061]: this function takes 1\
    \ argument but 0 arguments were supplied\n   --> /tmp/tmpdbvriv2z.rs:17:27\n \
    \   |\n17  |     let mut max_val = lst.max();\n    |                         \
    \  ^^^- supplied 0 arguments\n    |                           |\n    |       \
    \                    expected 1 argument\n    |\nnote: associated function defined\
    \ here\n\nerror[E0277]: can't compare `&isize` with `Vec<isize>`\n  --> /tmp/tmpdbvriv2z.rs:20:53\n\
    \   |\n20 |         let mut min_idx = lst.iter().position(|x| x == min_val);\n\
    \   |                                                     ^^ no implementation\
    \ for `&isize == Vec<isize>`\n   |\n   = help: the trait `PartialEq<Vec<isize>>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0277]: can't compare `&isize`\
    \ with `Vec<isize>`\n  --> /tmp/tmpdbvriv2z.rs:22:53\n   |\n22 |         let mut\
    \ max_idx = lst.iter().position(|x| x == max_val);\n   |                     \
    \                                ^^ no implementation for `&isize == Vec<isize>`\n\
    \   |\n   = help: the trait `PartialEq<Vec<isize>>` is not implemented for `&isize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror[E0368]: binary assignment operation `+=` cannot be applied\
    \ to type `Option<usize>`\n  --> /tmp/tmpdbvriv2z.rs:29:17\n   |\n29 |       \
    \          min_idx += 1;\n   |                 -------^^^^^\n "
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    lst.sort();\n    lst\n}\n\nfn main() {\n  \
    \  let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5,\
    \ 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2,\
    \ 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8,\
    \ 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n  \
    \  assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `lst` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmprgvby9nl.rs:12:5\n   |\n11 | fn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n   |                      --- help: consider changing\
    \ this to be mutable: `mut lst`\n12 |     lst.sort();\n   |     ^^^^^^^^^^ cannot\
    \ borrow as mutable\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1660010734
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut res = lst;\n    loop {\n        let\
    \ min = res.iter().min();\n        let max = res.iter().max();\n        let mid\
    \ = (min + max) / 2;\n        if res.iter().any(|&x| *x > mid) {\n           \
    \ res.swap(mid, 1);\n        } else {\n            break;\n        }\n    }\n\
    \    res\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot add `Option<&isize>` to `Option<&isize>`\n  --> /tmp/tmp8phavwlb.rs:16:24\n\
    \   |\n16 |         let mid = (min + max) / 2;\n   |                    --- ^\
    \ --- Option<&isize>\n   |                    |\n   |                    Option<&isize>\n\
    \nerror[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmp8phavwlb.rs:17:32\n\
    \   |\n17 |         if res.iter().any(|&x| *x > mid) {\n   |                 \
    \               ^^\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0369, E0614.\nFor more information about an error,\
    \ try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660010734
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut counter = Vec::new();\n    let mut\
    \ min_i = 1;\n    let mut max_i = lst.len() - 1;\n    let mut min_val = lst.len();\n\
    \    while min_i <= max_i {\n        counter[min_i] = 1;\n        counter[max_i]\
    \ = 1;\n        counter[min_val] = 1;\n        min_i += 1;\n        max_i -= 1;\n\
    \        if min_i == max_i {\n            counter[min_i] = counter[max_i];\n \
    \           min_i += 1;\n        }\n        if min_val == max_val {\n        \
    \    counter[min_val] = counter[max_val];\n            min_val += 1;\n       \
    \ }\n    }\n\n    let mut v = Vec::new();\n    let mut current_val = 1;\n    while\
    \ current_val <= lst.len() {\n        if counter[current_val] == 0 {\n       \
    \     v.append(current_val);\n            current_val += 1;\n        }\n     \
    \   current_val += 1;\n    }\n    v.reverse();\n    v\n}\n\nfn main() {\n    let\
    \ candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]),\
    \ vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9,\
    \ 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6,\
    \ 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `max_val` in this scope\n  --> /tmp/tmpvaybj6sa.rs:26:23\n\
    \   |\n26 |         if min_val == max_val {\n   |                       ^^^^^^^\
    \ help: a local variable with a similar name exists: `min_val`\n\nerror[E0425]:\
    \ cannot find value `max_val` in this scope\n  --> /tmp/tmpvaybj6sa.rs:27:40\n\
    \   |\n27 |             counter[min_val] = counter[max_val];\n   |           \
    \                             ^^^^^^^ help: a local variable with a similar name\
    \ exists: `min_val`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvaybj6sa.rs:36:22\n\
    \   |\n36 |             v.append(current_val);\n   |                      ^^^^^^^^^^^\
    \ expected `&mut Vec<_>`, found `usize`\n   |\n   = note: expected mutable reference\
    \ `&mut Vec<_>`\n                           found type `usize`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut lst2 = lst.iter().cloned().collect::<Vec<_>>();\n\
    \    lst2.sort_unstable_by(|a, b| {\n        let c = a - b;\n        c < 0 ? c\
    \ : c\n    });\n    lst2\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `c`\n\
    \  --> /tmp/tmplmw7pnlo.rs:15:17\n   |\n15 |         c < 0 ? c : c\n   |     \
    \            ^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: aborting\
    \ due to previous error\n\n"
  stdout: ''
  timestamp: 1660010734
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut lst = lst.to_owned();\n    lst.sort();\n\
    \    lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmp9gl6qdfw.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut new_list = lst;\n\n    new_list.sort();\n\
    \n    let mut idx = 0;\n    let mut next_max = new_list[0];\n\n    let mut next_min\
    \ = new_list[0];\n\n    for i in 1..new_list.len() {\n        if next_max == new_list[i]\
    \ {\n            next_max = new_list[i];\n            idx += 1;\n        } else\
    \ {\n            break;\n        }\n    }\n\n    for i in idx..new_list.len()\
    \ {\n        if next_min == new_list[i] {\n            next_min = new_list[i];\n\
    \        } else {\n            break;\n        }\n    }\n\n    for i in idx..new_list.len()\
    \ {\n        new_list[i] = new_list[i] - next_min - next_max;\n    }\n\n    new_list.sort();\n\
    \n    new_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n   \
    \ assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-1, 0, 1, 2]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpn9fwcwu5.rs:49:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut res = vec![];\n\n    let mut min =\
    \ lst.iter().min().unwrap();\n    let mut max = lst.iter().max().unwrap();\n \
    \   for v in lst {\n        if v < min {\n            min = v;\n        }\n  \
    \      if v > max {\n            max = v;\n        }\n    }\n\n    let mut mid\
    \ = min;\n    while mid < max {\n        let mut found = false;\n        for v\
    \ in lst {\n            if v == mid {\n                found = true;\n       \
    \     }\n        }\n        if found {\n            let tmp = mid;\n         \
    \   mid = min;\n            min = tmp;\n        } else {\n            res.push(mid);\n\
    \            min++;\n        }\n    }\n\n    res\n}\n\nfn main() {\n    let candidate\
    \ = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5,\
    \ 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpu7ox3akj.rs:39:16\n\
    \   |\n39 |             min++;\n   |                ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n39 |             { let tmp = min; min +=\
    \ 1; tmp };\n   |             +++++++++++    ~~~~~~~~~~~~~~~~~\n39 -         \
    \    min++;\n39 +             min += 1;\n   | \n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpu7ox3akj.rs:17:16\n   |\n17 |         if v < min {\n   |      \
    \          ^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n17 |         if v < *min {\n   |                +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpu7ox3akj.rs:18:19\n   |\n14 |     let mut min\
    \ = lst.iter().min().unwrap();\n   |                   -------------------------\
    \ expected due to this value\n...\n18 |             min = v;\n   |           \
    \        ^\n   |                   |\n   |                   expected `&isize`,\
    \ found `isize`\n   |                   help: consider borrowing here: `&v`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpu7ox3akj.rs:20:16\n   |\n20 |  \
    \       if v > max {\n   |                ^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n20 |         if v > *max\
    \ {\n   |                +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpu7ox3akj.rs:21:19\n\
    \   |\n15 |     let mut max = lst.iter().max().unwrap();\n   |               \
    \    ------------------------- expected due to this value\n...\n21 |         \
    \    max = v;\n   |                   ^\n   |                   |\n   |      \
    \             expected `&isize`, found `isize`\n   |                   help: consider\
    \ borrowing here: `&v`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpu7ox3akj.rs:29:21\n\
    \   |\n29 |             if v == mid {\n   |                     ^^^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n29 |  \
    \           if v == *mid {\n   |                     +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpu7ox3akj.rs:43:5\n   |\n11 | fn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n   |            "
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    lst.sort();\n    lst\n}\n\nfn main() {\n  \
    \  let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5,\
    \ 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2,\
    \ 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8,\
    \ 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n  \
    \  assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `lst` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmprgvby9nl.rs:12:5\n   |\n11 | fn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n   |                      --- help: consider changing\
    \ this to be mutable: `mut lst`\n12 |     lst.sort();\n   |     ^^^^^^^^^^ cannot\
    \ borrow as mutable\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1660010734
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut reverse = Vec::new();\n    reverse.extend_from_slice(lst.iter().rev());\n\
    \    let mut iter = lst.iter().clone();\n    let mut first = iter.next();\n  \
    \  let mut last = iter.next();\n\n    loop {\n        while !last.is_ok() {\n\
    \            if let Some(mut t) = reverse {\n                let t = last.unwrap();\n\
    \                reverse.push(t);\n                last = Some(iter);\n      \
    \      }\n            if !first.is_ok() {\n                break;\n          \
    \  }\n            first = first.unwrap();\n            iter.next();\n        }\n\
    \        if last.is_ok() {\n            if let Some(mut t) = reverse {\n     \
    \           let t = last.unwrap();\n                reverse.push(t);\n       \
    \         last = Some(iter);\n            }\n        }\n        if first.is_ok()\
    \ {\n            if let Some(mut t) = reverse {\n                let t = first.unwrap();\n\
    \                reverse.push(t);\n                first = Some(iter);\n     \
    \       }\n        }\n        if first.is_ok() && last.is_ok() {\n           \
    \ if let Some(mut t) = reverse {\n                let t = first.unwrap();\n  \
    \              reverse.push(t);\n                first = Some(iter);\n       \
    \     }\n            if let Some(mut t) = reverse {\n                let t = last.unwrap();\n\
    \                reverse.push(t);\n                last = Some(iter);\n      \
    \      }\n        }\n    }\n    reverse\n}\n\nfn main() {\n    let candidate =\
    \ strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5,\
    \ 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpupy06x5v.rs:13:31\n   |\n\
    13 |     reverse.extend_from_slice(lst.iter().rev());\n   |                  \
    \             ^^^^^^^^^^^^^^^^ expected `&[_]`, found struct `Rev`\n   |\n   =\
    \ note: expected reference `&[_]`\n                 found struct `Rev<std::slice::Iter<'_,\
    \ isize>>`\n\nerror[E0599]: no method named `is_ok` found for enum `Option` in\
    \ the current scope\n  --> /tmp/tmpupy06x5v.rs:19:21\n   |\n19 |         while\
    \ !last.is_ok() {\n   |                     ^^^^^ method not found in `Option<&isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpupy06x5v.rs:20:20\n   |\n20 |\
    \             if let Some(mut t) = reverse {\n   |                    ^^^^^^^^^^^\
    \   ------- this expression has type `Vec<_>`\n   |                    |\n   |\
    \                    expected struct `Vec`, found enum `Option`\n   |\n   = note:\
    \ expected struct `Vec<_>`\n                found enum `Option<_>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpupy06x5v.rs:23:29\n   |\n23 |              \
    \   last = Some(iter);\n   |                             ^^^^ expected `&isize`,\
    \ found struct `std::slice::Iter`\n   |\n   = note: expected reference `&isize`\n\
    \                 found struct `std::slice::Iter<'_, isize>`\n\nerror[E0599]:\
    \ no method named `is_ok` found for enum `Option` in the current scope\n  -->\
    \ /tmp/tmpupy06x5v.rs:25:23\n   |\n25 |             if !first.is_ok() {\n   |\
    \                       ^^^^^ method not found in `Option<&isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpupy06x5v.rs:28:21\n   |\n15 |     let mut first\
    \ = iter.next();\n   |                     ----------- expected due to this value\n\
    ...\n28 |             first = first.unwrap();\n   |                     ^^^^^^^^^^^^^^\
    \ expected enum `Option`, found `&isize`\n   |\n   = note:   expected enum `Option<&isize>`\n\
    \           found reference `&isize`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n28 |             first = Some(first.unwrap());\n   |                  \
    \   +++++              +\n\nerror[E0599]: no method named `is_ok` found for enum\
    \ `Option` in the current scope\n "
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    if lst.is_empty() {\n        return vec![];\n\
    \    }\n\n    let mut min_value = std::i32::MAX as isize;\n    let mut max_value\
    \ = std::i32::MIN as isize;\n    for i in lst.iter() {\n        min_value = std::cmp::min(min_value,\
    \ i);\n        max_value = std::cmp::max(max_value, i);\n    }\n\n    let mut\
    \ result = vec![];\n    for i in lst.iter_mut() {\n        if i >= min_value &&\
    \ i <= max_value {\n            result.push(i);\n        }\n    }\n\n    result\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprth60xip.rs:19:46\n   |\n\
    19 |         min_value = std::cmp::min(min_value, i);\n   |                  \
    \                            ^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n19 |         min_value = std::cmp::min(min_value,\
    \ *i);\n   |                                              +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmprth60xip.rs:20:46\n   |\n20 |         max_value = std::cmp::max(max_value,\
    \ i);\n   |                                              ^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n20 |        \
    \ max_value = std::cmp::max(max_value, *i);\n   |                            \
    \                  +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprth60xip.rs:25:17\n\
    \   |\n25 |         if i >= min_value && i <= max_value {\n   |              \
    \   ^^^^^^^^^\n   |                 |\n   |                 expected `&mut isize`,\
    \ found `isize`\n   |                 help: consider mutably borrowing here: `&mut\
    \ min_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprth60xip.rs:25:35\n\
    \   |\n25 |         if i >= min_value && i <= max_value {\n   |              \
    \                     ^^^^^^^^^\n   |                                   |\n  \
    \ |                                   expected `&mut isize`, found `isize`\n \
    \  |                                   help: consider mutably borrowing here:\
    \ `&mut max_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprth60xip.rs:30:5\n\
    \   |\n11 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |      \
    \                                    ---------- expected `Vec<isize>` because\
    \ of return type\n...\n30 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ `&mut isize`\n   |\n   = note: expected struct `Vec<isize>`\n              found\
    \ struct `Vec<&mut isize>`\n\nerror: aborting due to 5 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    debug_assert!(lst.len() <= 4);\n\n    let mut\
    \ i = 0;\n\n    if lst.len() == 1 {\n        i += 1;\n    }\n\n    if lst.len()\
    \ == 2 {\n        i += 2;\n    }\n\n    if lst.len() == 3 {\n        i += 3;\n\
    \    }\n\n    if lst.len() == 4 {\n        i += 4;\n    }\n\n    lst.drain(..).sort();\n\
    \    lst.drain(..).reverse();\n\n    i += lst[1..].len();\n\n    while i <= lst.len()\
    \ {\n        i += 1;\n    }\n\n    lst\n}\n\nfn main() {\n    let candidate =\
    \ strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5,\
    \ 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort` found for struct `std::vec::Drain`\
    \ in the current scope\n  --> /tmp/tmplrof5nks.rs:32:19\n   |\n32 |     lst.drain(..).sort();\n\
    \   |                   ^^^^ method not found in `std::vec::Drain<'_, isize>`\n\
    \nerror[E0599]: no method named `reverse` found for struct `std::vec::Drain` in\
    \ the current scope\n  --> /tmp/tmplrof5nks.rs:33:19\n   |\n33 |     lst.drain(..).reverse();\n\
    \   |                   ^^^^^^^ method not found in `std::vec::Drain<'_, isize>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut new_list = vec![0; lst.len()];\n  \
    \  new_list.sort_unstable();\n    new_list.clone_from_slice(&lst);\n    new_list\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpifxyz826.rs:20:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut min_val = std::ptr::null();\n    let\
    \ mut max_val = std::ptr::null();\n    for i in lst.iter() {\n        if i ==\
    \ *min_val {\n            *min_val = i;\n        } else if i == *max_val {\n \
    \           *max_val = i;\n        } else {\n            let min_pos = *min_val;\n\
    \            let max_pos = *max_val;\n            std::ptr::swap(*min_val, *max_val);\n\
    \            std::ptr::swap(min_pos, max_pos);\n        }\n    }\n    vec![*min_val\
    \ as isize, *max_val as isize]\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmoke_cer.rs:22:28\n   |\n\
    22 |             std::ptr::swap(*min_val, *max_val);\n   |                   \
    \         ^^^^^^^^ types differ in mutability\n   |\n   = note: expected raw pointer\
    \ `*mut _`\n                found reference `&isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpmoke_cer.rs:22:38\n   |\n22 |             std::ptr::swap(*min_val,\
    \ *max_val);\n   |                                      ^^^^^^^^ types differ\
    \ in mutability\n   |\n   = note: expected raw pointer `*mut _`\n            \
    \    found reference `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmoke_cer.rs:23:28\n\
    \   |\n23 |             std::ptr::swap(min_pos, max_pos);\n   |              \
    \              ^^^^^^^ types differ in mutability\n   |\n   = note: expected raw\
    \ pointer `*mut _`\n                found reference `&isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpmoke_cer.rs:23:37\n   |\n23 |             std::ptr::swap(min_pos,\
    \ max_pos);\n   |                                     ^^^^^^^ types differ in\
    \ mutability\n   |\n   = note: expected raw pointer `*mut _`\n               \
    \ found reference `&isize`\n\nerror[E0606]: casting `&isize` as `isize` is invalid\n\
    \  --> /tmp/tmpmoke_cer.rs:26:10\n   |\n26 |     vec![*min_val as isize, *max_val\
    \ as isize]\n   |          --------^^^^^^^^^\n   |          |\n   |          cannot\
    \ cast `&isize` as `isize`\n   |          help: dereference the expression: `**min_val`\n\
    \nerror[E0606]: casting `&isize` as `isize` is invalid\n  --> /tmp/tmpmoke_cer.rs:26:29\n\
    \   |\n26 |     vec![*min_val as isize, *max_val as isize]\n   |             \
    \                --------^^^^^^^^^\n   |                             |\n   | \
    \                            cannot cast `&isize` as `isize`\n   |           \
    \                  help: dereference the expression: `**max_val`\n\nerror: aborting\
    \ due to 6 previous errors\n\nSome errors have detailed explanations: E0308, E0606.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut min_val = ListElement::new(\n     \
    \   Arc::new(Mutex::new(\n            list::min_by(lst)\n                .expect(\"\
    Mutex::lock failed for min_by operation\"),\n        )),\n    );\n    let mut\
    \ max_val = ListElement::new(\n        Arc::new(Mutex::new(\n            list::max_by(lst)\n\
    \                .expect(\"Mutex::lock failed for max_by operation\"),\n     \
    \   )),\n    );\n    loop {\n        if min_val.val.load().is_some() &&\n    \
    \        max_val.val.load().is_some() &&\n            min_val.val.load().unwrap()\n\
    \                > max_val.val.load().unwrap()\n        {\n            let mut\
    \ min_val = ListElement::new(\n                Arc::new(Mutex::new(\n        \
    \            list::min_by(lst)\n                        .expect(\"Mutex::lock\
    \ failed for min_by operation\"),\n                )),\n            );\n     \
    \       let mut max_val = ListElement::new(\n                Arc::new(Mutex::new(\n\
    \                    list::max_by(lst)\n                        .expect(\"Mutex::lock\
    \ failed for max_by operation\"),\n                )),\n            );\n     \
    \       loop {\n                if min_val.val.load().is_some() &&\n         \
    \           max_val.val.load().is_some() &&\n                    min_val.val.load().unwrap()\n\
    \                        > max_val.val.load().unwrap()\n                {\n  \
    \                  min_val = ListElement::new(\n                        Arc::new(Mutex::new(\n\
    \                            list::min_by(lst)\n                             \
    \   .expect(\"Mutex::lock failed for min_by operation\"),\n                  \
    \      )),\n                    );\n                    max_val = ListElement::new(\n\
    \                        Arc::new(Mutex::new(\n                            list::max_by(lst)\n\
    \                                .expect(\"Mutex::lock failed for max_by operation\"\
    ),\n                        )),\n                    );\n                } else\
    \ {\n                    break;\n                }\n            }\n        } else\
    \ {\n            break;\n        }\n    }\n    list::sort_by(lst, |a, b| a.cmp(b)).unwrap()\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `ListElement`\n\
    \  --> /tmp/tmp7o0c89fg.rs:12:23\n   |\n12 |     let mut min_val = ListElement::new(\n\
    \   |                       ^^^^^^^^^^^ use of undeclared type `ListElement`\n\
    \nerror[E0433]: failed to resolve: use of undeclared crate or module `list`\n\
    \  --> /tmp/tmp7o0c89fg.rs:14:13\n   |\n14 |             list::min_by(lst)\n \
    \  |             ^^^^ use of undeclared crate or module `list`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `ListElement`\n  --> /tmp/tmp7o0c89fg.rs:18:23\n\
    \   |\n18 |     let mut max_val = ListElement::new(\n   |                    \
    \   ^^^^^^^^^^^ use of undeclared type `ListElement`\n\nerror[E0433]: failed to\
    \ resolve: use of undeclared crate or module `list`\n  --> /tmp/tmp7o0c89fg.rs:20:13\n\
    \   |\n20 |             list::max_by(lst)\n   |             ^^^^ use of undeclared\
    \ crate or module `list`\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `ListElement`\n  --> /tmp/tmp7o0c89fg.rs:30:31\n   |\n30 |            \
    \ let mut min_val = ListElement::new(\n   |                               ^^^^^^^^^^^\
    \ use of undeclared type `ListElement`\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared crate or module `list`\n  --> /tmp/tmp7o0c89fg.rs:32:21\n   |\n\
    32 |                     list::min_by(lst)\n   |                     ^^^^ use\
    \ of undeclared crate or module `list`\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared type `ListElement`\n  --> /tmp/tmp7o0c89fg.rs:36:31\n   |\n36\
    \ |             let mut max_val = ListElement::new(\n   |                    \
    \           ^^^^^^^^^^^ use of undeclared type `ListElement`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared crate or module `list`\n  --> /tmp/tmp7o0c89fg.rs:38:21\n\
    \   |\n38 |                     list::max_by(lst)\n   |                     ^^^^\
    \ use of undeclared crate or module `list`\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `ListElement`\n  --> /tmp/tmp7o0c89fg.rs:48:31\n   |\n\
    48 |                     min_val = ListElement::new(\n   |                   \
    \            ^^^^^^^^^^^ use of undeclared typ"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    lst.sort_by(|a, b| {\n        let mut cmp =\
    \ a.cmp(&b);\n        if cmp != cmp::Ordering::Equal {\n            if cmp < cmp::Ordering::Less\
    \ {\n                -1\n            } else if cmp > cmp::Ordering::Greater {\n\
    \                1\n            } else {\n                0\n            }\n \
    \       } else {\n            0\n        }\n    })\n}\n\nfn main() {\n    let\
    \ candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]),\
    \ vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9,\
    \ 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6,\
    \ 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmp8uqr6mo4.rs:14:19\n   |\n14 |         if cmp != cmp::Ordering::Equal\
    \ {\n   |                   ^^^ use of undeclared crate or module `cmp`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared crate or module `cmp`\n  --> /tmp/tmp8uqr6mo4.rs:15:22\n\
    \   |\n15 |             if cmp < cmp::Ordering::Less {\n   |                 \
    \     ^^^ use of undeclared crate or module `cmp`\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared crate or module `cmp`\n  --> /tmp/tmp8uqr6mo4.rs:17:29\n \
    \  |\n17 |             } else if cmp > cmp::Ordering::Greater {\n   |        \
    \                     ^^^ use of undeclared crate or module `cmp`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8uqr6mo4.rs:16:17\n   |\n16 |              \
    \   -1\n   |                 ^^ expected enum `std::cmp::Ordering`, found integer\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp8uqr6mo4.rs:18:17\n   |\n18 |\
    \                 1\n   |                 ^ expected enum `std::cmp::Ordering`,\
    \ found integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8uqr6mo4.rs:20:17\n\
    \   |\n20 |                 0\n   |                 ^ expected enum `std::cmp::Ordering`,\
    \ found integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8uqr6mo4.rs:23:13\n\
    \   |\n23 |             0\n   |             ^ expected enum `std::cmp::Ordering`,\
    \ found integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8uqr6mo4.rs:12:5\n\
    \   |\n11 |   fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |    \
    \                                        ---------- expected `Vec<isize>` because\
    \ of return type\n12 | /     lst.sort_by(|a, b| {\n13 | |         let mut cmp\
    \ = a.cmp(&b);\n14 | |         if cmp != cmp::Ordering::Equal {\n15 | |      \
    \       if cmp < cmp::Ordering::Less {\n...  |\n24 | |         }\n25 | |     })\n\
    \   | |______^ expected struct `Vec`, found `()`\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n           found unit type `()`\n\nerror: aborting due to 8 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an err"
  stdout: ''
  timestamp: 1660010735
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut res = vec![];\n    let mut curr = lst[0];\n\
    \    let mut min_curr = lst[0];\n\n    for x in lst {\n        if x < min_curr\
    \ {\n            min_curr = x;\n        }\n\n        if x == curr {\n        \
    \    match curr {\n                x if x == min_curr => panic!(),\n         \
    \       y if y > min_curr => {\n                    res.push(y);\n           \
    \         curr = y;\n                }\n                _ => panic!(),\n     \
    \       }\n        } else {\n            res.push(x);\n            curr = x;\n\
    \        }\n    }\n\n    res.push(curr);\n    res.push(min_curr);\n    res.sort();\n\
    \    res\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''explicit panic'', /tmp/tmp4_ou71j5.rs:23:39

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = lst;\n    let mut min_value\
    \ = sorted_list.iter().min().unwrap();\n    let mut max_value = sorted_list.iter().max().unwrap();\n\
    \    for i in (0..sorted_list.len()).rev() {\n        if min_value < sorted_list[i]\
    \ {\n            min_value = sorted_list[i];\n        }\n        if max_value\
    \ > sorted_list[i] {\n            max_value = sorted_list[i];\n        }\n   \
    \ }\n    for val in sorted_list {\n        if val < min_value {\n            sorted_list.swap(val,\
    \ min_value);\n        }\n        if val > max_value {\n            sorted_list.swap(val,\
    \ max_value);\n        }\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate\
    \ = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5,\
    \ 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqc5klgj9.rs:16:24\n   |\n\
    16 |         if min_value < sorted_list[i] {\n   |                        ^^^^^^^^^^^^^^\n\
    \   |                        |\n   |                        expected `&isize`,\
    \ found `isize`\n   |                        help: consider borrowing here: `&sorted_list[i]`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpqc5klgj9.rs:17:25\n   |\n13 |\
    \     let mut min_value = sorted_list.iter().min().unwrap();\n   |           \
    \              --------------------------------- expected due to this value\n\
    ...\n17 |             min_value = sorted_list[i];\n   |                      \
    \   ^^^^^^^^^^^^^^\n   |                         |\n   |                     \
    \    expected `&isize`, found `isize`\n   |                         help: consider\
    \ borrowing here: `&sorted_list[i]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqc5klgj9.rs:19:24\n\
    \   |\n19 |         if max_value > sorted_list[i] {\n   |                    \
    \    ^^^^^^^^^^^^^^\n   |                        |\n   |                     \
    \   expected `&isize`, found `isize`\n   |                        help: consider\
    \ borrowing here: `&sorted_list[i]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqc5klgj9.rs:20:25\n\
    \   |\n14 |     let mut max_value = sorted_list.iter().max().unwrap();\n   | \
    \                        --------------------------------- expected due to this\
    \ value\n...\n20 |             max_value = sorted_list[i];\n   |             \
    \            ^^^^^^^^^^^^^^\n   |                         |\n   |            \
    \             expected `&isize`, found `isize`\n   |                         help:\
    \ consider borrowing here: `&sorted_list[i]`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpqc5klgj9.rs:24:18\n   |\n24 |         if val < min_value {\n  \
    \ |                  ^^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n24 |         if val < *min_value {\n   |   \
    \               +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqc5klgj9.rs:25:30\n\
    \   |\n25 |             sorted_list.swap(val, min_value);\n   |              \
    \          "
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut tmp = lst;\n    let mut min_val = tmp.iter().min().unwrap();\n\
    \    let mut max_val = tmp.iter().max().unwrap();\n    tmp.remove(&min_val);\n\
    \    tmp.remove(&max_val);\n    tmp.push(*min_val);\n    tmp.push(*max_val);\n\
    \    tmp.sort_by_key(|x| *x).collect::<Vec<isize>>()\n}\n\nfn main() {\n    let\
    \ candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]),\
    \ vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9,\
    \ 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6,\
    \ 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphdjrpjqp.rs:15:16\n   |\n\
    15 |     tmp.remove(&min_val);\n   |                ^^^^^^^^ expected `usize`,\
    \ found `&&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphdjrpjqp.rs:16:16\n\
    \   |\n16 |     tmp.remove(&max_val);\n   |                ^^^^^^^^ expected `usize`,\
    \ found `&&isize`\n\nerror[E0599]: `()` is not an iterator\n  --> /tmp/tmphdjrpjqp.rs:19:29\n\
    \   |\n19 |     tmp.sort_by_key(|x| *x).collect::<Vec<isize>>()\n   |        \
    \                     ^^^^^^^ `()` is not an iterator\n   |\n   = note: the following\
    \ trait bounds were not satisfied:\n           `(): Iterator`\n           which\
    \ is required by `&mut (): Iterator`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut lst_copy: Vec<isize> = lst;\n    for\
    \ element in lst_copy.iter() {\n        swap(lst_copy, element, element+1);\n\
    \    }\n    return lst_copy;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmpabsu5li7.rs:14:9\n\
    \   |\n14 |         swap(lst_copy, element, element+1);\n   |         ^^^^ not\
    \ found in this scope\n   |\nhelp: consider importing one of these items\n   |\n\
    1  | use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut res = Vec::new();\n\n    for i in lst\
    \ {\n        res.insert(i, i);\n    }\n\n    res\n}\n\nfn main() {\n    let candidate\
    \ = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5,\
    \ 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1fvctef5.rs:15:20\n   |\n\
    15 |         res.insert(i, i);\n   |                    ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n15 |         res.insert(i.try_into().unwrap(),\
    \ i);\n   |                     ++++++++++++++++++++\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut max_element: isize = 0;\n    let mut\
    \ min_element: isize = 0;\n\n    for elem in lst {\n        if elem > max_element\
    \ {\n            max_element = elem;\n        }\n        if elem < min_element\
    \ {\n            min_element = elem;\n        }\n    }\n\n    let mut lst: Vec<isize>\
    \ = Vec::new();\n    let mut min_element = min_element + 1;\n    let mut max_element\
    \ = max_element - 1;\n\n    while min_element <= max_element {\n        lst.append(min_element);\n\
    \        min_element += 1;\n        max_element -= 1;\n    }\n\n    lst\n}\n\n\
    fn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpktcri1_1.rs:29:20\n   |\n\
    29 |         lst.append(min_element);\n   |                    ^^^^^^^^^^^ expected\
    \ `&mut Vec<isize>`, found `isize`\n   |\n   = note: expected mutable reference\
    \ `&mut Vec<isize>`\n                           found type `isize`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut new_lst = Vec::new();\n    let mut\
    \ current_min = vec![0];\n    let mut current_max = vec![0];\n\n    for value\
    \ in lst {\n        if value < current_min.iter().min().unwrap() {\n         \
    \   current_min = vec![value];\n        } else {\n            current_min = current_min.iter().filter(|&elt|\
    \ elt != value).collect();\n        }\n\n        if value > current_max.iter().max().unwrap()\
    \ {\n            current_max = vec![value];\n        } else {\n            current_max\
    \ = current_max.iter().filter(|&elt| elt != value).collect();\n        }\n   \
    \ }\n\n    for value in current_min {\n        new_lst.push(value);\n    }\n\n\
    \    for value in current_max {\n        new_lst.push(value);\n    }\n\n    new_lst\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpy_os4bz6.rs:17:20\n   |\n\
    17 |         if value < current_min.iter().min().unwrap() {\n   |            \
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `&{integer}`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n17 |         if value <\
    \ *current_min.iter().min().unwrap() {\n   |                    +\n\nerror[E0277]:\
    \ can't compare `&isize` with `isize`\n  --> /tmp/tmpy_os4bz6.rs:20:64\n   |\n\
    20 |             current_min = current_min.iter().filter(|&elt| elt != value).collect();\n\
    \   |                                                                ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror[E0277]: a value of type `Vec<isize>`\
    \ cannot be built from an iterator over elements of type `&isize`\n    --> /tmp/tmpy_os4bz6.rs:20:74\n\
    \     |\n20   |             current_min = current_min.iter().filter(|&elt| elt\
    \ != value).collect();\n     |                                               \
    \                           ^^^^^^^ value of type `Vec<isize>` cannot be built\
    \ from `std::iter::Iterator<Item=&isize>`\n     |\n     = help: the trait `FromIterator<&isize>`\
    \ is not implemented for `Vec<isize>`\n     = help: the trait `FromIterator<T>`\
    \ is implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpy_os4bz6.rs:23:20\n   |\n23 |         if value\
    \ > current_max.iter().max().unwrap() {\n   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `&{integer}`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n23 |         if value > *current_max.iter().max().unwrap() {\n\
    \   |                    +\n\nerror[E0277]: can't compare `&isize` with `isize`\n\
    \  --> /tmp/tmpy_os4bz6.rs:26:64\n   |\n26 |             current_max = cu"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    sort::cmp::sort_by(\n        &lst,\n      \
    \  |e1, e2| if e1 < e2 { Some(e1) } else { Some(e2) },\n        |e1, e2| if e2\
    \ < e1 { Some(e2) } else { Some(e1) },\n    )\n}\n\nfn main() {\n    let candidate\
    \ = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5,\
    \ 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `sort`\n\
    \  --> /tmp/tmp34uv52xz.rs:12:5\n   |\n12 |     sort::cmp::sort_by(\n   |    \
    \ ^^^^ use of undeclared crate or module `sort`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    if lst.is_empty() {\n        return vec![];\n\
    \    }\n    let mut minimum = i32::MAX;\n    let mut maximum = i32::MIN;\n   \
    \ for i in lst.iter().rev() {\n        if i <= minimum {\n            minimum\
    \ = i;\n        }\n        if i > maximum {\n            maximum = i;\n      \
    \  }\n    }\n    let mut lst2 = vec![];\n    for i in lst.iter().rev() {\n   \
    \     if i < minimum && i > maximum {\n            lst2.push(i);\n        }\n\
    \    }\n    lst2\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvyvljg6a.rs:18:17\n   |\n\
    18 |         if i <= minimum {\n   |                 ^^^^^^^ expected `&isize`,\
    \ found `i32`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvyvljg6a.rs:19:23\n\
    \   |\n15 |     let mut minimum = i32::MAX;\n   |                       --------\
    \ expected due to this value\n...\n19 |             minimum = i;\n   |       \
    \                ^ expected `i32`, found `&isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpvyvljg6a.rs:21:16\n   |\n21 |         if i > maximum {\n\
    \   |                ^^^^^^^ expected `&isize`, found `i32`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpvyvljg6a.rs:22:23\n   |\n16 |     let mut maximum = i32::MIN;\n\
    \   |                       -------- expected due to this value\n...\n22 |   \
    \          maximum = i;\n   |                       ^ expected `i32`, found `&isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpvyvljg6a.rs:27:16\n   |\n27 |\
    \         if i < minimum && i > maximum {\n   |                ^^^^^^^ expected\
    \ `&isize`, found `i32`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvyvljg6a.rs:27:31\n\
    \   |\n27 |         if i < minimum && i > maximum {\n   |                    \
    \           ^^^^^^^ expected `&isize`, found `i32`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpvyvljg6a.rs:31:5\n   |\n11 | fn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n   |                                          ----------\
    \ expected `Vec<isize>` because of return type\n...\n31 |     lst2\n   |     ^^^^\
    \ expected `isize`, found `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Vec<&isize>`\n\nerror: aborting due to 7 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n    sorted_list.push(lst[0]);\n\
    \    for el in lst.iter().skip(1) {\n        sorted_list.push(el);\n        sorted_list.push(-el);\n\
    \    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjyrmhp7y.rs:15:26\n   |\n\
    15 |         sorted_list.push(el);\n   |                          ^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    15 |         sorted_list.push(*el);\n   |                          +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut min = isize::MAX;\n    let mut max\
    \ = isize::MIN;\n    for x in lst.iter() {\n        if x < min {\n           \
    \ min = x;\n        }\n        if x > max {\n            max = x;\n        }\n\
    \    }\n    let mut rev = vec![];\n    for x in lst.iter() {\n        if x < min\
    \ {\n            rev.push(x);\n        }\n        if x > max {\n            rev.push(max);\n\
    \            rev.push(x);\n        }\n        if min <= x && x < max {\n     \
    \       rev.push(x);\n        }\n    }\n    rev\n}\n\nfn main() {\n    let candidate\
    \ = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5,\
    \ 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzjsld4iv.rs:15:16\n   |\n\
    15 |         if x < min {\n   |                ^^^\n   |                |\n  \
    \ |                expected `&isize`, found `isize`\n   |                help:\
    \ consider borrowing here: `&min`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzjsld4iv.rs:16:19\n\
    \   |\n12 |     let mut min = isize::MAX;\n   |                   ---------- expected\
    \ due to this value\n...\n16 |             min = x;\n   |                   ^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n16 |             min = *x;\n   |                   +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpzjsld4iv.rs:18:16\n   |\n18 |         if x > max {\n  \
    \ |                ^^^\n   |                |\n   |                expected `&isize`,\
    \ found `isize`\n   |                help: consider borrowing here: `&max`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpzjsld4iv.rs:19:19\n   |\n13 |  \
    \   let mut max = isize::MIN;\n   |                   ---------- expected due\
    \ to this value\n...\n19 |             max = x;\n   |                   ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    19 |             max = *x;\n   |                   +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpzjsld4iv.rs:24:16\n   |\n24 |         if x < min {\n  \
    \ |                ^^^\n   |                |\n   |                expected `&isize`,\
    \ found `isize`\n   |                help: consider borrowing here: `&min`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpzjsld4iv.rs:27:16\n   |\n27 |  \
    \       if x > max {\n   |                ^^^\n   |                |\n   |   \
    \             expected `&isize`, found `isize`\n   |                help: consider\
    \ borrowing here: `&max`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzjsld4iv.rs:28:22\n\
    \   |\n28 |             rev.push(max);\n   |                      ^^^\n   |  \
    \                    |\n   |                      expected `&isize`, found `isize`\n\
    \   |                      help: consider borrowing here: `&max`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpzjs"
  stdout: ''
  timestamp: 1660010735
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut tmp = lst;\n    tmp.sort_by_key(|&x|\
    \ x);\n    tmp.iter().cloned().collect()\n}\n\nfn main() {\n    let candidate\
    \ = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5,\
    \ 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmp5hzjfnbo.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let len = lst.len();\n    let mut i = 0;\n\
    \    let mut last = Vec::new();\n    let mut current = Vec::new();\n    for i\
    \ in 0..len {\n        if lst[i] != i {\n            last.clear();\n         \
    \   current.clear();\n            current.push(lst[i]);\n            i += 1;\n\
    \        } else {\n            last.push(i);\n        }\n    }\n    last.push(len\
    \ - 1);\n    while i < last {\n        current.push(lst[i]);\n        i += 1;\n\
    \    }\n    current\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_89hylh9.rs:17:22\n   |\n\
    17 |         if lst[i] != i {\n   |                      ^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |         if lst[i] != i.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0277]: can't compare\
    \ `{integer}` with `Vec<usize>`\n  --> /tmp/tmp_89hylh9.rs:27:13\n   |\n27 | \
    \    while i < last {\n   |             ^ no implementation for `{integer} < Vec<usize>`\
    \ and `{integer} > Vec<usize>`\n   |\n   = help: the trait `PartialOrd<Vec<usize>>`\
    \ is not implemented for `{integer}`\n   = help: the following other types implement\
    \ trait `PartialOrd<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut res = vec![];\n    let mut min = lst.iter().min().unwrap();\n\
    \    for e in lst {\n        if e == min {\n            res.push(e);\n       \
    \ } else {\n            res.push(min);\n            min = e;\n        }\n    }\n\
    \    res.push(min);\n    res\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppv55g51p.rs:15:17\n   |\n\
    15 |         if e == min {\n   |                 ^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n15 |         if e == *min\
    \ {\n   |                 +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppv55g51p.rs:18:22\n\
    \   |\n18 |             res.push(min);\n   |                      ^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    18 |             res.push(*min);\n   |                      +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmppv55g51p.rs:19:19\n   |\n13 |     let mut min\
    \ = lst.iter().min().unwrap();\n   |                   -------------------------\
    \ expected due to this value\n...\n19 |             min = e;\n   |           \
    \        ^\n   |                   |\n   |                   expected `&isize`,\
    \ found `isize`\n   |                   help: consider borrowing here: `&e`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmppv55g51p.rs:22:14\n   |\n22 |  \
    \   res.push(min);\n   |              ^^^ expected `isize`, found `&isize`\n \
    \  |\nhelp: consider dereferencing the borrow\n   |\n22 |     res.push(*min);\n\
    \   |              +\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut res = vec![];\n\n    loop {\n     \
    \   if res.is_empty() {\n            match lst {\n                vec![_] => return\
    \ vec![],\n                x => return vec![x],\n            }\n        }\n\n\
    \        let mut min_val = res.last().unwrap();\n        let mut max_val = min_val;\n\
    \n        for value in lst {\n            if value < min_val {\n             \
    \   min_val = value;\n            }\n\n            if value > max_val {\n    \
    \            max_val = value;\n            }\n        }\n\n        res.insert(max_val\
    \ as usize);\n    }\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error: no rules expected the token `_`\n  --> /tmp/tmpd_43zax6.rs:17:22\n\
    \   |\n17 |                 vec![_] => return vec![],\n   |                  \
    \    ^ no rules expected this token in macro call\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpd_43zax6.rs:18:34\n   |\n18 |                 x => return\
    \ vec![x],\n   |                                  ^ expected `isize`, found struct\
    \ `Vec`\n   |\n   = note: expected type `isize`\n            found struct `Vec<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpd_43zax6.rs:26:24\n   |\n26 |\
    \             if value < min_val {\n   |                        ^^^^^^^ expected\
    \ `isize`, found reference\n   |\n   = note:   expected type `isize`\n       \
    \    found reference `&_`\nhelp: consider dereferencing the borrow\n   |\n26 |\
    \             if value < *min_val {\n   |                        +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpd_43zax6.rs:27:27\n   |\n22 |         let mut\
    \ min_val = res.last().unwrap();\n   |                           -------------------\
    \ expected due to this value\n...\n27 |                 min_val = value;\n   |\
    \                           ^^^^^\n   |                           |\n   |    \
    \                       expected reference, found `isize`\n   |              \
    \             help: consider borrowing here: `&value`\n   |\n   = note: expected\
    \ reference `&_`\n                   found type `isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpd_43zax6.rs:30:24\n   |\n30 |             if value > max_val\
    \ {\n   |                        ^^^^^^^ expected `isize`, found reference\n \
    \  |\n   = note:   expected type `isize`\n           found reference `&_`\nhelp:\
    \ consider dereferencing the borrow\n   |\n30 |             if value > *max_val\
    \ {\n   |                        +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpd_43zax6.rs:31:27\n\
    \   |\n23 |         let mut max_val = min_val;\n   |                         \
    \  ------- expected due to this value\n...\n31 |                 max_val = value;\n\
    \   |                           ^^^^^\n   |                           |\n   |\
    \                           expected reference, f"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut min_i = vec![];\n    let mut max_i\
    \ = vec![];\n    let mut tmp_i = vec![];\n    let mut tmp = vec![];\n    for i\
    \ in lst.iter() {\n        if i == min_i {\n            tmp_i.push(i);\n     \
    \   } else if i == max_i {\n            tmp.push(tmp_i);\n        } else {\n \
    \           tmp_i.push(i);\n        }\n    }\n    tmp.push(tmp_i);\n    min_i.push(0);\n\
    \    max_i.push(0);\n    tmp.push(min_i);\n    tmp.push(max_i);\n    tmp.push(min_i);\n\
    \    tmp.push(max_i);\n    tmp.push(min_i);\n    tmp.push(max_i);\n    tmp.push(min_i);\n\
    \    tmp.push(max_i);\n    tmp.push(min_i);\n    tmp.push(max_i);\n    tmp.push(min_i);\n\
    \    tmp.push(max_i);\n    tmp.push(min_i);\n    tmp.push(max_i);\n    tmp.push(min_i);\n\
    \    tmp.push(max_i);\n    tmp.push(min_i);\n    tmp.push(max_i);\n    tmp.push(min_i);\n\
    \    tmp.push(max_i);\n    tmp.push(min_i);\n    tmp.push(max_i);\n    tmp.push(min_i);\n\
    \    tmp.push(max_i);\n    tmp.push(min_i);\n    tmp.push(max_i);\n    tmp.push(min_i);\n\
    \    tmp.push(max_i);\n    tmp.push(min_i);\n    tmp.push(max_i);\n    tmp.push(min_i);\n\
    \    tmp.push(max_i);\n    tmp.push(min_i);\n    tmp.push(max_i);\n    tmp.push(min_i);\n\
    \    tmp.push(max_i);\n    tmp.push(min_i);\n    tmp.push(max_i);\n    tmp.push(min_i);\n\
    \    tmp.push(max_i);\n    tmp.push(min_i);\n    tmp.push(max_i);\n    tmp.push(min_i);\n\
    \    tmp.push(max_i);\n    tmp.push(min_i);\n    tmp.push(max_i);\n    tmp.push(min_i);\n\
    \    tmp.push(max_i);\n    tmp.push(min_i);\n    tmp.push(max_i);\n    tmp.push(min_i);\n\
    \    tmp.push(max_i);\n    tmp.push(min_i);\n    tmp.push(max_i);\n    tmp.push(min_i);\n\
    \    tmp.push(max_i);\n    tmp.push(min_i);\n    tmp.push(max_i);\n    tmp.push(min_i);\n\
    \    tmp.push(max_i);\n    tmp.push(min_i);\n    tmp.push(max_i);\n    tmp.push(min_i);\n\
    \    tmp.push(max_i);\n    tmp.push(min_i);\n    tmp.push(max_i);\n    tmp.push(min_i);\n\
    \    tmp.push(max_i);\n    tmp.push(min_i);\n    tmp.push(\n}\n\nfn main() {\n\
    \    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5,\
    \ 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2,\
    \ 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8,\
    \ 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n  \
    \  assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpxeisdmqk.rs:97:13\n\
    \   |\n11 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |      \
    \                                               - closing delimiter possibly meant\
    \ for this\n...\n97 |     tmp.push(\n   |             ^ unclosed delimiter\n98\
    \ | }\n   | ^ mismatched closing delimiter\n\nerror[E0277]: can't compare `&isize`\
    \ with `Vec<_>`\n  --> /tmp/tmpxeisdmqk.rs:17:14\n   |\n17 |         if i == min_i\
    \ {\n   |              ^^ no implementation for `&isize == Vec<_>`\n   |\n   =\
    \ help: the trait `PartialEq<Vec<_>>` is not implemented for `&isize`\n   = help:\
    \ the following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \nerror[E0277]: can't compare `&isize` with `Vec<_>`\n  --> /tmp/tmpxeisdmqk.rs:19:21\n\
    \   |\n19 |         } else if i == max_i {\n   |                     ^^ no implementation\
    \ for `&isize == Vec<_>`\n   |\n   = help: the trait `PartialEq<Vec<_>>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpxeisdmqk.rs:28:14\n   |\n28 |     tmp.push(min_i);\n   |           \
    \   ^^^^^ expected `&isize`, found integer\n   |\n   = note: expected struct `Vec<&isize>`\n\
    \              found struct `Vec<{integer}>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpxeisdmqk.rs:29:14\n   |\n29 |     tmp.push(max_i);\n   |      \
    \        ^^^^^ expected `&isize`, found integer\n   |\n   = note: expected struct\
    \ `Vec<&isize>`\n              found struct `Vec<{integer}>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpxeisdmqk.rs:30:14\n   |\n30 |     tmp.push(min_i);\n\
    \   |              ^^^^^ expected `&isize`, found integer\n   |\n   = note: expected\
    \ struct `Vec<&isize>`\n              found struct `"
  stdout: ''
  timestamp: 1660010736
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result: Vec<isize> = Vec::with_capacity(lst.len());\n\
    \    let mut current_min: isize = (*lst).min().unwrap();\n    let mut current_max:\
    \ isize = (*lst).max().unwrap();\n\n    for &i in lst {\n        if i > current_max\
    \ {\n            result.push(i);\n            current_max = i;\n        } else\
    \ if i < current_min {\n            result.push(current_max);\n            result.push(i);\n\
    \            current_min = i;\n        } else {\n            result.push(i);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the size for values of type `[isize]` cannot be known at\
    \ compilation time\n   --> /tmp/tmpzacyvzmy.rs:13:41\n    |\n13  |     let mut\
    \ current_min: isize = (*lst).min().unwrap();\n    |                         \
    \                ^^^ doesn't have a size known at compile-time\n    |\n    = help:\
    \ the trait `Sized` is not implemented for `[isize]`\nnote: required by a bound\
    \ in `std::cmp::Ord::min`\n\nerror[E0061]: this function takes 1 argument but\
    \ 0 arguments were supplied\n   --> /tmp/tmpzacyvzmy.rs:13:41\n    |\n13  |  \
    \   let mut current_min: isize = (*lst).min().unwrap();\n    |               \
    \                          ^^^- supplied 0 arguments\n    |                  \
    \                       |\n    |                                         expected\
    \ 1 argument\n    |\nnote: associated function defined here\n\nerror[E0599]: no\
    \ method named `unwrap` found for slice `[isize]` in the current scope\n  -->\
    \ /tmp/tmpzacyvzmy.rs:13:47\n   |\n13 |     let mut current_min: isize = (*lst).min().unwrap();\n\
    \   |                                               ^^^^^^ help: there is an associated\
    \ function with a similar name: `swap`\n\nerror[E0277]: the size for values of\
    \ type `[isize]` cannot be known at compilation time\n   --> /tmp/tmpzacyvzmy.rs:14:41\n\
    \    |\n14  |     let mut current_max: isize = (*lst).max().unwrap();\n    | \
    \                                        ^^^ doesn't have a size known at compile-time\n\
    \    |\n    = help: the trait `Sized` is not implemented for `[isize]`\nnote:\
    \ required by a bound in `std::cmp::Ord::max`\n\nerror[E0061]: this function takes\
    \ 1 argument but 0 arguments were supplied\n   --> /tmp/tmpzacyvzmy.rs:14:41\n\
    \    |\n14  |     let mut current_max: isize = (*lst).max().unwrap();\n    | \
    \                                        ^^^- supplied 0 arguments\n    |    \
    \                                     |\n    |                               \
    \          expected 1 argument\n    |\nnote: associated function defined here\n\
    \nerror[E0599]: no method named `unwrap` found for slice `[isize]` in the current\
    \ scope\n  --> /tmp/tmpzacyvzmy.rs:14:47\n   "
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut lst = lst.to_vec();\n    lst.sort_by_key(|&x|\
    \ match x.cmp(&lst[0]) {\n        Ordering::Less => 1,\n        Ordering::Greater\
    \ => -1,\n        Ordering::Equal => 0,\n    });\n    lst\n}\n\nfn main() {\n\
    \    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5,\
    \ 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2,\
    \ 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8,\
    \ 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n  \
    \  assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmpi2akknkj.rs:14:9\n   |\n14 |         Ordering::Less => 1,\n   |    \
    \     ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `Ordering`\n  --> /tmp/tmpi2akknkj.rs:15:9\n   |\n15\
    \ |         Ordering::Greater => -1,\n   |         ^^^^^^^^ use of undeclared\
    \ type `Ordering`\n\nerror[E0433]: failed to resolve: use of undeclared type `Ordering`\n\
    \  --> /tmp/tmpi2akknkj.rs:16:9\n   |\n16 |         Ordering::Equal => 0,\n  \
    \ |         ^^^^^^^^ use of undeclared type `Ordering`\n\nerror: aborting due\
    \ to 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut v = lst;\n    let mut len = v.len()\
    \ - 1;\n    v.swap(0, len);\n    for (i, &val) in v.iter().rev().enumerate() {\n\
    \        for (j, &val2) in v.iter().rev().enumerate() {\n            if *val2\
    \ > *val {\n                v.swap(i, j);\n                break;\n          \
    \  }\n        }\n    }\n    v\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmppyz9hnzi.rs:17:16\n\
    \   |\n17 |             if *val2 > *val {\n   |                ^^^^^\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmppyz9hnzi.rs:17:24\n   |\n\
    17 |             if *val2 > *val {\n   |                        ^^^^\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut slst = lst;\n    let mut i = slst[0];\n\
    \    let mut j = 0;\n    let mut min_len = isize::MAX;\n    while i < slst.get_len()\
    \ {\n        let mut min = i;\n        for j in slst.iter().rev() {\n        \
    \    if slst[j] < min {\n                min = j;\n            }\n        }\n\
    \        if min != i {\n            slst[min] = slst[i];\n            slst[i]\
    \ = min;\n            i += 1;\n        } else {\n            i += 1;\n       \
    \ }\n        min_len = min.cmp(&min_len);\n    }\n    slst\n}\n\nfn main() {\n\
    \    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5,\
    \ 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2,\
    \ 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8,\
    \ 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n  \
    \  assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `get_len` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmp1nhiqcfe.rs:16:20\n   |\n16 |     while i <\
    \ slst.get_len() {\n   |                    ^^^^^^^ help: there is an associated\
    \ function with a similar name: `set_len`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `&isize`\n  --> /tmp/tmp1nhiqcfe.rs:19:16\n   |\n19 | \
    \            if slst[j] < min {\n   |                ^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1nhiqcfe.rs:20:23\n\
    \   |\n17 |         let mut min = i;\n   |                       - expected due\
    \ to this value\n...\n20 |                 min = j;\n   |                    \
    \   ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n20 |                 min = *j;\n   |                       +\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp1nhiqcfe.rs:24:13\n\
    \   |\n24 |             slst[min] = slst[i];\n   |             ^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp1nhiqcfe.rs:24:25\n   |\n24 |  \
    \           slst[min] = slst[i];\n   |                         ^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isiz"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_lst = Vec::new();\n    let mut\
    \ min_value = lst[0];\n    let mut max_value = lst[0];\n\n    for val in lst {\n\
    \        if val < min_value {\n            min_value = val;\n        } else if\
    \ val > max_value {\n            max_value = val;\n        }\n    }\n\n    for\
    \ val in lst {\n        if val == min_value {\n            sorted_lst.push(min_value);\n\
    \        } else if (val == max_value) {\n            sorted_lst.push(max_value);\n\
    \        } else {\n            sorted_lst.push(val);\n        }\n    }\n\n   \
    \ sorted_lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp3k1mpaze.rs:27:19\n\
    \   |\n27 |         } else if (val == max_value) {\n   |                   ^ \
    \               ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp:\
    \ remove these parentheses\n   |\n27 -         } else if (val == max_value) {\n\
    27 +         } else if val == max_value {\n   | \n\nerror[E0382]: use of moved\
    \ value: `lst`\n   --> /tmp/tmp3k1mpaze.rs:24:16\n    |\n11  | fn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    |                      --- move occurs because\
    \ `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n...\n\
    16  |     for val in lst {\n    |                --- `lst` moved due to this implicit\
    \ call to `.into_iter()`\n...\n24  |     for val in lst {\n    |             \
    \   ^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice\
    \ of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n16\
    \  |     for val in &lst {\n    |                +\n\nerror: aborting due to previous\
    \ error; 1 warning emitted\n\nFor more information about this error, try `rustc\
    \ --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut min = *lst.iter().min().unwrap();\n\
    \    let mut max = *lst.iter().max().unwrap();\n    let mut min = *lst.iter().skip(1).min().unwrap();\n\
    \n    if min < max {\n        /*\n        TODO : This can be done without iterating.\n\
    \        Just iterate through the vector, skipping the first element\n       \
    \ and looking for the maximum.\n        */\n        for elt in lst.iter() {\n\
    \            if *elt >= max {\n                min = *elt;\n                max\
    \ = *lst.iter().skip(1).max().unwrap();\n            }\n        }\n    } else\
    \ {\n        min = *lst.iter().min().unwrap();\n    }\n\n    vec![min, max]\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[4, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpdk8iybwt.rs:37:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = vec![];\n    let mut min =\
    \ *lst.iter().min_unwrap_or_else(|| {\n        isize::MAX\n    });\n    let mut\
    \ max = *lst.iter().max_unwrap_or_else(|| {\n        isize::MIN\n    });\n   \
    \ let mut min_idx = 0;\n    let mut max_idx = lst.len() - 1;\n\n    while min_idx\
    \ < max_idx {\n        if lst[min_idx] >= min {\n            min_idx = min_idx\
    \ + 1;\n        } else {\n            let tmp = lst[min_idx];\n            lst[min_idx]\
    \ = min;\n            min = tmp;\n            min_idx = min_idx + 1;\n       \
    \ }\n\n        if lst[max_idx] <= max {\n            max_idx = max_idx - 1;\n\
    \        } else {\n            let tmp = lst[max_idx];\n            lst[max_idx]\
    \ = max;\n            max = tmp;\n            max_idx = max_idx - 1;\n       \
    \ }\n    }\n\n    result.append(min);\n    result.extend(lst.iter().skip(min_idx).cloned());\n\
    \    result.append(max);\n    result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `min_unwrap_or_else` found for struct `std::slice::Iter`\
    \ in the current scope\n  --> /tmp/tmp70bgh_nv.rs:13:31\n   |\n13 |     let mut\
    \ min = *lst.iter().min_unwrap_or_else(|| {\n   |                            \
    \   ^^^^^^^^^^^^^^^^^^ method not found in `std::slice::Iter<'_, isize>`\n\nerror[E0599]:\
    \ no method named `max_unwrap_or_else` found for struct `std::slice::Iter` in\
    \ the current scope\n  --> /tmp/tmp70bgh_nv.rs:16:31\n   |\n16 |     let mut max\
    \ = *lst.iter().max_unwrap_or_else(|| {\n   |                               ^^^^^^^^^^^^^^^^^^\
    \ method not found in `std::slice::Iter<'_, isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp70bgh_nv.rs:42:19\n   |\n42 |     result.append(min);\n\
    \   |                   ^^^ expected `&mut Vec<_>`, found `isize`\n   |\n   =\
    \ note: expected mutable reference `&mut Vec<_>`\n                           found\
    \ type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp70bgh_nv.rs:44:19\n\
    \   |\n44 |     result.append(max);\n   |                   ^^^ expected `&mut\
    \ Vec<isize>`, found `isize`\n   |\n   = note: expected mutable reference `&mut\
    \ Vec<isize>`\n                           found type `isize`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut min = lst.iter().min();\n    let mut\
    \ max = lst.iter().max();\n    lst.iter_mut().for_each(|x| {\n        if x < min\
    \ {\n            min = x;\n        }\n        if x > max {\n            max =\
    \ x;\n        }\n    });\n    vec.sort_by(|a, b| a.cmp(b));\n    for i in min..max\
    \ {\n        lst.insert(i, i);\n    }\n    lst\n}\n\nfn main() {\n    let candidate\
    \ = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5,\
    \ 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0423]: expected value, found macro `vec`\n  --> /tmp/tmp7r6u80fn.rs:22:5\n\
    \   |\n22 |     vec.sort_by(|a, b| a.cmp(b));\n   |     ^^^ not a value\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp7r6u80fn.rs:15:16\n   |\n15 |         if x <\
    \ min {\n   |                ^^^ expected `&mut isize`, found enum `Option`\n\
    \   |\n   = note: expected mutable reference `&mut isize`\n                  \
    \         found enum `Option<&isize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp7r6u80fn.rs:16:19\n   |\n12 |     let mut min = lst.iter().min();\n\
    \   |                   ---------------- expected due to this value\n...\n16 |\
    \             min = x;\n   |                   ^ expected enum `Option`, found\
    \ `&mut isize`\n   |\n   = note:           expected enum `Option<&isize>`\n  \
    \         found mutable reference `&mut isize`\nhelp: try wrapping the expression\
    \ in `Some`\n   |\n16 |             min = Some(x);\n   |                   +++++\
    \ +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7r6u80fn.rs:18:16\n   |\n\
    18 |         if x > max {\n   |                ^^^ expected `&mut isize`, found\
    \ enum `Option`\n   |\n   = note: expected mutable reference `&mut isize`\n  \
    \                         found enum `Option<&isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp7r6u80fn.rs:19:19\n   |\n13 |     let mut max = lst.iter().max();\n\
    \   |                   ---------------- expected due to this value\n...\n19 |\
    \             max = x;\n   |                   ^ expected enum `Option`, found\
    \ `&mut isize`\n   |\n   = note:           expected enum `Option<&isize>`\n  \
    \         found mutable reference `&mut isize`\nhelp: try wrapping the expression\
    \ in `Some`\n   |\n19 |             max = Some(x);\n   |                   +++++\
    \ +\n\nerror[E0277]: the trait bound `Option<&isize>: Step` is not satisfied\n\
    \  --> /tmp/tmp7r6u80fn.rs:23:14\n   |\n23 |     for i in min..max {\n   |   \
    \           ^^^^^^^^ the trait `Step` is not implemented for `Option<&isize>`\n\
    \   |\n   = help: the following other types implement trait `Step`:\n        \
    \     char\n             i128\n             i16\n             i32\n          \
    \   "
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    if lst.len() == 0 {\n        return vec![];\n\
    \    }\n    let mut current_minimum = i32::MAX;\n    let mut current_maximum =\
    \ i32::MIN;\n    let mut current_index = vec![];\n    for i in lst.iter().rev()\
    \ {\n        let current_number = *i;\n        if current_minimum > current_number\
    \ {\n            current_minimum = current_number;\n        }\n        if current_maximum\
    \ < current_number {\n            current_maximum = current_number;\n        }\n\
    \        current_index.append(current_number);\n    }\n    let mut final_list\
    \ = vec![];\n    for i in current_index.iter() {\n        final_list.append(i);\n\
    \    }\n    final_list.sort();\n    for i in final_list.iter().rev() {\n     \
    \   final_list.append(i);\n    }\n    final_list\n}\n\nfn main() {\n    let candidate\
    \ = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5,\
    \ 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpv2ci6r85.rs:20:30\n   |\n\
    20 |         if current_minimum > current_number {\n   |                     \
    \         ^^^^^^^^^^^^^^ expected `i32`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to an `i32` and panic if the converted value doesn't fit\n   |\n\
    20 |         if current_minimum > current_number.try_into().unwrap() {\n   | \
    \                                           ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpv2ci6r85.rs:21:31\n   |\n15 |     let mut current_minimum\
    \ = i32::MAX;\n   |                               -------- expected due to this\
    \ value\n...\n21 |             current_minimum = current_number;\n   |       \
    \                        ^^^^^^^^^^^^^^ expected `i32`, found `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpv2ci6r85.rs:23:30\n   |\n23 |         if current_maximum\
    \ < current_number {\n   |                              ^^^^^^^^^^^^^^ expected\
    \ `i32`, found `isize`\n   |\nhelp: you can convert an `isize` to an `i32` and\
    \ panic if the converted value doesn't fit\n   |\n23 |         if current_maximum\
    \ < current_number.try_into().unwrap() {\n   |                               \
    \             ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpv2ci6r85.rs:24:31\n\
    \   |\n16 |     let mut current_maximum = i32::MIN;\n   |                    \
    \           -------- expected due to this value\n...\n24 |             current_maximum\
    \ = current_number;\n   |                               ^^^^^^^^^^^^^^ expected\
    \ `i32`, found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpv2ci6r85.rs:26:30\n\
    \   |\n26 |         current_index.append(current_number);\n   |              \
    \                ^^^^^^^^^^^^^^ expected `&mut Vec<_>`, found `isize`\n   |\n\
    \   = note: expected mutable reference `&mut Vec<_>`\n                       \
    \    found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpv2ci6r85.rs:30:27\n\
    \   |\n30 |         final_list.append(i);\n   |                           ^ types\
    \ differ in mutability\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    sort_with_first_element(lst)\n}\n\nfn main()\
    \ {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `sort_with_first_element` in this scope\n\
    \  --> /tmp/tmpuzbtwtx6.rs:12:5\n   |\n12 |     sort_with_first_element(lst)\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut min = isize::MAX;\n    let mut max\
    \ = isize::MIN;\n    let mut reverse = vec![];\n    for v in lst {\n        if\
    \ v < min {\n            min = v;\n        }\n        if v > max {\n         \
    \   max = v;\n        }\n        reverse.push(v);\n    }\n    for v in lst {\n\
    \        if v == max {\n            reverse.push(v);\n        }\n    }\n    for\
    \ v in lst {\n        if v == min {\n            reverse.push(v);\n        }\n\
    \    }\n    reverse\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmpe6uw4wkt.rs:24:14\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n15  |     for v in lst {\n    |  \
    \            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n\
    24  |     for v in lst {\n    |              ^^^ value used here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to\
    \ avoid moving into the `for` loop\n    |\n15  |     for v in &lst {\n    |  \
    \            +\n\nerror[E0382]: use of moved value: `lst`\n  --> /tmp/tmpe6uw4wkt.rs:29:14\n\
    \   |\n11 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |      \
    \                --- move occurs because `lst` has type `Vec<isize>`, which does\
    \ not implement the `Copy` trait\n...\n24 |     for v in lst {\n   |         \
    \     --- `lst` moved due to this implicit call to `.into_iter()`\n...\n29 | \
    \    for v in lst {\n   |              ^^^ value used here after move\n   |\n\
    help: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving\
    \ into the `for` loop\n   |\n24 |     for v in &lst {\n   |              +\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result: Vec<isize> = Vec::new();\n\
    \    result.push(lst.min());\n    let mut first_item = result.last().unwrap();\n\
    \    let mut last_item = first_item;\n    for element in lst {\n        last_item\
    \ = element;\n        result.push(last_item);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \   --> /tmp/tmpzoezbyxx.rs:13:21\n    |\n13  |     result.push(lst.min());\n\
    \    |                     ^^^- supplied 0 arguments\n    |                  \
    \   |\n    |                     expected 1 argument\n    |\nnote: associated\
    \ function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzoezbyxx.rs:13:17\n\
    \   |\n13 |     result.push(lst.min());\n   |                 ^^^^^^^^^ expected\
    \ `isize`, found struct `Vec`\n   |\n   = note: expected type `isize`\n      \
    \      found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzoezbyxx.rs:17:21\n\
    \   |\n15 |     let mut last_item = first_item;\n   |                        \
    \ ---------- expected due to this value\n16 |     for element in lst {\n17 | \
    \        last_item = element;\n   |                     ^^^^^^^\n   |        \
    \             |\n   |                     expected `&isize`, found `isize`\n \
    \  |                     help: consider borrowing here: `&element`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpzoezbyxx.rs:18:21\n   |\n18 |         result.push(last_item);\n\
    \   |                     ^^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n18 |         result.push(*last_item);\n\
    \   |                     +\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0061, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = lst.to_vec();\n    sorted_list.sort();\n\
    \    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpnyk0dw5e.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    if lst.is_empty() {\n        return lst;\n\
    \    }\n    let mut new_list = vec![];\n    let mut min_value = std::i32::MIN;\n\
    \    let mut max_value = std::i32::MAX;\n    for v in lst {\n        if v < min_value\
    \ {\n            /*\n                min value is now min_value\n            \
    \    min value was found at position 0\n                new min value = v\n  \
    \          */\n            new_list.insert(0, v);\n            min_value = v;\n\
    \        } else {\n            if v > max_value {\n                /*\n      \
    \              max value is now max_value\n                    max value was found\
    \ at position 0\n                    new max value = v\n                */\n \
    \               new_list.insert(0, v);\n                max_value = v;\n     \
    \       } else {\n                /*\n                    min value is now max_value\n\
    \                    max value was found at position 0\n                    new\
    \ min value = v\n                */\n                new_list.insert(0, v);\n\
    \                max_value = v;\n            }\n        }\n    }\n    new_list\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvmplqs7p.rs:19:16\n   |\n\
    19 |         if v < min_value {\n   |                ^^^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |         if v < min_value.try_into().unwrap()\
    \ {\n   |                         ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpvmplqs7p.rs:26:25\n   |\n16 |     let mut min_value = std::i32::MIN;\n\
    \   |                         ------------- expected due to this value\n...\n\
    26 |             min_value = v;\n   |                         ^ expected `i32`,\
    \ found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvmplqs7p.rs:28:20\n\
    \   |\n28 |             if v > max_value {\n   |                    ^^^^^^^^^\
    \ expected `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n28 |             if v >\
    \ max_value.try_into().unwrap() {\n   |                             ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpvmplqs7p.rs:35:29\n   |\n17 |\
    \     let mut max_value = std::i32::MAX;\n   |                         -------------\
    \ expected due to this value\n...\n35 |                 max_value = v;\n   | \
    \                            ^ expected `i32`, found `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpvmplqs7p.rs:43:29\n   |\n17 |     let mut max_value\
    \ = std::i32::MAX;\n   |                         ------------- expected due to\
    \ this value\n...\n43 |                 max_value = v;\n   |                 \
    \            ^ expected `i32`, found `isize`\n\nerror: aborting due to 5 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    match lst {\n        [] => vec![],\n      \
    \  l => lst.sort_unstable().collect()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5,\
    \ 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0529]: expected an array or slice, found `Vec<isize>`\n  --> /tmp/tmpypr82k0r.rs:13:9\n\
    \   |\n12 |     match lst {\n   |           --- help: consider slicing here: `lst[..]`\n\
    13 |         [] => vec![],\n   |         ^^ pattern cannot match with input type\
    \ `Vec<isize>`\n\nerror[E0599]: `()` is not an iterator\n  --> /tmp/tmpypr82k0r.rs:14:34\n\
    \   |\n14 |         l => lst.sort_unstable().collect()\n   |                 \
    \                 ^^^^^^^ `()` is not an iterator\n   |\n   = note: the following\
    \ trait bounds were not satisfied:\n           `(): Iterator`\n           which\
    \ is required by `&mut (): Iterator`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0529, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0529`.\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = lst;\n    for i in 1..sorted_list.len()\
    \ {\n        let min = sorted_list[i];\n        let max_idx = i;\n\n        for\
    \ j in i..sorted_list.len() {\n            if sorted_list[j] < min {\n       \
    \         min = sorted_list[j];\n                max_idx = j;\n            }\n\
    \        }\n\n        let tmp = sorted_list[max_idx];\n        sorted_list[max_idx]\
    \ = sorted_list[i];\n        sorted_list[i] = tmp;\n    }\n    sorted_list\n}\n\
    \nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign twice to immutable variable `min`\n  --> /tmp/tmphn1jrxr0.rs:19:17\n\
    \   |\n14 |         let min = sorted_list[i];\n   |             ---\n   |    \
    \         |\n   |             first assignment to `min`\n   |             help:\
    \ consider making this binding mutable: `mut min`\n...\n19 |                 min\
    \ = sorted_list[j];\n   |                 ^^^^^^^^^^^^^^^^^^^^ cannot assign twice\
    \ to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable\
    \ `max_idx`\n  --> /tmp/tmphn1jrxr0.rs:20:17\n   |\n15 |         let max_idx =\
    \ i;\n   |             -------\n   |             |\n   |             first assignment\
    \ to `max_idx`\n   |             help: consider making this binding mutable: `mut\
    \ max_idx`\n...\n20 |                 max_idx = j;\n   |                 ^^^^^^^^^^^\
    \ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let len = lst.len();\n    let mut sorted =\
    \ vec![];\n    sorted.push(lst[0]);\n    for i in 1..len - 1 {\n        let j\
    \ = (i - 1) * (len - 1) + i;\n        if lst[j] > lst[j + 1] {\n            sorted.push(lst[j]);\n\
    \            sorted.push(lst[j + 1]);\n        }\n    }\n    sorted\n}\n\nfn main()\
    \ {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 4 but the
    index is 5'', /tmp/tmpnptr0o73.rs:17:12

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010735
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    debug_assert!(lst.len() > 1);\n    let mut\
    \ lst = lst;\n    lst.sort();\n    lst\n}\n\nfn main() {\n    let candidate =\
    \ strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5,\
    \ 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpz93lur_w.rs:20:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = Vec::new();\n    let\
    \ mut min_value = lst[0];\n    let mut max_value = lst[0];\n    for i in lst.iter().skip(1)\
    \ {\n        if *i < min_value {\n            min_value = *i;\n        }\n   \
    \     if *i > max_value {\n            max_value = *i;\n        }\n    }\n   \
    \ for i in lst.iter().take(lst.len() - 1).rev() {\n        if *i < min_value {\n\
    \            min_value = *i;\n        }\n        if *i > max_value {\n       \
    \     max_value = *i;\n        }\n    }\n    for i in lst.iter() {\n        if\
    \ i == min_value {\n            sorted_list.push(i);\n        } else if i == max_value\
    \ {\n            sorted_list.push(i);\n        } else {\n            sorted_list.push(min_value);\n\
    \            sorted_list.push(i);\n            sorted_list.push(max_value);\n\
    \        }\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpqouj13vj.rs:32:14\n\
    \   |\n32 |         if i == min_value {\n   |              ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror[E0277]: can't compare `&isize`\
    \ with `isize`\n  --> /tmp/tmpqouj13vj.rs:34:21\n   |\n34 |         } else if\
    \ i == max_value {\n   |                     ^^ no implementation for `&isize\
    \ == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqouj13vj.rs:37:30\n\
    \   |\n37 |             sorted_list.push(min_value);\n   |                   \
    \           ^^^^^^^^^\n   |                              |\n   |             \
    \                 expected `&isize`, found `isize`\n   |                     \
    \         help: consider borrowing here: `&min_value`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpqouj13vj.rs:39:30\n   |\n39 |             sorted_list.push(max_value);\n\
    \   |                              ^^^^^^^^^\n   |                           \
    \   |\n   |                              expected `&isize`, found `isize`\n  \
    \ |                              help: consider borrowing here: `&max_value`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpqouj13vj.rs:42:5\n   |\n11 | fn\
    \ strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |                   \
    \                       ---------- expected `Vec<isize>` because of return type\n\
    ...\n42 |     sorted_list\n   |     ^^^^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              foun"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut lst = lst.to_owned();\n\n    let mut\
    \ min = std::i32::MAX;\n    let mut max = std::i32::MIN;\n    let mut i = 0;\n\
    \n    while i < lst.len() {\n        if lst[i] < min {\n            min = lst[i];\n\
    \        }\n\n        if lst[i] > max {\n            max = lst[i];\n        }\n\
    \n        i += 1;\n    }\n\n    let mut ret = vec![];\n\n    while i < lst.len()\
    \ {\n        let idx = min.wrapping_add(1).wrapping_mul(i as usize).wrapping_add(1);\n\
    \n        ret.push(idx);\n        i += 1;\n    }\n\n    ret\n}\n\nfn main() {\n\
    \    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5,\
    \ 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2,\
    \ 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8,\
    \ 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n  \
    \  assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp83c0sdtu.rs:19:21\n   |\n\
    19 |         if lst[i] < min {\n   |                     ^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |         if lst[i] < min.try_into().unwrap()\
    \ {\n   |                        ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp83c0sdtu.rs:20:19\n   |\n14 |     let mut min = std::i32::MAX;\n\
    \   |                   ------------- expected due to this value\n...\n20 |  \
    \           min = lst[i];\n   |                   ^^^^^^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp83c0sdtu.rs:23:21\n\
    \   |\n23 |         if lst[i] > max {\n   |                     ^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n23 |         if lst[i] > max.try_into().unwrap()\
    \ {\n   |                        ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp83c0sdtu.rs:24:19\n   |\n15 |     let mut max = std::i32::MIN;\n\
    \   |                   ------------- expected due to this value\n...\n24 |  \
    \           max = lst[i];\n   |                   ^^^^^^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp83c0sdtu.rs:33:52\n\
    \   |\n33 |         let idx = min.wrapping_add(1).wrapping_mul(i as usize).wrapping_add(1);\n\
    \   |                                                    ^^^^^^^^^^ expected `i32`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `i32` and panic if\
    \ the converted value doesn't fit\n   |\n33 |         let idx = min.wrapping_add(1).wrapping_mul((i\
    \ as usize).try_into().unwrap()).wrapping_add(1);\n   |                      \
    \                              +          +++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp83c0sdtu.rs:39:5\n   |\n11 | fn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n   |                                          ----------\
    \ expected `Vec<isize>` because of return type\n...\n39 |     ret\n   |   "
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut m = vec![None; lst.len()];\n    for\
    \ (i, v) in lst.iter().enumerate() {\n        m[i] = Some(v);\n    }\n    m\n\
    \        .iter()\n        .clone()\n        .map(|x| x.unwrap())\n        .chain(m.iter().cloned().chain(vec![None;\
    \ lst.len() + 1]))\n        .flatten()\n        .collect()\n}\n\nfn main() {\n\
    \    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5,\
    \ 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2,\
    \ 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8,\
    \ 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n  \
    \  assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<std::slice::Iter<'_, Option<&isize>>\
    \ as Iterator>::Item == &&isize`\n   --> /tmp/tmpvb1_k1dq.rs:20:16\n    |\n20\
    \  |         .chain(m.iter().cloned().chain(vec![None; lst.len() + 1]))\n    |\
    \          ----- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&isize`,\
    \ found enum `Option`\n    |          |\n    |          required by a bound introduced\
    \ by this call\n    |\n    = note: expected reference `&&isize`\n            \
    \   found reference `&Option<&isize>`\n    = note: required because of the requirements\
    \ on the impl of `Iterator` for `Cloned<std::slice::Iter<'_, Option<&isize>>>`\n\
    \    = note: 1 redundant requirement hidden\n    = note: required because of the\
    \ requirements on the impl of `Iterator` for `std::iter::Chain<Cloned<std::slice::Iter<'_,\
    \ Option<&isize>>>, std::vec::IntoIter<Option<&isize>>>`\nnote: required by a\
    \ bound in `std::iter::Iterator::chain`\n\nerror[E0271]: type mismatch resolving\
    \ `<std::vec::IntoIter<Option<&isize>> as Iterator>::Item == &isize`\n   --> /tmp/tmpvb1_k1dq.rs:20:16\n\
    \    |\n20  |         .chain(m.iter().cloned().chain(vec![None; lst.len() + 1]))\n\
    \    |          ----- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `&isize`, found enum `Option`\n    |          |\n    |          required by\
    \ a bound introduced by this call\n    |\n    = note: expected reference `&isize`\n\
    \                    found enum `Option<&isize>`\n    = note: required because\
    \ of the requirements on the impl of `Iterator` for `std::iter::Chain<Cloned<std::slice::Iter<'_,\
    \ Option<&isize>>>, std::vec::IntoIter<Option<&isize>>>`\nnote: required by a\
    \ bound in `std::iter::Iterator::chain`\n\nerror[E0599]: the method `flatten`\
    \ exists for struct `std::iter::Chain<Map<std::slice::Iter<'_, Option<&isize>>,\
    \ [closure@/tmp/tmpvb1_k1dq.rs:19:14: 19:28]>, std::iter::Chain<Cloned<std::slice::Iter<'_,\
    \ Option<&isize>>>, std::vec::IntoIter<Option<&isize>>>>`, but its trait bounds\
    \ were not satisfied\n  --> /tmp/tmpvb1_k1dq.rs:21:10\n   |\n21 |           .flatten()\n\
    \   |            ^^^^^^^ method cannot"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut lst_copy = lst;\n\n    let mut smallest\
    \ = lst_copy.first().unwrap();\n    let mut biggest = lst_copy.last().unwrap();\n\
    \n    while lst_copy.len() > 0 {\n        if smallest > biggest {\n          \
    \  let tmp = smallest;\n            smallest = biggest;\n            biggest =\
    \ tmp;\n        }\n\n        let mut smallest_idx = lst_copy.iter().position(|x|\
    \ *x == smallest).unwrap();\n        let mut biggest_idx = lst_copy.iter().position(|x|\
    \ *x == biggest).unwrap();\n\n        if smallest > lst_copy[smallest_idx - 1]\
    \ {\n            smallest_idx -= 1;\n        }\n\n        if biggest < lst_copy[biggest_idx\
    \ + 1] {\n            biggest_idx += 1;\n        }\n\n        smallest_idx +=\
    \ 1;\n        biggest_idx -= 1;\n\n        lst_copy[smallest_idx] = biggest;\n\
    \        lst_copy[biggest_idx] = smallest;\n    }\n\n    lst_copy\n}\n\nfn main()\
    \ {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpagrxo8qd.rs:24:67\n   |\n\
    24 |         let mut smallest_idx = lst_copy.iter().position(|x| *x == smallest).unwrap();\n\
    \   |                                                                   ^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n24 |         let mut smallest_idx = lst_copy.iter().position(|x| *x ==\
    \ *smallest).unwrap();\n   |                                                 \
    \                  +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpagrxo8qd.rs:25:66\n\
    \   |\n25 |         let mut biggest_idx = lst_copy.iter().position(|x| *x == biggest).unwrap();\n\
    \   |                                                                  ^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n25 |         let mut biggest_idx = lst_copy.iter().position(|x| *x == *biggest).unwrap();\n\
    \   |                                                                  +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpagrxo8qd.rs:27:23\n   |\n27 |         if smallest\
    \ > lst_copy[smallest_idx - 1] {\n   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                       |\n   |                       expected `&isize`, found\
    \ `isize`\n   |                       help: consider borrowing here: `&lst_copy[smallest_idx\
    \ - 1]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpagrxo8qd.rs:31:22\n \
    \  |\n31 |         if biggest < lst_copy[biggest_idx + 1] {\n   |            \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |                      |\n   |      \
    \                expected `&isize`, found `isize`\n   |                      help:\
    \ consider borrowing here: `&lst_copy[biggest_idx + 1]`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpagrxo8qd.rs:38:34\n   |\n38 |         lst_copy[smallest_idx]\
    \ = biggest;\n   |         ----------------------   ^^^^^^^ expected `isize`,\
    \ found `&isize`\n   |         |\n   |         expected due to the type of this\
    \ binding\n   |\nhelp: consider dereferencing the borrow\n   |\n38 |         lst_copy[smallest_idx]\
    \ = *biggest;\n   |          "
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted = vec![];\n    let mut current\
    \ = vec![];\n    let mut max = vec![];\n\n    for el in lst {\n        if !current.is_empty()\
    \ {\n            // find minimum, which is going to be the top value from the\
    \ current list\n            let min_value = &current\n                .iter()\n\
    \                .min_by_key(|x| x.cmp(&el));\n            sorted.push(min_value[0]);\n\
    \            current.remove(min_value[0]);\n        }\n        current.push(el);\n\
    \        if current.len() == 1 {\n            // if current list has one value,\
    \ it is the maximum\n            max.push(current[0]);\n        } else {\n   \
    \         // otherwise, it is the minimum of the remaining values\n          \
    \  let mut min_value = &current\n                .iter()\n                .min_by_key(|x|\
    \ x.cmp(&el));\n            sorted.push(min_value[0]);\n            current.remove(min_value[0]);\n\
    \        }\n    }\n    sorted.push(max);\n    sorted\n}\n\nfn main() {\n    let\
    \ candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]),\
    \ vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9,\
    \ 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6,\
    \ 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `&&T`\n  --> /tmp/tmpocz3tmud.rs:21:30\n\
    \   |\n21 |                 .min_by_key(|x| x.cmp(&el));\n   |               \
    \               ^ consider giving this closure parameter the explicit type `&&T`,\
    \ where the type parameter `T` is specified\n   |\n   = note: type must be known\
    \ at this point\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpocz3tmud.rs:39:5\n\
    \   |\n11 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |      \
    \                                    ---------- expected `Vec<isize>` because\
    \ of return type\n...\n39 |     sorted\n   |     ^^^^^^ expected `isize`, found\
    \ struct `Vec`\n   |\n   = note: expected struct `Vec<isize>`\n              found\
    \ struct `Vec<Vec<_>>`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0282, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut lst_copy = lst.to_owned();\n    let\
    \ mut lst_sorted = vec![];\n\n    // sort list from first element to last\n  \
    \  // sort list from first element to last\n    while lst_copy.len() > 0 {\n \
    \       lst_sorted.push(lst_copy.min_by_key(|x| x).unwrap());\n        lst_copy.remove(lst_sorted.len()\
    \ - 1);\n    }\n\n    lst_sorted\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: `Vec<isize>` is not an iterator\n   --> /tmp/tmptbul1fu0.rs:18:34\n\
    \    |\n18  |           lst_sorted.push(lst_copy.min_by_key(|x| x).unwrap());\n\
    \    |                                    ^^^^^^^^^^ `Vec<isize>` is not an iterator\n\
    \    |\n    = note: the following trait bounds were not satisfied:\n         \
    \   `Vec<isize>: Iterator`\n            which is required by `&mut Vec<isize>:\
    \ Iterator`\n            `[isize]: Iterator`\n            which is required by\
    \ `&mut [isize]: Iterator`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut res = vec![];\n    let mut last_elem\
    \ = lst[0];\n    for elem in lst.iter().rev() {\n        if elem > last_elem {\n\
    \            res.push(elem);\n            last_elem = elem;\n        }\n    }\n\
    \    res.extend(vec![last_elem]);\n    res\n}\n\nfn main() {\n    let candidate\
    \ = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5,\
    \ 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsh1mtkj6.rs:15:19\n   |\n\
    15 |         if elem > last_elem {\n   |                   ^^^^^^^^^\n   |   \
    \                |\n   |                   expected `&isize`, found `isize`\n\
    \   |                   help: consider borrowing here: `&last_elem`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpsh1mtkj6.rs:17:25\n   |\n13 |     let mut last_elem\
    \ = lst[0];\n   |                         ------ expected due to this value\n\
    ...\n17 |             last_elem = elem;\n   |                         ^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    17 |             last_elem = *elem;\n   |                         +\n\nerror[E0277]:\
    \ the trait bound `Vec<&isize>: Extend<isize>` is not satisfied\n  --> /tmp/tmpsh1mtkj6.rs:20:9\n\
    \   |\n20 |     res.extend(vec![last_elem]);\n   |         ^^^^^^ the trait `Extend<isize>`\
    \ is not implemented for `Vec<&isize>`\n   |\n   = help: the following other types\
    \ implement trait `Extend<A>`:\n             <Vec<T, A> as Extend<&'a T>>\n  \
    \           <Vec<T, A> as Extend<T>>\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpsh1mtkj6.rs:21:5\n   |\n11 | fn strange_sort_list(lst: Vec<isize>) ->\
    \ Vec<isize> {\n   |                                          ---------- expected\
    \ `Vec<isize>` because of return type\n...\n21 |     res\n   |     ^^^ expected\
    \ `isize`, found `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n   \
    \           found struct `Vec<&isize>`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    if lst.len() < 2 {\n        return lst;\n \
    \   }\n    let mut i = 0;\n    let mut j = lst.len() - 1;\n    let mut k = lst.len()\
    \ - 2;\n    let mut swap = false;\n    while i < j {\n        if lst[k] > lst[k\
    \ + 1] {\n            let t = lst[k];\n            lst[k] = lst[k + 1];\n    \
    \        lst[k + 1] = t;\n            swap = true;\n        }\n        i += 1;\n\
    \        j -= 1;\n        k += 1;\n    }\n    if swap {\n        let tmp = lst[k];\n\
    \        lst[k] = lst[j];\n        lst[j] = tmp;\n    }\n    lst\n}\n\nfn main()\
    \ {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `lst` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmp6pq2wu76.rs:22:13\n   |\n11 | fn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n   |                      --- help: consider changing\
    \ this to be mutable: `mut lst`\n...\n22 |             lst[k] = lst[k + 1];\n\
    \   |             ^^^ cannot borrow as mutable\n\nerror[E0596]: cannot borrow\
    \ `lst` as mutable, as it is not declared as mutable\n  --> /tmp/tmp6pq2wu76.rs:23:13\n\
    \   |\n11 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |      \
    \                --- help: consider changing this to be mutable: `mut lst`\n...\n\
    23 |             lst[k + 1] = t;\n   |             ^^^ cannot borrow as mutable\n\
    \nerror[E0596]: cannot borrow `lst` as mutable, as it is not declared as mutable\n\
    \  --> /tmp/tmp6pq2wu76.rs:32:9\n   |\n11 | fn strange_sort_list(lst: Vec<isize>)\
    \ -> Vec<isize> {\n   |                      --- help: consider changing this\
    \ to be mutable: `mut lst`\n...\n32 |         lst[k] = lst[j];\n   |         ^^^\
    \ cannot borrow as mutable\n\nerror[E0596]: cannot borrow `lst` as mutable, as\
    \ it is not declared as mutable\n  --> /tmp/tmp6pq2wu76.rs:33:9\n   |\n11 | fn\
    \ strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |                   \
    \   --- help: consider changing this to be mutable: `mut lst`\n...\n33 |     \
    \    lst[j] = tmp;\n   |         ^^^ cannot borrow as mutable\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0596`.\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut vec: Vec<isize> = vec![];\n    let\
    \ min_val = vec![0];\n    let max_val = vec![0];\n    for val in lst {\n     \
    \   if val < min_val[0] {\n            vec.insert(0, val);\n            min_val[0]\
    \ = val;\n        }\n        if val > max_val[0] {\n            vec.insert(vec.len(),\
    \ val);\n            max_val[0] = val;\n        }\n    }\n    for val in lst.iter().rev()\
    \ {\n        if val < min_val[0] {\n            vec.insert(vec.len(), val);\n\
    \            min_val[0] = val;\n        }\n        if val > max_val[0] {\n   \
    \         vec.insert(0, val);\n            max_val[0] = val;\n        }\n    }\n\
    \    vec\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqp7s843j.rs:26:18\n   |\n\
    26 |         if val < min_val[0] {\n   |                  ^^^^^^^^^^\n   |   \
    \               |\n   |                  expected `&isize`, found `isize`\n  \
    \ |                  help: consider borrowing here: `&min_val[0]`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpqp7s843j.rs:27:35\n   |\n27 |             vec.insert(vec.len(),\
    \ val);\n   |                                   ^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n27 |             vec.insert(vec.len(),\
    \ *val);\n   |                                   +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpqp7s843j.rs:28:26\n   |\n28 |             min_val[0] =\
    \ val;\n   |             ----------   ^^^ expected `isize`, found `&isize`\n \
    \  |             |\n   |             expected due to the type of this binding\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n28 |             min_val[0]\
    \ = *val;\n   |                          +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpqp7s843j.rs:30:18\n   |\n30 |         if val > max_val[0] {\n \
    \  |                  ^^^^^^^^^^\n   |                  |\n   |              \
    \    expected `&isize`, found `isize`\n   |                  help: consider borrowing\
    \ here: `&max_val[0]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqp7s843j.rs:31:27\n\
    \   |\n31 |             vec.insert(0, val);\n   |                           ^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n31 |             vec.insert(0, *val);\n   |                           +\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpqp7s843j.rs:32:26\n   |\n32 |\
    \             max_val[0] = val;\n   |             ----------   ^^^ expected `isize`,\
    \ found `&isize`\n   |             |\n   |             expected due to the type\
    \ of this binding\n   |\nhelp: consider dereferencing the borrow\n   |\n32 | \
    \            max_val[0] = *val;\n   |                          +\n\nerror: aborting\
    \ due to 6 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut new_list = Vec::with_capacity(lst.len());\n\
    \    for x in lst {\n        let mut new_x = x;\n        let mut min_idx = new_list.len();\n\
    \        for (i, x) in new_list.into_iter().enumerate() {\n            if x <\
    \ new_x {\n                min_idx = i;\n                break;\n            }\n\
    \        }\n        new_list.insert(min_idx, new_x);\n    }\n    new_list\n}\n\
    \nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmptrt0wr0j.rs:14:13\n\
    \   |\n14 |         let mut new_x = x;\n   |             ----^^^^^\n   |     \
    \        |\n   |             help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: borrow of moved value: `new_list`\n   --> /tmp/tmptrt0wr0j.rs:15:27\n\
    \    |\n12  |     let mut new_list = Vec::with_capacity(lst.len());\n    |   \
    \      ------------ move occurs because `new_list` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n15  |         let mut min_idx = new_list.len();\n\
    \    |                           ^^^^^^^^^^^^^^ value borrowed here after move\n\
    16  |         for (i, x) in new_list.into_iter().enumerate() {\n    |        \
    \                        ----------- `new_list` moved due to this method call,\
    \ in previous iteration of loop\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `new_list`\n\nerror: aborting due to previous\
    \ error; 1 warning emitted\n\nFor more information about this error, try `rustc\
    \ --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut res = vec![];\n\n    let mut min_v\
    \ = isize::MIN;\n    let mut max_v = isize::MAX;\n\n    for x in lst {\n     \
    \   if x < min_v {\n            min_v = x;\n        }\n        if x > max_v {\n\
    \            max_v = x;\n        }\n    }\n\n    for x in lst {\n        if x\
    \ == min_v {\n            res.push(min_v);\n            min_v = max_v;\n     \
    \   }\n        if x == max_v {\n            res.push(max_v);\n            max_v\
    \ = min_v;\n        }\n        res.push(x);\n    }\n\n    res\n}\n\nfn main()\
    \ {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmpopdgj11t.rs:26:14\n\
    \    |\n11  | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    |   \
    \                   --- move occurs because `lst` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n17  |     for x in lst {\n    |  \
    \            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n\
    26  |     for x in lst {\n    |              ^^^ value used here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to\
    \ avoid moving into the `for` loop\n    |\n17  |     for x in &lst {\n    |  \
    \            +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = vec![];\n    let min_val =\
    \ lst[0] as isize;\n\n    for i in lst.iter().rev() {\n        if i > min_val\
    \ {\n            result.push(min_val);\n            result.push(i);\n        }\
    \ else {\n            result.push(i);\n        }\n\n        min_val = i;\n   \
    \ }\n\n    result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyv4097ea.rs:16:16\n   |\n\
    16 |         if i > min_val {\n   |                ^^^^^^^\n   |             \
    \   |\n   |                expected `&isize`, found `isize`\n   |            \
    \    help: consider borrowing here: `&min_val`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpyv4097ea.rs:18:25\n   |\n18 |             result.push(i);\n   |\
    \                         ^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n18 |             result.push(*i);\n   |    \
    \                     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyv4097ea.rs:20:25\n\
    \   |\n20 |             result.push(i);\n   |                         ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    20 |             result.push(*i);\n   |                         +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpyv4097ea.rs:23:19\n   |\n13 |     let min_val\
    \ = lst[0] as isize;\n   |                   --------------- expected due to this\
    \ value\n...\n23 |         min_val = i;\n   |                   ^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n23 |  \
    \       min_val = *i;\n   |                   +\n\nerror: aborting due to 4 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    if lst.len() <= 1 {\n        return lst;\n\
    \    }\n\n    let mut min = lst.iter().min().unwrap();\n    let mut max = lst.iter().max().unwrap();\n\
    \n    let mut indexes = vec![min.index()];\n    for &index in indexes {\n    \
    \    let mut min_value = min;\n        let mut max_value = max;\n        loop\
    \ {\n            index = index + 1;\n            if index == lst.len() {\n   \
    \             break;\n            }\n            min_value = min;\n          \
    \  max_value = max;\n\n            match lst.iter().position(|&x| x == min_value).cloned()\
    \ {\n                None => {\n                    max = max_value;\n       \
    \         }\n                Some(index) => {\n                    min = min_value;\n\
    \                }\n            }\n        }\n        indexes.push(index);\n \
    \   }\n\n    vec![min] + lst[indexes.clone() + 1..].iter().cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `index` found for reference `&isize` in the\
    \ current scope\n  --> /tmp/tmpr0xa_a6y.rs:19:32\n   |\n19 |     let mut indexes\
    \ = vec![min.index()];\n   |                                ^^^^^ method not found\
    \ in `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpr0xa_a6y.rs:31:49\n\
    \   |\n31 |             match lst.iter().position(|&x| x == min_value).cloned()\
    \ {\n   |                                                 ^^^^^^^^^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n31 |  \
    \           match lst.iter().position(|&x| x == *min_value).cloned() {\n   | \
    \                                                +\n\nerror[E0599]: `Option<usize>`\
    \ is not an iterator\n   --> /tmp/tmpr0xa_a6y.rs:31:60\n    |\n31  |         \
    \      match lst.iter().position(|&x| x == min_value).cloned() {\n    |      \
    \                                                        ^^^^^^ `Option<usize>`\
    \ is not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Option<usize>: Iterator`\n            which is required by `&mut\
    \ Option<usize>: Iterator`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpr0xa_a6y.rs:40:22\n\
    \   |\n40 |         indexes.push(index);\n   |                      ^^^^^\n  \
    \ |                      |\n   |                      cyclic type of infinite\
    \ size\n   |                      help: consider borrowing here: `&index`\n\n\
    error[E0369]: cannot add `{integer}` to `Vec<&_, _>`\n  --> /tmp/tmpr0xa_a6y.rs:43:37\n\
    \   |\n43 |     vec![min] + lst[indexes.clone() + 1..].iter().cloned().collect()\n\
    \   |                     --------------- ^ - {integer}\n   |                \
    \     |\n   |                     Vec<&_, _>\n\nerror[E0369]: cannot add `_` to\
    \ `Vec<&isize>`\n  --> /tmp/tmpr0xa_a6y.rs:43:15\n   |\n43 |     vec![min] + lst[indexes.clone()\
    \ + 1..].iter().cloned().collect()\n   |     --------- ^ ----------------------------------------------------\
    \ _\n   |     |\n   |     Vec<&isize>\n\nerror: aborting due to 6 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0369, E0599.\nFor m"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = Vec::new();\n    let\
    \ mut min_value = i32::MAX;\n    let mut max_value = i32::MIN;\n    for x in lst.iter()\
    \ {\n        let value = i32::min(max_value, x);\n        max_value = value;\n\
    \    }\n    for x in lst.iter() {\n        let value = i32::max(min_value, x);\n\
    \        min_value = value;\n    }\n    for x in lst.iter() {\n        sorted_list.push(x);\n\
    \    }\n    sorted_list.sort_unstable();\n    sorted_list\n}\n\nfn main() {\n\
    \    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5,\
    \ 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2,\
    \ 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8,\
    \ 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n  \
    \  assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphgb32ql0.rs:16:41\n   |\n\
    16 |         let value = i32::min(max_value, x);\n   |                       \
    \                  ^ expected `i32`, found `&isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmphgb32ql0.rs:20:41\n   |\n20 |         let value = i32::max(min_value,\
    \ x);\n   |                                         ^ expected `i32`, found `&isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmphgb32ql0.rs:27:5\n   |\n11 | fn\
    \ strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |                   \
    \                       ---------- expected `Vec<isize>` because of return type\n\
    ...\n27 |     sorted_list\n   |     ^^^^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<&isize>`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut lst = lst.clone();\n    lst.sort_unstable();\n\
    \    lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpiqcpbumh.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut lst_new: Vec<isize> = lst.clone();\n\
    \    lst_new.sort_unstable();\n    return lst_new;\n}\n\nfn main() {\n    let\
    \ candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]),\
    \ vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9,\
    \ 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6,\
    \ 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmp55kqf_mq.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    sorted_vec!(1, lst.len(), lst.clone())\n}\n\
    \nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error: cannot find macro `sorted_vec` in this scope\n  --> /tmp/tmp6j4iswca.rs:12:5\n\
    \   |\n12 |     sorted_vec!(1, lst.len(), lst.clone())\n   |     ^^^^^^^^^^\n\n\
    error: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut cur = 0;\n    let mut result = vec![];\n\
    \    while cur < lst.len() {\n        if lst[cur] <= cur {\n            let mut\
    \ tmp = lst[cur];\n            while tmp < cur {\n                result.append(tmp);\n\
    \                tmp += 1;\n            }\n            result += &mut lst[cur..];\n\
    \            i += 1;\n        }\n        cur += 1;\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmpv6lkd3n3.rs:22:13\n\
    \   |\n22 |             i += 1;\n   |             ^ not found in this scope\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpv6lkd3n3.rs:15:24\n   |\n15 |  \
    \       if lst[cur] <= cur {\n   |                        ^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n15 |         if lst[cur] <= cur.try_into().unwrap()\
    \ {\n   |                           ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpv6lkd3n3.rs:17:25\n   |\n17 |             while tmp < cur\
    \ {\n   |                         ^^^ expected `isize`, found `usize`\n   |\n\
    help: you can convert a `usize` to an `isize` and panic if the converted value\
    \ doesn't fit\n   |\n17 |             while tmp < cur.try_into().unwrap() {\n\
    \   |                            ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpv6lkd3n3.rs:18:31\n   |\n18 |                 result.append(tmp);\n\
    \   |                               ^^^ expected `&mut Vec<_>`, found `isize`\n\
    \   |\n   = note: expected mutable reference `&mut Vec<_>`\n                 \
    \          found type `isize`\n\nerror[E0368]: binary assignment operation `+=`\
    \ cannot be applied to type `Vec<_>`\n  --> /tmp/tmpv6lkd3n3.rs:21:13\n   |\n\
    21 |             result += &mut lst[cur..];\n   |             ------^^^^^^^^^^^^^^^^^^^\n\
    \   |             |\n   |             cannot use `+=` on type `Vec<_>`\n\nerror:\
    \ aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0368, E0425.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    lst.sort_unstable_by(|a, b| a.cmp(b));\n  \
    \  lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `lst` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpzdsik0ey.rs:12:5\n   |\n11 | fn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n   |                      --- help: consider changing\
    \ this to be mutable: `mut lst`\n12 |     lst.sort_unstable_by(|a, b| a.cmp(b));\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    // initialize result vector\n    let mut rev\
    \ = Vec::new();\n    rev.resize(lst.len(), 0usize);\n\n    // initialize pointer\n\
    \    let mut p = 0;\n\n    // traverse list\n    for x in lst.iter() {\n     \
    \   // if pointer is already at the end, reverse the elements\n        if p ==\
    \ lst.len() - 1 {\n            p = 0;\n            lst.reverse();\n        }\n\
    \n        // move the pointer\n        rev[p] = x;\n        p++;\n    }\n\n  \
    \  // return the result\n    rev\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp__dlsw52.rs:29:10\n\
    \   |\n29 |         p++;\n   |          ^^ not a valid postfix operator\n   |\n\
    help: use `+= 1` instead\n   |\n29 |         { let tmp = p; p += 1; tmp };\n \
    \  |         +++++++++++  ~~~~~~~~~~~~~~~\n29 -         p++;\n29 +         p +=\
    \ 1;\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmp__dlsw52.rs:28:18\n\
    \   |\n28 |         rev[p] = x;\n   |         ------   ^ expected `usize`, found\
    \ `&isize`\n   |         |\n   |         expected due to the type of this binding\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp__dlsw52.rs:33:5\n   |\n11 | fn\
    \ strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |                   \
    \                       ---------- expected `Vec<isize>` because of return type\n\
    ...\n33 |     rev\n   |     ^^^ expected `isize`, found `usize`\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n              found struct `Vec<usize>`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    if lst.is_empty() {\n        return vec![];\n\
    \    }\n\n    let mut sorted_list = lst;\n    sorted_list.sort();\n\n    for i\
    \ in 0..(lst.len() - 1) {\n        let tmp = &sorted_list[i];\n        for j in\
    \ (i + 1)..(lst.len()) {\n            if tmp > &sorted_list[j] {\n           \
    \     sorted_list[j] = tmp;\n            }\n        }\n    }\n\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpo25f16kx.rs:23:34\n   |\n\
    23 |                 sorted_list[j] = tmp;\n   |                 --------------\
    \   ^^^ expected `isize`, found `&isize`\n   |                 |\n   |       \
    \          expected due to the type of this binding\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n23 |                 sorted_list[j] = *tmp;\n   |        \
    \                          +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    use std::cmp::Ordering;\n\n    if lst.is_empty()\
    \ {\n        return Vec::new();\n    }\n\n    let mut list = lst.iter().cloned().collect::<Vec<_>>();\n\
    \    list.sort_by(|a, b| {\n        if let Ordering::Less = a.partial_cmp(b) {\n\
    \            Ordering::Less\n        } else if let Ordering::Greater = b.partial_cmp(a)\
    \ {\n            Ordering::Greater\n        } else {\n            Ordering::Equal\n\
    \        }\n    });\n\n    list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpinwud2i2.rs:20:16\n   |\n\
    20 |         if let Ordering::Less = a.partial_cmp(b) {\n   |                ^^^^^^^^^^^^^^\
    \   ---------------- this expression has type `Option<std::cmp::Ordering>`\n \
    \  |                |\n   |                expected enum `Option`, found enum\
    \ `std::cmp::Ordering`\n   |\n   = note: expected enum `Option<std::cmp::Ordering>`\n\
    \              found enum `std::cmp::Ordering`\nhelp: try wrapping the pattern\
    \ in `Some`\n   |\n20 |         if let Some(Ordering::Less) = a.partial_cmp(b)\
    \ {\n   |                +++++              +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpinwud2i2.rs:22:23\n   |\n22 |         } else if let Ordering::Greater\
    \ = b.partial_cmp(a) {\n   |                       ^^^^^^^^^^^^^^^^^   ----------------\
    \ this expression has type `Option<std::cmp::Ordering>`\n   |                \
    \       |\n   |                       expected enum `Option`, found enum `std::cmp::Ordering`\n\
    \   |\n   = note: expected enum `Option<std::cmp::Ordering>`\n              found\
    \ enum `std::cmp::Ordering`\nhelp: try wrapping the pattern in `Some`\n   |\n\
    22 |         } else if let Some(Ordering::Greater) = b.partial_cmp(a) {\n   |\
    \                       +++++                 +\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    lst.sort();\n    lst\n}\n\nfn main() {\n  \
    \  let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5,\
    \ 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2,\
    \ 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8,\
    \ 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n  \
    \  assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `lst` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmprgvby9nl.rs:12:5\n   |\n11 | fn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n   |                      --- help: consider changing\
    \ this to be mutable: `mut lst`\n12 |     lst.sort();\n   |     ^^^^^^^^^^ cannot\
    \ borrow as mutable\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1660010734
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list: Vec<isize> = Vec::new();\n\
    \    let mut min: Option<isize> = None;\n    let mut max: Option<isize> = None;\n\
    \    let mut i: isize = 0;\n    let mut j: isize = 0;\n    while i < lst.len()\
    \ {\n        let val: isize = lst[i];\n        if min.is_none() {\n          \
    \  min = Some(val);\n            max = Some(val);\n        } else {\n        \
    \    if val < min.unwrap() {\n                min = Some(val);\n            }\n\
    \            if val > max.unwrap() {\n                max = Some(val);\n     \
    \       }\n        }\n        i += 1;\n        sorted_list.push(val);\n    }\n\
    \    let mut next_min = Some(min.unwrap());\n    let mut next_max = Some(max.unwrap());\n\
    \    while next_min != next_max {\n        if next_min.is_none() {\n         \
    \   sorted_list.push(next_max.unwrap());\n            next_max = Some(next_max.unwrap());\n\
    \        } else {\n            sorted_list.push(next_min.unwrap());\n        \
    \    next_min = Some(next_min.unwrap());\n        }\n    }\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_rpox91_.rs:17:15\n   |\n\
    17 |     while i < lst.len() {\n   |               ^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n17 |     while i < lst.len().try_into().unwrap()\
    \ {\n   |                        ++++++++++++++++++++\n\nerror[E0277]: the type\
    \ `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp_rpox91_.rs:18:26\n  \
    \ |\n18 |         let val: isize = lst[i];\n   |                          ^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    if lst.is_empty() {\n        return Vec::new();\n\
    \    }\n\n    let mut min_value = lst[0];\n    let mut max_value = lst[0];\n\n\
    \    for v in lst.iter_mut() {\n        if *v > max_value {\n            max_value\
    \ = *v;\n        }\n        if *v < min_value {\n            min_value = *v;\n\
    \        }\n    }\n\n    let mut new_list = Vec::new();\n    new_list.push(min_value);\n\
    \    new_list.push(max_value);\n\n    for v in lst.iter_mut().rev() {\n      \
    \  if *v < min_value {\n            *v = min_value;\n        }\n        if *v\
    \ > max_value {\n            *v = max_value;\n        }\n        new_list.push(*v);\n\
    \    }\n\n    new_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `lst` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpgenf0d21.rs:19:14\n   |\n11 | fn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n   |                      --- help: consider changing\
    \ this to be mutable: `mut lst`\n...\n19 |     for v in lst.iter_mut() {\n   |\
    \              ^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot\
    \ borrow `lst` as mutable, as it is not declared as mutable\n  --> /tmp/tmpgenf0d21.rs:32:14\n\
    \   |\n11 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |      \
    \                --- help: consider changing this to be mutable: `mut lst`\n...\n\
    32 |     for v in lst.iter_mut().rev() {\n   |              ^^^^^^^^^^^^^^ cannot\
    \ borrow as mutable\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    lst.sort_unstable_by(|a, b| b.cmp(a));\n  \
    \  lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `lst` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmp036etq5g.rs:12:5\n   |\n11 | fn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n   |                      --- help: consider changing\
    \ this to be mutable: `mut lst`\n12 |     lst.sort_unstable_by(|a, b| b.cmp(a));\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = vec![];\n    loop {\n    \
    \    if result.is_empty() {\n            match lst {\n                [] => return\
    \ result,\n                _ => return result,\n            }\n        }\n   \
    \     let min = lst.iter().min(|a, b| a.partial_cmp(&b));\n        let max = lst.iter().max(|a,\
    \ b| a.partial_cmp(&b));\n        let min_index: usize = lst.iter().position(|x|\
    \ *x == min).unwrap_or(usize::max_value());\n        let max_index: usize = lst.iter().position(|x|\
    \ *x == max).unwrap_or(usize::max_value());\n        result.push(min);\n     \
    \   result.push(max.unwrap());\n        result.push(min_index);\n        result.push(max_index);\n\
    \        lst.remove(min_index);\n        lst.remove(max_index);\n    }\n}\n\n\
    fn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0529]: expected an array or slice, found `Vec<isize>`\n  --> /tmp/tmpiqfim4xr.rs:16:17\n\
    \   |\n15 |             match lst {\n   |                   --- help: consider\
    \ slicing here: `lst[..]`\n16 |                 [] => return result,\n   |   \
    \              ^^ pattern cannot match with input type `Vec<isize>`\n\nerror[E0061]:\
    \ this function takes 0 arguments but 1 argument was supplied\n    --> /tmp/tmpiqfim4xr.rs:20:30\n\
    \     |\n20   |         let min = lst.iter().min(|a, b| a.partial_cmp(&b));\n\
    \     |                              ^^^ ------------------------ supplied 1 argument\n\
    \     |                              |\n     |                              expected\
    \ 0 arguments\n     |\nnote: associated function defined here\n\nerror[E0061]:\
    \ this function takes 0 arguments but 1 argument was supplied\n    --> /tmp/tmpiqfim4xr.rs:21:30\n\
    \     |\n21   |         let max = lst.iter().max(|a, b| a.partial_cmp(&b));\n\
    \     |                              ^^^ ------------------------ supplied 1 argument\n\
    \     |                              |\n     |                              expected\
    \ 0 arguments\n     |\nnote: associated function defined here\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpiqfim4xr.rs:22:62\n   |\n22 |         let min_index:\
    \ usize = lst.iter().position(|x| *x == min).unwrap_or(usize::max_value());\n\
    \   |                                                              ^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<&isize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpiqfim4xr.rs:23:62\n   |\n23 |         let max_index: usize = lst.iter().position(|x|\
    \ *x == max).unwrap_or(usize::max_value());\n   |                            \
    \                                  ^^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected type `isize`\n              found enum `Option<&isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpiqfim4xr.rs:24:21\n   |\n24 |\
    \         result.push(min);\n   |                     ^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected type `isize"
  stdout: ''
  timestamp: 1660010735
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = vec![];\n\n    for i\
    \ in lst {\n        sorted_list.push(i);\n    }\n\n    sorted_list.sort_unstable_by(|a,\
    \ b| b.cmp(a));\n\n    sorted_list\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[4, 3, 2, 1]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpcgv209gi.rs:25:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    if lst.is_empty() {\n        return vec![];\n\
    \    }\n\n    let mut vec: Vec<isize> = vec![];\n\n    for i in lst[1..].iter().rev()\
    \ {\n        for j in lst[0..i - 1].iter().rev() {\n            vec.push(j);\n\
    \        }\n        vec.push(i);\n    }\n\n    vec\n}\n\nfn main() {\n    let\
    \ candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]),\
    \ vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9,\
    \ 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6,\
    \ 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `std::ops::Range<isize>`\n\
    \  --> /tmp/tmpy0cmzs34.rs:19:18\n   |\n19 |         for j in lst[0..i - 1].iter().rev()\
    \ {\n   |                  ^^^^^^^^^^^^^ slice indices are of type `usize` or\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `std::ops::Range<isize>`\n   = help: the following other types implement\
    \ trait `SliceIndex<T>`:\n             <std::ops::Range<usize> as SliceIndex<[T]>>\n\
    \             <std::ops::Range<usize> as SliceIndex<str>>\n   = note: required\
    \ because of the requirements on the impl of `Index<std::ops::Range<isize>>` for\
    \ `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpy0cmzs34.rs:22:18\n\
    \   |\n22 |         vec.push(i);\n   |                  ^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n22 |        \
    \ vec.push(*i);\n   |                  +\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut min_value\
    \ = lst[0];\n    let mut max_value = lst[0];\n    for value in lst.iter() {\n\
    \        if value < min_value {\n            min_value = value;\n        }\n \
    \       if value > max_value {\n            max_value = value;\n        }\n  \
    \  }\n    for value in lst.iter() {\n        if value == min_value {\n       \
    \     result.push(value);\n        } else {\n            if value == max_value\
    \ {\n                result.push(value);\n            } else {\n             \
    \   let tmp = min_value;\n                while tmp.cmp_to(max_value) < 0 {\n\
    \                    tmp = min_value;\n                    min_value = *min_value.next_cmp_to(&max_value);\n\
    \                }\n                result.push(min_value);\n                result.push(max_value);\n\
    \                result.push(tmp);\n            }\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpm7du0ngd.rs:16:20\n   |\n\
    16 |         if value < min_value {\n   |                    ^^^^^^^^^\n   | \
    \                   |\n   |                    expected `&isize`, found `isize`\n\
    \   |                    help: consider borrowing here: `&min_value`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpm7du0ngd.rs:17:25\n   |\n13 |     let mut min_value\
    \ = lst[0];\n   |                         ------ expected due to this value\n\
    ...\n17 |             min_value = value;\n   |                         ^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    17 |             min_value = *value;\n   |                         +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpm7du0ngd.rs:19:20\n   |\n19 |         if value\
    \ > max_value {\n   |                    ^^^^^^^^^\n   |                    |\n\
    \   |                    expected `&isize`, found `isize`\n   |              \
    \      help: consider borrowing here: `&max_value`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpm7du0ngd.rs:20:25\n   |\n14 |     let mut max_value = lst[0];\n\
    \   |                         ------ expected due to this value\n...\n20 |   \
    \          max_value = value;\n   |                         ^^^^^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n20 |  \
    \           max_value = *value;\n   |                         +\n\nerror[E0277]:\
    \ can't compare `&isize` with `isize`\n  --> /tmp/tmpm7du0ngd.rs:24:18\n   |\n\
    24 |         if value == min_value {\n   |                  ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror[E0277]: can't compare `&isize`\
    \ with `isize`\n  --> /tmp/tmpm7du0ngd.rs:27:22\n   |\n27 |             if value\
    \ == max_value {\n   |                      ^^ no implementation for"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut iter = lst.iter();\n    let mut result\
    \ = iter.collect::<Vec<_>>();\n    let mut tmp = Vec::with_capacity(lst.len());\n\
    \    for i in iter {\n        tmp.unshift(i);\n    }\n    for i in tmp.iter()\
    \ {\n        match result.len() {\n            0 => result.push(i),\n        \
    \    _ => continue,\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5,\
    \ 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unshift` found for struct `Vec<_>` in the\
    \ current scope\n  --> /tmp/tmp5m1qpl5a.rs:16:13\n   |\n16 |         tmp.unshift(i);\n\
    \   |             ^^^^^^^ method not found in `Vec<_>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp5m1qpl5a.rs:24:5\n   |\n11 | fn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n   |                                          ----------\
    \ expected `Vec<isize>` because of return type\n...\n24 |     result\n   |   \
    \  ^^^^^^ expected `isize`, found `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Vec<&isize>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    if lst.is_empty() {\n        return vec![];\n\
    \    }\n    let mut min = lst.iter().min(|a, b| a.cmp(b)).unwrap();\n    let mut\
    \ max = lst.iter().max(|a, b| a.cmp(b)).unwrap();\n    let mut i = 1;\n    while\
    \ i <= lst.len() {\n        if max == min.clone() {\n            break;\n    \
    \    }\n        if min.cmp(&i) > 0 {\n            // swap min and max\n      \
    \      let swap = min.clone();\n            min.swap(&i);\n            max.swap(&swap);\n\
    \        } else {\n            // swap min with i\n            let swap = min.clone();\n\
    \            min.swap(&i);\n            max.swap(&swap);\n        }\n        i\
    \ += 1;\n    }\n    vec![min.clone(), *max, min.clone()]\n}\n\nfn main() {\n \
    \   let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5,\
    \ 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2,\
    \ 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8,\
    \ 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n  \
    \  assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpdc1t8vww.rs:15:35\n\
    \   |\n15 |     let mut min = lst.iter().min(|a, b| a.cmp(b)).unwrap();\n   |\
    \                                   ^ consider giving this closure parameter a\
    \ type\n   |\n   = note: type must be known at this point\n\nerror[E0061]: this\
    \ function takes 0 arguments but 1 argument was supplied\n    --> /tmp/tmpdc1t8vww.rs:15:30\n\
    \     |\n15   |     let mut min = lst.iter().min(|a, b| a.cmp(b)).unwrap();\n\
    \     |                              ^^^ --------------- supplied 1 argument\n\
    \     |                              |\n     |                              expected\
    \ 0 arguments\n     |\nnote: associated function defined here\n\nerror[E0061]:\
    \ this function takes 0 arguments but 1 argument was supplied\n    --> /tmp/tmpdc1t8vww.rs:16:30\n\
    \     |\n16   |     let mut max = lst.iter().max(|a, b| a.cmp(b)).unwrap();\n\
    \     |                              ^^^ --------------- supplied 1 argument\n\
    \     |                              |\n     |                              expected\
    \ 0 arguments\n     |\nnote: associated function defined here\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpdc1t8vww.rs:22:20\n   |\n22 |         if min.cmp(&i)\
    \ > 0 {\n   |                    ^^ expected `isize`, found `usize`\n   |\n  \
    \ = note: expected reference `&isize`\n              found reference `&usize`\n\
    \nerror[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpdc1t8vww.rs:19:16\n\
    \   |\n19 |         if max == min.clone() {\n   |                ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpdc1t8vww.rs:22:26\n   |\n22 |         if min.cmp(&i) > 0 {\n   |   \
    \                       ^ expected enum `std::cmp::Ordering`, found integer\n\n\
    error[E0599]: no method named `swap` found "
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    lst.sort_by_key(|x| {\n        let max = lst.iter().max().unwrap();\n\
    \        let min = lst.iter().min().unwrap();\n        let diff = x - min;\n \
    \       (diff * diff).floor() as isize\n    })\n}\n\nfn main() {\n    let candidate\
    \ = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5,\
    \ 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `floor` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpi1dsn14r.rs:16:23\n   |\n16 |         (diff * diff).floor()\
    \ as isize\n   |                       ^^^^^ help: there is an associated function\
    \ with a similar name: `div_floor`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpi1dsn14r.rs:12:5\n\
    \   |\n11 |   fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |    \
    \                                        ---------- expected `Vec<isize>` because\
    \ of return type\n12 | /     lst.sort_by_key(|x| {\n13 | |         let max = lst.iter().max().unwrap();\n\
    14 | |         let min = lst.iter().min().unwrap();\n15 | |         let diff =\
    \ x - min;\n16 | |         (diff * diff).floor() as isize\n17 | |     })\n   |\
    \ |______^ expected struct `Vec`, found `()`\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut i = 0;\n    let mut j = 0;\n    let\
    \ mut k = 0;\n    let mut current = vec![];\n    let mut next = vec![];\n    while\
    \ i < lst.len() {\n        while j < lst.len() {\n            if lst[i] > lst[j]\
    \ {\n                current.push(lst[i]);\n                i += 1;\n        \
    \        next = vec![];\n                while k < lst.len() {\n             \
    \       next.push(lst[k]);\n                    k += 1;\n                }\n \
    \               lst = next;\n                i = j;\n            }\n         \
    \   i += 1;\n        }\n        current = vec![];\n        j = 0;\n        next\
    \ = vec![];\n        while k < lst.len() {\n            next.push(lst[k]);\n \
    \           k += 1;\n        }\n        lst = next;\n    }\n    lst\n}\n\nfn main()\
    \ {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "warning: value assigned to `next` is never read\n  --> /tmp/tmp0f8nbhvz.rs:16:13\n\
    \   |\n16 |     let mut next = vec![];\n   |             ^^^^\n   |\n   = note:\
    \ `#[warn(unused_assignments)]` on by default\n   = help: maybe it is overwritten\
    \ before being read?\n\nwarning: value assigned to `i` is never read\n  --> /tmp/tmp0f8nbhvz.rs:21:17\n\
    \   |\n21 |                 i += 1;\n   |                 ^\n   |\n   = help:\
    \ maybe it is overwritten before being read?\n\nerror[E0384]: cannot assign to\
    \ immutable argument `lst`\n  --> /tmp/tmp0f8nbhvz.rs:27:17\n   |\n11 | fn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n   |                      --- help: consider making\
    \ this binding mutable: `mut lst`\n...\n27 |                 lst = next;\n   |\
    \                 ^^^ cannot assign to immutable argument\n\nerror[E0384]: cannot\
    \ assign to immutable argument `lst`\n  --> /tmp/tmp0f8nbhvz.rs:39:9\n   |\n11\
    \ | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |              \
    \        --- help: consider making this binding mutable: `mut lst`\n...\n39 |\
    \         lst = next;\n   |         ^^^ cannot assign to immutable argument\n\n\
    error: aborting due to 2 previous errors; 2 warnings emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    vec!(lst.iter().rev().cloned().collect())\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `isize` cannot be built from an iterator\
    \ over elements of type `isize`\n    --> /tmp/tmpo8uh249z.rs:12:36\n     |\n12\
    \   |     vec!(lst.iter().rev().cloned().collect())\n     |                  \
    \                  ^^^^^^^ value of type `isize` cannot be built from `std::iter::Iterator<Item=isize>`\n\
    \     |\n     = help: the trait `FromIterator<isize>` is not implemented for `isize`\n\
    note: required by a bound in `collect`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut minimum\
    \ = *lst.iter().min();\n    let mut maximum = *lst.iter().max();\n    let mut\
    \ pivot = *lst.iter().skip(1).min();\n    result.push(minimum);\n    result.push(maximum);\n\
    \    while pivot != *lst.iter().next() {\n        if *lst.iter().any(|x| *x ==\
    \ *pivot) {\n            let value = *lst.iter().find(|x| *x == *pivot).unwrap();\n\
    \            result.push(value);\n        }\n        result.push(pivot);\n   \
    \     pivot = *lst.iter().skip(1).max();\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5,\
    \ 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2,\
    \ 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8,\
    \ 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n  \
    \  assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `Option<&isize>` cannot be dereferenced\n  --> /tmp/tmp6_qeadmn.rs:13:23\n\
    \   |\n13 |     let mut minimum = *lst.iter().min();\n   |                   \
    \    ^^^^^^^^^^^^^^^^^\n\nerror[E0614]: type `Option<&isize>` cannot be dereferenced\n\
    \  --> /tmp/tmp6_qeadmn.rs:14:23\n   |\n14 |     let mut maximum = *lst.iter().max();\n\
    \   |                       ^^^^^^^^^^^^^^^^^\n\nerror[E0614]: type `Option<&isize>`\
    \ cannot be dereferenced\n  --> /tmp/tmp6_qeadmn.rs:15:21\n   |\n15 |     let\
    \ mut pivot = *lst.iter().skip(1).min();\n   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0614]: type `Option<&isize>` cannot be dereferenced\n  --> /tmp/tmp6_qeadmn.rs:18:20\n\
    \   |\n18 |     while pivot != *lst.iter().next() {\n   |                    ^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0614]: type `bool` cannot be dereferenced\n  --> /tmp/tmp6_qeadmn.rs:19:12\n\
    \   |\n19 |         if *lst.iter().any(|x| *x == *pivot) {\n   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0614]: type `Option<&isize>` cannot be dereferenced\n  --> /tmp/tmp6_qeadmn.rs:24:17\n\
    \   |\n24 |         pivot = *lst.iter().skip(1).max();\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to 6 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut min = lst[0];\n    let mut max = lst[0];\n\
    \    for i in 1..lst.len() {\n        match min {\n            Some(m) if m >\
    \ lst[i] => { min = Some(lst[i]); },\n            Some(m) => { min = Some(lst[i]);\
    \ },\n            None => { min = Some(lst[i]); },\n        }\n        match max\
    \ {\n            Some(m) if m < lst[i] => { max = Some(lst[i]); },\n         \
    \   Some(m) => { max = Some(lst[i]); },\n            None => { max = Some(lst[i]);\
    \ },\n        }\n    }\n    let mut lst2 = vec![];\n    while !min.is_empty()\
    \ {\n        lst2.push(min.take().unwrap());\n    }\n    while !max.is_empty()\
    \ {\n        lst2.push(max.take().unwrap());\n    }\n    while !min.is_empty()\
    \ {\n        lst2.push(min.take().unwrap());\n    }\n    while !max.is_empty()\
    \ {\n        lst2.push(max.take().unwrap());\n    }\n    lst2\n}\n\nfn main()\
    \ {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplupcp6dl.rs:16:13\n   |\n\
    15 |         match min {\n   |               --- this expression has type `isize`\n\
    16 |             Some(m) if m > lst[i] => { min = Some(lst[i]); },\n   |     \
    \        ^^^^^^^ expected `isize`, found enum `Option`\n   |\n   = note: expected\
    \ type `isize`\n              found enum `Option<_>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmplupcp6dl.rs:17:13\n   |\n15 |         match min {\n   |\
    \               --- this expression has type `isize`\n16 |             Some(m)\
    \ if m > lst[i] => { min = Some(lst[i]); },\n17 |             Some(m) => { min\
    \ = Some(lst[i]); },\n   |             ^^^^^^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected type `isize`\n              found enum `Option<_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmplupcp6dl.rs:18:13\n   |\n15 |\
    \         match min {\n   |               --- this expression has type `isize`\n\
    ...\n18 |             None => { min = Some(lst[i]); },\n   |             ^^^^\
    \ expected `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n\
    \              found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmplupcp6dl.rs:16:46\n   |\n12 |     let mut min = lst[0];\n   |      \
    \             ------ expected due to this value\n...\n16 |             Some(m)\
    \ if m > lst[i] => { min = Some(lst[i]); },\n   |                            \
    \                  ^^^^^^^^^^^^ expected `isize`, found enum `Option`\n   |\n\
    \   = note: expected type `isize`\n              found enum `Option<isize>`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmplupcp6dl.rs:17:32\n   |\n12 |  \
    \   let mut min = lst[0];\n   |                   ------ expected due to this\
    \ value\n...\n17 |             Some(m) => { min = Some(lst[i]); },\n   |     \
    \                           ^^^^^^^^^^^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected type `isize`\n              found enum `Option<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmplupcp6dl.rs:18:29\n   |\n12 |\
    \     let mut min = lst[0];\n   |                   ------ expected due to this\
    \ value\n.."
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted = vec![];\n    \n    sorted.push((lst.iter().min()).unwrap());\n\
    \    sorted.push((lst.iter().max()).unwrap());\n\n    for i in lst.iter().skip(1)\
    \ {\n        sorted.push((i).unwrap());\n    }\n\n    sorted\n}\n\nfn main() {\n\
    \    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5,\
    \ 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2,\
    \ 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8,\
    \ 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n  \
    \  assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap` found for reference `&isize` in\
    \ the current scope\n  --> /tmp/tmpivxnrx78.rs:18:25\n   |\n18 |         sorted.push((i).unwrap());\n\
    \   |                         ^^^^^^ method not found in `&isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpivxnrx78.rs:21:5\n   |\n11 | fn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n   |                                          ----------\
    \ expected `Vec<isize>` because of return type\n...\n21 |     sorted\n   |   \
    \  ^^^^^^ expected `isize`, found `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Vec<&isize>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut lst_sorted = vec![];\n    lst.iter().for_each(|val|\
    \ {\n        lst_sorted.push(val);\n    });\n    lst_sorted.sort();\n    lst_sorted\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4xvbusk5.rs:17:5\n   |\n\
    11 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |             \
    \                             ---------- expected `Vec<isize>` because of return\
    \ type\n...\n17 |     lst_sorted\n   |     ^^^^^^^^^^ expected `isize`, found\
    \ `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n              found\
    \ struct `Vec<&isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    vec![]\n        .into_iter()\n        .chain(vec!lst)\n\
    \        .into_iter()\n        .chain(vec!lst.iter().rev())\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `(`, `[`, or `{`, found `lst`\n  --> /tmp/tmptd8f6npq.rs:14:20\n\
    \   |\n14 |         .chain(vec!lst)\n   |                    ^^^ expected one\
    \ of `(`, `[`, or `{`\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    debug_assert!(lst.len() >= 1);\n    let mut\
    \ sorted_list = vec![];\n    let mut min_value = std::cmp::min(*lst.begin(), *lst.rbegin());\n\
    \    let mut max_value = std::cmp::max(*lst.begin(), *lst.rbegin());\n    while\
    \ min_value != max_value {\n        sorted_list.push(min_value);\n        if max_value\
    \ > min_value {\n            max_value = std::cmp::max(*lst.rbegin(), *lst.end());\n\
    \        } else {\n            min_value = std::cmp::min(*lst.rbegin(), *lst.end());\n\
    \        }\n    }\n    sorted_list.push(*lst.min());\n    sorted_list\n}\n\nfn\
    \ main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `begin` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmpw7qo3p6a.rs:14:44\n   |\n14 |     let mut min_value\
    \ = std::cmp::min(*lst.begin(), *lst.rbegin());\n   |                        \
    \                    ^^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no\
    \ method named `rbegin` found for struct `Vec<isize>` in the current scope\n \
    \ --> /tmp/tmpw7qo3p6a.rs:14:58\n   |\n14 |     let mut min_value = std::cmp::min(*lst.begin(),\
    \ *lst.rbegin());\n   |                                                      \
    \    ^^^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named\
    \ `begin` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpw7qo3p6a.rs:15:44\n\
    \   |\n15 |     let mut max_value = std::cmp::max(*lst.begin(), *lst.rbegin());\n\
    \   |                                            ^^^^^ method not found in `Vec<isize>`\n\
    \nerror[E0599]: no method named `rbegin` found for struct `Vec<isize>` in the\
    \ current scope\n  --> /tmp/tmpw7qo3p6a.rs:15:58\n   |\n15 |     let mut max_value\
    \ = std::cmp::max(*lst.begin(), *lst.rbegin());\n   |                        \
    \                                  ^^^^^^ method not found in `Vec<isize>`\n\n\
    error[E0599]: no method named `rbegin` found for struct `Vec<isize>` in the current\
    \ scope\n  --> /tmp/tmpw7qo3p6a.rs:19:44\n   |\n19 |             max_value = std::cmp::max(*lst.rbegin(),\
    \ *lst.end());\n   |                                            ^^^^^^ method\
    \ not found in `Vec<isize>`\n\nerror[E0599]: no method named `end` found for struct\
    \ `Vec<isize>` in the current scope\n  --> /tmp/tmpw7qo3p6a.rs:19:59\n   |\n19\
    \ |             max_value = std::cmp::max(*lst.rbegin(), *lst.end());\n   |  \
    \                                                         ^^^ help: there is an\
    \ associated function with a similar name: `append`\n\nerror[E0599]: no method\
    \ named `rbegin` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpw7qo3p6a.rs:21:44\n\
    \   |\n21 |             min_value = std::cmp::min(*lst.rbegin(), *lst.end());\n\
    \   |                                            ^^^^"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result: Vec<isize> = vec![];\n    let\
    \ mut current: isize = 0;\n    let mut min = lst.iter().min().unwrap();\n    let\
    \ mut max = lst.iter().max().unwrap();\n    loop {\n        if current < min {\n\
    \            result.push(current);\n            break;\n        }\n        if\
    \ current > max {\n            result.push(current);\n            break;\n   \
    \     }\n        current = current + 1;\n        result.push(current);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5_yyedrr.rs:17:22\n   |\n\
    17 |         if current < min {\n   |                      ^^^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n17 |  \
    \       if current < *min {\n   |                      +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp5_yyedrr.rs:21:22\n   |\n21 |         if current > max\
    \ {\n   |                      ^^^ expected `isize`, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n21 |         if current > *max {\n\
    \   |                      +\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut lst = lst.into_iter().cloned().collect::<Vec<isize>>();\n\
    \    let mut min_val = i32::MAX;\n    let mut max_val = i32::MIN;\n    while !lst.is_empty()\
    \ {\n        if *lst.front() < min_val {\n            min_val = *lst.front();\n\
    \        }\n        if *lst.front() > max_val {\n            max_val = *lst.front();\n\
    \        }\n        lst.front() = i32::MAX;\n        lst.next() = i32::MIN;\n\
    \    }\n    while !lst.is_empty() {\n        lst.front() = i32::MIN;\n       \
    \ lst.next() = i32::MAX;\n    }\n    if min_val < i32::MIN {\n        vec![]\n\
    \    } else {\n        vec![min_val..max_val]\n    }\n}\n\nfn main() {\n    let\
    \ candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]),\
    \ vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9,\
    \ 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6,\
    \ 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<std::vec::IntoIter<isize> as Iterator>::Item\
    \ == &_`\n    --> /tmp/tmpq2zy8ei1.rs:12:35\n     |\n12   |     let mut lst =\
    \ lst.into_iter().cloned().collect::<Vec<isize>>();\n     |                  \
    \                 ^^^^^^ expected reference, found `isize`\n     |\n     = note:\
    \ expected reference `&_`\n                     found type `isize`\nnote: required\
    \ by a bound in `cloned`\n\nerror[E0599]: the method `collect` exists for struct\
    \ `Cloned<std::vec::IntoIter<isize>>`, but its trait bounds were not satisfied\n\
    \  --> /tmp/tmpq2zy8ei1.rs:12:44\n   |\n12 |       let mut lst = lst.into_iter().cloned().collect::<Vec<isize>>();\n\
    \   |                                              ^^^^^^^ method cannot be called\
    \ on `Cloned<std::vec::IntoIter<isize>>` due to unsatisfied trait bounds\n   |\n\
    \   = note: the following trait bounds were not satisfied:\n           `<std::vec::IntoIter<isize>\
    \ as Iterator>::Item = &_`\n           which is required by `Cloned<std::vec::IntoIter<isize>>:\
    \ Iterator`\n           `Cloned<std::vec::IntoIter<isize>>: Iterator`\n      \
    \     which is required by `&mut Cloned<std::vec::IntoIter<isize>>: Iterator`\n\
    \nerror[E0070]: invalid left-hand side of assignment\n  --> /tmp/tmpq2zy8ei1.rs:22:21\n\
    \   |\n22 |         lst.front() = i32::MAX;\n   |         ----------- ^\n   |\
    \         |\n   |         cannot assign to this expression\n\nerror[E0070]: invalid\
    \ left-hand side of assignment\n  --> /tmp/tmpq2zy8ei1.rs:23:20\n   |\n23 |  \
    \       lst.next() = i32::MIN;\n   |         ---------- ^\n   |         |\n  \
    \ |         cannot assign to this expression\n\nerror[E0070]: invalid left-hand\
    \ side of assignment\n  --> /tmp/tmpq2zy8ei1.rs:26:21\n   |\n26 |         lst.front()\
    \ = i32::MIN;\n   |         ----------- ^\n   |         |\n   |         cannot\
    \ assign to this expression\n\nerror[E0070]: invalid left-hand side of assignment\n\
    \  --> /tmp/tmpq2zy8ei1.rs:27:20\n   |\n27 |         lst.next() = i32::MAX;\n\
    \   |         ---------- ^\n   |         |\n   |         cannot assign to this\
    \ expression\n\nerror[E0308]: mismatched types\n  --> /tmp/"
  stdout: ''
  timestamp: 1660010735
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = lst;\n    for i in 1..result.len()\
    \ {\n        let min = i; //min(i, result[i]);\n        let max = i; //max(i,\
    \ result[i]);\n        let mn = min; //min(i, result[i]);\n        for j in min..max\
    \ {\n            let k = j;\n            let value = result[k];\n            let\
    \ tmp = result[j];\n            result[j] = value;\n            result[k] = tmp;\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpanzpgn6a.rs:30:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    if lst.len() == 0 {\n        return vec![];\n\
    \    }\n\n    let mut list = vec![];\n    let mut min = lst.iter().min().unwrap();\n\
    \    let mut max = lst.iter().max().unwrap();\n\n    let mut i = 1;\n    while\
    \ i <= lst.len() {\n        if min > max {\n            min = lst.iter().min().unwrap();\n\
    \            max = lst.iter().max().unwrap();\n        }\n\n        list.push(min);\n\
    \        list.push(max);\n        min = lst.iter().min().unwrap();\n        max\
    \ = lst.iter().max().unwrap();\n\n        i += 1;\n    }\n\n    list\n}\n\nfn\
    \ main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmigmul3m.rs:35:5\n   |\n\
    11 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |             \
    \                             ---------- expected `Vec<isize>` because of return\
    \ type\n...\n35 |     list\n   |     ^^^^ expected `isize`, found `&isize`\n \
    \  |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<&isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    // let mut lst_cpy: Vec<isize> = lst;\n   \
    \ let mut lst_cpy = lst.clone();\n    lst_cpy.sort_unstable();\n    lst_cpy\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpjcvnvcxi.rs:20:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    if lst.len() <= 1 {\n        return lst;\n\
    \    }\n\n    let mut s = lst.clone();\n    s.sort();\n    s.reverse();\n    s\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[4, 3, 2, 1]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpoovr8acx.rs:24:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    if lst.len() <= 1 {\n        return lst;\n\
    \    }\n\n    let mut curr = vec![];\n    let mut next = vec![];\n    let mut\
    \ min = lst.iter().min_by_key(|x| x).unwrap();\n    let mut max = lst.iter().max_by_key(|x|\
    \ x).unwrap();\n\n    for i in lst.iter().take(lst.len() - 1).rev() {\n      \
    \  next = vec![];\n\n        if i < min {\n            next = next.push(min);\n\
    \            min = i;\n        } else {\n            next = next.push(max);\n\
    \            max = i;\n        }\n\n        curr = curr.push(i);\n\n        if\
    \ next.len() >= 2 {\n            if next < next.last() {\n                next\
    \ = next.push(i);\n            }\n\n            curr = curr.push(next.pop());\n\
    \            curr = curr.push(next.pop());\n        }\n    }\n\n    curr = curr.push(min);\n\
    \    curr = curr.push(max);\n\n    return curr;\n}\n\nfn main() {\n    let candidate\
    \ = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5,\
    \ 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9oc1zwvc.rs:25:20\n   |\n\
    17 |     let mut next = vec![];\n   |                    ------ expected due to\
    \ this value\n...\n25 |             next = next.push(min);\n   |             \
    \       ^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\n   = note: expected\
    \ struct `Vec<&isize>`\n           found unit type `()`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp9oc1zwvc.rs:28:20\n   |\n17 |     let mut next = vec![];\n\
    \   |                    ------ expected due to this value\n...\n28 |        \
    \     next = next.push(max);\n   |                    ^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<&isize>`\n \
    \          found unit type `()`\nnote: method `push` modifies its receiver in-place\n\
    \  --> /tmp/tmp9oc1zwvc.rs:28:25\n   |\n28 |             next = next.push(max);\n\
    \   |                    ---- ^^^^ this call modifies `next` in-place\n   |  \
    \                  |\n   |                    you probably want to use this value\
    \ after calling the method...\n   = note: ...instead of the `()` output of method\
    \ `push`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9oc1zwvc.rs:32:16\n\
    \   |\n16 |     let mut curr = vec![];\n   |                    ------ expected\
    \ due to this value\n...\n32 |         curr = curr.push(i);\n   |            \
    \    ^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\n   = note: expected\
    \ struct `Vec<&isize>`\n           found unit type `()`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp9oc1zwvc.rs:35:23\n   |\n35 |             if next < next.last()\
    \ {\n   |                       ^^^^^^^^^^^ expected struct `Vec`, found enum\
    \ `Option`\n   |\n   = note: expected struct `Vec<&isize>`\n                found\
    \ enum `Option<&&isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9oc1zwvc.rs:36:24\n\
    \   |\n17 |     let mut next = vec![];\n   |                    ------ expected\
    \ due to this value\n...\n36 |                 next = next.push(i);\n   |    \
    \                    ^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\n  \
    \ = note: expected struct `Vec<&isize>`\n           found unit"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    // We first sort the list by its first element,\
    \ then\n    // by its last, then by the next-to-last, etc...\n    let mut new_list\
    \ = lst.clone();\n    new_list.sort_by_key(|x| x);\n    new_list.sort_by_key(|x|\
    \ -x);\n    new_list.sort_by_key(|x| x + 1);\n    new_list\n}\n\nfn main() {\n\
    \    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5,\
    \ 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2,\
    \ 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8,\
    \ 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n  \
    \  assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error: lifetime may not live long enough\n  --> /tmp/tmpi8uqv0jw.rs:15:30\n\
    \   |\n15 |     new_list.sort_by_key(|x| x);\n   |                           --\
    \ ^ returning this value requires that `'1` must outlive `'2`\n   |          \
    \                 ||\n   |                           |return type of closure is\
    \ &'2 isize\n   |                           has type `&'1 isize`\n\nerror: aborting\
    \ due to previous error\n\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut it = lst.iter();\n    let mut lst =\
    \ Vec::new();\n    let mut min_value = *it.next();\n    let mut max_value = *it.next();\n\
    \    lst.append(min_value);\n    lst.append(max_value);\n    for i in 1..lst.len()\
    \ {\n        min_value = *it.next();\n        max_value = *it.next();\n      \
    \  if min_value > max_value {\n            lst.append(min_value);\n          \
    \  lst.append(max_value);\n        } else {\n            lst.append(max_value);\n\
    \            lst.append(min_value);\n        }\n    }\n    lst\n}\n\nfn main()\
    \ {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `Option<&isize>` cannot be dereferenced\n  --> /tmp/tmpjhgumwzt.rs:14:25\n\
    \   |\n14 |     let mut min_value = *it.next();\n   |                        \
    \ ^^^^^^^^^^\n\nerror[E0614]: type `Option<&isize>` cannot be dereferenced\n \
    \ --> /tmp/tmpjhgumwzt.rs:15:25\n   |\n15 |     let mut max_value = *it.next();\n\
    \   |                         ^^^^^^^^^^\n\nerror[E0614]: type `Option<&isize>`\
    \ cannot be dereferenced\n  --> /tmp/tmpjhgumwzt.rs:19:21\n   |\n19 |        \
    \ min_value = *it.next();\n   |                     ^^^^^^^^^^\n\nerror[E0614]:\
    \ type `Option<&isize>` cannot be dereferenced\n  --> /tmp/tmpjhgumwzt.rs:20:21\n\
    \   |\n20 |         max_value = *it.next();\n   |                     ^^^^^^^^^^\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut res = vec![];\n    let mut max = lst.len()\
    \ as isize;\n    let mut min_idx = 1;\n    for idx in lst.iter().rev() {\n   \
    \     if idx == 0 {\n            max = idx - 1;\n        } else {\n          \
    \  max = idx;\n        }\n        if max > min_idx {\n            for _ in 0..(max_idx\
    \ - max) {\n                res.push(0);\n            }\n            min_idx =\
    \ max;\n        }\n        res.push(idx);\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5,\
    \ 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2,\
    \ 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8,\
    \ 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n  \
    \  assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `max_idx` in this scope\n  --> /tmp/tmp1ohlbazx.rs:22:26\n\
    \   |\n22 |             for _ in 0..(max_idx - max) {\n   |                  \
    \        ^^^^^^^ help: a local variable with a similar name exists: `min_idx`\n\
    \nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp1ohlbazx.rs:16:16\n\
    \   |\n16 |         if idx == 0 {\n   |                ^^ no implementation for\
    \ `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is\
    \ not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp1ohlbazx.rs:19:19\n   |\n13 |     let mut max = lst.len() as isize;\n\
    \   |                   ------------------ expected due to this value\n...\n19\
    \ |             max = idx;\n   |                   ^^^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n19 |        \
    \     max = *idx;\n   |                   +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp1ohlbazx.rs:27:18\n   |\n27 |         res.push(idx);\n   |    \
    \              ^^^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n27 |         res.push(*idx);\n   |                  +\n\n\
    error: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0425.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    if lst.is_empty() {\n        return vec![];\n\
    \    }\n    let mut min_val = lst.iter().min().unwrap();\n    let mut max_val\
    \ = lst.iter().max().unwrap();\n    let mut min_iter = lst.iter().skip(1).take(min_val).rev().collect::<Vec<_>>();\n\
    \    let mut max_iter = lst.iter().skip(1).take(max_val).rev().collect::<Vec<_>>();\n\
    \n    let mut res = vec![];\n    while !min_iter.is_empty() && !max_iter.is_empty()\
    \ {\n        if min_iter.iter().next().unwrap() < max_iter.iter().next().unwrap()\
    \ {\n            res.push(min_iter.iter().next().unwrap());\n            min_iter.pop();\n\
    \        } else {\n            res.push(max_iter.iter().next().unwrap());\n  \
    \          max_iter.pop();\n        }\n    }\n\n    res.extend(min_iter);\n  \
    \  res.extend(max_iter);\n    res\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6xgfeu7x.rs:17:48\n   |\n\
    17 |     let mut min_iter = lst.iter().skip(1).take(min_val).rev().collect::<Vec<_>>();\n\
    \   |                                                ^^^^^^^ expected `usize`,\
    \ found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6xgfeu7x.rs:18:48\n\
    \   |\n18 |     let mut max_iter = lst.iter().skip(1).take(max_val).rev().collect::<Vec<_>>();\n\
    \   |                                                ^^^^^^^ expected `usize`,\
    \ found `&isize`\n\nerror[E0277]: the trait bound `Vec<&&isize>: Extend<&isize>`\
    \ is not satisfied\n  --> /tmp/tmp6xgfeu7x.rs:31:9\n   |\n31 |     res.extend(min_iter);\n\
    \   |         ^^^^^^ the trait `Extend<&isize>` is not implemented for `Vec<&&isize>`\n\
    \   |\n   = help: the following other types implement trait `Extend<A>`:\n   \
    \          <Vec<T, A> as Extend<&'a T>>\n             <Vec<T, A> as Extend<T>>\n\
    \nerror[E0277]: the trait bound `Vec<&&isize>: Extend<&isize>` is not satisfied\n\
    \  --> /tmp/tmp6xgfeu7x.rs:32:9\n   |\n32 |     res.extend(max_iter);\n   |  \
    \       ^^^^^^ the trait `Extend<&isize>` is not implemented for `Vec<&&isize>`\n\
    \   |\n   = help: the following other types implement trait `Extend<A>`:\n   \
    \          <Vec<T, A> as Extend<&'a T>>\n             <Vec<T, A> as Extend<T>>\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp6xgfeu7x.rs:33:5\n   |\n11 | fn\
    \ strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |                   \
    \                       ---------- expected `Vec<isize>` because of return type\n\
    ...\n33 |     res\n   |     ^^^ expected `isize`, found `&&isize`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n              found struct `Vec<&&isize>`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    lst.sort_by(|a, b| {\n        let diff = a\
    \ - b;\n        let is_negative = diff < 0;\n        if is_negative {\n      \
    \      // Swap a and b if a is less than b\n            diff\n        } else {\n\
    \            // Reverse the sign of the difference\n            -diff\n      \
    \  }\n    });\n    lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgygrfq9v.rs:17:13\n   |\n\
    17 |             diff\n   |             ^^^^ expected enum `std::cmp::Ordering`,\
    \ found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgygrfq9v.rs:20:13\n\
    \   |\n20 |             -diff\n   |             ^^^^^ expected enum `std::cmp::Ordering`,\
    \ found `isize`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut lst = lst.iter().cloned().collect::<Vec<isize>>();\n\
    \    let mut min = lst.iter().min_by(|a, b| a.cmp(b)).unwrap();\n    let mut max\
    \ = lst.iter().max_by(|a, b| a.cmp(b)).unwrap();\n\n    while lst.len() > 1 {\n\
    \        // find max and min of remaining list\n        let mn = lst.iter().cloned().collect::<Vec<isize>>();\n\
    \        let mi = lst.iter().cloned().collect::<Vec<isize>>();\n        // swap\n\
    \        lst[0] = (*mi)[0];\n        lst[1] = (*mn)[0];\n        // update min\n\
    \        if lst.iter().min_by(|a, b| a.cmp(b)).unwrap().cmp(&min) {\n        \
    \    min = lst.iter().min_by(|a, b| a.cmp(b)).unwrap();\n        }\n        //\
    \ update max\n        if lst.iter().max_by(|a, b| a.cmp(b)).unwrap().cmp(&max)\
    \ {\n            max = lst.iter().max_by(|a, b| a.cmp(b)).unwrap();\n        }\n\
    \    }\n    lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n  \
    \  assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqb64thq3.rs:24:12\n   |\n\
    24 |         if lst.iter().min_by(|a, b| a.cmp(b)).unwrap().cmp(&min) {\n   |\
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`,\
    \ found enum `std::cmp::Ordering`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqb64thq3.rs:28:12\n\
    \   |\n28 |         if lst.iter().max_by(|a, b| a.cmp(b)).unwrap().cmp(&max) {\n\
    \   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `bool`, found enum `std::cmp::Ordering`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut new_list = vec![];\n    let mut current_min\
    \ = isize::MAX;\n    for elem in lst.iter() {\n        if elem < current_min {\n\
    \            new_list.push(*elem);\n            current_min = *elem;\n       \
    \ }\n    }\n    new_list.push(*current_min);\n    new_list\n}\n\nfn main() {\n\
    \    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5,\
    \ 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2,\
    \ 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8,\
    \ 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n  \
    \  assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpt28qrzfl.rs:15:19\n   |\n\
    15 |         if elem < current_min {\n   |                   ^^^^^^^^^^^\n   |\
    \                   |\n   |                   expected `&isize`, found `isize`\n\
    \   |                   help: consider borrowing here: `&current_min`\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmpt28qrzfl.rs:20:19\n   |\n\
    20 |     new_list.push(*current_min);\n   |                   ^^^^^^^^^^^^\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0614.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut retval = vec![];\n    let mut curr\
    \ = vec![];\n\n    for x in lst {\n        curr.append(x);\n\n        if curr.len()\
    \ == 2 {\n            retval.append(*curr.clone());\n            curr.pop();\n\
    \        }\n    }\n\n    retval\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp25ff__qm.rs:16:21\n   |\n\
    16 |         curr.append(x);\n   |                     ^ expected `&mut Vec<_>`,\
    \ found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n \
    \                          found type `isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp25ff__qm.rs:19:27\n   |\n19 |             retval.append(*curr.clone());\n\
    \   |                           ^^^^^^^^^^^^^ expected `&mut Vec<_>`, found slice\n\
    \   |\n   = note: expected mutable reference `&mut Vec<_>`\n                 \
    \         found slice `[_]`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted = vec![];\n    sorted.push(std::cmp::min(&lst));\n\
    \n    for x in lst {\n        if x < sorted.last() {\n            sorted.push(x);\n\
    \            sorted.push(std::cmp::max(&sorted.last().unwrap()));\n        } else\
    \ {\n            sorted.push(x);\n        }\n    }\n\n    sorted\n}\n\nfn main()\
    \ {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 2 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmp25xn_kwf.rs:13:17\n     |\n13   |     sorted.push(std::cmp::min(&lst));\n\
    \     |                 ^^^^^^^^^^^^^ ---- supplied 1 argument\n     |       \
    \          |\n     |                 expected 2 arguments\n     |\nnote: function\
    \ defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp25xn_kwf.rs:16:16\n\
    \   |\n16 |         if x < sorted.last() {\n   |                ^^^^^^^^^^^^^\
    \ expected `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n\
    \              found enum `Option<&_>`\n\nerror[E0061]: this function takes 2\
    \ arguments but 1 argument was supplied\n    --> /tmp/tmp25xn_kwf.rs:18:25\n \
    \    |\n18   |             sorted.push(std::cmp::max(&sorted.last().unwrap()));\n\
    \     |                         ^^^^^^^^^^^^^ ----------------------- supplied\
    \ 1 argument\n     |                         |\n     |                       \
    \  expected 2 arguments\n     |\nnote: function defined here\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0061, E0308.\n\
    For more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    debug_assert!(lst.len() <= 5);\n    let mut\
    \ curr = lst[0];\n    let mut next = 0;\n    let mut i = 1;\n    loop {\n    \
    \    if lst[i] > curr {\n            while i < lst.len() && lst[i] <= curr {\n\
    \                curr = lst[i];\n                i += 1;\n            }\n    \
    \        next += 1;\n            lst[next] = lst[i];\n            lst[i] = curr;\n\
    \        }\n        i += 1;\n        if i >= lst.len() {\n            break;\n\
    \        }\n        curr = lst[i];\n    }\n    lst[next..lst.len()].iter().cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `lst` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpz5f2t924.rs:23:13\n   |\n11 | fn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n   |                      --- help: consider changing\
    \ this to be mutable: `mut lst`\n...\n23 |             lst[next] = lst[i];\n \
    \  |             ^^^ cannot borrow as mutable\n\nerror[E0596]: cannot borrow `lst`\
    \ as mutable, as it is not declared as mutable\n  --> /tmp/tmpz5f2t924.rs:24:13\n\
    \   |\n11 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |      \
    \                --- help: consider changing this to be mutable: `mut lst`\n...\n\
    24 |             lst[i] = curr;\n   |             ^^^ cannot borrow as mutable\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    vec!(lst.iter().cloned().enumerate().map(|(i,\
    \ v)| (i + 1, v)).cloned().collect())\n        .iter()\n        .cloned()\n  \
    \      .enumerate()\n        .map(|(i, v)| v % 2)\n        .clone()\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<[closure@/tmp/tmpmnj5yldl.rs:12:46:\
    \ 12:65] as FnOnce<((usize, isize),)>>::Output == &_`\n    --> /tmp/tmpmnj5yldl.rs:12:67\n\
    \     |\n12   |     vec!(lst.iter().cloned().enumerate().map(|(i, v)| (i + 1,\
    \ v)).cloned().collect())\n     |                                            \
    \                       ^^^^^^ expected reference, found tuple\n     |\n     =\
    \ note: expected reference `&_`\n                    found tuple `(usize, isize)`\n\
    \     = note: required because of the requirements on the impl of `Iterator` for\
    \ `Map<Enumerate<Cloned<std::slice::Iter<'_, isize>>>, [closure@/tmp/tmpmnj5yldl.rs:12:46:\
    \ 12:65]>`\nnote: required by a bound in `cloned`\n\nerror[E0599]: the method\
    \ `collect` exists for struct `Cloned<Map<Enumerate<Cloned<std::slice::Iter<'_,\
    \ isize>>>, [closure@/tmp/tmpmnj5yldl.rs:12:46: 12:65]>>`, but its trait bounds\
    \ were not satisfied\n  --> /tmp/tmpmnj5yldl.rs:12:76\n   |\n12 |       vec!(lst.iter().cloned().enumerate().map(|(i,\
    \ v)| (i + 1, v)).cloned().collect())\n   |                                  \
    \                                            ^^^^^^^ method cannot be called on\
    \ `Cloned<Map<Enumerate<Cloned<std::slice::Iter<'_, isize>>>, [closure@/tmp/tmpmnj5yldl.rs:12:46:\
    \ 12:65]>>` due to unsatisfied trait bounds\n   |\n   = note: the following trait\
    \ bounds were not satisfied:\n           `<Map<Enumerate<Cloned<std::slice::Iter<'_,\
    \ isize>>>, [closure@/tmp/tmpmnj5yldl.rs:12:46: 12:65]> as Iterator>::Item = &_`\n\
    \           which is required by `Cloned<Map<Enumerate<Cloned<std::slice::Iter<'_,\
    \ isize>>>, [closure@/tmp/tmpmnj5yldl.rs:12:46: 12:65]>>: Iterator`\n        \
    \   `Cloned<Map<Enumerate<Cloned<std::slice::Iter<'_, isize>>>, [closure@/tmp/tmpmnj5yldl.rs:12:46:\
    \ 12:65]>>: Iterator`\n           which is required by `&mut Cloned<Map<Enumerate<Cloned<std::slice::Iter<'_,\
    \ isize>>>, [closure@/tmp/tmpmnj5yldl.rs:12:46: 12:65]>>: Iterator`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0599.\nFor more information about an error, try `rustc --explain"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_list = lst;\n    loop {\n  \
    \      let mut min_val = sorted_list.iter().min().unwrap();\n        sorted_list.remove(min_val);\n\
    \        let mut max_val = sorted_list.iter().max().unwrap();\n        sorted_list.remove(max_val);\n\
    \        if min_val >= max_val {\n            break;\n        }\n        sorted_list.push(min_val);\n\
    \        sorted_list.push(max_val);\n    }\n    sorted_list\n}\n\nfn main() {\n\
    \    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5,\
    \ 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2,\
    \ 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8,\
    \ 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n  \
    \  assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwu4dgjvd.rs:15:28\n   |\n\
    15 |         sorted_list.remove(min_val);\n   |                            ^^^^^^^\
    \ expected `usize`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwu4dgjvd.rs:17:28\n\
    \   |\n17 |         sorted_list.remove(max_val);\n   |                       \
    \     ^^^^^^^ expected `usize`, found `&isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpwu4dgjvd.rs:21:26\n   |\n21 |         sorted_list.push(min_val);\n\
    \   |                          ^^^^^^^ expected `isize`, found `&isize`\n   |\n\
    help: consider dereferencing the borrow\n   |\n21 |         sorted_list.push(*min_val);\n\
    \   |                          +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwu4dgjvd.rs:22:26\n\
    \   |\n22 |         sorted_list.push(max_val);\n   |                         \
    \ ^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n22 |         sorted_list.push(*max_val);\n   |           \
    \               +\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut i = 0;\n    let mut j = 0;\n    let\
    \ mut largest = lst.iter().max().unwrap();\n\n    while i < lst.len() {\n    \
    \    while j < lst.len() {\n            if lst[j] < largest {\n              \
    \  largest = lst[j];\n            }\n            j += 1\n        }\n        i\
    \ += 1;\n        j = 0\n    }\n\n    let mut i = i;\n    let mut j = 0;\n    let\
    \ mut largest = lst.iter().max().unwrap();\n\n    while i < lst.len() {\n    \
    \    while j < lst.len() {\n            if lst[j] > largest {\n              \
    \  largest = lst[j];\n            }\n            j += 1\n        }\n        i\
    \ += 1;\n        j = 0\n    }\n\n    lst\n}\n\nfn main() {\n    let candidate\
    \ = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5,\
    \ 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmm6rthcg.rs:18:25\n   |\n\
    18 |             if lst[j] < largest {\n   |                         ^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    18 |             if lst[j] < *largest {\n   |                         +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpmm6rthcg.rs:19:27\n   |\n14 |     let mut largest\
    \ = lst.iter().max().unwrap();\n   |                       -------------------------\
    \ expected due to this value\n...\n19 |                 largest = lst[j];\n  \
    \ |                           ^^^^^^\n   |                           |\n   | \
    \                          expected `&isize`, found `isize`\n   |            \
    \               help: consider borrowing here: `&lst[j]`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpmm6rthcg.rs:33:25\n   |\n33 |             if lst[j] > largest\
    \ {\n   |                         ^^^^^^^ expected `isize`, found `&isize`\n \
    \  |\nhelp: consider dereferencing the borrow\n   |\n33 |             if lst[j]\
    \ > *largest {\n   |                         +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpmm6rthcg.rs:34:27\n   |\n29 |     let mut largest = lst.iter().max().unwrap();\n\
    \   |                       ------------------------- expected due to this value\n\
    ...\n34 |                 largest = lst[j];\n   |                           ^^^^^^\n\
    \   |                           |\n   |                           expected `&isize`,\
    \ found `isize`\n   |                           help: consider borrowing here:\
    \ `&lst[j]`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut v = vec![];\n    let mut min_ind =\
    \ vec![];\n    let mut max_ind = vec![];\n    for ind in 0..lst.len() {\n    \
    \    if ind == 0 {\n            min_ind.push(ind);\n            v.push(lst[ind]);\n\
    \        } else {\n            let tmp = min_ind.last().unwrap();\n          \
    \  if lst[ind] > v[tmp] {\n                min_ind.push(ind);\n              \
    \  v.push(lst[ind]);\n            } else {\n                let tmp2 = min_ind.last().unwrap();\n\
    \                if lst[ind] < v[tmp2] {\n                    min_ind.push(ind);\n\
    \                    v.push(lst[ind]);\n                } else {\n           \
    \         let tmp3 = min_ind.last().unwrap();\n                    if lst[ind]\
    \ > v[tmp3] {\n                        min_ind.push(ind);\n                  \
    \      v.push(lst[ind]);\n                    } else {\n                     \
    \   let tmp4 = min_ind.last().unwrap();\n                        if lst[ind] <\
    \ v[tmp4] {\n                            min_ind.push(ind);\n                \
    \            v.push(lst[ind]);\n                        } else {\n           \
    \                 let tmp5 = min_ind.last().unwrap();\n                      \
    \      if lst[ind] > v[tmp5] {\n                                min_ind.push(ind);\n\
    \                                v.push(lst[ind]);\n                         \
    \   } else {\n                                let tmp6 = min_ind.last().unwrap();\n\
    \                                if lst[ind] < v[tmp6] {\n                   \
    \                 min_ind.push(ind);\n                                    v.push(lst[ind]);\n\
    \                                } else {\n                                  \
    \  let tmp7 = min_ind.last().unwrap();\n                                    if\
    \ lst[ind] > v[tmp7] {\n                                        min_ind.push(ind);\n\
    \                                        v.push(lst[ind]);\n                 \
    \                   } else {\n                                        let tmp8\
    \ = min_ind.last().unwrap();\n                                        if lst[ind]\
    \ < v[tmp8] {\n                                            min_ind.push(ind);\n\
    \                                            v.push(lst[ind]);\n             \
    \                           } else {\n                                       \
    \     let tmp9 = min_ind.last().unwrap();\n                                  \
    \          if lst[ind] > v[tmp9] {\n                                         \
    \       min_ind.push(ind);\n                                                v.push(lst[ind]);\n\
    \                                            } else {\n                      \
    \                          let tmp10 = min_ind.last().unwrap();\n            \
    \                                    if lst[ind] < v[tmp10] {\n              \
    \                                      min_ind.push(ind);\n                  \
    \                                  v.push(lst[ind]);\n                       \
    \                         } else {\n                                         \
    \           let tmp11 = min_ind.last().unwrap();\n                           \
    \                         if lst[ind] > v[tmp11] {\n                         \
    \                               min_ind.push(ind);\n                         \
    \                               v.push(lst[ind]);\n                          \
    \                          } else {\n                                        \
    \                let tmp12 = min_ind.last().unwrap();\n                      \
    \                                  if lst[ind] < v[tmp12] {\n                \
    \                                            \n}\n\nfn main() {\n    let candidate\
    \ = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5,\
    \ 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpobp74tal.rs:91:3\n\
    \   |\n11 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |      \
    \                                               - unclosed delimiter\n...\n15\
    \ |     for ind in 0..lst.len() {\n   |                             - unclosed\
    \ delimiter\n...\n19 |         } else {\n   |                - unclosed delimiter\n\
    ...\n24 |             } else {\n   |                    - unclosed delimiter\n\
    ...\n29 |                 } else {\n   |                        - unclosed delimiter\n\
    ...\n34 |                     } else {\n   |                            - unclosed\
    \ delimiter\n...\n39 |                         } else {\n   |                \
    \                - unclosed delimiter\n...\n44 |                             }\
    \ else {\n   |                                    - unclosed delimiter\n...\n\
    49 |                                 } else {\n   |                          \
    \              - unclosed delimiter\n...\n54 |                               \
    \      } else {\n   |                                            - unclosed delimiter\n\
    ...\n59 |                                         } else {\n   |             \
    \                                   - unclosed delimiter\n...\n64 |          \
    \                                   } else {\n   |                           \
    \                         - unclosed delimiter\n...\n69 |                    \
    \                             } else {\n   |                                 \
    \                       - unclosed delimiter\n...\n74 |                      \
    \                               } else {\n   |                               \
    \                             - unclosed delimiter\n75 |                     \
    \                                    let tmp12 = min_ind.last().unwrap();\n76\
    \ |                                                         if lst[ind] < v[tmp12]\
    \ {\n   |                                                                    \
    \            - this delimiter might not be properly closed...\n77 |          \
    \                                                   \n78 | }\n   | - ...as"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut iter = lst.iter();\n    let mut min\
    \ = iter.next().unwrap();\n    let mut max = iter.next().unwrap();\n    while\
    \ let Some(mut x) = iter.next() {\n        if x > max {\n            max = x;\n\
    \        }\n        if x < min {\n            min = x;\n        }\n    }\n   \
    \ iter\n        .into_iter()\n        .take_while(|x| x < min || x > max)\n  \
    \      .cloned()\n        .collect()\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_hw1m8cw.rs:25:29\n   |\n\
    25 |         .take_while(|x| x < min || x > max)\n   |                       \
    \      ^^^ expected `&isize`, found `isize`\n   |\n   = note: expected reference\
    \ `&&isize`\n              found reference `&isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_hw1m8cw.rs:25:40\n   |\n25 |         .take_while(|x| x\
    \ < min || x > max)\n   |                                        ^^^ expected\
    \ `&isize`, found `isize`\n   |\n   = note: expected reference `&&isize`\n   \
    \           found reference `&isize`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut min = lst[0];\n    let mut max = lst[0];\n\
    \    for el in lst.iter().rev() {\n        if el < min {\n            min = el;\n\
    \        }\n        if el > max {\n            max = el;\n        }\n    }\n \
    \   vec![min, max].iter().cloned().collect()\n}\n\nfn main() {\n    let candidate\
    \ = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5,\
    \ 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsbtqp2o1.rs:15:17\n   |\n\
    15 |         if el < min {\n   |                 ^^^\n   |                 |\n\
    \   |                 expected `&isize`, found `isize`\n   |                 help:\
    \ consider borrowing here: `&min`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsbtqp2o1.rs:16:19\n\
    \   |\n12 |     let mut min = lst[0];\n   |                   ------ expected\
    \ due to this value\n...\n16 |             min = el;\n   |                   ^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n16 |             min = *el;\n   |                   +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpsbtqp2o1.rs:18:17\n   |\n18 |         if el\
    \ > max {\n   |                 ^^^\n   |                 |\n   |            \
    \     expected `&isize`, found `isize`\n   |                 help: consider borrowing\
    \ here: `&max`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsbtqp2o1.rs:19:19\n\
    \   |\n13 |     let mut max = lst[0];\n   |                   ------ expected\
    \ due to this value\n...\n19 |             max = el;\n   |                   ^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n19 |             max = *el;\n   |                   +\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut vec = Vec::new();\n    let mut minmax\
    \ = vec![0];\n\n    for elem in lst.iter() {\n        let min = elem.cmp(&minmax[0]).unwrap();\n\
    \        let max = elem.cmp(&minmax[1]).unwrap();\n\n        if min < 0 {\n  \
    \          vec.push(minmax[0]);\n            minmax.push(elem);\n        } else\
    \ {\n            vec.push(minmax[1]);\n            minmax.push(elem);\n      \
    \  }\n    }\n    vec\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap` found for enum `std::cmp::Ordering`\
    \ in the current scope\n  --> /tmp/tmpbq_ph91b.rs:16:40\n   |\n16 |         let\
    \ min = elem.cmp(&minmax[0]).unwrap();\n   |                                 \
    \       ^^^^^^ method not found in `std::cmp::Ordering`\n\nerror[E0599]: no method\
    \ named `unwrap` found for enum `std::cmp::Ordering` in the current scope\n  -->\
    \ /tmp/tmpbq_ph91b.rs:17:40\n   |\n17 |         let max = elem.cmp(&minmax[1]).unwrap();\n\
    \   |                                        ^^^^^^ method not found in `std::cmp::Ordering`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpbq_ph91b.rs:21:25\n   |\n21 |\
    \             minmax.push(elem);\n   |                         ^^^^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n21 |  \
    \           minmax.push(*elem);\n   |                         +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpbq_ph91b.rs:24:25\n   |\n24 |             minmax.push(elem);\n\
    \   |                         ^^^^ expected `isize`, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n24 |             minmax.push(*elem);\n\
    \   |                         +\n\nerror: aborting due to 4 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_lst = Vec::new();\n    let mut\
    \ min_val = lst.iter().min().unwrap();\n    let mut max_val = lst.iter().max().unwrap();\n\
    \    sorted_lst.push(min_val);\n    sorted_lst.push(max_val);\n    min_val -=\
    \ 1;\n    for v in lst.iter().rev() {\n        let mut elem = v - min_val;\n \
    \       while elem > sorted_lst.len() {\n            sorted_lst.push(elem);\n\
    \            elem -= 1;\n        }\n        sorted_lst.push(elem);\n    }\n  \
    \  sorted_lst.push(min_val);\n    sorted_lst.push(max_val);\n    sorted_lst\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `-=` cannot be applied to type\
    \ `&isize`\n  --> /tmp/tmpdnrimw9_.rs:17:5\n   |\n17 |     min_val -= 1;\n   |\
    \     -------^^^^^\n   |     |\n   |     cannot use `-=` on type `&isize`\n  \
    \ |\nhelp: `-=` can be used on `isize`, you can dereference `min_val`\n   |\n\
    17 |     *min_val -= 1;\n   |     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdnrimw9_.rs:20:22\n\
    \   |\n20 |         while elem > sorted_lst.len() {\n   |                    \
    \  ^^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    20 |         while elem > sorted_lst.len().try_into().unwrap() {\n   |       \
    \                               ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpdnrimw9_.rs:21:29\n   |\n21 |             sorted_lst.push(elem);\n\
    \   |                             ^^^^\n   |                             |\n \
    \  |                             expected `&isize`, found `isize`\n   |      \
    \                       help: consider borrowing here: `&elem`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpdnrimw9_.rs:24:25\n   |\n24 |         sorted_lst.push(elem);\n\
    \   |                         ^^^^\n   |                         |\n   |     \
    \                    expected `&isize`, found `isize`\n   |                  \
    \       help: consider borrowing here: `&elem`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpdnrimw9_.rs:28:5\n   |\n11 | fn strange_sort_list(lst: Vec<isize>)\
    \ -> Vec<isize> {\n   |                                          ---------- expected\
    \ `Vec<isize>` because of return type\n...\n28 |     sorted_lst\n   |     ^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Vec<&isize>`\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0368.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    if lst.len() <= 1 {\n        return lst;\n\
    \    }\n    let mut min = lst[0];\n    let mut max = lst[0];\n    for i in 1..lst.len()\
    \ {\n        if lst[i] < min {\n            min = lst[i];\n        }\n       \
    \ if lst[i] > max {\n            max = lst[i];\n        }\n    }\n    let mut\
    \ mid: isize = 0;\n    let mut rev_lst = lst.rev();\n    for i in 1..lst.len()\
    \ {\n        if lst[i] < min {\n            mid = i;\n            break;\n   \
    \     }\n    }\n    let mut mv_min = max;\n    for i in 0..mid {\n        let\
    \ tmp = lst[i];\n        lst[i] = mv_min;\n        mv_min = tmp;\n    }\n    rev_lst.sort_by(|a,\
    \ b| cmp::Reverse(a).cmp(&b));\n    rev_lst.insert(0, min);\n    rev_lst\n}\n\n\
    fn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmpbb9m_hbm.rs:39:28\n   |\n39 |     rev_lst.sort_by(|a, b| cmp::Reverse(a).cmp(&b));\n\
    \   |                            ^^^ use of undeclared crate or module `cmp`\n\
    \nerror[E0599]: `Vec<isize>` is not an iterator\n   --> /tmp/tmpbb9m_hbm.rs:26:27\n\
    \    |\n26  |       let mut rev_lst = lst.rev();\n    |                      \
    \       ^^^ `Vec<isize>` is not an iterator\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `Vec<isize>: Iterator`\n     \
    \       which is required by `&mut Vec<isize>: Iterator`\n            `[isize]:\
    \ Iterator`\n            which is required by `&mut [isize]: Iterator`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpbb9m_hbm.rs:29:19\n   |\n25 |     let mut mid:\
    \ isize = 0;\n   |                  ----- expected due to this type\n...\n29 |\
    \             mid = i;\n   |                   ^ expected `isize`, found `usize`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpbb9m_hbm.rs:35:19\n\
    \   |\n35 |         let tmp = lst[i];\n   |                   ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpbb9m_hbm.rs:36:9\n   |\n36 |         lst[i]\
    \ = mv_min;\n   |         ^^^^^^ slice indices are of type `usize` or ranges of\
    \ `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 5 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308, E0433, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut i = 0;\n    while i < lst.len() {\n\
    \        let min = i;\n        let max = i + 1;\n\n        while max < lst.len()\
    \ && lst[max] < lst[min] {\n            max += 1;\n        }\n\n        swap(&mut\
    \ lst[min..i]);\n        swap(&mut lst[i..max]);\n        i += 1;\n    }\n   \
    \ lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmprc_bygzi.rs:21:9\n\
    \   |\n21 |         swap(&mut lst[min..i]);\n   |         ^^^^ not found in this\
    \ scope\n   |\nhelp: consider importing one of these items\n   |\n1  | use std::mem::swap;\n\
    \   |\n1  | use std::ptr::swap;\n   |\n\nerror[E0425]: cannot find function `swap`\
    \ in this scope\n  --> /tmp/tmprc_bygzi.rs:22:9\n   |\n22 |         swap(&mut\
    \ lst[i..max]);\n   |         ^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing one of these items\n   |\n1  | use std::mem::swap;\n   |\n1  | use\
    \ std::ptr::swap;\n   |\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut it = lst.iter();\n    it.sort_by(|a,\
    \ b| cmp::Reverse(a, b));\n    it\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmpjzmzi6ry.rs:13:23\n   |\n13 |     it.sort_by(|a, b| cmp::Reverse(a,\
    \ b));\n   |                       ^^^ use of undeclared crate or module `cmp`\n\
    \nerror[E0599]: no method named `sort_by` found for struct `std::slice::Iter`\
    \ in the current scope\n  --> /tmp/tmpjzmzi6ry.rs:13:8\n   |\n13 |     it.sort_by(|a,\
    \ b| cmp::Reverse(a, b));\n   |        ^^^^^^^ method not found in `std::slice::Iter<'_,\
    \ isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjzmzi6ry.rs:14:5\n\
    \   |\n11 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |      \
    \                                    ---------- expected `Vec<isize>` because\
    \ of return type\n...\n14 |     it\n   |     ^^ expected struct `Vec`, found struct\
    \ `std::slice::Iter`\n   |\n   = note: expected struct `Vec<isize>`\n        \
    \      found struct `std::slice::Iter<'_, isize>`\n\nerror: aborting due to 3\
    \ previous errors\n\nSome errors have detailed explanations: E0308, E0433, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut min_idx = lst.iter().min().unwrap();\n\
    \    let mut max_idx = lst.iter().max().unwrap();\n    let mut new_lst = Vec::new();\n\
    \n    while min_idx < max_idx {\n        new_lst.push(*min_idx);\n        min_idx++;\n\
    \        while *min_idx < max_idx {\n            min_idx++;\n        }\n     \
    \   new_lst.push(*max_idx);\n        max_idx--;\n        while *max_idx >= min_idx\
    \ {\n            max_idx--;\n        }\n    }\n    new_lst.extend(lst.iter().skip(min_idx).take(max_idx\
    \ - min_idx + 1));\n\n    new_lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpz3_0lill.rs:18:16\n\
    \   |\n18 |         min_idx++;\n   |                ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n18 |         { let tmp = min_idx; min_idx\
    \ += 1; tmp };\n   |         +++++++++++        ~~~~~~~~~~~~~~~~~~~~~\n18 -  \
    \       min_idx++;\n18 +         min_idx += 1;\n   | \n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpz3_0lill.rs:28:36\n   |\n28 |     new_lst.extend(lst.iter().skip(min_idx).take(max_idx\
    \ - min_idx + 1));\n   |                                    ^^^^^^^ expected `usize`,\
    \ found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpz3_0lill.rs:28:50\n\
    \   |\n28 |     new_lst.extend(lst.iter().skip(min_idx).take(max_idx - min_idx\
    \ + 1));\n   |                                                  ^^^^^^^^^^^^^^^^^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n28 |     new_lst.extend(lst.iter().skip(min_idx).take((max_idx\
    \ - min_idx + 1).try_into().unwrap()));\n   |                                \
    \                  +                     +++++++++++++++++++++\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut min:\
    \ isize = 0;\n    for x in lst.iter() {\n        if x < min {\n            min\
    \ = x;\n        }\n    }\n    let mut max = min;\n    for x in lst.iter() {\n\
    \        if x > max {\n            max = x;\n        }\n    }\n    if min < max\
    \ {\n        for x in lst.iter() {\n            if x > min && x < max {\n    \
    \            result.append(x);\n            }\n        }\n    } else {\n     \
    \   for x in lst.iter() {\n            if x < min && x > max {\n             \
    \   result.append(x);\n            }\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpp2zzebau.rs:15:16\n   |\n\
    15 |         if x < min {\n   |                ^^^\n   |                |\n  \
    \ |                expected `&isize`, found `isize`\n   |                help:\
    \ consider borrowing here: `&min`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp2zzebau.rs:16:19\n\
    \   |\n13 |     let mut min: isize = 0;\n   |                  ----- expected\
    \ due to this type\n...\n16 |             min = x;\n   |                   ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    16 |             min = *x;\n   |                   +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpp2zzebau.rs:21:16\n   |\n21 |         if x > max {\n  \
    \ |                ^^^\n   |                |\n   |                expected `&isize`,\
    \ found `isize`\n   |                help: consider borrowing here: `&max`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpp2zzebau.rs:22:19\n   |\n19 |  \
    \   let mut max = min;\n   |                   --- expected due to this value\n\
    ...\n22 |             max = x;\n   |                   ^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n22 |        \
    \     max = *x;\n   |                   +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpp2zzebau.rs:27:20\n   |\n27 |             if x > min && x < max\
    \ {\n   |                    ^^^\n   |                    |\n   |            \
    \        expected `&isize`, found `isize`\n   |                    help: consider\
    \ borrowing here: `&min`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp2zzebau.rs:27:31\n\
    \   |\n27 |             if x > min && x < max {\n   |                        \
    \       ^^^\n   |                               |\n   |                      \
    \         expected `&isize`, found `isize`\n   |                             \
    \  help: consider borrowing here: `&max`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpp2zzebau.rs:28:31\n   |\n28 |                 result.append(x);\n\
    \   |                               ^ types differ in mutability\n   |\n   = note:\
    \ expected mutable reference `&mut Vec<_>`\n                   "
  stdout: ''
  timestamp: 1660010735
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut v = lst.clone();\n    v.sort();\n \
    \   v\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpqnlaqur8.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    if lst.len() < 2 {\n        return lst;\n \
    \   }\n    let mut min_int = i32::MIN;\n    let mut max_int = i32::MAX;\n    let\
    \ mut swap_count = 0;\n    let mut result = Vec::new();\n    for elt in lst.iter()\
    \ {\n        match elt {\n            elt if elt < min_int => {\n            \
    \    min_int = elt;\n                result.push(elt);\n                swap_count\
    \ += 1;\n            },\n            elt if elt > max_int => {\n             \
    \   max_int = elt;\n                result.push(elt);\n                swap_count\
    \ += 1;\n            },\n            _ => {}\n        }\n    }\n    while swap_count\
    \ != 0 {\n        for elt in lst.iter() {\n            match elt {\n         \
    \       elt if elt < min_int => {\n                    min_int = elt;\n      \
    \              result.push(elt);\n                    swap_count += 1;\n     \
    \           },\n                elt if elt > max_int => {\n                  \
    \  max_int = elt;\n                    result.push(elt);\n                   \
    \ swap_count += 1;\n                },\n                _ => {}\n            }\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7f9uqkkn.rs:21:26\n   |\n\
    21 |             elt if elt < min_int => {\n   |                          ^^^^^^^\
    \ expected `&isize`, found `i32`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7f9uqkkn.rs:22:27\n\
    \   |\n15 |     let mut min_int = i32::MIN;\n   |                       --------\
    \ expected due to this value\n...\n22 |                 min_int = elt;\n   | \
    \                          ^^^ expected `i32`, found `&isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp7f9uqkkn.rs:26:26\n   |\n26 |             elt\
    \ if elt > max_int => {\n   |                          ^^^^^^^ expected `&isize`,\
    \ found `i32`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7f9uqkkn.rs:27:27\n\
    \   |\n16 |     let mut max_int = i32::MAX;\n   |                       --------\
    \ expected due to this value\n...\n27 |                 max_int = elt;\n   | \
    \                          ^^^ expected `i32`, found `&isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp7f9uqkkn.rs:37:30\n   |\n37 |              \
    \   elt if elt < min_int => {\n   |                              ^^^^^^^ expected\
    \ `&isize`, found `i32`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7f9uqkkn.rs:38:31\n\
    \   |\n15 |     let mut min_int = i32::MIN;\n   |                       --------\
    \ expected due to this value\n...\n38 |                     min_int = elt;\n \
    \  |                               ^^^ expected `i32`, found `&isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp7f9uqkkn.rs:42:30\n   |\n42 |              \
    \   elt if elt > max_int => {\n   |                              ^^^^^^^ expected\
    \ `&isize`, found `i32`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7f9uqkkn.rs:43:31\n\
    \   |\n16 |     let mut max_int = i32::MAX;\n   |                       --------\
    \ expected due to this value\n...\n43 |                     max_int = elt;\n \
    \  |                               ^^^ expected `i32`, found `&isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp7f9uqkkn.rs:51:5\n   |\n11 | fn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n   |                                          ----------\
    \ expected "
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    if lst.is_empty() {\n        return vec![];\n\
    \    }\n\n    let min_idx = lst.iter().min().unwrap();\n    let max_idx = lst.iter().max().unwrap();\n\
    \n    let mut idx = min_idx;\n\n    for i in 0 .. lst.len() - 2 {\n        if\
    \ idx == max_idx {\n            break;\n        }\n\n        idx = min_idx;\n\
    \        if idx > max_idx {\n            break;\n        }\n\n        let tmp\
    \ = lst[idx];\n        lst[idx] = lst[max_idx];\n        lst[max_idx] = tmp;\n\
    \    }\n\n    lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpa8v1e2k1.rs:31:19\n\
    \   |\n31 |         let tmp = lst[idx];\n   |                   ^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpa8v1e2k1.rs:32:9\n\
    \   |\n32 |         lst[idx] = lst[max_idx];\n   |         ^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot\
    \ be indexed by `&isize`\n  --> /tmp/tmpa8v1e2k1.rs:32:20\n   |\n32 |        \
    \ lst[idx] = lst[max_idx];\n   |                    ^^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot\
    \ be indexed by `&isize`\n  --> /tmp/tmpa8v1e2k1.rs:33:9\n   |\n33 |         lst[max_idx]\
    \ = tmp;\n   |         ^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<&isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 101
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut lst_copy = lst.to_vec();\n    lst_copy.sort();\n\
    \    lst_copy\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4]`,\n right: `[1, 4, 2, 3]`', /tmp/tmpsnl4wwnx.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010736
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut lst = lst.clone();\n    let n = lst.len();\n\
    \    sort_list(&mut lst, 0, n - 1);\n    lst\n}\n\nfn main() {\n    let candidate\
    \ = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5,\
    \ 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]),\
    \ vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5,\
    \ 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `sort_list` in this scope\n  --> /tmp/tmp6e6la7q4.rs:14:5\n\
    \   |\n14 |     sort_list(&mut lst, 0, n - 1);\n   |     ^^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let len = lst.len();\n    let mut res = vec![len];\n\
    \n    let mut max = 0;\n    let mut min = len - 1;\n\n    while min < max {\n\
    \        let m = min + max / 2;\n        let c = &lst[m];\n        let n = &lst[m\
    \ - 1];\n\n        if *c > *n {\n            max -= 1;\n        }\n        if\
    \ *c < *n {\n            min += 1;\n        }\n        if *c < *n {\n        \
    \    res[m - 1] = *c;\n        }\n        if *c > *n {\n            res[min] =\
    \ *c;\n        }\n    }\n\n    res\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgqs413yf.rs:30:26\n   |\n\
    30 |             res[m - 1] = *c;\n   |             ----------   ^^ expected `usize`,\
    \ found `isize`\n   |             |\n   |             expected due to the type\
    \ of this binding\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgqs413yf.rs:33:24\n\
    \   |\n33 |             res[min] = *c;\n   |             --------   ^^ expected\
    \ `usize`, found `isize`\n   |             |\n   |             expected due to\
    \ the type of this binding\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgqs413yf.rs:37:5\n\
    \   |\n11 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |      \
    \                                    ---------- expected `Vec<isize>` because\
    \ of return type\n...\n37 |     res\n   |     ^^^ expected `isize`, found `usize`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<usize>`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_lst = vec![];\n\n    for i in\
    \ lst.iter().cloned().rev() {\n        sorted_lst.push(i);\n    }\n\n    sorted_lst.iter().cloned().rev()\n\
    }\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpy1oi663_.rs:18:5\n   |\n\
    11 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |             \
    \                             ---------- expected `Vec<isize>` because of return\
    \ type\n...\n18 |     sorted_lst.iter().cloned().rev()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found struct `Rev`\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n              found struct `Rev<Cloned<std::slice::Iter<'_, isize>>>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    if lst.is_empty() {\n        vec![]\n    }\
    \ else {\n        let mut new_vec = vec![];\n        let min_value = vec![\n \
    \           lst[0],\n            lst[lst.len() - 1],\n        ];\n        let\
    \ mut max_value = vec![\n            lst[0],\n            lst[lst.len() - 1],\n\
    \        ];\n\n        for v in lst {\n            if v < min_value[0] {\n   \
    \             new_vec.push(min_value[0]);\n                min_value[0] = v;\n\
    \            } else {\n                if v < min_value[1] {\n               \
    \     min_value[1] = v;\n                }\n            }\n\n            if v\
    \ > max_value[0] {\n                new_vec.push(max_value[0]);\n            \
    \    max_value[0] = v;\n            } else {\n                if v > max_value[1]\
    \ {\n                    max_value[1] = v;\n                }\n            }\n\
    \        }\n        new_vec.push(min_value[1]);\n        new_vec.push(max_value[1]);\n\
    \        new_vec\n    }\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `min_value` as mutable, as it is not declared\
    \ as mutable\n  --> /tmp/tmpj15yb79p.rs:28:17\n   |\n16 |         let min_value\
    \ = vec![\n   |             --------- help: consider changing this to be mutable:\
    \ `mut min_value`\n...\n28 |                 min_value[0] = v;\n   |         \
    \        ^^^^^^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot borrow `min_value`\
    \ as mutable, as it is not declared as mutable\n  --> /tmp/tmpj15yb79p.rs:31:21\n\
    \   |\n16 |         let min_value = vec![\n   |             --------- help: consider\
    \ changing this to be mutable: `mut min_value`\n...\n31 |                    \
    \ min_value[1] = v;\n   |                     ^^^^^^^^^ cannot borrow as mutable\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut sorted_lst = Vec::new();\n    for num\
    \ in lst {\n        if num < sorted_lst.len() {\n            sorted_lst.swap_remove(num)\n\
    \        }\n    }\n    sorted_lst\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9,\
    \ 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5,\
    \ 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5,\
    \ 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvu1ifova.rs:14:18\n   |\n\
    14 |         if num < sorted_lst.len() {\n   |                  ^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n14 |         if\
    \ num < sorted_lst.len().try_into().unwrap() {\n   |                         \
    \         ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvu1ifova.rs:15:36\n\
    \   |\n15 |             sorted_lst.swap_remove(num)\n   |                    \
    \                ^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    15 |             sorted_lst.swap_remove(num.try_into().unwrap())\n   |       \
    \                                ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpvu1ifova.rs:18:5\n   |\n11 | fn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n   |                                          ----------\
    \ expected `Vec<isize>` because of return type\n...\n18 |     sorted_lst\n   |\
    \     ^^^^^^^^^^ expected `isize`, found `()`\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n              found struct `Vec<()>`\n\nerror: aborting due to\
    \ 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "/// Given vector of integers, return vector in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1,\
    \ 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n\
    /// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// vec![]\nfn strange_sort_list(lst:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut n = lst.len() as isize;\n    let mut\
    \ i = 1;\n    while i < n {\n        let mut j = 0;\n        while j < n && lst[j]\
    \ < lst[i] {\n            j += 1\n        };\n        i += j;\n    };\n    while\
    \ i < n {\n        let tmp = lst[i];\n        lst[i] = lst[n - 1];\n        lst[n\
    \ - 1] = tmp;\n        i += 1;\n        n -= 1;\n    }\n    lst\n}\n\nfn main()\
    \ {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
    \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
    \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9,\
    \ 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
    \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
    \ vec![111111]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpx0hpf0hg.rs:16:24\n\
    \   |\n16 |         while j < n && lst[j] < lst[i] {\n   |                   \
    \     ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n  \
    \ = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n   =\
    \ help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpx0hpf0hg.rs:16:33\n\
    \   |\n16 |         while j < n && lst[j] < lst[i] {\n   |                   \
    \              ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpx0hpf0hg.rs:22:19\n\
    \   |\n22 |         let tmp = lst[i];\n   |                   ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpx0hpf0hg.rs:23:9\n   |\n23 |         lst[i]\
    \ = lst[n - 1];\n   |         ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpx0hpf0hg.rs:23:18\n   |\n23 |         lst[i] = lst[n - 1];\n  \
    \ |                  ^^^^^^^^^^ slice indices are"
  stdout: ''
  timestamp: 1660010735
