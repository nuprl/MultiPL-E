language: rs
name: HumanEval_76_is_simple_power
results:
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    debug_assert!(n % 2 == 0);\n    let mut a = x;\n    while a >\
    \ 1 {\n        a >>= 1;\n        n += 1;\n    }\n    a == 1\n}\n\nfn main() {\n\
    \    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmppozbk5ce.rs:22:9\n\
    \   |\n17 | fn is_simple_power(x: isize, n: isize) -> bool {\n   |           \
    \                   - help: consider making this binding mutable: `mut n`\n...\n\
    22 |         n += 1;\n   |         ^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    // TODO: Write you solution here\n    false\n}\n\nfn main() {\n\
    \    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp3k62mifr.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if n == 0 {\n        return true;\n    }\n    if x < n && n >\
    \ 1 {\n        return is_simple_power(x * (n - 1), n);\n    }\n    if x == n {\n\
    \        return true;\n    }\n    return false;\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpel88n2e0.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if n == 1 { return true; }\n    if x != n { return false; }\n\
    \    if x == 0 || x == n { return true; }\n\n    if n % x == 0 { return true;\
    \ }\n\n    let mut i = 1;\n    while i < n {\n        if x % i == 0 { return false;\
    \ }\n        i += 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpr03rn0rx.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if n == 1 { return true }\n\n    match n {\n        4 | 8 | 16\
    \ | 32 | 64 | 128 | 256 | 512 | 1024 => x == n ** 4,\n        _ => false\n   \
    \ }\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `{integer}` cannot be dereferenced\n  --> /tmp/tmpkh5fqcj5.rs:21:66\n\
    \   |\n21 |         4 | 8 | 16 | 32 | 64 | 128 | 256 | 512 | 1024 => x == n **\
    \ 4,\n   |                                                                  ^^^\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    (x == 1) || (x == n) || ((x * n) == x)\n}\n\nfn main() {\n  \
    \  let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp_jm1zktm.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    (1i..x).all(|x| {\n        let mut x_pow_n = 1;\n        if x\
    \ != 0 {\n            match n {\n                1 => x_pow_n = x,\n         \
    \       x if x == x => x_pow_n = x,\n                _ => {\n                \
    \    for _ in 0..x {\n                        x_pow_n *= n;\n                \
    \    }\n                }\n            }\n        }\n        x_pow_n == x\n  \
    \  })\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: SyntaxError
  stderr: "error: invalid suffix `i` for number literal\n  --> /tmp/tmphyc0fvbc.rs:18:6\n\
    \   |\n18 |     (1i..x).all(|x| {\n   |      ^^ invalid suffix `i`\n   |\n   =\
    \ help: the suffix must be one of the numeric types (`u32`, `isize`, `f32`, etc.)\n\
    \nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    n > 0 && n % x == 0\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp0rbqbt6q.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    x != 0 && !is_power_of_two(x) && x **= n == x;\n}\n\nfn main()\
    \ {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `*=`\n  --> /tmp/tmplmg0eds1.rs:18:41\n\
    \   |\n18 |     x != 0 && !is_power_of_two(x) && x **= n == x;\n   |         \
    \                                ^^ expected expression\n\nerror: aborting due\
    \ to previous error\n\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    (x * n) == (x * n)\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpivk77v2r.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    let mut power = 0;\n    while power < n {\n        if (x * power\
    \ == n) {\n            return true;\n        }\n        power += 1;\n    }\n \
    \   false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpaaqmg_9m.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x < n {\n        return false;\n    }\n\n    let mut acc =\
    \ 1;\n    for _ in 0..n {\n        acc *= x;\n    }\n\n    acc == x\n}\n\nfn main()\
    \ {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp7y3zxlir.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 || x == n {\n        return true;\n    }\n    for k\
    \ in 1..n {\n        if x * n == x * k {\n            return true;\n        }\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n  \
    \  assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpmtbcw862.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == n {\n        return true;\n    }\n\n    if n % x == 0\
    \ {\n        return false;\n    }\n\n    for _ in 0..n-1 {\n        if x % n ==\
    \ 0 {\n            return false;\n        }\n\n        x = x * x % n;\n    }\n\
    \n    true\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `x`\n  --> /tmp/tmpic_k601u.rs:31:9\n\
    \   |\n17 | fn is_simple_power(x: isize, n: isize) -> bool {\n   |           \
    \         - help: consider making this binding mutable: `mut x`\n...\n31 |   \
    \      x = x * x % n;\n   |         ^^^^^^^^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if n == 1 {\n        return true;\n    }\n\n    if n%x == 0 {\n\
    \        return true;\n    }\n\n    if x > n / 2 {\n        return false;\n  \
    \  }\n\n    return is_simple_power(x, n/x);\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpuxnn2ptq.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if n == 1 || (n ** x) == x {\n        return true;\n    }\n \
    \   if x <= 0 {\n        return false;\n    }\n    if x == n / 2 {\n        return\
    \ true;\n    }\n    if n == n / 2 {\n        return false;\n    }\n    if n %\
    \ 2 == 0 {\n        return is_simple_power(x, n - 2);\n    }\n    if n % 3 ==\
    \ 0 {\n        return is_simple_power(x, n - 3);\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpggwci5e9.rs:18:22\n\
    \   |\n18 |     if n == 1 || (n ** x) == x {\n   |                      ^^^\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    use std::cmp::Ordering;\n\n    if n == 1 {\n        return true;\n\
    \    }\n\n    if n == 2 {\n        if x == 1 {\n            return true;\n   \
    \     }\n        return false;\n    }\n\n    if n % 2 == 0 {\n        if x ==\
    \ 1 {\n            return true;\n        }\n        return false;\n    }\n\n \
    \   if x == 1 {\n        return true;\n    }\n\n    if x < n / 2 {\n        if\
    \ n == 1 {\n            return true;\n        }\n        return false;\n    }\n\
    \n    if x <= n / 2 {\n        if x > n / 2 {\n            return false;\n   \
    \     }\n        return is_simple_power(x, n / 2);\n    }\n\n    let mut x2 =\
    \ x;\n    let mut x4 = x;\n    let mut x8 = x;\n    let mut x2 = x;\n    while\
    \ x8 <= x4 {\n        x4 = x8;\n        x4 = x4 * x;\n        x2 = x4 + x2;\n\
    \        x8 = x8;\n        x8 = x8 * x;\n    }\n    if x2 <= n {\n        return\
    \ true;\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp1_nb7udk.rs:75:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 0 {\n        if n == 1 {\n            return true;\n\
    \        }\n        return false;\n    }\n    \n    if n >= x {\n        return\
    \ false;\n    }\n    \n    let mut ans = 0;\n    \n    if x <= n {\n        for\
    \ _ in 0..x {\n            ans += 1;\n        }\n    } else {\n        for _ in\
    \ 0..(n - x) {\n            ans += 1;\n        }\n    }\n    \n    if ans == x\
    \ {\n        return true;\n    }\n    return false;\n}\n\nfn main() {\n    let\
    \ candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpah1kc53o.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    pow(x, n).is_approx(x)\n}\n\nfn main() {\n    let candidate =\
    \ is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `pow` in this scope\n  --> /tmp/tmpx6gbunzs.rs:18:5\n\
    \   |\n18 |     pow(x, n).is_approx(x)\n   |     ^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    match n {\n        1 => true,\n        x if x < 2 => x == 1,\n\
    \        _ => x < std::i32::MAX as isize / (n - 1),\n    }\n}\n\nfn main() {\n\
    \    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp3d5du8j6.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    let mut power = x;\n    let mut counter = 0;\n\n    while power\
    \ != 1 {\n        power = power * n;\n        counter += 1;\n    }\n    counter\
    \ == n\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to multiply with overflow'', /tmp/tmps6kg_c0e.rs:22:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    x.is_power_of_2() && n == pow2(x).unwrap_or(0)\n}\n\nfn main()\
    \ {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `pow2` in this scope\n  --> /tmp/tmptgmb60wl.rs:18:31\n\
    \   |\n18 |     x.is_power_of_2() && n == pow2(x).unwrap_or(0)\n   |         \
    \                      ^^^^ not found in this scope\n\nerror[E0599]: no method\
    \ named `is_power_of_2` found for type `isize` in the current scope\n  --> /tmp/tmptgmb60wl.rs:18:7\n\
    \   |\n18 |     x.is_power_of_2() && n == pow2(x).unwrap_or(0)\n   |       ^^^^^^^^^^^^^\
    \ method not found in `isize`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0425, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: -1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    if n == 0 {\n \
    \       return false;\n    }\n    if n % x == 0 {\n        return is_simple_power(x,\
    \ n/x);\n    }\n    else {\n        return is_simple_power(x, n);\n    }\n}\n\n\
    fn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    x <= 1\n        || (n ** int(x)) == x\n}\n\nfn main() {\n   \
    \ let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `int` in this scope\n  --> /tmp/tmprm20zky1.rs:19:18\n\
    \   |\n19 |         || (n ** int(x)) == x\n   |                  ^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    let mut xpow = x;\n    let mut xpowpow = 1;\n    while xpow <\
    \ n {\n        xpowpow *= xpow;\n        xpow += 1;\n    }\n    xpow == xpowpow\n\
    }\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmptluus5xd.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    use std::cmp::Ordering;\n    use std::cmp::PartialOrd;\n\n  \
    \  if n == 1 {\n        true\n    } else if n == 0 {\n        false\n    } else\
    \ {\n        x >= n\n            && Ordering::Less(n, x).partial_cmp(&x)\n   \
    \         == PartialOrd::Equal\n    }\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: SyntaxError
  stderr: "warning: the item `PartialOrd` is imported redundantly\n   --> /tmp/tmpye90yv52.rs:19:9\n\
    \    |\n19  |     use std::cmp::PartialOrd;\n    |         ^^^^^^^^^^^^^^^^^^^^\n\
    \    |\n    = note: `#[warn(unused_imports)]` on by default\n\nerror[E0618]: expected\
    \ function, found enum variant `Ordering::Less`\n  --> /tmp/tmpye90yv52.rs:27:16\n\
    \   |\n27 |             && Ordering::Less(n, x).partial_cmp(&x)\n   |        \
    \        ^^^^^^^^^^^^^^------\n   |                |\n   |                call\
    \ expression requires function\n   |\nhelp: `Ordering::Less` is a unit variant,\
    \ you need to write it without the parentheses\n   |\n27 -             && Ordering::Less(n,\
    \ x).partial_cmp(&x)\n27 +             && Ordering::Less.partial_cmp(&x)\n   |\
    \ \n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> /tmp/tmpye90yv52.rs:28:16\n\
    \   |\n28 |             == PartialOrd::Equal\n   |                ^^^^^^^^^^\n\
    \   |\n   = note: `#[warn(bare_trait_objects)]` on by default\n   = warning: this\
    \ is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n\
    \   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\
    help: use `dyn`\n   |\n28 |             == <dyn PartialOrd>::Equal\n   |     \
    \           ++++           +\n\nerror[E0599]: no associated item named `Equal`\
    \ found for trait object `dyn PartialOrd<_>` in the current scope\n  --> /tmp/tmpye90yv52.rs:28:28\n\
    \   |\n28 |             == PartialOrd::Equal\n   |                           \
    \ ^^^^^ associated item not found in `dyn PartialOrd<_>`\n\nerror: aborting due\
    \ to 2 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations:\
    \ E0599, E0618.\nFor more information about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    // Your code goes here\n}\n\nfn main() {\n    let candidate =\
    \ is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp62mk5tye.rs:17:43\n   |\n\
    17 | fn is_simple_power(x: isize, n: isize) -> bool {\n   |    ---------------\
    \                        ^^^^ expected `bool`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    match n {\n        0 => true,\n        _ if n == 1 => true,\n\
    \        _ => n % 2 == 0 && x > 1 && x > x / 2 || n % 2 == 1 && x > 1 / x && x\
    \ > x / 2,\n    }\n}\n\nfn main() {\n    let candidate = is_simple_power;\n  \
    \  assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp730tot2c.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    x % n == 0\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpxxopd5r4.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    let mut y = n as isize;\n    while y < x {\n        y = (y <<\
    \ 1) + 1;\n    }\n    y == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpmdsq3_dd.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    if n*n == x {\n\
    \        return true;\n    }\n    if x % n == 0 {\n        return true;\n    }\n\
    \    if x > n {\n        return false;\n    }\n    if x == 0 {\n        return\
    \ false;\n    }\n    for d in 0..(x - 1) {\n        if is_simple_power(x, n) &&\
    \ is_simple_power(x, d*n) {\n            return true;\n        }\n    }\n    return\
    \ false;\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp3cw1n7sy.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    let mut result = x;\n    while result < n {\n        result *=\
    \ result;\n    }\n    result == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpbup_4mdt.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    (1usize << n) == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5rsjurrr.rs:18:22\n   |\n\
    18 |     (1usize << n) == x\n   |                      ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n18 |     (1usize << n) == x.try_into().unwrap()\n\
    \   |                       ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    !x.is_power_of_two() || n.is_power_of_two() && x == n.pow(n as\
    \ usize)\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmpso5ttrxi.rs:18:8\n   |\n18 |     !x.is_power_of_two()\
    \ || n.is_power_of_two() && x == n.pow(n as usize)\n   |        ^^^^^^^^^^^^^^^\
    \ method not found in `isize`\n\nerror[E0599]: no method named `is_power_of_two`\
    \ found for type `isize` in the current scope\n  --> /tmp/tmpso5ttrxi.rs:18:31\n\
    \   |\n18 |     !x.is_power_of_two() || n.is_power_of_two() && x == n.pow(n as\
    \ usize)\n   |                               ^^^^^^^^^^^^^^^ method not found\
    \ in `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpso5ttrxi.rs:18:63\n\
    \   |\n18 |     !x.is_power_of_two() || n.is_power_of_two() && x == n.pow(n as\
    \ usize)\n   |                                                               ^^^^^^^^^^\
    \ expected `u32`, found `usize`\n   |\nhelp: you can convert a `usize` to a `u32`\
    \ and panic if the converted value doesn't fit\n   |\n18 |     !x.is_power_of_two()\
    \ || n.is_power_of_two() && x == n.pow((n as usize).try_into().unwrap())\n   |\
    \                                                               +          +++++++++++++++++++++\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    n <= 0 || x <= 0\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp4gcv1bpa.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == n { true } else { false }\n}\n\nfn main() {\n    let\
    \ candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpvj4g90oe.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    // write your function here\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfn83b2e4.rs:17:43\n   |\n\
    17 | fn is_simple_power(x: isize, n: isize) -> bool {\n   |    ---------------\
    \                        ^^^^ expected `bool`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if n <= 1 {\n        return false;\n    }\n    let mut x = x;\n\
    \    let mut y = 1;\n    while n > 1 {\n        if n % 2 == 0 {\n            y\
    \ *= x;\n        }\n        x *= x;\n        n /= 2;\n    }\n    y == x\n}\n\n\
    fn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmptgxn09al.rs:28:9\n\
    \   |\n17 | fn is_simple_power(x: isize, n: isize) -> bool {\n   |           \
    \                   - help: consider making this binding mutable: `mut n`\n...\n\
    28 |         n /= 2;\n   |         ^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if n % x == 0 {\n        return true;\n    }\n    if n % x ==\
    \ -1 {\n        return false;\n    }\n    let mut x = x;\n    while x <= n {\n\
    \        x = x * x;\n        if n % x == 0 {\n            return true;\n     \
    \   }\n        if n % x == -1 {\n            return false;\n        }\n    }\n\
    \    return false;\n}\n\nfn main() {\n    let candidate = is_simple_power;\n \
    \   assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmphrl_xn5t.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x <= 1 {\n        return false;\n    }\n    if x != n ** n\
    \ {\n        return false;\n    }\n    if n == 1 {\n        return true;\n   \
    \ }\n    fn is_simple_power_helper(n: isize, x: isize) -> bool {\n        if x\
    \ == 1 {\n            return true;\n        }\n        if is_simple_power_helper(n,\
    \ x - 1) {\n            return true;\n        }\n        return false;\n    }\n\
    \    is_simple_power_helper(n, n - 1)\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmp2129fzbw.rs:21:16\n\
    \   |\n21 |     if x != n ** n {\n   |                ^^^\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0614`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    (x * n) == (x * x)\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpi6x6csnr.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if n == 1 {\n        return true;\n    }\n\n    if x == n {\n\
    \        return true;\n    }\n\n    if n == x {\n        return true;\n    }\n\
    \n    if x == 1 {\n        return false;\n    }\n\n    let mut y = x;\n    for\
    \ i in 0..n {\n        y = ((y * y) % n) % n;\n        if y != 1 {\n         \
    \   return false;\n        }\n    }\n\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpe_82z6ku.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if n == 1 {\n        return true;\n    }\n\n    if x < n && is_simple_power(x,\
    \ n - 1) {\n        return true;\n    }\n\n    if n <= 0 {\n        return false;\n\
    \    }\n\n    if x == 1 {\n        return n == 1;\n    }\n\n    if n == 2 {\n\
    \        return true;\n    }\n\n    if x <= 2 {\n        return is_simple_power(x,\
    \ n - 1);\n    }\n\n    if n % 2 == 0 {\n        return is_simple_power(x, n /\
    \ 2);\n    }\n\n    let a = (x - 1) / (n - 1);\n    let b = (n - 1) / n;\n\n \
    \   (n - 1) <= x && x <= b && is_simple_power(a, n - 1) && (n - 1) <= x && x <=\
    \ b && is_simple_power(b, n - 1);\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxkujefuf.rs:17:43\n   |\n\
    17 | fn is_simple_power(x: isize, n: isize) -> bool {\n   |    ---------------\
    \                        ^^^^ expected `bool`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n...\n\
    49 |     (n - 1) <= x && x <= b && is_simple_power(a, n - 1) && (n - 1) <= x &&\
    \ x <= b && is_simple_power(b, n - 1);\n   |                                 \
    \                                                                            \
    \  - help: remove this semicolon\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    // TODO: Implement this function\n    false\n}\n\nfn main() {\n\
    \    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpgelum38f.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    // write your code here\n    if n != 1 {\n        return (x *\
    \ n == n ** x);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around `return` value\n  --> /tmp/tmpgpapvfvz.rs:20:16\n\
    \   |\n20 |         return (x * n == n ** x);\n   |                ^         \
    \      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove\
    \ these parentheses\n   |\n20 -         return (x * n == n ** x);\n20 +      \
    \   return x * n == n ** x;\n   | \n\nerror[E0614]: type `isize` cannot be dereferenced\n\
    \  --> /tmp/tmpgpapvfvz.rs:20:29\n   |\n20 |         return (x * n == n ** x);\n\
    \   |                             ^^^\n\nerror: aborting due to previous error;\
    \ 1 warning emitted\n\nFor more information about this error, try `rustc --explain\
    \ E0614`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == n {\n        return true;\n    }\n    if x <= n {\n \
    \       return is_simple_power(x, n-1);\n    }\n    let m = pow(x, n).unwrap();\n\
    \    // m will be 0 or 1 here.\n    if m == 0 {\n        return true;\n    }\n\
    \    if m == 1 {\n        return false;\n    }\n    return is_simple_power(m,\
    \ n-1);\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `pow` in this scope\n  --> /tmp/tmp_lr8ad4n.rs:24:13\n\
    \   |\n24 |     let m = pow(x, n).unwrap();\n   |             ^^^ not found in\
    \ this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    n.is_integer() && (n.is_even() || n.is_odd()) && x.is_integer()\
    \ && (x.is_even() || x.is_odd())\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_integer` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmpvpf9m3z0.rs:18:7\n   |\n18 |     n.is_integer()\
    \ && (n.is_even() || n.is_odd()) && x.is_integer() && (x.is_even() || x.is_odd())\n\
    \   |       ^^^^^^^^^^ method not found in `isize`\n\nerror[E0599]: no method\
    \ named `is_even` found for type `isize` in the current scope\n  --> /tmp/tmpvpf9m3z0.rs:18:26\n\
    \   |\n18 |     n.is_integer() && (n.is_even() || n.is_odd()) && x.is_integer()\
    \ && (x.is_even() || x.is_odd())\n   |                          ^^^^^^^ method\
    \ not found in `isize`\n\nerror[E0599]: no method named `is_odd` found for type\
    \ `isize` in the current scope\n  --> /tmp/tmpvpf9m3z0.rs:18:41\n   |\n18 |  \
    \   n.is_integer() && (n.is_even() || n.is_odd()) && x.is_integer() && (x.is_even()\
    \ || x.is_odd())\n   |                                         ^^^^^^ method not\
    \ found in `isize`\n\nerror[E0599]: no method named `is_integer` found for type\
    \ `isize` in the current scope\n  --> /tmp/tmpvpf9m3z0.rs:18:56\n   |\n18 |  \
    \   n.is_integer() && (n.is_even() || n.is_odd()) && x.is_integer() && (x.is_even()\
    \ || x.is_odd())\n   |                                                       \
    \ ^^^^^^^^^^ method not found in `isize`\n\nerror[E0599]: no method named `is_even`\
    \ found for type `isize` in the current scope\n  --> /tmp/tmpvpf9m3z0.rs:18:75\n\
    \   |\n18 |     n.is_integer() && (n.is_even() || n.is_odd()) && x.is_integer()\
    \ && (x.is_even() || x.is_odd())\n   |                                       \
    \                                    ^^^^^^^ method not found in `isize`\n\nerror[E0599]:\
    \ no method named `is_odd` found for type `isize` in the current scope\n  -->\
    \ /tmp/tmpvpf9m3z0.rs:18:90\n   |\n18 |     n.is_integer() && (n.is_even() ||\
    \ n.is_odd()) && x.is_integer() && (x.is_even() || x.is_odd())\n   |         \
    \                                                                            \
    \     ^^^^^^ method not found in `isize`\n\nerror: aborting due to 6 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x < 1 {\n        return false;\n    }\n    if x <= n {\n \
    \       return true;\n    }\n    if x == n {\n        return true;\n    }\n  \
    \  if n == 1 {\n        if x == 1 {\n            return true;\n        }\n   \
    \     return false;\n    }\n    if n % 2 == 0 {\n        return is_simple_power(x,\
    \ n / 2);\n    }\n    if n % 3 == 0 {\n        return is_simple_power(x, n / 3);\n\
    \    }\n    return is_simple_power(x, n / 2);\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpvdwv3p_j.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    // TODO: implement this\n    assert!(false, \"Not implemented\"\
    );\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4_978tng.rs:17:43\n   |\n\
    17 | fn is_simple_power(x: isize, n: isize) -> bool {\n   |    ---------------\
    \                        ^^^^ expected `bool`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: -1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == n {\n        return true;\n    }\n    if n % x == 0 {\n\
    \        return false;\n    }\n    return is_simple_power(x, n - x);\n}\n\nfn\
    \ main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976130
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    // Write your code here.\n    let mut i = 0;\n    let mut sum\
    \ = 1;\n    while i < n {\n        let t = n * sum;\n        if x == t {\n   \
    \         return true;\n        }\n        sum += x;\n        i += 1;\n    }\n\
    \    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpv0sj2s74.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x <= 0 {\n        return false;\n    }\n    if x == 1 {\n\
    \        return true;\n    }\n    if n == 0 {\n        return false;\n    }\n\
    \    if n == 1 {\n        return true;\n    }\n    let mut x = x;\n    let mut\
    \ n = n;\n    if n % 2 == 1 {\n        x = x * x;\n        n = n / 2;\n    }\n\
    \    loop {\n        if x == n**x {\n            return true;\n        }\n   \
    \     if n <= 1 {\n            return false;\n        }\n        n = n / 2;\n\
    \        x = x * x;\n    }\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpyee43sik.rs:37:19\n\
    \   |\n37 |         if x == n**x {\n   |                   ^^\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0614`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if n < 1 {\n        return false\n    }\n    let mut power: isize\
    \ = 1;\n    loop {\n        if power % x == 0 {\n            return true;\n  \
    \      }\n        power += 1;\n    }\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpscwd64h_.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if n == 1 {\n        return true;\n    }\n    if n == 0 {\n \
    \       return false;\n    }\n    if n == 2 {\n        return x == 1;\n    }\n\
    \    if n == 3 {\n        return x == 1;\n    }\n    let mut i = 0;\n    let mut\
    \ f = 1;\n    loop {\n        if f > pow(x, n) {\n            return false;\n\
    \        }\n        i += 1;\n        f *= x;\n    }\n}\n\nfn main() {\n    let\
    \ candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `pow` in this scope\n  --> /tmp/tmp8jdfwo3h.rs:33:16\n\
    \   |\n33 |         if f > pow(x, n) {\n   |                ^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if n % x == 0 {\n        let mut x = x;\n        let mut y =\
    \ 1;\n        while x != 0 {\n            x /= n;\n            y *= n;\n     \
    \   }\n        return y == x;\n    }\n    return false;\n}\n\nfn main() {\n  \
    \  let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp8hfajo8_.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x < n {\n        false\n    } else if x == n {\n        true\n\
    \    } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpttlhpfjc.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if n == 0 || (n % x == 0) {\n        return true;\n    }\n  \
    \  n /= x;\n    loop {\n        if n % x == 0 {\n            return true;\n  \
    \      }\n        n /= x;\n    }\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpezg4g677.rs:21:5\n\
    \   |\n17 | fn is_simple_power(x: isize, n: isize) -> bool {\n   |           \
    \                   - help: consider making this binding mutable: `mut n`\n...\n\
    21 |     n /= x;\n   |     ^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `n`\n  --> /tmp/tmpezg4g677.rs:26:9\n  \
    \ |\n17 | fn is_simple_power(x: isize, n: isize) -> bool {\n   |             \
    \                 - help: consider making this binding mutable: `mut n`\n...\n\
    26 |         n /= x;\n   |         ^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    let mut power = 1;\n    while power <= n {\n        if x % power\
    \ == 0 {\n            return true;\n        }\n        power <<= 1;\n    }\n \
    \   return false;\n}\n\nfn main() {\n    let candidate = is_simple_power;\n  \
    \  assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpheynt6l8.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    true\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpyjwog22b.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    match n {\n        1 => x == 1,\n        2 => x == 2,\n     \
    \   4 => x == 4,\n        _ => {\n            let mut y = 1;\n            loop\
    \ {\n                if n % y == 0 {\n                    return x == n ** y;\n\
    \                }\n                y *= 2;\n            }\n        }\n    }\n\
    }\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmp5gb_zevp.rs:26:36\n\
    \   |\n26 |                     return x == n ** y;\n   |                    \
    \                ^^^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    (n * n) == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpeulajrnv.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if n < 0 {\n        return false;\n    }\n    if x == 1 {\n \
    \       return true;\n    }\n    if n == 1 {\n        return true;\n    }\n  \
    \  if n % 2 == 0 {\n        if x % n == 0 {\n            return true;\n      \
    \  }\n    }\n    else if x % n == 0 {\n        return false;\n    }\n    else\
    \ if n%2==0 {\n        return is_simple_power(x/n, n-1);\n    }\n    else {\n\
    \        return is_simple_power(x, n-1);\n    }\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0317]: `if` may be missing an `else` clause\n  --> /tmp/tmpcw8qzkhx.rs:28:9\n\
    \   |\n28 | /         if x % n == 0 {\n29 | |             return true;\n30 | |\
    \         }\n   | |_________^ expected `()`, found `bool`\n   |\n   = note: `if`\
    \ expressions without `else` evaluate to `()`\n   = help: consider adding an `else`\
    \ block that evaluates to the expected type\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0317`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if n == 1 {\n        return true;\n    }\n\n    if x == 1 {\n\
    \        return false;\n    }\n\n    let mut res = false;\n    while n != 1 {\n\
    \        if x % n == 0 {\n            n /= 2;\n            res = true;\n     \
    \   }\n        x /= n;\n    }\n    res\n}\n\nfn main() {\n    let candidate =\
    \ is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpit0biron.rs:29:13\n\
    \   |\n17 | fn is_simple_power(x: isize, n: isize) -> bool {\n   |           \
    \                   - help: consider making this binding mutable: `mut n`\n...\n\
    29 |             n /= 2;\n   |             ^^^^^^ cannot assign to immutable argument\n\
    \nerror[E0384]: cannot assign to immutable argument `x`\n  --> /tmp/tmpit0biron.rs:32:9\n\
    \   |\n17 | fn is_simple_power(x: isize, n: isize) -> bool {\n   |           \
    \         - help: consider making this binding mutable: `mut x`\n...\n32 |   \
    \      x /= n;\n   |         ^^^^^^ cannot assign to immutable argument\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x < 1 {\n        return false;\n    }\n    if n == 0 {\n \
    \       return true;\n    }\n\n    let mut x = x;\n    let mut n = n;\n    while\
    \ x > n {\n        x -= n;\n        n += 1;\n    }\n\n    if n == 1 {\n      \
    \  return true;\n    }\n\n    let mut i = 2;\n    while i <= x {\n        if x\
    \ % i == 0 {\n            return false;\n        }\n        i += 1;\n    }\n \
    \   true\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpxsdwslc6.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    x <= 0 && n < 0\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp5813p4if.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    (1..n).any(|x| *x ** (*n) == x)\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpnqduq2rq.rs:18:20\n\
    \   |\n18 |     (1..n).any(|x| *x ** (*n) == x)\n   |                    ^^\n\n\
    error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpnqduq2rq.rs:18:26\n\
    \   |\n18 |     (1..n).any(|x| *x ** (*n) == x)\n   |                        \
    \  ^^^^\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x < n && x ** n == x {\n        return true;\n    }\n    return\
    \ false;\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpr_2ty_ns.rs:18:20\n\
    \   |\n18 |     if x < n && x ** n == x {\n   |                    ^^^\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    x.is_power_of_2() && n.is_power_of_2() && pow(x, n) == x\n}\n\
    \nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `pow` in this scope\n  --> /tmp/tmpb8onppan.rs:18:47\n\
    \   |\n18 |     x.is_power_of_2() && n.is_power_of_2() && pow(x, n) == x\n   |\
    \                                               ^^^ not found in this scope\n\n\
    error[E0599]: no method named `is_power_of_2` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpb8onppan.rs:18:7\n   |\n18 |     x.is_power_of_2() && n.is_power_of_2()\
    \ && pow(x, n) == x\n   |       ^^^^^^^^^^^^^ method not found in `isize`\n\n\
    error[E0599]: no method named `is_power_of_2` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpb8onppan.rs:18:28\n   |\n18 |     x.is_power_of_2() &&\
    \ n.is_power_of_2() && pow(x, n) == x\n   |                            ^^^^^^^^^^^^^\
    \ method not found in `isize`\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0425, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x <= 1 || !is_power_of_two(n) {\n        return false;\n \
    \   }\n    for _ in 0..x {\n        if n % n == 0 {\n            return true;\n\
    \        }\n    }\n    return false;\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_power_of_two` in this scope\n  -->\
    \ /tmp/tmpl06atvih.rs:18:19\n   |\n18 |     if x <= 1 || !is_power_of_two(n) {\n\
    \   |                   ^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    match n {\n        1 => true,\n        _ => false,\n    }\n \
    \   x.is_power_of_2() && is_power_of_two(x)\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_power_of_two` in this scope\n  -->\
    \ /tmp/tmp6lbs9jer.rs:22:26\n   |\n22 |     x.is_power_of_2() && is_power_of_two(x)\n\
    \   |                          ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp6lbs9jer.rs:18:5\n   |\n18 | /     match n {\n\
    19 | |         1 => true,\n20 | |         _ => false,\n21 | |     }\n   | |  \
    \   ^- help: consider using a semicolon here\n   | |_____|\n   |       expected\
    \ `()`, found `bool`\n\nerror[E0599]: no method named `is_power_of_2` found for\
    \ type `isize` in the current scope\n  --> /tmp/tmp6lbs9jer.rs:22:7\n   |\n22\
    \ |     x.is_power_of_2() && is_power_of_two(x)\n   |       ^^^^^^^^^^^^^ method\
    \ not found in `isize`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0425, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    use std::cmp::Ordering::{Equal, Less};\n    if n < 0 || n % x\
    \ == 0 || n % x == 1 {\n        return false;\n    }\n    for i in 0..(n + 1).step_by(x)\
    \ {\n        if n <= i * x {\n            return true;\n        }\n    }\n   \
    \ false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: SyntaxError
  stderr: "warning: unused imports: `Equal`, `Less`\n  --> /tmp/tmpcxf2hvx8.rs:18:30\n\
    \   |\n18 |     use std::cmp::Ordering::{Equal, Less};\n   |                 \
    \             ^^^^^  ^^^^\n   |\n   = note: `#[warn(unused_imports)]` on by default\n\
    \nerror[E0599]: `isize` is not an iterator\n  --> /tmp/tmpcxf2hvx8.rs:22:25\n\
    \   |\n22 |     for i in 0..(n + 1).step_by(x) {\n   |                       \
    \  ^^^^^^^ `isize` is not an iterator\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `isize: Iterator`\n           which is required\
    \ by `&mut isize: Iterator`\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if n == 1 {\n        return true;\n    }\n\n    if n % x == 0\
    \ {\n        return is_simple_power(x, n-1);\n    }\n\n    return false;\n}\n\n\
    fn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp_bpia1ha.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x < n && n % x == 0 {\n        return true;\n    }\n    else\
    \ {\n        return false;\n    }\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpt5vl1la_.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    // TODO: implement this\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpap02dapf.rs:17:43\n   |\n\
    17 | fn is_simple_power(x: isize, n: isize) -> bool {\n   |    ---------------\
    \                        ^^^^ expected `bool`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x <= 1 || (n == 1 && x == 1) || n == 0 {\n        true\n \
    \   } else {\n        n % x == 0\n    }\n}\n\nfn main() {\n    let candidate =\
    \ is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpbls9awpe.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if n < 1 {\n        return false;\n    }\n    if x == 1 {\n \
    \       return true;\n    }\n    if n == 1 {\n        if x != 1 {\n          \
    \  return false;\n        }\n        return true;\n    }\n    if x <= n / 2 {\n\
    \        return is_simple_power(x, n - 1) && is_simple_power(x * n, n - 1);\n\
    \    }\n    return is_simple_power(x, n / 2) && is_simple_power(x * n, n / 2);\n\
    }\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpp3le058d.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    x.is_integer() && is_integer(n) && n.is_integer() && x == n**x\n\
    }\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_integer` in this scope\n  --> /tmp/tmpupekat63.rs:18:23\n\
    \   |\n18 |     x.is_integer() && is_integer(n) && n.is_integer() && x == n**x\n\
    \   |                       ^^^^^^^^^^ not found in this scope\n\nerror[E0599]:\
    \ no method named `is_integer` found for type `isize` in the current scope\n \
    \ --> /tmp/tmpupekat63.rs:18:7\n   |\n18 |     x.is_integer() && is_integer(n)\
    \ && n.is_integer() && x == n**x\n   |       ^^^^^^^^^^ method not found in `isize`\n\
    \nerror[E0599]: no method named `is_integer` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpupekat63.rs:18:42\n   |\n18 |     x.is_integer() && is_integer(n)\
    \ && n.is_integer() && x == n**x\n   |                                       \
    \   ^^^^^^^^^^ method not found in `isize`\n\nerror[E0614]: type `isize` cannot\
    \ be dereferenced\n  --> /tmp/tmpupekat63.rs:18:65\n   |\n18 |     x.is_integer()\
    \ && is_integer(n) && n.is_integer() && x == n**x\n   |                      \
    \                                           ^^\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0425, E0599, E0614.\nFor\
    \ more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if is_power_of_two(n) {\n        if x % n == 0 {\n          \
    \  true\n        } else {\n            false\n        }\n    } else {\n      \
    \  if x % n != 0 {\n            false\n        } else {\n            x != n *\
    \ is_simple_power(x, n - 1)\n        }\n    }\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_power_of_two` in this scope\n  -->\
    \ /tmp/tmpi6jjufac.rs:18:8\n   |\n18 |     if is_power_of_two(n) {\n   |     \
    \   ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0277]: cannot multiply `isize`\
    \ by `bool`\n  --> /tmp/tmpi6jjufac.rs:28:20\n   |\n28 |             x != n *\
    \ is_simple_power(x, n - 1)\n   |                    ^ no implementation for `isize\
    \ * bool`\n   |\n   = help: the trait `Mul<bool>` is not implemented for `isize`\n\
    \   = help: the following other types implement trait `Mul<Rhs>`:\n          \
    \   <&'a f32 as Mul<f32>>\n             <&'a f64 as Mul<f64>>\n             <&'a\
    \ i128 as Mul<i128>>\n             <&'a i16 as Mul<i16>>\n             <&'a i32\
    \ as Mul<i32>>\n             <&'a i64 as Mul<i64>>\n             <&'a i8 as Mul<i8>>\n\
    \             <&'a isize as Mul<isize>>\n           and 49 others\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0425.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if n == 0 {\n        return true;\n    }\n\n    if n == 1 {\n\
    \        if x == 1 {\n            return true;\n        }\n\n        return false;\n\
    \    }\n\n    // if n is power of x then return true\n    if x&1 == 1 {\n    \
    \    return is_simple_power(x >> 1, n-1);\n    }\n\n    // n is not power of x\
    \ return false\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpmwitrlmi.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: -1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n\n    if x == n {\n\
    \        return true;\n    }\n\n    if x == n {\n        return true;\n    }\n\
    \n    if x % n == 0 {\n        if x != n {\n            return is_simple_power(x\
    \ / (n - 1), n);\n        }\n        return true;\n    }\n\n    return false;\n\
    }\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976130
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 && n == 1 {\n        return true;\n    }\n    if n\
    \ == 1 {\n        return false;\n    }\n    if n & 1 == 1 {\n        if is_power_of_two(x)\
    \ {\n            return true;\n        }\n        if x != 1 {\n            return\
    \ false;\n        }\n    }\n    if x > n / 2 {\n        return is_power_of_two(x);\n\
    \    }\n    let mut x = x;\n    while n > 1 {\n        if n % 2 == 1 {\n     \
    \       if x % 2 != 0 {\n                x /= 2;\n            } else {\n     \
    \           n /= 2;\n            }\n        } else {\n            x = (x * (x\
    \ % 2)) / 2;\n            n /= 2;\n        }\n    }\n    if x == 1 {\n       \
    \ return true;\n    }\n    if x != 1 {\n        return false;\n    }\n    return\
    \ true;\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_power_of_two` in this scope\n  -->\
    \ /tmp/tmpd2imrzvx.rs:25:12\n   |\n25 |         if is_power_of_two(x) {\n   |\
    \            ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ function `is_power_of_two` in this scope\n  --> /tmp/tmpd2imrzvx.rs:33:16\n\
    \   |\n33 |         return is_power_of_two(x);\n   |                ^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if n < 1 {\n        return false;\n    }\n    let mut counter\
    \ = 1;\n    while counter < n {\n        if x * counter != x {\n            return\
    \ false;\n        }\n        counter += 1;\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpbn07g4y1.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if n == 0 {\n        return false;\n    }\n    if n == 1 {\n\
    \        return true;\n    }\n\n    // find m such that m**int == x\n    let mut\
    \ int_part = x as isize;\n    let mut m_div: isize = n;\n    let mut n_div: isize\
    \ = n;\n    let mut remainder: isize = x;\n    loop {\n        let n_div = remainder;\n\
    \        remainder = remainder % m_div;\n        int_part = int_part / m_div;\n\
    \        if int_part == 0 {\n            if n_div == 0 {\n                return\
    \ true;\n            }\n            break;\n        }\n        m_div = n_div;\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n  \
    \  assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmps1yzeykx.rs:52:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: -1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    let mut a = x;\n    let mut b = n;\n    while a > 0 {\n     \
    \   let t = b / a;\n        a = a - t * a;\n        b = t;\n    }\n    if n ==\
    \ 1 {\n        a == 1\n    } else {\n        a != n\n    }\n}\n\nfn main() {\n\
    \    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976129
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if n < 3 {\n        return false;\n    }\n\n    if n == 1 {\n\
    \        return true;\n    }\n\n    if x == 1 {\n        return true;\n    }\n\
    \n    if x == n {\n        return true;\n    }\n\n    if n == x {\n        return\
    \ true;\n    }\n\n    if n % x == 0 {\n        return false;\n    }\n\n    if\
    \ n % x == 1 {\n        return true;\n    }\n\n    if n % x == n / x {\n     \
    \   return true;\n    }\n\n    let mut m = n;\n    while m >= x {\n        m -=\
    \ x;\n    }\n    if x == m {\n        return true;\n    }\n\n    return false;\n\
    }\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpoh1mxd4p.rs:63:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    if x < n && (n\
    \ ** int(x) == x) {\n        return true;\n    }\n    if x > n && (n ** int(x)\
    \ - 1) == x {\n        return true;\n    }\n    if n > x && x < n && (n ** int(x)\
    \ - 1) == x {\n        return true;\n    }\n    if n == x {\n        return true;\n\
    \    }\n    return false;\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `int` in this scope\n  --> /tmp/tmpbd1x3q5y.rs:21:23\n\
    \   |\n21 |     if x < n && (n ** int(x) == x) {\n   |                       ^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `int` in this\
    \ scope\n  --> /tmp/tmpbd1x3q5y.rs:24:23\n   |\n24 |     if x > n && (n ** int(x)\
    \ - 1) == x {\n   |                       ^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `int` in this scope\n  --> /tmp/tmpbd1x3q5y.rs:27:32\n\
    \   |\n27 |     if n > x && x < n && (n ** int(x) - 1) == x {\n   |          \
    \                      ^^^ not found in this scope\n\nerror: aborting due to 3\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut x: isize\
    \ = x;\n    let mut n: isize = n;\n\n    while n % x == 0 {\n        x = x / n;\n\
    \        n = n + 1;\n    }\n\n    if x == n {\n        return true;\n    }\n \
    \   return false;\n}\n\nfn main() {\n    let candidate = is_simple_power;\n  \
    \  assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpqius22v6.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    let x: isize = x as isize;\n    let n: isize = n as isize;\n\
    \    if x == 1 {\n        return true;\n    }\n    if n % 2 == 0 {\n        return\
    \ false;\n    }\n    if x < n {\n        return false;\n    }\n    if x == n {\n\
    \        return true;\n    }\n    if n <= x {\n        return false;\n    }\n\
    \    let mut i = x;\n    while i > n {\n        i /= 2;\n    }\n    let mut rest\
    \ = x;\n    while rest > 1 {\n        rest /= 2;\n    }\n    if rest == 1 {\n\
    \        return false;\n    }\n    if rest % 2 == 0 {\n        return false;\n\
    \    }\n    for k in 1..(x - 1) {\n        if rest % k == 0 {\n            return\
    \ false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp800_fvm7.rs:59:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    let mut x: isize = x;\n    while n != 1 {\n        if n & 1 ==\
    \ 1 {\n            x >>= 1;\n            n >>= 1;\n        } else if n == 1 {\n\
    \            return true;\n        }\n        n >>= 1;\n    }\n    return false;\n\
    }\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: SyntaxError
  stderr: "warning: variable `x` is assigned to, but never used\n  --> /tmp/tmpnhqnxb54.rs:18:13\n\
    \   |\n18 |     let mut x: isize = x;\n   |             ^\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n   = note: consider using `_x` instead\n\nerror[E0384]: cannot\
    \ assign to immutable argument `n`\n  --> /tmp/tmpnhqnxb54.rs:22:13\n   |\n17\
    \ | fn is_simple_power(x: isize, n: isize) -> bool {\n   |                   \
    \           - help: consider making this binding mutable: `mut n`\n...\n22 | \
    \            n >>= 1;\n   |             ^^^^^^^ cannot assign to immutable argument\n\
    \nerror[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpnhqnxb54.rs:26:9\n\
    \   |\n17 | fn is_simple_power(x: isize, n: isize) -> bool {\n   |           \
    \                   - help: consider making this binding mutable: `mut n`\n...\n\
    26 |         n >>= 1;\n   |         ^^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to 2 previous errors; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if n == 1 {\n        return true;\n    }\n    if n == 0 {\n \
    \       return false;\n    }\n\n    // return false for even n\n    if n % 2 ==\
    \ 0 {\n        return false;\n    }\n    // return true if n is a power of two\n\
    \    if n == 1 || n == 2 {\n        return true;\n    }\n\n    let mut k = n;\n\
    \    while k > 1 {\n        if k&1 == 0 {\n            return false;\n       \
    \ }\n        k >>= 1;\n    }\n\n    let mut j = 1;\n    while j*j<=n {\n     \
    \   if x%j == 0 {\n            return false;\n        }\n        j += 1;\n   \
    \ }\n    return true;\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmph0v1nutj.rs:54:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    (1u64 << n).checked_shl(x).is_power_of_two()\n}\n\nfn main()\
    \ {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpni3ceyph.rs:18:29\n   |\n\
    18 |     (1u64 << n).checked_shl(x).is_power_of_two()\n   |                  \
    \           ^ expected `u32`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `u32` and panic if the converted value doesn't fit\n   |\n18 |     (1u64\
    \ << n).checked_shl(x.try_into().unwrap()).is_power_of_two()\n   |           \
    \                   ++++++++++++++++++++\n\nerror[E0599]: no method named `is_power_of_two`\
    \ found for enum `Option` in the current scope\n  --> /tmp/tmpni3ceyph.rs:18:32\n\
    \   |\n18 |     (1u64 << n).checked_shl(x).is_power_of_two()\n   |           \
    \                     ^^^^^^^^^^^^^^^ method not found in `Option<u64>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    let mut acc = 1;\n    for i in 1..n {\n        acc *= x;\n  \
    \      acc %= i;\n    }\n    acc == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmprn3pwtlx.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    let mut acc = 1;\n    for i in 1..n {\n        if i * acc ==\
    \ x {\n            return true;\n        }\n        acc += 1;\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpu7_xzn_o.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    let y = n * x;\n    let q = y;\n    while q > 1 {\n        q\
    \ = q / n;\n    }\n    y == q\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign twice to immutable variable `q`\n  --> /tmp/tmpthjtxr9u.rs:21:9\n\
    \   |\n19 |     let q = y;\n   |         -\n   |         |\n   |         first\
    \ assignment to `q`\n   |         help: consider making this binding mutable:\
    \ `mut q`\n20 |     while q > 1 {\n21 |         q = q / n;\n   |         ^^^^^^^^^\
    \ cannot assign twice to immutable variable\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if n == 0 {\n        return true;\n    }\n    if n == 1 {\n \
    \       if x%2 == 0 {\n            return true;\n        }\n        return false;\n\
    \    }\n    if n % 2 == 0 {\n        return is_simple_power(x, n/2);\n    }\n\
    \    let mut p = n;\n    while p > 1 {\n        if p % 2 == 0 {\n            return\
    \ is_simple_power(x, n/2);\n        }\n        p /= 2;\n    }\n    if p % 2 ==\
    \ 0 {\n        return true;\n    }\n    return false;\n}\n\nfn main() {\n    let\
    \ candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpaks23rzg.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    (n*n).is_power_of_two() == x\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmpdh0g36zz.rs:18:11\n   |\n18 |     (n*n).is_power_of_two()\
    \ == x\n   |           ^^^^^^^^^^^^^^^ method not found in `isize`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    (n % x) == 0 && is_pow_of_n(n * x, n)\n}\n\nfn main() {\n   \
    \ let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_pow_of_n` in this scope\n  --> /tmp/tmpf94qs95w.rs:18:21\n\
    \   |\n18 |     (n % x) == 0 && is_pow_of_n(n * x, n)\n   |                  \
    \   ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    let mut x = x;\n    let mut n = n;\n    let mut cnt = 0;\n\n\
    \    while n > 1 {\n        if n % 2 == 0 {\n            n /= 2;\n           \
    \ cnt += 1;\n        }\n        else {\n            n = n / 2;\n            cnt\
    \ += 1;\n        }\n    }\n\n    x == n\n}\n\nfn main() {\n    let candidate =\
    \ is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp375wppx1.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    let s = pow(x, n);\n    s == x\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `pow` in this scope\n  --> /tmp/tmpikv0i85_.rs:18:13\n\
    \   |\n18 |     let s = pow(x, n);\n   |             ^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    let x = x.abs();\n    let n = n.abs();\n    if n < x {\n    \
    \    return false;\n    }\n    if n == 1 {\n        return true;\n    }\n    if\
    \ n % 2 != 0 {\n        return false;\n    }\n    if x == n {\n        return\
    \ true;\n    }\n    if x < n {\n        return false;\n    }\n    let mut x: isize\
    \ = 1;\n    let mut y: isize = 1;\n    while x * y <= n {\n        x <<= 1;\n\
    \        y <<= 1;\n    }\n    if x != n {\n        return false;\n    }\n    fn\
    \ f(x: isize) -> bool {\n        x.pow(2) != x\n    }\n    if !f(y) {\n      \
    \  return false;\n    }\n    f(y)\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmplhoxnn2c.rs:55:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    (x * n).is_power_of_two()\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmp1275sbn5.rs:18:13\n   |\n18 |     (x * n).is_power_of_two()\n\
    \   |             ^^^^^^^^^^^^^^^ method not found in `isize`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    n % x == 0\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpeyabfebv.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    x < n && x == n ** x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpl9h_28sk.rs:18:22\n\
    \   |\n18 |     x < n && x == n ** x\n   |                      ^^^\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    // TODO: write your code here\n    let mut result = false;\n\
    \    if n&1 == 1 {\n        result = true;\n    } else {\n        if x > n {\n\
    \            return false;\n        }\n        let mut x = 1;\n        while x\
    \ <= n {\n            if x&1 == 1 {\n                result = true;\n        \
    \        break;\n            }\n            x = x * 2;\n        }\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp_3mom6e3.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    // TODO: Use the pow() function\n    if n == 1 {\n        return\
    \ true\n    }\n    if x == 0 || n == 1 {\n        return false\n    }\n    let\
    \ mut i = 1;\n    while i <= n {\n        let temp = x;\n        x = n * (x -\
    \ temp);\n        i += 1;\n    }\n    if x != 0 {\n        return false\n    }\n\
    \    return true\n}\n\nfn main() {\n    let candidate = is_simple_power;\n   \
    \ assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16), false);\n\
    \    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9, 3), true);\n\
    \    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24, 2), false);\n\
    \    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12, 6), false);\n\
    \    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1, 12), true);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `x`\n  --> /tmp/tmpasuflepy.rs:28:9\n\
    \   |\n17 | fn is_simple_power(x: isize, n: isize) -> bool {\n   |           \
    \         - help: consider making this binding mutable: `mut x`\n...\n28 |   \
    \      x = n * (x - temp);\n   |         ^^^^^^^^^^^^^^^^^^ cannot assign to immutable\
    \ argument\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    (n % x) == (x * (n - x))\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmprbstwrqf.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    n > 1 && n % x == 0\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpr8u00btx.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    match pow(x, n) {\n        1 => true,\n        _ => false,\n\
    \    }\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `pow` in this scope\n  --> /tmp/tmprq694d55.rs:18:11\n\
    \   |\n18 |     match pow(x, n) {\n   |           ^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    // Your code here\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpom5q2w6z.rs:17:43\n   |\n\
    17 | fn is_simple_power(x: isize, n: isize) -> bool {\n   |    ---------------\
    \                        ^^^^ expected `bool`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    (1u as isize).pow(n as isize) == x\n}\n\nfn main() {\n    let\
    \ candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: SyntaxError
  stderr: "error: invalid suffix `u` for number literal\n  --> /tmp/tmpxsmzfae_.rs:18:6\n\
    \   |\n18 |     (1u as isize).pow(n as isize) == x\n   |      ^^ invalid suffix\
    \ `u`\n   |\n   = help: the suffix must be one of the numeric types (`u32`, `isize`,\
    \ `f32`, etc.)\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    let x_pow = pow(x, n).unwrap();\n    if x_pow == x {\n      \
    \  return true;\n    }\n    else {\n        return false;\n    }\n}\n\nfn main()\
    \ {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `pow` in this scope\n  --> /tmp/tmpk228jacr.rs:18:17\n\
    \   |\n18 |     let x_pow = pow(x, n).unwrap();\n   |                 ^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if n < 0 {\n        return false\n    }\n    if x == 1 {\n  \
    \      return true\n    }\n    if n&1 == 0 {\n        return false;\n    }\n \
    \   if n == 1 {\n        return true;\n    }\n    let mut t = x;\n    let mut\
    \ b = false;\n    while t > 1 {\n        if t&1 == 1 {\n            return true;\n\
    \        }\n        t >>= 1;\n        if t != 1 {\n            b = true;\n   \
    \     }\n    }\n    b\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp_tg19mcg.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    let x = x as f64;\n    let n = n as f64;\n    if x == 1.0 &&\
    \ n == 1.0 {\n        return true;\n    }\n\n    let x_pow_n = (x as f64).powi(n);\n\
    \n    let max_precision = std::f64::MAX;\n    let x_pow_n = x_pow_n.max(max_precision);\n\
    \    if x_pow_n == 0.0 {\n        return false;\n    }\n\n    let x_pow_n = x_pow_n.min(max_precision);\n\
    \    if x_pow_n == 0.0 {\n        return false;\n    }\n\n    if x_pow_n != x\
    \ {\n        return false;\n    }\n\n    if n == 1.0 {\n        return true;\n\
    \    }\n\n    if n == 0.0 {\n        return false;\n    }\n\n    let exp = n as\
    \ isize;\n    if exp > x.len() {\n        return false;\n    }\n\n    let mut\
    \ y = 0.0;\n    for _ in 0..exp {\n        y = y.powi(x);\n    }\n    let x_pow_n\
    \ = x.powi(n);\n    if x_pow_n != y {\n        return false;\n    }\n\n    return\
    \ true;\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpie1lsg9a.rs:24:35\n   |\n\
    24 |     let x_pow_n = (x as f64).powi(n);\n   |                             \
    \      ^ expected `i32`, found `f64`\n\nerror[E0599]: no method named `len` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmpie1lsg9a.rs:50:16\n   |\n\
    50 |     if exp > x.len() {\n   |                ^^^ help: there is an associated\
    \ function with a similar name: `ln`\n\nerror[E0689]: can't call method `powi`\
    \ on ambiguous numeric type `{float}`\n  --> /tmp/tmpie1lsg9a.rs:56:15\n   |\n\
    56 |         y = y.powi(x);\n   |               ^^^^\n   |\nhelp: you must specify\
    \ a type for this binding, like `f32`\n   |\n54 |     let mut y: f32 = 0.0;\n\
    \   |         ~~~~~~~~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpie1lsg9a.rs:58:26\n\
    \   |\n58 |     let x_pow_n = x.powi(n);\n   |                          ^ expected\
    \ `i32`, found `f64`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599, E0689.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    (1..n).contains(&x) && x == (x ** n)\n}\n\nfn main() {\n    let\
    \ candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpp17c6ndq.rs:18:37\n\
    \   |\n18 |     (1..n).contains(&x) && x == (x ** n)\n   |                   \
    \                  ^^^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    let mut x = x * (n - 1);\n    while x <= n {\n        if x !=\
    \ x * x {\n            return false;\n        }\n        x = x + 1;\n    }\n \
    \   true\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmptyifpzuq.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    // TODO: implement your solution here\n    return true;\n}\n\n\
    fn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpvd45jjel.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if n % x == 0 {\n        true\n    } else {\n        false\n\
    \    }\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpojuvj7vt.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if n < 2 {\n        return false;\n    }\n\n    if x == 1 {\n\
    \        return true;\n    }\n\n    let mut y = x;\n    while y % n == 0 {\n \
    \       y /= n;\n    }\n\n    // if y is now a power of n then x is not a simple\
    \ power of n\n    return y != 1;\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp9u8c5u1o.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x < 1 {\n        return false;\n    }\n    if x <= n {\n \
    \       return true;\n    }\n    for d in 0..(x-1).min(n as isize).min(n as isize)\
    \ {\n        if x % d == 0 {\n            return false;\n        }\n    }\n  \
    \  return true;\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpgsjj_m1x.rs:25:12

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976125
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if n == 1 {\n        return true;\n    }\n\n    if n == 0 {\n\
    \        return false;\n    }\n\n    // return true if n**int = x or if x is a\
    \ power of n\n    match n % x {\n        0 => n % x == 0,\n        _ => false,\n\
    \    }\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpbia6693c.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    use std::cmp::Ordering;\n    (0..n).any(|i| {\n        let x:\
    \ u64 = i as u64;\n        let n: u64 = n as u64;\n        (x / (n * n)).is_eq(x)\n\
    \    })\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: SyntaxError
  stderr: "warning: unused import: `std::cmp::Ordering`\n  --> /tmp/tmp0xqxo8t4.rs:18:9\n\
    \   |\n18 |     use std::cmp::Ordering;\n   |         ^^^^^^^^^^^^^^^^^^\n   |\n\
    \   = note: `#[warn(unused_imports)]` on by default\n\nerror[E0599]: no method\
    \ named `is_eq` found for type `u64` in the current scope\n  --> /tmp/tmp0xqxo8t4.rs:22:23\n\
    \   |\n22 |         (x / (n * n)).is_eq(x)\n   |                       ^^^^^ method\
    \ not found in `u64`\n\nerror: aborting due to previous error; 1 warning emitted\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    match x {\n        1 => true,\n        x if x < n => true,\n\
    \        _ => false,\n    }\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpjgwduo83.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if is_power_of_2(n) == true {\n        return is_power_of_2(x);\n\
    \    }\n    else {\n        let mut result = is_power_of_2(x * n);\n        if\
    \ result == true {\n            return true;\n        }\n        else {\n    \
    \        return false;\n        }\n    }\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_power_of_2` in this scope\n  -->\
    \ /tmp/tmpomz863q9.rs:18:8\n   |\n18 |     if is_power_of_2(n) == true {\n   |\
    \        ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `is_power_of_2` in this scope\n  --> /tmp/tmpomz863q9.rs:19:16\n   |\n19 | \
    \        return is_power_of_2(x);\n   |                ^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `is_power_of_2` in this\
    \ scope\n  --> /tmp/tmpomz863q9.rs:22:26\n   |\n22 |         let mut result =\
    \ is_power_of_2(x * n);\n   |                          ^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == n {\n        return true;\n    }\n\n    if x < n {\n\
    \        return false;\n    }\n\n    if x == n {\n        return true;\n    }\n\
    \n    if x > n {\n        return false;\n    }\n\n    if x == 1 {\n        if\
    \ n == 1 {\n            return true;\n        }\n        return false;\n    }\n\
    \n    if n == 1 {\n        return false;\n    }\n\n    if x == 2 {\n        return\
    \ true;\n    }\n\n    if n == 2 {\n        return false;\n    }\n\n    if x ==\
    \ 3 {\n        return true;\n    }\n\n    if n == 3 {\n        return false;\n\
    \    }\n\n    if x == 4 {\n        return true;\n    }\n\n    if n == 4 {\n  \
    \      return true;\n    }\n\n    if x == 5 {\n        if n == 5 {\n         \
    \   return true;\n        }\n        return false;\n    }\n\n    if n == 5 {\n\
    \        return false;\n    }\n\n    if x == 6 {\n        return true;\n    }\n\
    \n    if n == 6 {\n        return false;\n    }\n\n    if x == 7 {\n        return\
    \ true;\n    }\n\n    if n == 7 {\n        return false;\n    }\n\n    if x ==\
    \ 8 {\n        return true;\n    }\n\n    if n == 8 {\n        return false;\n\
    \    }\n\n    if x == 9 {\n        return true;\n    }\n\n    if n == 9 {\n  \
    \      return false;\n    }\n\n    if x == 10 {\n        return true;\n    }\n\
    \n    if n == 10 {\n        return false;\n    }\n\n    if x == 11 {\n       \
    \ return true;\n    }\n\n    if n == 11 {\n        return false;\n    }\n\n  \
    \  if x == 12 {\n        return true;\n    }\n\n    if n == 12 {\n        return\
    \ false;\n    }\n\n    if x == 13 {\n        return true;\n    }\n\n    if n ==\
    \ 13 {\n        return false;\n    }\n\n    if x == 14 {\n        return true;\n\
    \    }\n\n    if n == 14 {\n        return false;\n    }\n\n    if x == 15 {\n\
    \        return true;\n    }\n\n    if n == 15 {\n        return false;\n    }\n\
    \n    if x == 16 {\n        return true;\n    }\n\n    if n == 16 {\n        return\
    \ false;\n    }\n\n    if x == 17 {\n        return true;\n    }\n\n    if n ==\
    \ 17 {\n        return false;\n    }\n\n    if x == 18 {\n        return true;\n\
    \    }\n\n    if n == 18 {\n        return false;\n    }\n\n    if x == 19 {\n\
    \        return true;\n    }\n\n    if n == 19 {\n        return false;\n    }\n\
    \n    if x == 20 {\n        return true;\n    }\n\n    if n == 20 {\n        return\
    \ false;\n    }\n\n    if x == 21 {\n        return true;\n    }\n\n    if n ==\
    \ 21 {\n        return false;\n    }\n\n    if x == 22 {\n        return true;\n\
    \    }\n\n    if n == 22 {\n        return false;\n    }\n\n    if x == 23 {\n\
    \        return true;\n    }\n\n    if n == 23 {\n        return false;\n    }\n\
    \n    if x == 24 {\n        return true;\n    }\n\n    if n == 24 {\n        return\
    \ false;\n    }\n\n    if x == 25 {\n        return true;\n    }\n\n    if n ==\
    \ 25 {\n        return false;\n    }\n\n    if x == 26 {\n        return true;\n\
    \    }\n\n    if n == 26 {\n        return false;\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmppyxsy7lw.rs:260:3\n\
    \    |\n17  | fn is_simple_power(x: isize, n: isize) -> bool {\n    |        \
    \                                        - unclosed delimiter\n...\n244 |    \
    \ if n == 26 {\n    |                - this delimiter might not be properly closed...\n\
    245 |         return false;\n246 | }\n    | - ...as it matches this but it has\
    \ different indentation\n...\n260 | }\n    |   ^\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmppyxsy7lw.rs:17:43\n   |\n17 | fn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n   |    ---------------                        ^^^^ expected `bool`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    let mut power_of_n = pow(x, n);\n    power_of_n /= x;\n    power_of_n\
    \ == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `pow` in this scope\n  --> /tmp/tmpfb4mtlbo.rs:18:26\n\
    \   |\n18 |     let mut power_of_n = pow(x, n);\n   |                        \
    \  ^^^ not found in this scope\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    x != 0 && n % x == 0 && n / x > 1\n}\n\nfn main() {\n    let\
    \ candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp7qgajbpk.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    x.is_power_of_two() && x.bits() == n.bits()\n}\n\nfn main() {\n\
    \    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmpyypmpijb.rs:18:7\n   |\n18 |     x.is_power_of_two()\
    \ && x.bits() == n.bits()\n   |       ^^^^^^^^^^^^^^^ method not found in `isize`\n\
    \nerror[E0599]: no method named `bits` found for type `isize` in the current scope\n\
    \  --> /tmp/tmpyypmpijb.rs:18:30\n   |\n18 |     x.is_power_of_two() && x.bits()\
    \ == n.bits()\n   |                              ^^^^ method not found in `isize`\n\
    \nerror[E0599]: no method named `bits` found for type `isize` in the current scope\n\
    \  --> /tmp/tmpyypmpijb.rs:18:42\n   |\n18 |     x.is_power_of_two() && x.bits()\
    \ == n.bits()\n   |                                          ^^^^ method not found\
    \ in `isize`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    pow(x, n, n) == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `pow` in this scope\n  --> /tmp/tmp4yvjpxuy.rs:18:5\n\
    \   |\n18 |     pow(x, n, n) == x\n   |     ^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    x.pow(n) == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_mkybdva.rs:18:11\n   |\n\
    18 |     x.pow(n) == x\n   |           ^ expected `u32`, found `isize`\n   |\n\
    help: you can convert an `isize` to a `u32` and panic if the converted value doesn't\
    \ fit\n   |\n18 |     x.pow(n.try_into().unwrap()) == x\n   |            ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    n <= 0 || n % x == 0\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp29eoaw9z.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if n ** int == x {\n        true\n    } else {\n        false\n\
    \    }\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `int` in this scope\n  --> /tmp/tmpputi3oix.rs:18:13\n\
    \   |\n18 |     if n ** int == x {\n   |             ^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if n == 1 {\n        true\n    } else if n != x {\n        false\n\
    \    } else {\n        n - 1\n    }\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjwagkklg.rs:23:9\n   |\n\
    17 | fn is_simple_power(x: isize, n: isize) -> bool {\n   |                  \
    \                         ---- expected `bool` because of return type\n...\n23\
    \ |         n - 1\n   |         ^^^^^ expected `bool`, found `isize`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    match n % x {\n        0 => n == x,\n        n => n % x == 0,\n\
    \    }\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp89ydes2j.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    // TODO: replace this by an iterative solution\n    let mut i\
    \ = 0;\n    while i < n {\n        if x ** i == x {\n            return true;\n\
    \        }\n        i += 1;\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmp0tu3ki93.rs:21:15\n\
    \   |\n21 |         if x ** i == x {\n   |               ^^^\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0614`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    x <= n && x > 1\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpxowj5i15.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    x % n == 0 && x != n\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpknqdwi45.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    (x == 1) || (n == 1) || (n % x == 0)\n}\n\nfn main() {\n    let\
    \ candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpxg4wawe_.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    match n {\n        0 => false,\n        _ => x >= n * n,\n  \
    \  }\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpqt4e1ucy.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    x > 0 && n == 1 && n % x == 0\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmprb4a6qe3.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    x > n || x < 1\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0br6mnzw.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if n == 0 {\n        return false;\n    }\n\n    if n == 1 {\n\
    \        return true;\n    }\n\n    if n % 2 == 0 {\n        return (is_simple_power(x,\
    \ n / 2) || is_simple_power(x, (n - 1) / 2));\n    } else {\n        return (is_simple_power(x,\
    \ n / 2) && is_simple_power(x, (n - 1) / 2));\n    }\n}\n\nfn main() {\n    let\
    \ candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpvywb8u3_.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if n <= 0 {\n        return false;\n    }\n\n    if x <= n {\n\
    \        return n == 1;\n    }\n\n    x <= n\n        && (n % x == 0)\n      \
    \  && (n / x == n) as bool\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp0czdamdt.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if n == 1 {\n        return true;\n    }\n\n    if x == 0 ||\
    \ x == 1 {\n        return true;\n    }\n\n    if n % x == 0 {\n        loop {\n\
    \            let y = n / x;\n            if n%x == 0 {\n                return\
    \ true;\n            }\n            n = y;\n        }\n    }\n\n    return false;\n\
    }\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmph7l3o5fb.rs:32:13\n\
    \   |\n17 | fn is_simple_power(x: isize, n: isize) -> bool {\n   |           \
    \                   - help: consider making this binding mutable: `mut n`\n...\n\
    32 |             n = y;\n   |             ^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == n {\n        true\n    } else {\n        if n % x ==\
    \ 0 {\n            false\n        } else {\n            true\n        }\n    }\n\
    }\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpmz0_5pnz.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if n == 0 { true }\n    if n % 2 == 1 { false }\n\n    let mut\
    \ x = x;\n    while x > 1 { x /= 2; }\n\n    x % n == 0\n}\n\nfn main() {\n  \
    \  let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0hs8cf4o.rs:18:17\n   |\n\
    18 |     if n == 0 { true }\n   |     ------------^^^^--\n   |     |         \
    \  |\n   |     |           expected `()`, found `bool`\n   |     expected this\
    \ to be `()`\n   |\nhelp: you might have meant to return this value\n   |\n18\
    \ |     if n == 0 { return true; }\n   |                 ++++++     +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp0hs8cf4o.rs:19:21\n   |\n19 |     if n % 2 ==\
    \ 1 { false }\n   |     ----------------^^^^^--\n   |     |               |\n\
    \   |     |               expected `()`, found `bool`\n   |     expected this\
    \ to be `()`\n   |\nhelp: you might have meant to return this value\n   |\n19\
    \ |     if n % 2 == 1 { return false; }\n   |                     ++++++     \
    \ +\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    let mut x = x.checked_mul(n.checked_pow(n as usize));\n    if\
    \ x == x.checked_mul(x as u64) {\n        true\n    } else {\n        false\n\
    \    }\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpp9csqg9r.rs:18:45\n   |\n\
    18 |     let mut x = x.checked_mul(n.checked_pow(n as usize));\n   |         \
    \                                    ^^^^^^^^^^ expected `u32`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to a `u32` and panic if the converted value\
    \ doesn't fit\n   |\n18 |     let mut x = x.checked_mul(n.checked_pow((n as usize).try_into().unwrap()));\n\
    \   |                                             +          +++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpp9csqg9r.rs:18:31\n   |\n18 |\
    \     let mut x = x.checked_mul(n.checked_pow(n as usize));\n   |            \
    \                   ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected type `isize`\n              found enum `Option<isize>`\n\
    \nerror[E0599]: no method named `checked_mul` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmpp9csqg9r.rs:19:15\n   |\n19 |     if x == x.checked_mul(x\
    \ as u64) {\n   |               ^^^^^^^^^^^ method not found in `Option<isize>`\n\
    \nerror[E0605]: non-primitive cast: `Option<isize>` as `u64`\n  --> /tmp/tmpp9csqg9r.rs:19:27\n\
    \   |\n19 |     if x == x.checked_mul(x as u64) {\n   |                      \
    \     ^^^^^^^^ an `as` expression can only be used to convert between primitive\
    \ types or to coerce to a specific trait object\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599, E0605.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    let x = f64::pow(x, n);\n    x == x\n}\n\nfn main() {\n    let\
    \ candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no function or associated item named `pow` found for type\
    \ `f64` in the current scope\n  --> /tmp/tmpieq8wb6c.rs:18:18\n   |\n18 |    \
    \ let x = f64::pow(x, n);\n   |                  ^^^\n   |                  |\n\
    \   |                  function or associated item not found in `f64`\n   |  \
    \                help: there is an associated function with a similar name: `powf`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return n == 1;\n    }\n\n    let mut acc\
    \ = x;\n    while n > 1 {\n        if n & 1 == 0 {\n            acc *= acc;\n\
    \        }\n        acc /= n;\n        n /= 2;\n    }\n    acc == x\n}\n\nfn main()\
    \ {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpliy3_28n.rs:28:9\n\
    \   |\n17 | fn is_simple_power(x: isize, n: isize) -> bool {\n   |           \
    \                   - help: consider making this binding mutable: `mut n`\n...\n\
    28 |         n /= 2;\n   |         ^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    x <= 1 ||\n    (n % x == 0) &&\n    (n % x == 1)\n}\n\nfn main()\
    \ {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpo4ceo2z6.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x <= 1 || n <= 1 {\n        return false;\n    }\n    let\
    \ y = pow(x, n);\n    y == x || is_simple_power(y, n - 1)\n}\n\nfn main() {\n\
    \    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `pow` in this scope\n  --> /tmp/tmpgutlvdw1.rs:21:13\n\
    \   |\n21 |     let y = pow(x, n);\n   |             ^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    (x**n) == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmp9rb0p9c0.rs:18:8\n\
    \   |\n18 |     (x**n) == x\n   |        ^^\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    let a = pow(x, n);\n    pow(a, n - 1) >= x && (a % x == 0)\n\
    }\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `pow` in this scope\n  --> /tmp/tmp52jmbmuc.rs:18:13\n\
    \   |\n18 |     let a = pow(x, n);\n   |             ^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `pow` in this scope\n  --> /tmp/tmp52jmbmuc.rs:19:5\n\
    \   |\n19 |     pow(a, n - 1) >= x && (a % x == 0)\n   |     ^^^ not found in\
    \ this scope\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    x <= 0 || n ** x == x\n}\n\nfn main() {\n    let candidate =\
    \ is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpj_3efsry.rs:18:18\n\
    \   |\n18 |     x <= 0 || n ** x == x\n   |                  ^^^\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0614`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    n % x == 0\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpeyabfebv.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if n == 1 {\n        return true;\n    }\n    if x % n == 0 {\n\
    \        return is_simple_power(x / n, n);\n    }\n    return false;\n}\n\nfn\
    \ main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp9hadsnnu.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    let mut pow = 0;\n    while n != 0 {\n        pow = pow * n;\n\
    \        n /= 2;\n    }\n    pow = pow * x;\n    pow == x\n}\n\nfn main() {\n\
    \    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpgsjxhsvv.rs:21:9\n\
    \   |\n17 | fn is_simple_power(x: isize, n: isize) -> bool {\n   |           \
    \                   - help: consider making this binding mutable: `mut n`\n...\n\
    21 |         n /= 2;\n   |         ^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    // Solution is easy\n    if x == 1 {\n        return true;\n\
    \    }\n\n    // check if n is power of x, if not, return false\n    // n**int\
    \ < x\n    if n == x {\n        return true;\n    }\n\n    if n % x == 0 {\n \
    \       return is_simple_power(x, n / x);\n    }\n\n    // if n is not power of\
    \ x, return false\n    // n**int > x\n    return false\n}\n\nfn main() {\n   \
    \ let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpx7eag6_4.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    match n % x {\n        0 => n == 0,\n        _ => false,\n  \
    \  }\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpxuqp6i5g.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    let mut pow: isize = 1;\n    while pow < n {\n        if pow\
    \ % x == 0 {\n            return false;\n        }\n        pow += 1;\n    }\n\
    \    true\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp6cevj8q1.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    pow(x, n) == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `pow` in this scope\n  --> /tmp/tmpqdks7xgn.rs:18:5\n\
    \   |\n18 |     pow(x, n) == x\n   |     ^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    if x == 0 {\n \
    \       return false;\n    }\n    let x_div_2 = x / 2;\n    if n == 1 { //1**int\
    \ = 1\n        return true;\n    }\n    if n == 0 { //0**int = 0\n        return\
    \ false;\n    }\n    if n >= x_div_2 {\n        return is_simple_power(x_div_2,\
    \ n);\n    }\n    return is_simple_power(x, n / 2) && is_simple_power(x_div_2,\
    \ n / 2);\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp3466yxha.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    match n {\n        0 => false,\n        1 => x == 1,\n      \
    \  2 => x == 1,\n        n if n % 2 == 1 => x == n * x,\n        n => false\n\
    \    }\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpxsviq3z4.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    x <= n && n == (std::ipow(n, x) % n) == x\n}\n\nfn main() {\n\
    \    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: SyntaxError
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmpdxa8ss6e.rs:18:17\n\
    \   |\n18 |     x <= n && n == (std::ipow(n, x) % n) == x\n   |              \
    \   ^^                       ^^\n   |\nhelp: split the comparison into two\n \
    \  |\n18 |     x <= n && n == (std::ipow(n, x) % n) && (std::ipow(n, x) % n) ==\
    \ x\n   |                                          ++++++++++++++++++++++++\n\n\
    error[E0425]: cannot find function `ipow` in crate `std`\n  --> /tmp/tmpdxa8ss6e.rs:18:26\n\
    \   |\n18 |     x <= n && n == (std::ipow(n, x) % n) == x\n   |              \
    \            ^^^^ not found in `std`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpdxa8ss6e.rs:18:45\n   |\n18 |     x <= n && n == (std::ipow(n, x) %\
    \ n) == x\n   |                                             ^ expected `bool`,\
    \ found `isize`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0425.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    (1u64 << n).is_power_of_2()\n        && (x & ((1u64 << n) - 1))\
    \ == 0\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_power_of_2` found for type `u64` in the\
    \ current scope\n  --> /tmp/tmplyo_n_c3.rs:18:17\n   |\n18 |     (1u64 << n).is_power_of_2()\n\
    \   |                 ^^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `is_power_of_two`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplyo_n_c3.rs:19:17\n\
    \   |\n19 |         && (x & ((1u64 << n) - 1)) == 0\n   |                 ^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `u64`\n\nerror[E0277]: no implementation for `isize\
    \ & u64`\n  --> /tmp/tmplyo_n_c3.rs:19:15\n   |\n19 |         && (x & ((1u64 <<\
    \ n) - 1)) == 0\n   |               ^ no implementation for `isize & u64`\n  \
    \ |\n   = help: the trait `BitAnd<u64>` is not implemented for `isize`\n   = help:\
    \ the following other types implement trait `BitAnd<Rhs>`:\n             <&'a\
    \ i128 as BitAnd<i128>>\n             <&'a i16 as BitAnd<i16>>\n             <&'a\
    \ i32 as BitAnd<i32>>\n             <&'a i64 as BitAnd<i64>>\n             <&'a\
    \ i8 as BitAnd<i8>>\n             <&'a isize as BitAnd<isize>>\n             <&'a\
    \ u128 as BitAnd<u128>>\n             <&'a u16 as BitAnd<u16>>\n           and\
    \ 40 others\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x < n {\n        return false;\n    }\n\n    let mut result\
    \ = true;\n\n    for _ in 0..n-1 {\n        result = result && (x % n == 0);\n\
    \        x /= n;\n    }\n\n    result\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `x`\n  --> /tmp/tmpkxzt2rlj.rs:26:9\n\
    \   |\n17 | fn is_simple_power(x: isize, n: isize) -> bool {\n   |           \
    \         - help: consider making this binding mutable: `mut x`\n...\n26 |   \
    \      x /= n;\n   |         ^^^^^^ cannot assign to immutable argument\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if n == 0 { return true; }\n    if x == 0 { return false; }\n\
    \    if x == 1 { return true; }\n\n    if n <= x {\n        return is_simple_power(x,\
    \ n-1);\n    }\n\n    let mut i = 1;\n    let mut y = (x as f64 / (n as f64));\n\
    \    while i < n {\n        y = y*y;\n        i += 1;\n    }\n    if y == x {\n\
    \        return true;\n    }\n    else {\n        return false;\n    }\n}\n\n\
    fn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around assigned value\n  --> /tmp/tmp7o3iaowm.rs:27:17\n\
    \   |\n27 |     let mut y = (x as f64 / (n as f64));\n   |                 ^ \
    \                    ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\n\
    help: remove these parentheses\n   |\n27 -     let mut y = (x as f64 / (n as f64));\n\
    27 +     let mut y = x as f64 / (n as f64);\n   | \n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp7o3iaowm.rs:32:13\n   |\n32 |     if y == x {\n   |   \
    \          ^ expected `f64`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to an `f64`, producing the floating point representation of the integer, rounded\
    \ if necessary\n   |\n32 |     if y == x as f64 {\n   |               ++++++\n\
    \nerror: aborting due to previous error; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if is_power_of_two(n) {\n        let x: isize = n; // lvalue\
    \ reference to avoid type alias\n        (1u64 << (n as usize * 2)) == x\n   \
    \ } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_power_of_two` in this scope\n  -->\
    \ /tmp/tmpnfyqhwsl.rs:18:8\n   |\n18 |     if is_power_of_two(n) {\n   |     \
    \   ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpnfyqhwsl.rs:20:39\n   |\n20 |         (1u64 << (n as usize * 2))\
    \ == x\n   |                                       ^ expected `u64`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `u64` and panic if the converted\
    \ value doesn't fit\n   |\n20 |         (1u64 << (n as usize * 2)) == x.try_into().unwrap()\n\
    \   |                                        ++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    x.pow(n.trunc()).is_eq(x)\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `trunc` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpc5j74cwq.rs:18:13\n   |\n18 |     x.pow(n.trunc()).is_eq(x)\n\
    \   |             ^^^^^ method not found in `isize`\n\nerror[E0599]: no method\
    \ named `is_eq` found for type `isize` in the current scope\n  --> /tmp/tmpc5j74cwq.rs:18:22\n\
    \   |\n18 |     x.pow(n.trunc()).is_eq(x)\n   |                      ^^^^^ method\
    \ not found in `isize`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if is_power_of_n(x) {\n        return is_power_of_n(n);\n   \
    \ }\n    for i in 1..=n {\n        if x * i == x {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_power_of_n` in this scope\n  -->\
    \ /tmp/tmpvaz1ow70.rs:18:8\n   |\n18 |     if is_power_of_n(x) {\n   |       \
    \ ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `is_power_of_n` in this scope\n  --> /tmp/tmpvaz1ow70.rs:19:16\n   |\n19 | \
    \        return is_power_of_n(n);\n   |                ^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == n {\n        return true;\n    }\n\n    if x % n == 0\
    \ {\n        return is_simple_power(x, n-1);\n    }\n    return false;\n}\n\n\
    fn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmp2vytlqt1.rs:22:8

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976125
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    debug_assert!(n >= 1);\n    debug_assert!(n % 2 == 0);\n\n  \
    \  if n == 1 {\n        true\n    } else {\n        x * x == n\n    }\n}\n\nfn\
    \ main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmppi9a9wz9.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if n <= 0 {\n        return false;\n    }\n    if x == 1 {\n\
    \        return true;\n    }\n    if x == 2 {\n        return n == 2;\n    }\n\
    \    if n == 3 {\n        return x == 1;\n    }\n    if n == 4 {\n        return\
    \ x != 1;\n    }\n    if n % 2 == 0 {\n        return false;\n    }\n    if n\
    \ % 3 == 0 {\n        return is_simple_power(x, n / 3);\n    }\n    if n % 5 ==\
    \ 0 {\n        return is_simple_power(x, n / 5);\n    }\n    if n % 7 == 0 {\n\
    \        return false;\n    }\n    let mut sum = 0;\n    while n > 0 {\n     \
    \   sum += n % 10;\n        n = n / 10;\n    }\n    return x == sum;\n}\n\nfn\
    \ main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpnj230m4v.rs:48:9\n\
    \   |\n17 | fn is_simple_power(x: isize, n: isize) -> bool {\n   |           \
    \                   - help: consider making this binding mutable: `mut n`\n...\n\
    48 |         n = n / 10;\n   |         ^^^^^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    (1u64 << n).pow(x) == x\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3_vuyw49.rs:18:21\n   |\n\
    18 |     (1u64 << n).pow(x) == x\n   |                     ^ expected `u32`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `u32` and panic if the\
    \ converted value doesn't fit\n   |\n18 |     (1u64 << n).pow(x.try_into().unwrap())\
    \ == x\n   |                      ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp3_vuyw49.rs:18:27\n   |\n18 |     (1u64 << n).pow(x) ==\
    \ x\n   |                           ^ expected `u64`, found `isize`\n   |\nhelp:\
    \ you can convert an `isize` to a `u64` and panic if the converted value doesn't\
    \ fit\n   |\n18 |     (1u64 << n).pow(x) == x.try_into().unwrap()\n   |      \
    \                      ++++++++++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    x % n == 0\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpxxopd5r4.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    x.checked_pow_eq(n).is_ok()\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `checked_pow_eq` found for type `isize` in\
    \ the current scope\n  --> /tmp/tmpi43t72su.rs:18:7\n   |\n18 |     x.checked_pow_eq(n).is_ok()\n\
    \   |       ^^^^^^^^^^^^^^ help: there is an associated function with a similar\
    \ name: `checked_pow`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    let mut y = x as isize;\n    if n%y == 0 {\n        true\n  \
    \  } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmph9yau0vn.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if n == 1 {\n        true\n    } else {\n        x == n * (n\
    \ + 1)\n    }\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpws49zyfc.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    (1..=n).all(|i| x.pow(i) == x)\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2wbe78kk.rs:18:27\n   |\n\
    18 |     (1..=n).all(|i| x.pow(i) == x)\n   |                           ^ expected\
    \ `u32`, found `isize`\n   |\nhelp: you can convert an `isize` to a `u32` and\
    \ panic if the converted value doesn't fit\n   |\n18 |     (1..=n).all(|i| x.pow(i.try_into().unwrap())\
    \ == x)\n   |                            ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    // TODO: Your code here\n    \n    // assert!(n > 0);\n    //\
    \ assert!(n);\n    // assert!(x != 0);\n\n    // if n == 1 {\n    //     return\
    \ true;\n    // }\n\n    // if n & 1 == 1 {\n    //     return false;\n    //\
    \ }\n\n    // if x == 0 {\n    //     return false;\n    // }\n\n    // let mut\
    \ p = x;\n    // while p < n {\n    //     p <<= 1;\n    //     if p == n {\n\
    \    //         return true;\n    //     }\n    // }\n    \n    // return false;\n\
    \    \n    return true;\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpxyzhnd9e.rs:52:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    x <= n && n % x == 0\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp3dgwqeez.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    } else if n == 1 {\n \
    \       return false;\n    }\n\n    let mut counter = 0;\n    let mut result =\
    \ x;\n\n    while result == n {\n        result += x;\n        counter += 1;\n\
    \    }\n\n    if counter == 2 {\n        return true;\n    }\n\n    return false;\n\
    }\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp82uw_vzi.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    (1..=n).all(|i| is_power_of_2(x * i) && x == i ** (n - 1))\n\
    }\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_power_of_2` in this scope\n  -->\
    \ /tmp/tmpb7e6tpmg.rs:18:21\n   |\n18 |     (1..=n).all(|i| is_power_of_2(x *\
    \ i) && x == i ** (n - 1))\n   |                     ^^^^^^^^^^^^^ not found in\
    \ this scope\n\nerror[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpb7e6tpmg.rs:18:53\n\
    \   |\n18 |     (1..=n).all(|i| is_power_of_2(x * i) && x == i ** (n - 1))\n \
    \  |                                                     ^^^^^^^^^\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0425, E0614.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: -1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == n {\n        return true;\n    }\n    let mut p = 1;\n\
    \    while p <= n {\n        let q = p / n;\n        if q == x {\n           \
    \ return true;\n        }\n        if q > x {\n            return false;\n   \
    \     }\n        p = q;\n    }\n    return false;\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976130
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    let y = x * x;\n    if n == y {\n        return true;\n    }\n\
    \n    let z = n - y;\n    let x = z % n;\n    if x == 0 {\n        return true;\n\
    \    }\n    return false;\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpqmc3977t.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if n < 1 || n < x {\n        return false;\n    }\n    if n ==\
    \ 1 || x == 1 {\n        return true;\n    }\n    for _ in 0..x {\n        if\
    \ x % n == 0 {\n            return true;\n        }\n        n /= n;\n    }\n\
    \    return false;\n}\n\nfn main() {\n    let candidate = is_simple_power;\n \
    \   assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp2nr88b07.rs:28:9\n\
    \   |\n17 | fn is_simple_power(x: isize, n: isize) -> bool {\n   |           \
    \                   - help: consider making this binding mutable: `mut n`\n...\n\
    28 |         n /= n;\n   |         ^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if n == 0 || (x * n) != x {\n        return false;\n    }\n\n\
    \    let mut factor = 1;\n    let mut sum = 1;\n\n    while n > 1 {\n        factor\
    \ *= x;\n        sum += factor;\n        n /= x;\n    }\n\n    factor * (n ==\
    \ x)\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot multiply `isize` by `bool`\n  --> /tmp/tmpjfdraj0e.rs:31:12\n\
    \   |\n31 |     factor * (n == x)\n   |            ^ no implementation for `isize\
    \ * bool`\n   |\n   = help: the trait `Mul<bool>` is not implemented for `isize`\n\
    \   = help: the following other types implement trait `Mul<Rhs>`:\n          \
    \   <&'a f32 as Mul<f32>>\n             <&'a f64 as Mul<f64>>\n             <&'a\
    \ i128 as Mul<i128>>\n             <&'a i16 as Mul<i16>>\n             <&'a i32\
    \ as Mul<i32>>\n             <&'a i64 as Mul<i64>>\n             <&'a i8 as Mul<i8>>\n\
    \             <&'a isize as Mul<isize>>\n           and 49 others\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    x & (x - 1) != 0 && x != 0 && n % x == 0 && is_simple_power(x\
    \ / n, n) && n % x == 0\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpkr8vfk6f.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    debug_assert!(n > 1);\n\n    if n == 1 {\n        true\n    }\
    \ else if x == 1 {\n        false\n    } else if x < n {\n        n % x == 0\n\
    \    } else {\n        n % x == 0\n    }\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpto5wtn22.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    x <= 1 || (x==1 && n==0)\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpzue00ng5.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if n == 0 {\n        return true\n    }\n    if x < n {\n   \
    \     return false\n    }\n    if n == 1 {\n        return x == 1 && n % 2 ==\
    \ 0\n    }\n    if n == 2 {\n        return x == 1 && x == 2 && n % 2 == 0\n \
    \   }\n    if n % 2 == 0 {\n        if x == 1 {\n            return false\n  \
    \      }\n        if x == n {\n            return true\n        }\n    }\n   \
    \ if x == n {\n        return true\n    }\n    if n % 2 == 1 {\n        x /= 2\n\
    \    }\n    if is_simple_power(x, n - 1) && is_simple_power(x, n) {\n        return\
    \ true\n    }\n    return false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `x`\n  --> /tmp/tmp390my3v9.rs:42:9\n\
    \   |\n17 | fn is_simple_power(x: isize, n: isize) -> bool {\n   |           \
    \         - help: consider making this binding mutable: `mut x`\n...\n42 |   \
    \      x /= 2\n   |         ^^^^^^ cannot assign to immutable argument\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    // Base case for base case\n    if n == 0 {\n        return true;\n\
    \    }\n\n    // Check if x is a power of n\n    match x % n {\n        0 => true,\n\
    \        1 => true,\n        _ => false,\n    }\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpd00nsg_r.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if n ** x == x {\n        return true;\n    }\n    return false;\n\
    }\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmp16jrux4_.rs:18:11\n\
    \   |\n18 |     if n ** x == x {\n   |           ^^^\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0614`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    (n - 1) / x == 1\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpz8dlycya.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    pow(x, n, n)\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `pow` in this scope\n  --> /tmp/tmpkk5m8z7m.rs:18:5\n\
    \   |\n18 |     pow(x, n, n)\n   |     ^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == n {\n        return true;\n    }\n    if n == 1 {\n \
    \       return false;\n    }\n    let mut i: int = n as i32;\n    while i != 0\
    \ {\n        if x % i == 0 {\n            return false;\n        }\n        i\
    \ /= 2;\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `int` in this scope\n  --> /tmp/tmpuxttmm_3.rs:24:16\n\
    \   |\n24 |     let mut i: int = n as i32;\n   |                ^^^\n   |    \
    \            |\n   |                not found in this scope\n   |            \
    \    help: perhaps you intended to use this type: `i32`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0412`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    // Your code here\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpom5q2w6z.rs:17:43\n   |\n\
    17 | fn is_simple_power(x: isize, n: isize) -> bool {\n   |    ---------------\
    \                        ^^^^ expected `bool`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976124
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if n == 1 {\n        true\n    } else {\n        x == n ** x\n\
    \    }\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmp10spmtqk.rs:21:17\n\
    \   |\n21 |         x == n ** x\n   |                 ^^^\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0614`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    (1..=n).contains(x) == (n % x == 0)\n}\n\nfn main() {\n    let\
    \ candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptnv7ijt6.rs:18:22\n   |\n\
    18 |     (1..=n).contains(x) == (n % x == 0)\n   |                      ^\n  \
    \ |                      |\n   |                      expected `&isize`, found\
    \ `isize`\n   |                      help: consider borrowing here: `&x`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == n { return true; }\n    for i in 1..n { if x % i == 0\
    \ { return false; } }\n    true\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpx816h9n8.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976125
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    match x {\n        1 => n == 1,\n        _ => n == 0 || !(x %\
    \ n),\n    }\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp31wdl1cl.rs:20:24\n   |\n\
    20 |         _ => n == 0 || !(x % n),\n   |                        ^^^^^^^^ expected\
    \ `bool`, found `isize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976125
