name: HumanEval_20_find_closest_elements
language: rs
prompt: "/// From a supplied vector of numbers (of length at least two) select and\
  \ return two that are the closest to each\n/// other and return them in order (smaller\
  \ number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0,\
  \ 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0,\
  \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) ->\
  \ (f64, f64) {\n"
tests: "}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
  \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0,\
  \ 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
  \ 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
  \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
  \ (2.2, 3.1));\n}\n"
completions: ["    assert!(numbers.size() >= 2);\n    let mut closest_num = numbers[0];\n\
    \    let mut second_closest_num = numbers[0];\n    let mut closest_distance =\
    \ 1.0;\n    for &num in &numbers {\n        if closest_distance > f64::abs(num\
    \ - closest_num) {\n            closest_distance = num - closest_num;\n      \
    \      closest_num = num;\n        }\n        if closest_distance > f64::abs(num\
    \ - second_closest_num) {\n            second_closest_num = num;\n        }\n\
    \    }\n    (closest_num, second_closest_num)", "    let mut min_dist = f64::MAX;\n\
    \    let mut min_number = f64::MAX;\n    for &n in numbers {\n        let dist\
    \ = n.abs();\n        if dist < min_dist {\n            min_dist = dist;\n   \
    \         min_number = n;\n        }\n    }\n\n    (min_number, min_dist)", " \
    \   let mut min_dist = std::f64::MAX;\n    let mut min_num = 0.;\n    let mut\
    \ max_num = 0.;\n    for (i, n) in numbers.iter().enumerate() {\n        let dist\
    \ = std::f64::abs(n - numbers[0]);\n        if dist < min_dist {\n           \
    \ min_dist = dist;\n            min_num = numbers[0];\n            max_num = numbers[0];\n\
    \        } else if dist == min_dist {\n            if n > numbers[0] {\n     \
    \           max_num = n;\n            } else {\n                min_num = n;\n\
    \            }\n        }\n    }\n    (min_num, max_num)", "    let mut min =\
    \ numbers[0];\n    let mut max = numbers[0];\n    for (i, number) in numbers.iter().enumerate()\
    \ {\n        if number > max {\n            max = number;\n        }\n       \
    \ if number < min {\n            min = number;\n        }\n    }\n    (min, max)",
  "    let mut smallest_number = f64::MAX;\n    let mut largest_number = f64::MIN;\n\
    \n    for i in 0..numbers.len() {\n        let distance = numbers[i] - largest_number;\n\
    \n        if distance < smallest_number {\n            smallest_number = distance;\n\
    \        }\n        if distance > largest_number {\n            largest_number\
    \ = distance;\n        }\n    }\n\n    (smallest_number, largest_number)", " \
    \   if numbers.len() < 2 {\n        return (numbers[0], numbers[0]);\n    }\n\
    \    let mut min_val = numbers[0];\n    let mut max_val = numbers[0];\n    for\
    \ i in 1..numbers.len() {\n        let mut min_val = numbers[i];\n        let\
    \ mut max_val = numbers[i];\n        for j in 0..i {\n            let distance\
    \ = std::f64::consts::PI * std::f64::consts::PI / (2.0 * j);\n            if numbers[j]\
    \ < (min_val + distance) {\n                min_val = numbers[j];\n          \
    \  }\n            if numbers[j] > (max_val - distance) {\n                max_val\
    \ = numbers[j];\n            }\n        }\n        return (min_val, max_val);\n\
    \    }\n    (numbers[0], numbers[0]);", "    let mut smallest_number = numbers[0];\n\
    \    let mut largest_number = numbers[0];\n    for i in numbers.iter().rev() {\n\
    \        if i >= smallest_number {\n            continue;\n        }\n       \
    \ if largest_number < i {\n            largest_number = i;\n        }\n      \
    \  if smallest_number > i {\n            smallest_number = i;\n        }\n   \
    \ }\n\n    (smallest_number, largest_number)", "    let mut min = numbers[0];\n\
    \    let mut max = numbers[0];\n    for number in numbers {\n        if number\
    \ > max {\n            max = number;\n        }\n        if number < min {\n \
    \           min = number;\n        }\n    }\n    (min, max)", "    // find the\
    \ smallest and largest numbers in the numbers\n    let smallest = numbers[0];\n\
    \    let largest = numbers[0];\n    for number in numbers {\n        if number\
    \ < smallest {\n            smallest = number;\n        }\n        if number >\
    \ largest {\n            largest = number;\n        }\n    }\n\n    // find the\
    \ midpoint between the smallest and largest\n    let midpoint = smallest + (largest\
    \ - smallest) / 2;\n\n    // find the two numbers closest to each other\n    let\
    \ closest_to_smallest = numbers[numbers\n        .iter()\n        .min_by(|&number|\
    \ f64::abs(number - smallest))\n        .unwrap() as usize];\n    let closest_to_largest\
    \ = numbers[numbers\n        .iter()\n        .min_by(|&number| f64::abs(number\
    \ - largest))\n        .unwrap() as usize];\n\n    // return the values\n    (smallest,\
    \ midpoint), (largest, closest_to_smallest)", "    let mut min_number = std::f64::MAX;\n\
    \    let mut max_number = std::f64::MIN;\n    for number in numbers {\n      \
    \  if number < min_number {\n            min_number = number;\n        }\n   \
    \     if number > max_number {\n            max_number = number;\n        }\n\
    \    }\n    (min_number, max_number)", "    numbers.iter().cloned().enumerate().for_each(|(i,\
    \ n)| {\n        let mut min_dist = std::f64::MAX;\n        let mut min_i = -1;\n\
    \n        for j in 0..i {\n            let dist: f64 = n.0 - numbers[j].0;\n \
    \           if dist < min_dist {\n                min_dist = dist;\n         \
    \       min_i = j;\n            }\n        }\n\n        if min_dist == std::f64::MAX\
    \ {\n            println!(\"found all elements {}\", numbers);\n        } else\
    \ {\n            println!(\"found element {} (dist={}) and element {} (dist={})\"\
    , min_i, min_dist, i + 1, n - 1);\n        }\n    });", "    let mut min_distance\
    \ = numbers[0];\n    let mut min_number = numbers[0];\n\n    for i in 1..numbers.len()\
    \ {\n        let mut distance = 0;\n        let mut number = numbers[0];\n\n \
    \       for j in 1..numbers.len() {\n            distance += &numbers[j] - &mut\
    \ number;\n            number = numbers[j];\n        }\n\n        if distance\
    \ < min_distance {\n            min_distance = distance;\n            min_number\
    \ = number;\n        }\n    }\n\n    (min_number, min_distance)", "    fn get_closest_index(number:\
    \ f64) -> usize {\n        (number as usize - numbers.iter().enumerate().filter(|(_,\
    \ v)| *v == number).count() as usize)\n    }\n\n    let mut min_index = get_closest_index(numbers.iter().min());\n\
    \    let mut max_index = get_closest_index(numbers.iter().max());\n\n    if max_index\
    \ < min_index {\n        (numbers.iter().min(), numbers.iter().max())\n    } else\
    \ {\n        (numbers.iter()\n            .zip(&numbers[min_index..max_index])\n\
    \            .min(|(_, x)| x.0)\n            .0,\n            numbers.iter()\n\
    \                .zip(&numbers[min_index..max_index])\n                .max(|(_,\
    \ x)| x.0)\n                .0,\n        )\n    }", "    // We are going to try\
    \ and find the closest number from each\n    // number. If we find two numbers\
    \ that are closer then they will\n    // be returned. If we only find one then\
    \ we will return the smallest\n    // one\n    let mut min_distance = numbers[0]\n\
    \    let mut smallest_number = numbers[0]\n    for i in numbers.iter().rev() {\n\
    \        let distance = i - smallest_number;\n        if distance < min_distance\
    \ {\n            min_distance = distance;\n            smallest_number = i;\n\
    \        }\n    }\n    (smallest_number, min_distance)", "    let mut min_distance\
    \ = numbers[0] as f64;\n    let mut best_index = numbers[0];\n    for (i, &n)\
    \ in numbers.iter().enumerate() {\n        let distance = n.abs() - min_distance;\n\
    \        if distance < best_distance {\n            best_index = i;\n        \
    \    best_distance = distance;\n        }\n    }\n    (numbers[best_index], numbers[best_index\
    \ + 1] as f64)", "    debug_assert!(numbers.len() >= 2);\n    let mut min_d =\
    \ std::f64::MAX;\n    let mut min_num = numbers[0];\n\n    for &d in &numbers[1..]\
    \ {\n        if d < min_d {\n            min_d = d;\n            min_num = *min_num;\n\
    \        }\n    }\n\n    (min_num, min_d)", "    let (mut lower, mut upper) =\
    \ numbers.windows(2);\n    let mut current_lower = f64::MAX;\n    let mut current_upper\
    \ = -f64::MAX;\n\n    for &n in &numbers {\n        if n < lower {\n         \
    \   lower = n;\n        }\n        if n > upper {\n            upper = n;\n  \
    \      }\n    }\n\n    while !lower.is_nan() && !upper.is_nan() {\n        let\
    \ delta_lower = lower - current_lower;\n        let delta_upper = upper - current_upper;\n\
    \n        if delta_lower < delta_upper {\n            // Lower\n            current_lower\
    \ = lower;\n        } else {\n            // Upper\n            current_upper\
    \ = upper;\n        }\n        lower = numbers.remove(&lower);\n        upper\
    \ = numbers.remove(&upper);\n    }\n\n    (lower, upper)", "    if numbers.len()\
    \ < 2 {\n        (numbers[0], numbers[1])\n    } else {\n        let mut smallest\
    \ = numbers[0];\n        let mut largest = numbers[0];\n        let mut i = 0;\n\
    \n        while i < numbers.len() {\n            smallest = numbers[i];\n\n  \
    \          for j in i + 1 .. numbers.len() {\n                largest = numbers[j];\n\
    \n                if smallest < largest {\n                    (smallest, largest)\n\
    \                } else {\n                    smallest = largest;\n         \
    \       }\n            }\n\n            i += 1;\n        }\n    }", "    let mut\
    \ smallest = numbers[0]; // smallest number\n    let mut largest = numbers[0];\
    \ // largest number\n    for number in numbers {\n        if number < smallest\
    \ {\n            largest = number;\n        } else if number > largest {\n   \
    \         smallest = number;\n        }\n    }\n    (smallest, largest)", "  \
    \  let mut smallest_difference = numbers[0].clone(); // smallest difference to\
    \ numbers[0]\n    let mut largest_difference = numbers[0].clone(); // largest\
    \ difference to numbers[0]\n    let mut smallest_index = numbers[0].clone(); //\
    \ smallest number to numbers[0]\n    let mut largest_index = numbers[0].clone();\
    \ // largest number to numbers[0]\n    for n in numbers {\n        let d = n.f64()\
    \ - smallest_difference;\n        if d < smallest_difference {\n            smallest_difference\
    \ = d;\n            smallest_index = n;\n        }\n        let d = n.f64() -\
    \ largest_difference;\n        if d > largest_difference {\n            largest_difference\
    \ = d;\n            largest_index = n;\n        }\n    }\n    (smallest_index,\
    \ largest_index)", "    let mut min = None;\n    let mut max = None;\n\n    for\
    \ &n in numbers {\n        if min == None || n < min {\n            min = Some(n);\n\
    \        }\n        if max == None || n > max {\n            max = Some(n);\n\
    \        }\n    }\n\n    (min, max).unwrap()", "    let mut best = numbers[0].min(numbers[1]);\n\
    \    let mut second = numbers[0].min(numbers[0]);\n    for n in numbers.iter().skip(1)\
    \ {\n        let mut c = n.min(&mut second);\n        second = n.min(&mut best);\n\
    \        best = c;\n    }\n    (best, second)", "    let mut min_diff = std::f64::MAX;\n\
    \    let mut min_diff_index = -1;\n    let mut max_diff = 0;\n    let mut max_diff_index\
    \ = 0;\n    let mut max_number = numbers[0];\n    let mut min_number = numbers[0];\n\
    \n    for &n in &numbers[1..] {\n        let diff = (n - min_number).abs();\n\n\
    \        if diff < min_diff {\n            min_diff = diff;\n            min_diff_index\
    \ = -1;\n        }\n        if diff > max_diff {\n            max_diff = diff;\n\
    \            max_diff_index = 0;\n        }\n\n        if n == min_number {\n\
    \            min_diff_index = 0;\n            break;\n        }\n        if n\
    \ == max_number {\n            max_diff_index = 1;\n            break;\n     \
    \   }\n    }\n\n    (min_number, max_number)", "    assert!(numbers.size() > 1);\n\
    \    if numbers[0] - numbers[1] > 0 {\n        (numbers[0], numbers[1])\n    }\
    \ else {\n        (numbers[1], numbers[0])\n    }", "    if numbers.is_empty()\
    \ {\n        return (-1, -1);\n    }\n    let mut min_distance = vec![numbers[0];\
    \ 2];\n    let mut min_dist_idx = 2;\n    for (i, &number) in numbers.iter().enumerate()\
    \ {\n        if i == 0 {\n            continue;\n        }\n        let distance\
    \ = numbers.iter().map(|number| number - numbers[i]).sum();\n        if distance\
    \ < min_distance[0] {\n            min_distance[0] = distance;\n            min_dist_idx\
    \ = i;\n        }\n    }\n    (min_distance[min_dist_idx], numbers[min_dist_idx])",
  "    let mut smallest: usize = 0;\n    let mut largest = 0;\n    for &num in numbers\
    \ {\n        if smallest == 0 {\n            smallest = largest = num;\n     \
    \   }\n        else {\n            if num < smallest {\n                smallest\
    \ = num;\n            }\n            else if num > largest {\n               \
    \ largest = num;\n            }\n        }\n    }\n    (numbers[smallest], numbers[largest])",
  "    let mut closest = numbers[0];\n    let mut smallest = numbers[0];\n\n    for\
    \ n in numbers {\n        if n < smallest {\n            smallest = n;\n     \
    \       closest = n;\n        } else if n > smallest {\n            let mut mid\
    \ = closest;\n            let mut delta = n - closest;\n            while delta\
    \ >= smallest {\n                mid = numbers[(mid.index() + 1) % numbers.len()];\n\
    \                delta = mid - closest;\n            }\n            (closest,\
    \ mid);\n        }\n    }\n    (closest, smallest)", "    let mut smallest = numbers[0];\n\
    \    let mut largest = numbers[0];\n    for &number in numbers {\n        if smallest\
    \ > number {\n            smallest = number;\n        }\n        if largest <\
    \ number {\n            largest = number;\n        }\n    }\n    (smallest, largest)",
  '    numbers.iter().enumerate().filter(|(_, n)| n < numbers.len() && n >= 1).map(|(i,
    v)| v as f64 - numbers[i * 2] as f64).min_by(|a, b| a.abs() < b.abs()).unwrap()',
  "    let mut low = numbers[0];\n    let mut high = numbers[0];\n\n    for &n in\
    \ numbers {\n        if n > high {\n            high = n;\n        }\n       \
    \ if n < low {\n            low = n;\n        }\n    }\n    (low, high)", "  \
    \  let mut best_d = std::f64::MAX;\n    let mut best_elem = Vec::new();\n\n  \
    \  for (i, &value) in numbers.iter().enumerate() {\n        let d = value.dist(numbers[0]);\n\
    \        if d < best_d {\n            best_d = d;\n            best_elem = vec![i];\n\
    \        }\n    }\n\n    (numbers[best_elem[0]], numbers[best_elem[1]])", "  \
    \  let mut min_diff: f64 = numbers[0];\n    let mut max_diff: f64 = numbers[0];\n\
    \    let mut index: usize = 0;\n\n    for number in numbers {\n        if number\
    \ < min_diff {\n            min_diff = number;\n        }\n\n        if number\
    \ > max_diff {\n            max_diff = number;\n        }\n\n        let mut min_diff_num:\
    \ f64 = number;\n        let mut max_diff_num: f64 = number;\n\n        let mut\
    \ current_index = index;\n\n        while current_index != 0 {\n            if\
    \ current_index > 0 && numbers[current_index - 1] < min_diff_num {\n         \
    \       min_diff_num = numbers[current_index - 1];\n                let mut current_index\
    \ = current_index - 1;\n            } else {\n                break;\n       \
    \     }\n        }\n\n        while current_index != numbers.len() - 1 {\n   \
    \         if numbers[current_index + 1] < min_diff_num {\n                min_diff_num\
    \ = numbers[current_index + 1];\n                let mut current_index = current_index\
    \ + 1;\n            } else {\n                break;\n            }\n        }\n\
    \n        index = current_index;\n\n        if min_diff_num > max_diff_num {\n\
    \            (min_diff_num, max_diff_num)\n        } else {\n            (max_diff_num,\
    \ min_diff_num)\n        }\n    }", "    let mut min_diff = std::f64::MAX;\n \
    \   let mut closest_elem = numbers[0];\n    let mut closest_idx = 1;\n\n    for\
    \ x in &numbers[1..] {\n        let diff = (*x - closest_elem).abs();\n      \
    \  if diff < min_diff {\n            min_diff = diff;\n            closest_elem\
    \ = x;\n            closest_idx = closest_idx + 1;\n        }\n    }\n\n    (closest_elem,\
    \ closest_idx)", "    let mut mindiff = numbers[0] as f64;\n    let mut mindiff\
    \ = numbers[0] as f64;\n    for n in numbers.iter().skip(1) {\n        match n\
    \ {\n            n if n < mindiff =>\n                if n == mindiff {\n    \
    \                mindiff = n;\n                    mindiff = n;\n            \
    \    } else {\n                    mindiff = n;\n                }\n         \
    \   n if n > mindiff =>\n                if n == mindiff {\n                 \
    \   mindiff = n;\n                } else {\n                    mindiff = n;\n\
    \                }\n        }\n    }\n    (mindiff, mindiff)", "    numbers.sort();\n\
    \n    let mut first_idx = vec![];\n    let mut second_idx = vec![];\n\n    let\
    \ mut largest_different_idx = 0;\n    let mut second_largest_different_idx = 0;\n\
    \n    for i in 0..numbers.len() - 1 {\n        let first_diff = f64::abs(numbers[i]\
    \ - numbers[i + 1]);\n\n        if first_diff > largest_different_idx {\n    \
    \        largest_different_idx = first_diff;\n            first_idx.push(i);\n\
    \        }\n    }\n\n    for j in 0..numbers.len() - 1 {\n        let second_diff\
    \ = f64::abs(numbers[j] - numbers[first_idx[j] + 1]);\n\n        if second_diff\
    \ > second_largest_different_idx {\n            second_largest_different_idx =\
    \ second_diff;\n            second_idx.push(j);\n        }\n    }\n\n    (numbers[first_idx[0]],\
    \ numbers[second_idx[0]])", "    if numbers.len() < 2 {\n        return (0.f64,\
    \ 0.f64);\n    }\n\n    let mut min_index = 0;\n    let mut max_index = numbers.len()\
    \ - 1;\n\n    let mut min_value = numbers[min_index];\n    let mut max_value =\
    \ numbers[max_index];\n\n    while min_index < max_index {\n        let mut mid_index\
    \ = min_index + (max_index - min_index) / 2;\n        let mut mid_value = numbers[mid_index];\n\
    \n        if mid_value < min_value {\n            min_value = mid_value;\n   \
    \         min_index = mid_index;\n        } else {\n            max_index = mid_index;\n\
    \            max_value = mid_value;\n        }\n    }\n\n    (min_value, max_value)",
  "    let mut min_distance = std::f64::MAX;\n    let mut min_element = numbers.iter().min().unwrap();\n\
    \    let mut max_element = numbers.iter().max().unwrap();\n    for i in numbers.iter().rev()\
    \ {\n        let distance = &i - &min_element;\n        if distance < min_distance\
    \ {\n            min_element = i;\n            min_distance = distance;\n    \
    \    }\n        let distance = &max_element - &i;\n        if distance < min_distance\
    \ {\n            min_distance = distance;\n            max_element = i;\n    \
    \    }\n    }\n    (min_element, max_element)", "    let mut min_distance = std::f64::MAX;\n\
    \    let mut min_number = numbers[0];\n    let mut max_number = numbers[0];\n\
    \    for number in numbers.iter() {\n        let distance = number.abs() - min_number;\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = number;\n        }\n        if number > max_number {\n\
    \            max_number = number;\n        }\n    }\n    (min_number, max_number)",
  "    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if min > n {\n            min = n;\n        }\n        if max < n\
    \ {\n            max = n;\n        }\n    }\n\n    (min, max)", "    let mut min_value\
    \ = numbers[0];\n    let mut max_value = numbers[0];\n\n    for &n in numbers\
    \ {\n        if n < min_value {\n            min_value = n;\n        }\n\n   \
    \     if n > max_value {\n            max_value = n;\n        }\n    }\n\n   \
    \ (min_value, max_value)", "    let mut smallest_difference = std::f64::MAX;\n\
    \    let mut second_smallest_difference = std::f64::MAX;\n    for i in numbers.iter()\
    \ {\n        if i >= smallest_difference {\n            smallest_difference =\
    \ i;\n        }\n        if second_smallest_difference < i {\n            second_smallest_difference\
    \ = i;\n        }\n    }\n    (smallest_difference, second_smallest_difference)",
  "    let mut min = f64::MAX;\n    let mut max = 0.0;\n    for n in numbers {\n \
    \       let d = n - min;\n        if d < 0.0 {\n            d = 0.0;\n       \
    \ }\n        if d > f64::MAX as f64 {\n            d = f64::MAX;\n        }\n\
    \        if d < min {\n            min = d;\n        }\n        if d > max {\n\
    \            max = d;\n        }\n    }\n    (min, max)", "    let mut smallest_element\
    \ = numbers[0];\n    let mut second_smallest_element = numbers[0];\n    for (i,\
    \ n) in numbers.iter().enumerate() {\n        if i < numbers.len() - 1 {\n   \
    \         let dist = f64::distance(n as f64, numbers[i + 1] as f64);\n       \
    \     if dist < smallest_element {\n                smallest_element = n as f64;\n\
    \            }\n            if dist < second_smallest_element {\n            \
    \    second_smallest_element = n as f64;\n            }\n        }\n    }\n  \
    \  (smallest_element, second_smallest_element)", "    let mut smallest_difference\
    \ = numbers[0] as f64;\n    let mut largest_difference = numbers[0] as f64;\n\
    \    let mut smallest_element = numbers[0] as f64;\n    let mut largest_element\
    \ = numbers[0] as f64;\n    let mut smallest_number = numbers[0] as f64;\n   \
    \ let mut largest_number = numbers[0] as f64;\n    for i in 1..numbers.len() {\n\
    \        let difference = numbers[i] - numbers[i - 1];\n        if smallest ==\
    \ largest {\n            if difference < smallest_difference {\n             \
    \   smallest_difference = difference;\n                smallest_element = numbers[i\
    \ - 1];\n                smallest_number = numbers[i - 1];\n            }\n  \
    \          if difference > largest_difference {\n                largest_difference\
    \ = difference;\n                largest_element = numbers[i - 1];\n         \
    \       largest_number = numbers[i - 1];\n            }\n        } else {\n  \
    \          if difference < smallest_difference {\n                smallest_difference\
    \ = difference;\n                smallest_element = numbers[i - 1];\n        \
    \        smallest_number = numbers[i - 1];\n            }\n            if difference\
    \ > largest_difference {\n                largest_difference = difference;\n \
    \               largest_element = numbers[i - 1];\n                largest_number\
    \ = numbers[i - 1];\n            }\n        }\n    }\n    (smallest_element, largest_element)",
  "    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for number in\
    \ numbers {\n        if number < min {\n            min = number;\n        }\n\
    \        if number > max {\n            max = number;\n        }\n    }\n    (min,\
    \ max)", "    debug_assert!(numbers.len() >= 2);\n    let smallest = numbers[0]\
    \ + f64::EPSILON;\n    let mut result = numbers[0] + f64::EPSILON;\n    for i\
    \ in 1..numbers.len() {\n        let difference = numbers[i] - result;\n     \
    \   if difference < smallest {\n            smallest = difference;\n         \
    \   result = numbers[i];\n        }\n    }\n    (result, smallest)", "    let\
    \ mut min_dist = std::f64::INFINITY;\n    let mut min_element = numbers[0];\n\
    \    for num in numbers {\n        let dist = abs(num - min_element);\n      \
    \  if dist < min_dist {\n            min_dist = dist;\n            min_element\
    \ = num;\n        }\n    }\n    (min_element, min_dist)", "    debug_assert!(numbers.size()\
    \ >= 2);\n    let mut min_diff = std::f64::MAX;\n    let mut min = numbers[0];\n\
    \    let mut max = numbers[0];\n    for i in numbers[1..] {\n        let d = f64::abs(i\
    \ - min);\n        if d < min_diff {\n            min = i;\n        }\n      \
    \  if d > max_diff {\n            max = i;\n        }\n    }\n    (min, max)",
  "    let mut min_dist = vec![];\n    let mut min_element = vec![];\n\n    for &number\
    \ in numbers {\n        for &dist in min_dist {\n            if number - dist\
    \ < 0 {\n                min_dist.push(dist);\n                min_element.push(number);\n\
    \                break;\n            }\n        }\n    }\n\n    let mut max_dist\
    \ = vec![];\n    let mut max_element = vec![];\n\n    for &dist in min_dist {\n\
    \        for &number in min_element {\n            if number + dist > 0 {\n  \
    \              max_dist.push(dist);\n                max_element.push(number);\n\
    \                break;\n            }\n        }\n    }\n\n    (min_element.len(),\
    \ max_element.len())", "    let mut smallest = numbers[0].clone();\n    let mut\
    \ largest = numbers[0].clone();\n\n    for i in 1..numbers.len() {\n        if\
    \ numbers[i - 1] <= numbers[i] {\n            if numbers[i - 1] > largest {\n\
    \                largest = numbers[i - 1];\n            }\n\n            if numbers[i\
    \ - 1] < smallest {\n                smallest = numbers[i - 1];\n            }\n\
    \        } else {\n            if numbers[i - 1] < largest {\n               \
    \ largest = numbers[i - 1];\n            }\n\n            if numbers[i - 1] >\
    \ smallest {\n                smallest = numbers[i - 1];\n            }\n    \
    \    }\n    }\n\n    (smallest, largest)", "    // The smallest distance between\
    \ any two given numbers\n    let mut closest_distance = std::f64::MAX;\n    //\
    \ The two closest numbers to the first given number\n    let mut closest_one:\
    \ f64 = std::f64::MAX;\n    // The two closest numbers to the second given number\n\
    \    let mut closest_two: f64 = std::f64::MAX;\n    // Look for two numbers in\
    \ the vector whose distance is smallest to each other\n    for &i in numbers {\n\
    \        closest_distance = i.abs();\n        if closest_distance < closest_distance\
    \ {\n            closest_one = i;\n        }\n        if closest_distance < closest_distance\
    \ {\n            closest_two = i;\n        }\n    }\n\n    (closest_one, closest_two)",
  "    let mut min_element = numbers[0];\n    let mut max_element = numbers[0];\n\
    \    for element in numbers {\n        if element < min_element {\n          \
    \  min_element = element;\n        }\n        if element > max_element {\n   \
    \         max_element = element;\n        }\n    }\n    (min_element, max_element)",
  "    if numbers.len() < 2 {\n        assert!(false, \"Must have at least two values\
    \ to find closest to\");\n    }\n\n    let mut index = 0;\n    let mut min_dist\
    \ = std::f64::MAX;\n    let mut min_number = numbers[index];\n\n    while index\
    \ < numbers.len() {\n        let dist = numbers[index] - min_number;\n       \
    \ if dist < min_dist {\n            min_number = numbers[index];\n           \
    \ min_dist = dist;\n        }\n        index += 1;\n    }\n    (min_number, min_dist)",
  "    use std::cmp::min;\n\n    numbers.windows(2)\n        .min_by(|a, b| a.partial_cmp(b))\n\
    \        .unwrap_or_else(|| {\n            assert!(numbers[numbers.size() - 2].partial_cmp(&numbers[numbers.size()\
    \ - 1]) <= 0);\n            numbers[numbers.size() - 2]\n        })", "    fn\
    \ compare(number1: f64, number2: f64) -> Ordering {\n        Ordering::Less if\
    \ number1 < number2 else Ordering::Greater\n    }\n\n    if numbers.len() <= 1\
    \ {\n        (0, 1)\n    } else {\n        let mut smaller = numbers[0];\n   \
    \     let mut larger = numbers[0];\n\n        for number in numbers.iter().skip(1)\
    \ {\n            let ordering = compare(number, smaller);\n\n            if ordering\
    \ == Ordering::Less {\n                smaller = number;\n            } else {\n\
    \                larger = number;\n            }\n        }\n\n        (smaller,\
    \ larger)\n    }", "    let mut smallest_num = numbers[0];\n    let mut largest_num\
    \ = numbers[0];\n\n    for num in numbers {\n        if num < smallest_num {\n\
    \            smallest_num = num;\n        }\n        if num > largest_num {\n\
    \            largest_num = num;\n        }\n    }\n\n    (smallest_num, largest_num)",
  "    let mut min: f64;\n    let mut max: f64;\n    for i in numbers.iter() {\n \
    \       let mut min_diff = std::f64::MAX;\n        for j in numbers.iter() {\n\
    \            let diff = (*i - j).abs();\n            if diff < min_diff {\n  \
    \              min_diff = diff;\n                min = i;\n                max\
    \ = j;\n            }\n        }\n    }\n    (min, max)", "    let mut smallest\
    \ = numbers[0];\n    let mut largest = numbers[0];\n\n    for i in numbers {\n\
    \        if i < smallest {\n            smallest = i;\n        }\n        if i\
    \ > largest {\n            largest = i;\n        }\n    }\n\n    (smallest, largest)",
  "    let mut min_val = numbers[0];\n    let mut max_val = numbers[0];\n    let mut\
    \ min_index = -1;\n    let mut max_index = -1;\n    for &val in &numbers {\n \
    \       if val < min_val {\n            min_val = val;\n            min_index\
    \ = 0;\n        }\n        if val > max_val {\n            max_val = val;\n  \
    \          max_index = i;\n        }\n    }\n    (min_val, max_val, min_index,\
    \ max_index);", "    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for i in numbers.iter() {\n        if i < min {\n            min = i;\n \
    \       }\n        if i > max {\n            max = i;\n        }\n    }\n    (min,\
    \ max)", "    let mut smallest_distance = std::f64::MAX;\n    let mut largest_distance\
    \ = 0;\n\n    for i in numbers {\n        let distance = i - numbers.iter().min().unwrap();\n\
    \        if distance < smallest_distance {\n            smallest_distance = distance;\n\
    \        }\n        if distance > largest_distance {\n            largest_distance\
    \ = distance;\n        }\n    }\n\n    (smallest_distance, largest_distance)",
  "    assert!(numbers.len() >= 2);\n    let mut smallest = numbers[0];\n    let mut\
    \ largest = numbers[0];\n    for i in 1..numbers.len() {\n        let mut mid\
    \ = (smallest + largest) / 2;\n        if numbers[i] > mid {\n            largest\
    \ = mid;\n        } else {\n            smallest = mid;\n        }\n    }\n  \
    \  (smallest, largest)", "    assert!(numbers.len() >= 2);\n    let mut a = numbers[0];\n\
    \    let mut b = numbers[0];\n    let mut dist = std::f64::MAX;\n    let mut index\
    \ = 0;\n    for (i, &mut number) in numbers.iter_mut().zip(&mut numbers[index..])\
    \ {\n        if number < a {\n            a = number;\n            index = i;\n\
    \        }\n        if number > b {\n            b = number;\n            index\
    \ = i;\n        }\n        dist = std::f64::MAX;\n    }\n    (index as f64, a\
    \ as f64)", "    let mut min_val: f64 = numbers[0];\n    let mut min_idx: usize\
    \ = 0;\n    let mut max_val: f64 = numbers[0];\n    let mut max_idx: usize = 0;\n\
    \n    for i in 1..numbers.len() {\n        if numbers[i] < min_val {\n       \
    \     min_val = numbers[i];\n            min_idx = i;\n        } else {\n    \
    \        if numbers[i] > max_val {\n                max_val = numbers[i];\n  \
    \              max_idx = i;\n            }\n        }\n    }\n\n    (min_val,\
    \ numbers[min_idx], max_val, numbers[max_idx])", "    let mut index = 0;\n   \
    \ let mut min_dist = numbers.len();\n    while index < numbers.len() {\n     \
    \   let dist = dist(numbers[index], numbers[index + 1], numbers[min_dist]);\n\
    \        if dist < min_dist {\n            min_dist = dist;\n        }\n     \
    \   index += 1\n    }\n\n    (numbers[min_dist], numbers[min_dist + 1])", "  \
    \  let mut min_delta = numbers[0];\n    let mut min_number = numbers[1];\n   \
    \ let mut max_number = numbers[0];\n    for i in &numbers[1..] {\n        if *i\
    \ < min_delta {\n            min_delta = *i;\n            min_number = i;\n  \
    \      } else {\n            *i -= min_delta;\n        }\n        if *i > *max_number\
    \ {\n            max_number = i;\n        }\n    }\n    (min_number, max_number)",
  "    let mut best = Some(numbers[0]);\n    let mut worst = Some(numbers[0]);\n \
    \   for num in numbers.iter().rev() {\n        if num > best.as_ref() {\n    \
    \        best = Some(num);\n        } else if num < worst.as_ref() {\n       \
    \     worst = Some(num);\n        }\n    }\n    (best.as_ref(), worst.as_ref())",
  "    let mut numbers_iter = numbers.iter().enumerate().rev();\n    let mut index\
    \ = 0;\n    let mut min = f64::MAX;\n    let mut max = f64::MIN;\n\n    while\
    \ let Some((i, number)) = numbers_iter.next() {\n        if number < min {\n \
    \           min = number;\n            index = i;\n        } else if number >\
    \ max {\n            max = number;\n        }\n    }\n\n    (numbers[index], numbers[index\
    \ + 1])", "    let mut smallest_one = numbers[0];\n    let mut second_smallest_one\
    \ = numbers[0];\n    for &x in numbers {\n        if x < smallest_one {\n    \
    \        smallest_one = x;\n        }\n        if x > second_smallest_one {\n\
    \            second_smallest_one = x;\n        }\n    }\n    (smallest_one, second_smallest_one)",
  "    let mut smallest = numbers[0] as f64;\n    let mut largest = numbers[0] as\
    \ f64;\n\n    for number in numbers.iter().skip(1) {\n        if number < smallest\
    \ {\n            smallest = number;\n        }\n        if number > largest {\n\
    \            largest = number;\n        }\n    }\n\n    (smallest, largest)",
  "    let mut best_idx = numbers.iter().min().unwrap();\n    let mut worst_idx =\
    \ numbers.iter().max().unwrap();\n\n    let mut new_numbers = Vec::new();\n\n\
    \    for idx in 0..numbers.len() {\n        let (smallest_idx, largest_idx) =\
    \ find_best_match(&numbers, idx, best_idx, worst_idx);\n        new_numbers.push(numbers[smallest_idx]);\n\
    \        new_numbers.push(numbers[largest_idx]);\n\n        best_idx = largest_idx;\n\
    \        worst_idx = smallest_idx;\n    }\n\n    (new_numbers[0], new_numbers[1])",
  "    if numbers.len() < 2 {\n        return (0., numbers[0]);\n    }\n    let mut\
    \ min_dist = numbers[0] as f64;\n    let mut min_val = numbers[1];\n    for &num\
    \ in numbers[1..] {\n        let dist = num - min_val;\n        if dist < min_dist\
    \ {\n            min_dist = dist;\n            min_val = num;\n        }\n   \
    \ }\n    (min_val, min_dist)", "    let mut sorted_numbers = numbers.clone();\n\
    \n    sorted_numbers.sort_unstable_by(|a, b| a.partial_cmp(b));\n\n    let lower\
    \ = sorted_numbers[..numbers.len()/2];\n    let upper = sorted_numbers[numbers.len()/2..];\n\
    \n    (lower.iter().min().unwrap(), upper.iter().max().unwrap())", "    if numbers.len()\
    \ < 2 {\n        return (f64::MAX_POSITIVE, f64::MAX_POSITIVE);\n    }\n    let\
    \ mut best = (f64::MAX_POSITIVE, f64::MAX_POSITIVE);\n    let mut best_index =\
    \ -1;\n    for index in 1..numbers.len() {\n        let distance = numbers.iter().nth(index).unwrap().fabs();\n\
    \        if distance < best.0 {\n            best = distance;\n            best_index\
    \ = index;\n        }\n    }\n    (numbers[best_index], numbers[best_index - 1])",
  "    use std::cmp::Ordering;\n    let mut min = std::cmp::Ordering::Less;\n    let\
    \ mut max = std::cmp::Ordering::Greater;\n\n    let mut index = 0;\n    let mut\
    \ distance = std::f64::MAX;\n\n    while index < numbers.len() {\n        let\
    \ number = numbers[index];\n        let new_distance = number.abs() - distance;\n\
    \n        if new_distance < distance {\n            index = index * 2;\n     \
    \       distance = new_distance;\n        } else {\n            index = index\
    \ + 1;\n            distance = std::f64::MAX;\n        }\n\n        if index >\
    \ numbers.len() / 2 {\n            break;\n        }\n\n        let mut new_min\
    \ = number;\n        let mut new_max = number;\n        if index >= numbers.len()\
    \ / 2 {\n            new_min = numbers[index];\n            new_max = numbers[0];\n\
    \        } else {\n            new_min = numbers[index * 2];\n            new_max\
    \ = numbers[index * 2 + 1];\n        }\n\n        if new_min > new_max {\n   \
    \         max = new_min;\n            min = new_max;\n        } else {\n     \
    \       min = new_min;\n            max = new_max;\n        }\n    }\n\n    (min,\
    \ max)", "    if numbers.len() <= 2 {\n        return numbers[0], numbers[0];\n\
    \    }\n    let mut smallest_element = numbers[0];\n    let mut largest_element\
    \ = numbers[0];\n    for element in &numbers[1..] {\n        if element < smallest_element\
    \ {\n            smallest_element = element;\n        }\n        if element >\
    \ largest_element {\n            largest_element = element;\n        }\n    }\n\
    \    (smallest_element, largest_element)", "    let mut a = numbers[0];\n    let\
    \ mut b = numbers[0];\n    let mut min_a = a;\n    let mut min_b = b;\n    for\
    \ &n in numbers {\n        if *n <= min_a {\n            min_a = *n;\n       \
    \ }\n        if *n <= min_b {\n            min_b = *n;\n        }\n    }\n   \
    \ let mut max_a = a;\n    let mut max_b = b;\n    for &n in numbers {\n      \
    \  if *n >= max_a {\n            max_a = *n;\n        }\n        if *n >= max_b\
    \ {\n            max_b = *n;\n        }\n    }\n    (min_a, min_b), (max_a, max_b)",
  "    let mut smallest = numbers[0];\n    let mut largest = numbers[0];\n\n    for\
    \ &n in numbers {\n        if n < smallest {\n            smallest = n;\n    \
    \    }\n\n        if n > largest {\n            largest = n;\n        }\n    }\n\
    \n    (smallest, largest)", "    if numbers.len() < 2 {\n        (numbers[0],\
    \ numbers[0])\n    } else {\n        let mut min = numbers[0];\n        let mut\
    \ max = numbers[0];\n        for &n in &numbers[1..] {\n            if n < min\
    \ {\n                min = n;\n            }\n            if n > max {\n     \
    \           max = n;\n            }\n        }\n        (min, max)\n    }", " \
    \   let mut min_element = numbers[0];\n    let mut max_element = numbers[0];\n\
    \n    for n in numbers {\n        if n <= min_element {\n            min_element\
    \ = n;\n        }\n        if n > max_element {\n            max_element = n;\n\
    \        }\n    }\n\n    (min_element, max_element)", "    assert!(numbers.len()\
    \ >= 2);\n    let mut smallest = numbers[0];\n    let mut largest = numbers[0];\n\
    \    let mut index = 1;\n\n    for number in &numbers {\n        if number > largest\
    \ {\n            largest = number;\n        }\n\n        if number < smallest\
    \ {\n            smallest = number;\n        }\n        if number == largest {\n\
    \            if index > numbers.len() - 1 {\n                break;\n        \
    \    }\n            largest = numbers[index];\n        }\n\n        if number\
    \ == smallest {\n            if index > numbers.len() - 1 {\n                break;\n\
    \            }\n            smallest = numbers[index];\n        }\n\n        index\
    \ += 1;\n    }\n\n    (smallest, largest)", "    debug_assert!(numbers[0] <= numbers[1]);\n\
    \n    let mut smallest = numbers[0] as f64;\n    let mut largest_1 = numbers[0]\
    \ as f64;\n    let mut largest_2 = numbers[0] as f64;\n\n    for n in numbers[1..]\
    \ {\n        let diff: f64 = (n - smallest).abs();\n        if diff < largest_1\
    \ {\n            smallest = n;\n            largest_1 = diff;\n        }\n   \
    \     if diff > largest_2 {\n            largest_2 = diff;\n            largest_2\
    \ = n;\n        }\n    }\n    (smallest, largest_2)", "    if numbers.len() <\
    \ 2 {\n        debug_assert_eq!(numbers.len(), 0);\n        return (f64::NEG_INFINITY,\
    \ f64::NEG_INFINITY);\n    }\n    let mut smallest_difference = numbers[0];\n\
    \    let mut second_smallest_difference = numbers[0];\n    for &n in numbers {\n\
    \        smallest_difference = if *n < smallest_difference { *n } else {\n   \
    \         smallest_difference };\n        second_smallest_difference =\n     \
    \       if smallest_difference == f64::NEG_INFINITY {\n                f64::NEG_INFINITY\n\
    \            } else {\n                if *n < second_smallest_difference { *n\
    \ } else {\n                    second_smallest_difference };\n            };\n\
    \    }\n    (smallest_difference, second_smallest_difference)", "    let mut min_dist\
    \ = std::f64::MAX;\n    let mut min_elem = &numbers[0];\n    let mut max_elem\
    \ = &numbers[0];\n\n    for num in numbers.iter() {\n        let dist = num.abs()\
    \ - min_dist;\n        if dist < min_dist {\n            min_dist = dist;\n  \
    \          min_elem = &num;\n        } else if dist > min_dist {\n           \
    \ max_elem = &num;\n        }\n    }\n\n    (min_elem, max_elem)", "    // TODO:\
    \ make faster\n\n    // If the vector is empty then return an empty tuple\n  \
    \  let mut closest_elem = Vec::with_capacity(2);\n    let mut smallest_elem =\
    \ numbers[0];\n    let mut largest_elem = numbers[0];\n\n    // Check if each\
    \ element in the vector is less than the previous or not\n    for num in numbers\
    \ {\n        if smallest_elem > num {\n            smallest_elem = num;\n    \
    \    }\n        if largest_elem < num {\n            largest_elem = num;\n   \
    \     }\n    }\n\n    // If the vector is empty then return an empty tuple\n \
    \   if smallest_elem == largest_elem {\n        (smallest_elem, smallest_elem)\n\
    \    } else {\n        let mut close_num = smallest_elem;\n        let mut close_num_idx\
    \ = 1;\n\n        // Loop through the vector to find the closest number from the\
    \ largest\n        // number in the vector\n        for num in numbers {\n   \
    \         if num == largest_elem {\n                continue;\n            }\n\
    \            let mut distance = Vec::with_capacity(2);\n            let mut smallest_val\
    \ = Vec::with_capacity(2);\n            let mut largest_val = Vec::with_capacity(2);\n\
    \            let mut smallest_idx = Vec::with_capacity(2);\n            let mut\
    \ largest_idx = Vec::with_capacity(2);\n\n            // Find the closest number\
    \ from the smallest\n            for num_idx in 0..2 {\n                distance.push(std::f64::MAX);\n\
    \                smallest_val.push(std::f64::MAX);\n                smallest_idx.push(0);\n\
    \                largest_val.push(std::f64::MIN);\n                largest_idx.push(0);\n\
    \            }\n\n            // Find the closest number from the largest\n  \
    \          for num_idx in 0..2 {\n                if num_idx < 2 {\n         \
    \           let mut difference = num - close_num;\n                    smallest_val[num_idx]\
    \ = smallest_val[num_idx + 1] + difference;\n                    smallest_idx[num_idx]\
    \ = smallest_idx[num_idx + 1] + 1;\n                } else {\n               \
    \     let mut difference = largest_val[num_idx - 2] - num;\n                 \
    \   largest_val[num_idx] = largest_val[num_idx - 2] + difference;\n          \
    \          largest_idx[num_idx] = largest_idx[num_idx - 2] + 1;\n            \
    \    }\n            }\n\n            // Find the smallest difference\n       \
    \     for num_idx in 0..2 {\n                if smallest_val[num_idx] < close_num\
    \ && largest_val[num_idx] >= close_num {\n                    let mut smallest_diff\
    \ = close_num - smallest_val[num_idx];\n                    if ", "    let numbers_clone\
    \ = numbers.clone();\n    let mut min = numbers_clone[0];\n    let mut max = numbers_clone[0];\n\
    \    for i in numbers_clone.iter_mut() {\n        if *i < min {\n            min\
    \ = *i;\n        }\n        if *i > max {\n            max = *i;\n        }\n\
    \    }\n    (min, max)", "    let mut smallest_distance = std::f64::MAX;\n   \
    \ let mut smallest_index = -1;\n\n    for i in 0..numbers.len() - 1 {\n      \
    \  let difference = numbers[i] - numbers[smallest_index];\n        if difference\
    \ < smallest_distance {\n            smallest_distance = difference;\n       \
    \     smallest_index = i;\n        }\n    }\n\n    (numbers[smallest_index], numbers[smallest_index\
    \ + 1])", "    let mut smallest = numbers[0].clone();\n    let mut largest = numbers[0].clone();\n\
    \n    for n in numbers.iter().skip(1) {\n        let diff = n.abs() - smallest;\n\
    \        if diff < smallest {\n            smallest = diff;\n        }\n     \
    \   if diff > largest {\n            largest = diff;\n        }\n    }\n    (smallest,\
    \ largest)", "    let min_element = numbers[0] as f64;\n    let max_element =\
    \ numbers[0] as f64;\n\n    for i in 1..numbers.len() {\n        let curr_element\
    \ = numbers[i] as f64;\n        if curr_element > max_element {\n            max_element\
    \ = curr_element;\n        } else if curr_element < min_element {\n          \
    \  min_element = curr_element;\n        }\n    }\n\n    (min_element, max_element)",
  "    // The algorithm is simple: find the smallest number in the list and move it\
    \ to the front\n    // if it's not already present. Repeat this until there are\
    \ two elements that are farthest apart.\n    let mut smallest = numbers[0];\n\
    \    let mut second: f64 = numbers.iter().next().unwrap();\n    let mut last:\
    \ Option<(f64, f64)> = None;\n\n    for i in &numbers[1..] {\n        if i !=\
    \ smallest {\n            last = Some((smallest, i));\n        }\n\n        if\
    \ i != second {\n            second = i;\n        }\n\n        if i == first {\n\
    \            break;\n        }\n\n        smallest = i;\n    }\n\n    if let Some((smallest,\
    \ second)) = last {\n        (smallest, second)\n    } else {\n        (numbers[0],\
    \ numbers[1..])\n    }", "    let mut smallest = numbers[0] as f64;\n    let mut\
    \ largest = numbers[0] as f64;\n\n    for number in numbers.iter().skip(1) {\n\
    \        let mut new_number = number;\n        if number < smallest {\n      \
    \      new_number = smallest;\n        }\n        if number > largest {\n    \
    \        new_number = largest;\n        }\n        if new_number < smallest {\n\
    \            smallest = number;\n        }\n        if new_number > largest {\n\
    \            largest = number;\n        }\n    }\n    (smallest, largest)", " \
    \   let mut min: Option<f64> = None;\n    let mut max: Option<f64> = None;\n \
    \   for n in numbers {\n        if let Some(n) = min {\n            if n < n {\n\
    \                min = Some(n);\n            } else {\n                max = Some(n);\n\
    \            }\n        } else {\n            min = Some(n);\n        }\n    }\n\
    \n    while let Some(mut min) = min {\n        if let Some(max) = max {\n    \
    \        if max < min {\n                min = max;\n            } else {\n  \
    \              max = Some(min);\n            }\n        } else {\n           \
    \ max = Some(min);\n        }\n    }\n\n    (*min).expect(\"min is none\"), (*max).expect(\"\
    max is none\")", "    let mut smallest = numbers[0];\n    let mut largest = numbers[0];\n\
    \n    for num in numbers {\n        if num < smallest {\n            largest =\
    \ num;\n            smallest = num;\n        } else {\n            if num > largest\
    \ {\n                largest = num;\n            }\n        }\n    }\n    (smallest,\
    \ largest)", "    // First element in the vector should be the lowest value\n\
    \    let lowest_number = numbers[0];\n\n    // Find the next highest value\n \
    \   let lowest_number = numbers[1];\n    let mut index = 1;\n    let mut found\
    \ = false;\n    while !found {\n        let number = numbers[index];\n       \
    \ if number > lowest_number {\n            found = true;\n        }\n        else\
    \ {\n            // Increment index\n            index += 1;\n            if index\
    \ >= numbers.len() {\n                index = 0;\n            }\n        }\n \
    \   }\n    (lowest_number, numbers[index])", "    // Find the first index\n  \
    \  let mut index = numbers.iter().min_by_key(|n| f64::abs(n));\n    // Find the\
    \ second index\n    let mut index2 = numbers.iter().max_by_key(|n| f64::abs(n));\n\
    \    (numbers[index], numbers[index2])", "    let mut min_distance = std::f64::MAX;\n\
    \    let mut min_number = None;\n\n    for number in numbers {\n        let distance\
    \ = number.powf(2.0);\n        if min_distance > distance {\n            min_distance\
    \ = distance;\n            min_number = number;\n        }\n    }\n    (min_number,\
    \ min_distance)", "    let mut min_diff = std::f64::MAX;\n    let mut min_val\
    \ = 0.0;\n    for n in numbers {\n        let diff = &n - &min_val;\n        if\
    \ diff < &min_diff {\n            min_val = n;\n            min_diff = diff;\n\
    \        }\n    }\n\n    (min_val, min_diff)", "    if numbers.len() < 2 {\n \
    \       return (0., 0.);\n    }\n    find_closest_elements_impl_inner(numbers,\
    \ numbers[0], numbers[1])", "    numbers.iter()\n        .zip(numbers.iter().cloned().skip(1))\n\
    \        .filter(|(_, v)| v != numbers[0])\n        .collect()", "    let mut\
    \ min_val = numbers[0];\n    let mut max_val = numbers[0];\n    let mut min_idx\
    \ = 1;\n    let mut max_idx = 1;\n\n    for i in numbers.iter_mut() {\n      \
    \  if *i < min_val {\n            *i = min_val;\n            min_idx += 1;\n \
    \       } else if *i > max_val {\n            *i = max_val;\n            max_idx\
    \ += 1;\n        }\n    }\n\n    (min_val, numbers[min_idx as usize])", "    assert!(numbers.len()\
    \ >= 2);\n\n    let mut min_distance: f64 = numbers[0];\n    let mut max_distance:\
    \ f64 = numbers[0];\n    for number in numbers {\n        if number < min_distance\
    \ {\n            min_distance = number;\n        }\n        if number > max_distance\
    \ {\n            max_distance = number;\n        }\n    }\n    (min_distance,\
    \ max_distance)", "    let mut min_diff = std::f64::MAX;\n    let mut closest_numbers\
    \ = Vec::new();\n    for i in 0..numbers.len() - 1 {\n        let diff = numbers[i]\
    \ - numbers[i - 1].abs();\n        if diff < min_diff {\n            closest_numbers.push((numbers[i],\
    \ numbers[i - 1]));\n            min_diff = diff;\n        } else if diff == min_diff\
    \ {\n            closest_numbers.push((numbers[i], numbers[i - 1]));\n       \
    \ }\n    }\n    (closest_numbers[0].0, closest_numbers[1])", "    let mut smallest_val\
    \ = numbers[0] as f64;\n    let mut largest_val = numbers[0] as f64;\n    let\
    \ mut current_index = numbers.iter().skip(1).count();\n    for i in numbers.iter().rev()\
    \ {\n        if current_index == 0 {\n            return (i, i);\n        }\n\
    \        if i.abs() < smallest_val.abs() {\n            smallest_val = i;\n  \
    \      }\n        if largest_val < i {\n            largest_val = i;\n       \
    \ }\n        current_index -= 1;\n    }\n    (smallest_val, largest_val)", " \
    \   if numbers.len() < 2 {\n        return (0., 0.);\n    }\n    let mut min_val\
    \ = numbers[0];\n    let mut max_val = numbers[0];\n    for i in 0..numbers.len()\
    \ {\n        let val = numbers[i];\n        if val < min_val {\n            min_val\
    \ = val;\n        }\n        if val > max_val {\n            max_val = val;\n\
    \        }\n    }\n    (min_val, max_val)", "    // If there are less than two\
    \ numbers, there's nothing to do.\n    if numbers.len() < 2 {\n        return\
    \ (0.f64, 0.f64);\n    }\n\n    let mut smallest = numbers[0];\n    let mut largest\
    \ = numbers[0];\n\n    // Loop through the vector.\n    for number in numbers.iter().rev()\
    \ {\n        // Find the smallest and largest numbers.\n        if smallest >\
    \ number {\n            smallest = number;\n        }\n        if largest < number\
    \ {\n            largest = number;\n        }\n    }\n    (smallest, largest)",
  "    if numbers[0] < numbers[1] {\n        numbers.swap(0, 1)\n    }\n    numbers",
  "    let (min_elem, max_elem) = (numbers[0], 1.0);\n    let mut min_distance = 1.0;\n\
    \    let mut min_idx = 1;\n    for (i, x) in numbers.iter().enumerate() {\n  \
    \      let distance = (x - min_elem).abs();\n        if min_distance > distance\
    \ {\n            min_distance = distance;\n            min_idx = i;\n        }\n\
    \    }\n    (numbers[min_idx], numbers[min_idx + 1])", "    let mut closest_to_center\
    \ = numbers[0].clone(); // default to the first number if the vector is empty\n\
    \    let mut furthest_from_center = numbers[0].clone();\n    let mut smallest_distance\
    \ = numbers[0].clone();\n\n    for i in 1..numbers.len() {\n        let current_distance\
    \ = closest_to_center.partial_cmp(&numbers[i]).unwrap();\n        if current_distance\
    \ < smallest_distance.partial_cmp(&numbers[i]) {\n            smallest_distance\
    \ = current_distance;\n            closest_to_center = numbers[i];\n        }\n\
    \n        // Now that we know the distance to the center of the vector and the\
    \ distance to the furthest point,\n        // it's easy to calculate the distances\
    \ to the other points using basic trigonometry (cos and sin)\n        let theta\
    \ = numbers[i] - closest_to_center;\n        let distance_to_furthest_point =\
    \ furthest_from_center.partial_cmp(&numbers[i]).unwrap();\n        if distance_to_furthest_point\
    \ < smallest_distance.partial_cmp(&numbers[i]) {\n            smallest_distance\
    \ = distance_to_furthest_point;\n            furthest_from_center = numbers[i];\n\
    \        }\n    }\n\n    // Return the 2 closest points\n    (closest_to_center,\
    \ furthest_from_center)", "    let mut closest_index = (0.0, 0.0);\n    let mut\
    \ closest_element = (0.0, 0.0);\n    let mut closest = numbers[0];\n\n    for\
    \ index in 1..numbers.len() {\n        if numbers[index] < closest {\n       \
    \     closest_element = (numbers[index], index);\n            closest_index =\
    \ (numbers[index], index);\n            closest = numbers[index];\n        } else\
    \ {\n            if numbers[index] < closest_element {\n                closest_element\
    \ = (numbers[index], index);\n                closest_index = (numbers[index],\
    \ index);\n            }\n        }\n    }\n    closest_element", "    let mut\
    \ smaller_num = numbers[0];\n    let mut larger_num = numbers[0];\n    for num\
    \ in numbers {\n        if num < smaller_num {\n            smaller_num = num;\n\
    \        } else if num > larger_num {\n            larger_num = num;\n       \
    \ }\n    }\n    (smaller_num, larger_num)", "    if numbers.len() >= 2 {\n   \
    \     let mut max_diff =\n            numbers[0]\n                .abs()\n   \
    \             .min(numbers[1].abs())\n                .unwrap_or(numbers[0]);\n\
    \        let mut min_diff =\n            numbers[0]\n                .abs()\n\
    \                .min(numbers[1].abs())\n                .unwrap_or(numbers[0]);\n\
    \        let mut smallest = numbers[0];\n        let mut largest = numbers[0];\n\
    \        for n in numbers[1..] {\n            let d = n.abs();\n            if\
    \ d < min_diff {\n                min_diff = d\n            }\n            if\
    \ d > max_diff {\n                max_diff = d\n            }\n            if\
    \ n < smallest {\n                smallest = n\n            }\n            if\
    \ n > largest {\n                largest = n\n            }\n        }\n     \
    \   (smallest, largest)\n    } else {\n        (numbers[0], numbers[0])\n    }",
  "    let mut smallest_number = numbers[0] as f64;\n    let mut largest_number =\
    \ numbers[0] as f64;\n\n    for i in 1..numbers.len() {\n        if numbers[i]\
    \ < smallest_number {\n            smallest_number = numbers[i];\n        }\n\
    \        if numbers[i] > largest_number {\n            largest_number = numbers[i];\n\
    \        }\n    }\n\n    (smallest_number, largest_number)", "    let mut smallest_two\
    \ = numbers[..];\n    let mut closest_two = numbers[..];\n\n    let mut smallest_one\
    \ = numbers[..];\n    let mut closest_one = numbers[..];\n\n    for i in 0..numbers.len()\
    \ - 1 {\n        if smallest_two.last().unwrap() < numbers[i].unwrap() {\n   \
    \         smallest_one = numbers[..i];\n            closest_one = numbers[i ..\
    \ numbers.len()].clone();\n        }\n        if smallest_one.last().unwrap()\
    \ < numbers[i].unwrap() {\n            smallest_two = numbers[i .. numbers.len()].clone();\n\
    \            closest_two = numbers[..i].clone();\n        }\n    }\n    (closest_one,\
    \ closest_two)", "    // Find smallest and largest number\n    let (smallest_num,\
    \ largest_num) = numbers.iter().fold((numbers[0], numbers[1]), |(smallest, largest),\
    \ number| {\n        if smallest > number {\n            smallest, number\n  \
    \      } else {\n            largest, number\n        }\n    });\n\n    // Calculate\
    \ midpoint between the two\n    let mid = (f64::from(largest_num) + f64::from(smallest_num))\
    \ / 2.0;\n\n    // Find two numbers whose midpoint is closest to each other\n\
    \    let mid1 = (f64::from(mid) - f64::from(smallest_num)) / 2.0;\n    let mid2\
    \ = (f64::from(mid) + f64::from(largest_num)) / 2.0;\n\n    // Return closest\
    \ number pairs\n    (mid1, mid2)", "    assert!(numbers.len() >= 2);\n    let\
    \ mut best = numbers[0] as f64;\n    let mut worst = numbers[0] as f64;\n    let\
    \ mut min_diff = std::f64::MAX;\n    for i in 0..numbers.len() {\n        let\
    \ diff = (numbers[i] - best).abs();\n        if diff < min_diff {\n          \
    \  best = numbers[i];\n            min_diff = diff;\n        }\n        let diff\
    \ = (numbers[i] - worst).abs();\n        if diff > min_diff {\n            worst\
    \ = numbers[i];\n            min_diff = diff;\n        }\n    }\n    (best, worst)",
  "    // find the two numbers with the smallest difference\n    // subtract both\
    \ numbers from the first number - smallest difference\n    let min_difference\
    \ = numbers[0] - numbers[1];\n\n    // find the two numbers with the largest difference\n\
    \    let max_difference = numbers[0] - numbers[2];\n\n    // subtract both numbers\
    \ from the second number - largest difference\n    let second_number = numbers[1]\
    \ - max_difference;\n\n    (min_difference, second_number)", "    let mut min\
    \ = std::f64::MAX;\n    let mut max = std::f64::MIN;\n    for n in numbers.iter()\
    \ {\n        let delta = n - min;\n        if delta < min {\n            min =\
    \ delta;\n        }\n        if delta > max {\n            max = delta;\n    \
    \    }\n    }\n    min, max", '    numbers.windows(2).min_by_key(|&a| a)', " \
    \   if numbers.len() < 2 {\n        panic!(\"Numbers vector must have at least\
    \ two elements\");\n    }\n\n    let mut smallest_diff = std::f64::MAX;\n    let\
    \ mut largest_diff = -std::f64::MAX;\n    let mut best_match = (numbers[0], numbers[0]);\n\
    \    let mut best_match_vec: Vec<f64> = vec![];\n\n    for i in 1..numbers.len()\
    \ {\n        let diff = (numbers[i] - best_match[0]);\n        let mut new_diff\
    \ = diff as f64;\n\n        if smallest_diff > new_diff {\n            smallest_diff\
    \ = new_diff;\n            best_match = (numbers[i], best_match[0]);\n       \
    \     best_match_vec.push(best_match[0]);\n        } else {\n            largest_diff\
    \ = new_diff;\n        }\n\n        let mut best_match_vec: Vec<f64> = vec![];\n\
    \    }\n\n    (best_match, best_match_vec)", "    use std::cmp::Ordering;\n  \
    \  let mut smallest = numbers[0];\n    let mut largest = numbers[0];\n    for\
    \ &n in numbers {\n        if smallest > n {\n            smallest = n;\n    \
    \    }\n        if largest < n {\n            largest = n;\n        }\n    }\n\
    \    let mut min = Ordering::<f64>().cloned();\n    let mut max = Ordering::<f64>().cloned();\n\
    \    for i in 0..numbers.len() {\n        if numbers[i] > max {\n            max\
    \ = numbers[i];\n        }\n        if numbers[i] < min {\n            min = numbers[i];\n\
    \        }\n    }\n    (smallest, largest)", "    let mut smallest = numbers[0]\
    \ as f64;\n    let mut largest = numbers[0] as f64;\n    for n in numbers {\n\
    \        if n > largest {\n            largest = n as f64;\n        }\n      \
    \  if n < smallest {\n            smallest = n as f64;\n        }\n    }\n   \
    \ (smallest, largest)", "    if numbers.len() < 2 {\n        return (0.f64, 0.f64);\n\
    \    }\n\n    let mut closest_to_small = numbers[0];\n    let mut closest_to_large\
    \ = numbers[0];\n\n    for number in numbers.iter().rev() {\n        if number\
    \ < closest_to_large {\n            closest_to_small = closest_to_large;\n   \
    \         closest_to_large = number;\n        } else if number < closest_to_small\
    \ {\n            closest_to_small = number;\n        }\n    }\n\n    (closest_to_small,\
    \ closest_to_large)", "    use std::cmp::min;\n    use std::cmp::max;\n\n    if\
    \ numbers.len() < 2 {\n        return (0, 0);\n    }\n    let mut largest = numbers[0]\
    \ as f64;\n    let mut smallest = numbers[0] as f64;\n    for &n in &numbers[1..]\
    \ {\n        let distance = max(n - largest, n - smallest);\n        if distance\
    \ == 0.0 {\n            continue;\n        }\n        if n == largest {\n    \
    \        largest = n;\n        } else if n == smallest {\n            smallest\
    \ = n;\n        } else {\n            (smallest, largest);\n        }\n    }\n\
    \    (smallest, largest);", "    let mut best = match &numbers[1..] {\n      \
    \  &[a, b] if b - a < 0.01 => (a, a),\n        &[a, b] if b - a > 0.01 => (a,\
    \ b),\n        _ => (numbers[0], numbers[0]),\n    };\n\n    for i in 2..numbers.len()\
    \ {\n        let mut cur = match &numbers[i..] {\n            &[a, b] if b - a\
    \ < 0.01 => (a, b),\n            &[a, b] if b - a > 0.01 => (b, a),\n        \
    \    _ => (numbers[0], numbers[0]),\n        };\n\n        if cur.0 > best.0 {\n\
    \            best = cur;\n        }\n        if cur.1 > best.1 {\n           \
    \ best = cur;\n        }\n    }\n\n    (best.0, best.1)", "    if numbers.is_empty()\
    \ {\n        return (0.0, 0.0);\n    }\n    let mut smaller = numbers[0];\n  \
    \  let mut larger = numbers[0];\n    for i in numbers.iter().rev() {\n       \
    \ if smaller.partial_cmp(&i) < 0 {\n            smaller = i;\n        }\n    \
    \    if larger.partial_cmp(&i) > 0 {\n            larger = i;\n        }\n   \
    \ }\n    (smaller, larger)", "    let mut min_diff = std::f64::MAX;\n    let mut\
    \ min_diff = std::f64::MAX;\n    let mut min_ele = std::f64::MAX;\n    for (i,\
    \ x) in numbers.iter().enumerate() {\n        let diff = x - numbers[0];\n   \
    \     if diff < min_diff {\n            min_diff = diff;\n            min_ele\
    \ = i;\n        }\n    }\n\n    (numbers[min_ele], numbers[min_ele + 1])", " \
    \   if numbers.len() < 2 {\n        return (0.f64, 0.f64);\n    }\n\n    let mut\
    \ smallest_distance = numbers[0].abs();\n    let mut closest_numbers = [numbers[0],\
    \ 0.f64];\n    let mut second_closest_numbers = [0.f64, 0.f64];\n\n    for (i,\
    \ number) in numbers.iter().enumerate() {\n        let distance = number.abs();\n\
    \        if i == 0 {\n            smallest_distance = distance;\n        }\n\n\
    \        if distance < smallest_distance {\n            smallest_distance = distance;\n\
    \            closest_numbers[0] = number;\n            closest_numbers[1] = closest_numbers[0];\n\
    \        }\n        else {\n            closest_numbers[1] = number;\n       \
    \ }\n\n        if i == numbers.len() - 1 {\n            second_closest_numbers[0]\
    \ = closest_numbers[1];\n            second_closest_numbers[1] = closest_numbers[0];\n\
    \        }\n    }\n\n    (closest_numbers[0], closest_numbers[1])", "    if numbers.len()\
    \ < 2 {\n        (numbers[0], numbers[0])\n    } else {\n        let mut min:\
    \ f64 = numbers[0];\n        let mut max: f64 = numbers[0];\n        for i in\
    \ 1..numbers.len() {\n            if numbers[i] > max {\n                max =\
    \ numbers[i];\n            }\n            if numbers[i] < min {\n            \
    \    min = numbers[i];\n            }\n        }\n        (min, max)\n    }",
  "    let mut min = numbers[0];\n    let mut max = numbers[0];\n    let mut min_idx\
    \ = 1;\n    let mut max_idx = 1;\n\n    for i in 1..numbers.len() {\n        if\
    \ min > numbers[i] {\n            max = numbers[i];\n            max_idx = i;\n\
    \        } else {\n            min = numbers[i];\n            min_idx = i;\n \
    \       }\n    }\n    (min, max);\n    (min_idx, max_idx);", "    let mut smallest_distance\
    \ = std::f64::MAX;\n    let mut largest_distance: f64 = std::f64::MIN;\n\n   \
    \ let mut closest_element1: usize = 0;\n    let mut closest_element2: usize =\
    \ 0;\n\n    for i in 0..numbers.len() - 1 {\n        // first element\n      \
    \  let difference = numbers[i] - numbers[0];\n\n        // check if the number\
    \ is closer\n        if difference < smallest_distance {\n            smallest_distance\
    \ = difference;\n            closest_element1 = i;\n        }\n\n        // second\
    \ element\n        let difference = numbers[i + 1] - numbers[i + 2];\n\n     \
    \   // check if the number is closer\n        if difference < smallest_distance\
    \ {\n            smallest_distance = difference;\n            closest_element2\
    \ = i + 1;\n        }\n\n        // if the smallest distance is smaller than the\
    \ maximum distance\n        // then update the max distance\n        if smallest_distance\
    \ > largest_distance {\n            largest_distance = smallest_distance;\n  \
    \      }\n    }\n\n    (numbers[closest_element1], numbers[closest_element2])",
  "    if numbers.len() < 2 {\n        (numbers[0], numbers[0])\n    } else {\n  \
    \      let mut smallest = numbers[0];\n        let mut largest = numbers[0];\n\
    \n        for i in 1..numbers.len() {\n            let mut diff = numbers[i] -\
    \ smallest;\n            if diff < smallest {\n                smallest = diff;\n\
    \            }\n            diff = numbers[i] - largest;\n            if diff\
    \ > largest {\n                largest = diff;\n            }\n        }\n\n \
    \       (smallest, largest)\n    }", "    let mut smaller = numbers[0];\n    let\
    \ mut larger = numbers[0];\n    let mut smallest_idx = 0;\n    let mut largest_idx\
    \ = numbers.len();\n\n    while smallest_idx < largest_idx {\n        let mut\
    \ current_idx = smallest_idx;\n        let mut current_number = numbers[smallest_idx];\n\
    \        smallest_idx += 1;\n\n        for idx in 0..smallest_idx {\n        \
    \    let current_number = numbers[idx];\n            if current_number < current_number\
    \ {\n                smaller = current_number;\n                current_idx =\
    \ idx;\n            }\n        }\n        largest_idx -= 1;\n\n        for idx\
    \ in 0..largest_idx {\n            let current_number = numbers[idx];\n      \
    \      if current_number > current_number {\n                larger = current_number;\n\
    \                current_idx = idx;\n            }\n        }\n\n        // We\
    \ found the smaller number\n        if smaller * larger == current_number\n  \
    \          || smaller * larger < current_number\n        {\n            return\
    \ (smaller, larger);\n        }\n    }\n    (numbers[largest_idx], numbers[largest_idx])",
  "    assert!(numbers.len() >= 2);\n    let mut min_element = numbers[0];\n    let\
    \ mut max_element = numbers[0];\n    for element in &numbers[1..] {\n        if\
    \ element < min_element {\n            min_element = element;\n        }\n   \
    \     if element > max_element {\n            max_element = element;\n       \
    \ }\n    }\n    (min_element, max_element)", "    numbers.windows(2).min_by_key(|i|\
    \ {\n        i.partial_cmp(&i.0).unwrap()\n    }).collect()", "    numbers.iter().enumerate().fold(\n\
    \        std::cmp::min(\n            numbers[0],\n            numbers.iter()\n\
    \                .map(|&n| f64::abs(n - numbers[0]))\n                .min_by(|a,\
    \ b| b.partial_cmp(a).unwrap()),\n        ),\n        |min| std::cmp::min(min,\
    \ numbers[0]),\n    )", "    let mut current_minimum = numbers[0]\n    let mut\
    \ current_maximum = numbers[0];\n\n    let mut smaller_element = numbers[1];\n\
    \    let mut larger_element = numbers[1];\n\n    for i in numbers.iter().rev()\
    \ {\n        if i < current_minimum {\n            current_minimum = i;\n    \
    \        smaller_element = numbers[i];\n        }\n\n        if i > current_maximum\
    \ {\n            current_maximum = i;\n            larger_element = numbers[i];\n\
    \        }\n    }\n\n    (current_minimum, current_maximum)", "    assert!(numbers.size()\
    \ >= 2);\n\n    let mut best = numbers[0];\n    let mut worst = numbers[0];\n\
    \    for n in numbers {\n        if n > best {\n            worst = best;\n  \
    \          best = (n as f64).abs();\n        } else {\n            worst = (n\
    \ as f64).abs();\n        }\n    }\n\n    (best, worst)", "    let len = numbers.size();\n\
    \    if len < 2 {\n        panic!(\"find_closest_elements(): Vec must have at\
    \ least 2 elements\");\n    }\n\n    let min_diff = std::f64::MAX;\n    let min_val\
    \ = numbers[0];\n    let min_idx = 1;\n    for (i, n) in numbers.iter().enumerate()\
    \ {\n        let diff = std::f64::abs(n - min_val);\n        if diff < min_diff\
    \ {\n            min_diff = diff;\n            min_val = n;\n            min_idx\
    \ = i;\n        }\n    }\n\n    (min_val, min_idx)", "    if numbers.is_empty()\
    \ {\n        return (0, 0);\n    }\n\n    let mut largest = numbers[0];\n    let\
    \ mut smallest = numbers[0];\n    let mut index = 0;\n    while index < numbers.len()\
    \ {\n        if numbers[index] < smallest {\n            smallest = numbers[index];\n\
    \        }\n        if numbers[index] > largest {\n            largest = numbers[index];\n\
    \        }\n        index += 1;\n    }\n\n    smallest, largest", "    let mut\
    \ smallest = numbers[0];\n    let mut largest = numbers[0];\n\n    for number\
    \ in numbers {\n        if number < smallest {\n            smallest = number;\n\
    \        } else if number > largest {\n            largest = number;\n       \
    \ }\n    }\n    (smallest, largest)", "    let mut current_min = numbers[0];\n\
    \    let mut current_max = numbers[0];\n    for number in &numbers[1..] {\n  \
    \      let dist = number.abs();\n        if dist < current_min {\n           \
    \ current_min = dist;\n        }\n        if dist > current_max {\n          \
    \  current_max = dist;\n        }\n    }\n    (current_min, current_max)", " \
    \   // If there are less than two elements, just return the numbers.\n    if numbers.len()\
    \ < 2 {\n        return numbers;\n    }\n\n    // Calculate the distance between\
    \ each pair of elements and return the one with the smallest distance.\n    let\
    \ mut min_distance = Vec::new();\n    for (i, &number) in numbers.iter().enumerate()\
    \ {\n        for j in (i + 1).iter().skip(1) {\n            let distance = (number\
    \ - numbers[j]).abs();\n            min_distance.push(distance);\n        }\n\
    \    }\n    min_distance.sort_unstable_by(|a, b| a.partial_cmp(b));\n\n    //\
    \ Return the smallest two numbers in the vector.\n    let mut numbers_filtered\
    \ = Vec::new();\n    for distance in min_distance {\n        if numbers_filtered.len()\
    \ < 2 {\n            numbers_filtered.push(numbers[distance]);\n        } else\
    \ {\n            if numbers_filtered[0] == numbers[distance] {\n             \
    \   if numbers_filtered[1] < numbers[distance] {\n                    // If the\
    \ first number in the list is less than the second number in the list, we must\
    \ choose the first number\n                    // to be the new first number in\
    \ the list.\n                    numbers_filtered[0] = numbers[distance];\n  \
    \              } else {\n                    // If the second number in the list\
    \ is less than the second number in the list, we must choose the second\n    \
    \                // number to be the new first number in the list.\n         \
    \           numbers_filtered[1] = numbers[distance];\n                }\n    \
    \        } else {\n                // If the first number in the list is less\
    \ than the second number in the list, we must choose the first\n             \
    \   // number to be the new first number in the list.\n                numbers_filtered.push(numbers[distance]);\n\
    \            }\n        }\n    }\n    (numbers_filtered[0], numbers_filtered[1])",
  "    numbers.iter()\n        .enumerate()\n        .sort_by(|(a, b), (i, _)| f64::cmp(&a[1],\
    \ &b[1]))\n        .take(2)\n        .map(|(i, _)| (numbers[i], numbers[i + 1]))\n\
    \        .collect()", "    let mut min: f64 = numbers[0];\n    let mut max: f64\
    \ = numbers[0];\n\n    for number in numbers.iter().skip(1) {\n        let delta\
    \ = number.sub(min);\n        if delta < 0.0 {\n            min = number;\n  \
    \      } else {\n            max = number;\n        }\n    }\n    (min, max)",
  "    let mut smallest = numbers[0];\n    let mut largest = numbers[0];\n    for\
    \ i in 1..numbers.len() {\n        let mut new_smallest = numbers[i];\n      \
    \  let mut new_largest = numbers[i];\n        if smallest > new_smallest {\n \
    \           new_smallest = smallest;\n        }\n        if largest < new_largest\
    \ {\n            new_largest = largest;\n        }\n        if smallest > new_smallest\
    \ {\n            smallest = new_smallest;\n        }\n        if largest < new_largest\
    \ {\n            largest = new_largest;\n        }\n    }\n    (smallest, largest)",
  "    let mut smallest = numbers[0];\n    let mut largest = numbers[0];\n    for\
    \ n in numbers.iter() {\n        if n < smallest {\n            smallest = n;\n\
    \        }\n        if n > largest {\n            largest = n;\n        }\n  \
    \  }\n    (smallest, largest)", "    let mut numbers_iter = numbers.iter().cloned();\n\
    \    let mut min_val = numbers[0];\n    let mut max_val = numbers[0];\n    let\
    \ mut cur_val = numbers[0];\n    while let Some(&x) = numbers_iter.next() {\n\
    \        cur_val = x;\n        if min_val == x {\n            min_val = x;\n \
    \       }\n        if max_val == x {\n            max_val = x;\n        }\n  \
    \  }\n    let min_val_index = numbers.iter().position(|&x| x == min_val);\n  \
    \  let max_val_index = numbers.iter().position(|&x| x == max_val);\n    (min_val\
    \ + max_val) / 2, numbers[min_val_index]", "    if numbers.len() < 2 {\n     \
    \   return (0., 0.);\n    }\n    let mut max_element = numbers[0];\n    let mut\
    \ min_element = numbers[0];\n\n    for &n in numbers {\n        if n > max_element\
    \ {\n            max_element = n;\n        }\n        if n < min_element {\n \
    \           min_element = n;\n        }\n    }\n\n    (min_element, max_element)",
  "    let mut min_value = numbers[0];\n    let mut max_value = numbers[0];\n    for\
    \ num in numbers {\n        let difference = num - min_value;\n        if difference\
    \ < 0 {\n            min_value = num;\n        } else if difference > 0 {\n  \
    \          max_value = num;\n        }\n    }\n    (min_value, max_value)", " \
    \   if numbers.size() < 2 {\n        return (0, numbers[0]);\n    }\n\n    let\
    \ mut closest = (numbers[0], numbers[0]);\n    let mut smallest = (numbers[0],\
    \ numbers[0]);\n\n    for &num in &numbers[1..] {\n        let mut closest = (numbers[0],\
    \ numbers[0]);\n\n        for &value in &mut closest {\n            if value <\
    \ num {\n                *value = num;\n            }\n        }\n\n        if\
    \ smallest == (numbers[0], numbers[0]) {\n            smallest = closest;\n  \
    \      } else {\n            if smallest == closest\n                || (smallest\
    \ as f64) - (closest as f64) < smallest\n            {\n                smallest\
    \ = closest;\n            }\n        }\n    }\n\n    (closest, smallest)", " \
    \   let mut result = numbers[0];\n    let mut best = f64::MAX;\n    for i in 1..numbers.len()\
    \ {\n        if numbers[i] - result < best {\n            best = numbers[i] -\
    \ result;\n            result = i;\n        }\n    }\n    (result, best)", " \
    \   let mut smallest_difference = numbers[0];\n    let mut second_smallest_difference\
    \ = numbers[0];\n    for (i, number) in numbers.iter().enumerate() {\n       \
    \ let difference_with_smallest = (number.abs() - smallest_difference).abs();\n\
    \        if difference_with_smallest < second_smallest_difference {\n        \
    \    second_smallest_difference = difference_with_smallest;\n            smallest_difference\
    \ = number;\n        } else if difference_with_smallest == second_smallest_difference\
    \ {\n            smallest_difference = number;\n        }\n    }\n    (smallest_difference,\
    \ second_smallest_difference)", "    let mut min_dist = std::f64::MAX;\n    let\
    \ mut min_num = numbers[0] as f64;\n    let mut max_num = numbers[0] as f64;\n\
    \    for num in numbers.iter().rev() {\n        let dist = *num - min_num;\n \
    \       if dist < min_dist {\n            min_dist = dist;\n            min_num\
    \ = num;\n        } else if dist > min_dist {\n            max_num = num;\n  \
    \      }\n    }\n    (min_num, max_num)", "    let mut current_min = (numbers[0].clone(),\
    \ numbers[1].clone());\n    let mut current_max = (numbers[0].clone(), numbers[1].clone());\n\
    \    let mut next_min = (numbers[0].clone(), numbers[1].clone());\n    let mut\
    \ next_max = (numbers[0].clone(), numbers[1].clone());\n    for number in numbers[1..]\
    \ {\n        let (min, max) = if number > current_min.1 {\n            current_min\
    \ = number\n        } else {\n            current_max = number\n        };\n \
    \       if number < next_min.1 {\n            next_min = number\n        } else\
    \ {\n            next_max = number\n        };\n    }\n    (current_min, next_min),\
    \ (current_max, next_max)", "    if numbers.len() < 2 {\n        std::vec::Vec::new()\n\
    \    } else {\n        let mut current_distance = std::vec::Vec::new();\n    \
    \    let mut current_index = std::vec::Vec::new();\n\n        for &n in &numbers\
    \ {\n            if !current_distance.is_empty() {\n                if current_distance.last().unwrap()\
    \ < n {\n                    current_index.remove_last_mut();\n              \
    \      current_distance.pop();\n                } else {\n                   \
    \ current_index.push(i);\n                }\n            }\n\n            current_distance.push(n);\n\
    \            current_index.push(i);\n        }\n\n        if current_distance.is_empty()\
    \ {\n            (0.0, 0.0)\n        } else {\n            (\n               \
    \ numbers[current_index[0].unwrap()],\n                numbers[current_index[1].unwrap()],\n\
    \            )\n        }\n    }", "    let mut min = numbers[0];\n    let mut\
    \ max = numbers[0];\n    for &num in numbers {\n        if num < min {\n     \
    \       min = num;\n        }\n        if num > max {\n            max = num;\n\
    \        }\n    }\n    (min, max)", "    let len = numbers.len();\n    if len\
    \ < 2 {\n        return numbers[0], numbers[0];\n    }\n\n    let mut smallest\
    \ = numbers[0];\n    let mut largest = numbers[0];\n\n    for number in numbers\
    \ {\n        if number > largest {\n            largest = number;\n        }\n\
    \        if number < smallest {\n            smallest = number;\n        }\n \
    \   }\n\n    (smallest, largest)", "    let mut min_value = numbers[0];\n    let\
    \ mut min_distance_to_min_value = f64::MAX;\n    let mut max_value = numbers[0];\n\
    \    let mut max_distance_to_max_value = f64::MAX;\n\n    for i in 1..numbers.len()\
    \ {\n        let value = numbers[i];\n        let distance_to_min_value = f64::MAX;\n\
    \        let distance_to_max_value = f64::MAX;\n        for j in 0..i-1 {\n  \
    \          let d = f64::max(value - numbers[j], f64::MIN);\n            distance_to_min_value\
    \ = f64::min(distance_to_min_value, d);\n            distance_to_max_value = f64::max(distance_to_max_value,\
    \ d);\n        }\n        let distance = (distance_to_min_value as f64) + (distance_to_max_value\
    \ as f64);\n        if distance < min_distance_to_min_value {\n            min_distance_to_min_value\
    \ = distance;\n            min_value = value;\n        }\n        if distance\
    \ > max_distance_to_max_value {\n            max_distance_to_max_value = distance;\n\
    \            max_value = value;\n        }\n    }\n    (min_value, max_value)",
  "    debug_assert!(numbers.len() >= 2);\n\n    let mut min_num = numbers[0] as f64;\n\
    \    let mut min_dist = numbers[0] as f64;\n    let mut max_num = numbers[0] as\
    \ f64;\n    let mut max_dist = numbers[0] as f64;\n\n    for i in 1..numbers.len()\
    \ {\n        let num = numbers[i] as f64;\n        let dist = i - 1;\n       \
    \ let (mut min_num2, mut min_dist2, mut max_num2, mut max_dist2) = find_closest_elements_helper(num,\
    \ dist, min_num, min_dist, max_num, max_dist, numbers, i);\n        (min_num2,\
    \ min_dist2)\n        => (min_num2, min_dist2)\n        if min_num2 < min_num\
    \ {\n            min_num = min_num2;\n            min_dist = min_dist2;\n    \
    \    }\n\n        (max_num2, max_dist2)\n        => (max_num2, max_dist2)\n  \
    \      if max_num2 > max_num {\n            max_num = max_num2;\n            max_dist\
    \ = max_dist2;\n        }\n    }\n\n    (min_num, min_dist)", "    let mut min_number\
    \ = numbers[0];\n    let mut max_number = numbers[0];\n    for number in numbers\
    \ {\n        if number < min_number {\n            min_number = number;\n    \
    \    } else if number > max_number {\n            max_number = number;\n     \
    \   }\n    }\n\n    let mut min_element = min_number;\n    let mut max_element\
    \ = max_number;\n\n    for element in numbers {\n        if element < min_number\
    \ {\n            min_element = element;\n        } else if element > max_number\
    \ {\n            max_element = element;\n        }\n    }\n\n    (min_element,\
    \ max_element)", "    let mut smallest_number = numbers[0];\n    let mut greatest_number\
    \ = numbers[0];\n\n    for (i, element) in numbers.iter().enumerate() {\n    \
    \    let current_number = element;\n        if current_number < greatest_number\
    \ {\n            greatest_number = current_number;\n            smallest_number\
    \ = greatest_number;\n        } else if current_number > greatest_number {\n \
    \           greatest_number = current_number;\n            smallest_number = current_number;\n\
    \        }\n    }\n    (smallest_number, greatest_number)", "    // TODO: assert\
    \ all numbers are >= 0\n    let mut smallest = (numbers[0], numbers[0]);\n   \
    \ let mut largest = (numbers[0], numbers[0]);\n    for num in numbers {\n    \
    \    let delta = largest.0 - num;\n        if delta < smallest.1 {\n         \
    \   smallest = (num, num);\n        } else {\n            largest = (num, num);\n\
    \        }\n    }\n    // Now smallest is the closest number but largest is still\
    \ the largest\n    (smallest.0, largest.1)", "    debug_assert!(numbers.len()\
    \ >= 2);\n\n    let mut min_element = numbers[0];\n    let mut max_element = numbers[0];\n\
    \    for i in 1..numbers.len() {\n        let element = numbers[i];\n        let\
    \ dist = i - min_element;\n        if dist < 0 {\n            continue;\n    \
    \    }\n        let tmp = element;\n        element = min_element;\n        min_element\
    \ = tmp;\n        let tmp = max_element;\n        max_element = element;\n   \
    \     element = tmp;\n    }\n    (min_element, max_element)", "    let mut min_dist\
    \ = numbers.iter().min().unwrap();\n    let mut min_element = numbers.iter().min().unwrap();\n\
    \n    let mut max_dist = numbers.iter().max().unwrap();\n    let mut max_element\
    \ = numbers.iter().max().unwrap();\n\n    for x in numbers {\n        if x < min_element\
    \ {\n            min_element = x;\n            min_dist = x;\n        }\n    \
    \    if x > max_element {\n            max_element = x;\n            max_dist\
    \ = x;\n        }\n    }\n\n    (min_element, min_dist)", "    let mut smallest\
    \ = numbers[0] as f64;\n    let mut largest = numbers[0] as f64;\n    for i in\
    \ 1..numbers.len() {\n        smallest = f32::min(smallest, numbers[i] as f64);\n\
    \        largest = f32::max(largest, numbers[i] as f64);\n    }\n    (smallest,\
    \ largest)", "    let mut lowest = vec![2**56, -2**56];\n    let mut highest =\
    \ vec![2**56, -2**56];\n\n    for &n in numbers {\n        let d = &n - lowest[0];\n\
    \        if d < 0 {\n            continue;\n        }\n        let mut tmp = lowest;\n\
    \        lowest[0] = n;\n        lowest[1] = tmp;\n    }\n\n    for &n in numbers\
    \ {\n        let d = &n - highest[0];\n        if d > 0 {\n            continue;\n\
    \        }\n        let mut tmp = highest;\n        highest[0] = n;\n        highest[1]\
    \ = tmp;\n    }\n\n    (lowest[0], lowest[1])", "    let mut i1 = 0;\n    let\
    \ mut i2 = numbers.len() - 1;\n    let mut diff1 = 0.0; // difference\n    let\
    \ mut diff2 = 0.0; // difference\n    let mut best = f64::MAX;\n\n    while i1\
    \ != i2 {\n        if numbers[i1] < numbers[i2] {\n            diff1 = numbers[i1];\n\
    \            diff2 = numbers[i2];\n            best = numbers[i2];\n         \
    \   i2 = i2 - 1;\n        } else {\n            diff1 = numbers[i1];\n       \
    \     diff2 = numbers[i2];\n            best = numbers[i1];\n            i1 =\
    \ i1 - 1;\n        }\n\n        if diff1 <= diff2 {\n            best = diff1;\n\
    \        } else {\n            best = diff2;\n        }\n    }\n\n    (numbers[best],\
    \ best)", "    // find minimum value first (if there are more min values then\
    \ return the last one we find).\n    let mut min: f64 = numbers.iter().min(|a,\
    \ b| a.partial_cmp(b).unwrap_or(b.partial_cmp(a).unwrap_or(0)))\n        .unwrap();\n\
    \    let mut min_index = 0;\n\n    // Now find second minimum value\n    for element\
    \ in numbers {\n        if element.partial_cmp(min).unwrap_or(element.partial_cmp(min).unwrap_or(0))\
    \ < 0 {\n            min = element;\n            min_index = elements.len() -\
    \ 1;\n        } else {\n            min_index -= 1;\n        }\n    }\n    (min,\
    \ min_index)", "    let mut closest_x = numbers[0];\n    let mut closest_y = numbers[0];\n\
    \n    for i in 1..numbers.len() {\n        let distance = distance(&numbers[i],\
    \ &closest_x);\n        if distance < closest_y {\n            closest_x = numbers[i];\n\
    \            closest_y = distance;\n        }\n    }\n\n    (closest_x, closest_y)",
  "    let mut smallest = numbers[0];\n    let mut largest = numbers[0];\n    let\
    \ mut smallest_index = -1;\n    let mut largest_index = -1;\n\n    for i in 1..numbers.len()\
    \ {\n        if numbers[i] < smallest {\n            smallest = numbers[i];\n\
    \            smallest_index = i;\n        }\n        if numbers[i] > largest {\n\
    \            largest = numbers[i];\n            largest_index = i;\n        }\n\
    \    }\n\n    (smallest_index, largest)", "    let mut best_dist = f64::MAX;\n\
    \    let mut best_num1 = f64::MAX;\n    let mut best_num2 = f64::MAX;\n\n    for\
    \ num1 in numbers {\n        let mut best_num2 = f64::MAX;\n\n        for num2\
    \ in numbers {\n            let dist = num1 - num2;\n            if dist < best_dist\
    \ {\n                best_dist = dist;\n                best_num1 = num1;\n  \
    \              best_num2 = num2;\n            }\n        }\n\n        // If we\
    \ found a pair of numbers that are closer to each other than the\n        // first\
    \ pair then we break out of the inner loop\n        if best_num1 > best_num2 {\n\
    \            break;\n        }\n    }\n\n    (best_num1, best_num2)", "    if\
    \ numbers.len() < 2 {\n        (numbers[0], numbers[0])\n    } else {\n      \
    \  let mut min = numbers[0];\n        let mut max = numbers[0];\n\n        for\
    \ n in numbers.iter().rev() {\n            let delta_n = max - min;\n        \
    \    if delta_n >= 0 {\n                // We found a number in the middle, return\
    \ the two numbers\n                let mut mid = min + ((max - min) / 2);\n  \
    \              (mid, n - delta_n + mid)\n            } else {\n              \
    \  // We found the smallest, return the two numbers\n                let mut mid\
    \ = min + ((max - min) / 2);\n                (n - delta_n, mid)\n           \
    \ }\n            min = n;\n            max = n;\n        }\n        (min, max)\n\
    \    }", "    debug_assert!(numbers.len() >= 2);\n    let mut min_diff = numbers.iter().map(|n|\
    \ f64::abs(n - numbers[0])).min().unwrap();\n    let mut max_diff = numbers.iter().map(|n|\
    \ f64::abs(n - numbers[0])).max().unwrap();\n    let mut min_dist = numbers.iter().map(|n|\
    \ f64::abs(n - numbers[0])).min_by_unstable().unwrap();\n    let mut max_dist\
    \ = numbers.iter().map(|n| f64::abs(n - numbers[0])).max_by_unstable().unwrap();\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    let mut min_dist\
    \ = numbers[0];\n    let mut max_dist = numbers[0];\n    for i in 1..numbers.len()\
    \ {\n        let diff = numbers[i] - numbers[i - 1];\n        if diff < min_diff\
    \ {\n            min_diff = diff;\n            min_dist = numbers[i];\n      \
    \  }\n        if diff > max_diff {\n            max_diff = diff;\n           \
    \ max_dist = numbers[i];\n        }\n        if numbers[i] < min {\n         \
    \   min = numbers[i];\n        }\n        if numbers[i] > max {\n            max\
    \ = numbers[i];\n        }\n        if numbers[i] < min_dist {\n            min_dist\
    \ = numbers[i];\n        }\n        if numbers[i] > max_dist {\n            max_dist\
    \ = numbers[i];\n        }\n    }\n    (min_dist, min_diff)", "    // Find the\
    \ two elements that are closest to each other in the vector\n    let mut min_dist\
    \ = f64::MAX;\n    let mut max_dist = numbers[0];\n\n    let mut min_element =\
    \ numbers[0];\n    let mut max_element = numbers[0];\n\n    for x in numbers {\n\
    \        let distance = x - min_element;\n\n        // If a new min has been found\
    \ update the current min\n        if distance < min_dist {\n            min_dist\
    \ = distance;\n            min_element = x;\n        }\n\n        // If a new\
    \ max has been found update the current max\n        if distance > max_dist {\n\
    \            max_dist = distance;\n            max_element = x;\n        }\n \
    \   }\n\n    (min_element, max_element)", "    if numbers.len() < 2 {\n      \
    \  return (numbers[0], numbers[1]);\n    }\n    let mut min_diff = std::f64::MAX;\n\
    \    let mut min_i = 1;\n    let mut min_val = numbers[0];\n    for &i in numbers[1..]\
    \ {\n        let diff = (i - min_val).abs();\n        if diff < min_diff {\n \
    \           min_diff = diff;\n            min_i = i;\n        }\n    }\n    (min_val,\
    \ min_i)", "    let mut smallest = numbers[0];\n    let mut largest = numbers[0];\n\
    \    for (i, element) in numbers.iter().enumerate() {\n        let mut smallest_new\
    \ = smallest;\n        let mut largest_new = largest;\n        if element < smallest_new\
    \ {\n            smallest_new = element;\n        }\n        if element > largest_new\
    \ {\n            largest_new = element;\n        }\n        if element < smallest\
    \ {\n            smallest = smallest_new;\n        }\n        if element > largest\
    \ {\n            largest = largest_new;\n        }\n    }\n    (smallest, largest)",
  "    let mut closest = &numbers[..];\n    let mut smallest = &numbers[..];\n   \
    \ let mut largest = &numbers[..];\n\n    for i in 0..(numbers.len() - 1) {\n \
    \       if *closest < *smallest\n            || *closest > *largest\n        \
    \    || *smallest < *largest\n        {\n            smallest = &numbers[i];\n\
    \            largest = &numbers[i];\n        } else {\n            smallest =\
    \ &numbers[i - 1];\n            largest = &numbers[i + 1];\n        }\n    }\n\
    \n    closest,\n    (smallest, largest),", "    let mut min = std::f64::MAX;\n\
    \    let mut max = std::f64::MIN;\n    for n in numbers {\n        if n < min\
    \ {\n            min = n;\n        }\n        if n > max {\n            max =\
    \ n;\n        }\n    }\n    let mut min_diff = std::f64::MAX;\n    let mut max_diff\
    \ = std::f64::MIN;\n    for n in numbers {\n        if n < min {\n           \
    \ continue;\n        }\n        if n > max {\n            continue;\n        }\n\
    \        let diff = n - min;\n        if diff < min_diff {\n            min_diff\
    \ = diff;\n        }\n        if diff > max_diff {\n            max_diff = diff;\n\
    \        }\n    }\n    (min, max)", "    let mut smallest = numbers[0] as f64;\n\
    \    let mut largest = numbers[0] as f64;\n\n    for i in numbers.iter().skip(1)\
    \ {\n        if *i < smallest {\n            smallest = *i;\n        }\n     \
    \   if *i > largest {\n            largest = *i;\n        }\n    }\n\n    smallest,\
    \ largest", "    if numbers.is_empty() {\n        (0.0, 0.0)\n    } else {\n \
    \       let mut min = numbers[0]\n        let mut max = numbers[0]\n        for\
    \ n in &numbers[1..] {\n            if n < min {\n                min = n\n  \
    \          }\n            if n > max {\n                max = n\n            }\n\
    \        }\n        (min, max)\n    }", "    if numbers.len() < 2 {\n        return\
    \ (-1, -1);\n    }\n\n    let mut min_dist = numbers.len() - 1;\n    let mut min_idx\
    \ = numbers.iter().rev().find(|&n| n < numbers[0]).unwrap();\n    let mut max_idx\
    \ = numbers.iter().rev().find(|&n| n > numbers[0]).unwrap();\n\n    while min_idx\
    \ < max_idx {\n        let mut dist = max_idx - min_idx + 1;\n\n        while\
    \ dist > 0 {\n            dist = (min_idx - min_idx + 1) + ((min_idx - min_idx)\
    \ % dist);\n            min_idx = min_idx - 1;\n        }\n\n        let mut min_dist2\
    \ = numbers.iter().rev().find(|&n| n == numbers[min_idx]).unwrap();\n        let\
    \ mut max_dist2 = numbers.iter().rev().find(|&n| n == numbers[max_idx]).unwrap();\n\
    \n        if min_dist2 > min_dist {\n            dist *= 2;\n        }\n     \
    \   if max_dist2 < min_dist {\n            dist *= 2;\n        }\n\n        min_dist\
    \ = min_dist2;\n        max_idx = max_dist2;\n    }\n\n    (numbers[min_idx],\
    \ numbers[max_idx])", "    if numbers.len() <= 2 {\n        (numbers[0], numbers[1])\n\
    \    } else {\n        let mut min_distance = numbers[0].abs();\n        let mut\
    \ min_element_id = 1;\n        for (i, num) in numbers.iter().enumerate() {\n\
    \            if num.abs() < min_distance {\n                min_distance = num.abs();\n\
    \                min_element_id = i;\n            }\n        }\n        (numbers[min_element_id],\
    \ numbers[min_element_id + 1])\n    }", "    let mut min_dist = std::f64::MAX;\n\
    \    let mut min_number = numbers[0];\n    let mut max_number = numbers[0];\n\
    \    for (i, number) in numbers.iter().enumerate() {\n        let dist = number.abs()\
    \ - min_dist;\n        if dist < min_dist {\n            min_dist = dist;\n  \
    \          min_number = number;\n        }\n        if i == 0 {\n            max_number\
    \ = number;\n        } else {\n            max_number = numbers[i..i].iter().max().unwrap();\n\
    \        }\n    }\n    (min_number, max_number)", "    let mut min_distance: f64\
    \ = std::f64::MAX;\n    let mut closest_val = numbers[0];\n    let mut closest_idx\
    \ = 1; // starts at 1 not 0\n    let mut closest = numbers[0]; // start at first\
    \ value\n    for (i, val) in numbers.iter().enumerate() {\n        let distance\
    \ = val - closest;\n        if min_distance > distance {\n            min_distance\
    \ = distance;\n            closest_val = val;\n            closest_idx = i;\n\
    \        }\n    }\n    (closest_val, closest)", '    numbers.iter().cloned().windows(2).min().min().unwrap_or((0,
    0))', "    if numbers.len() < 2 {\n        (numbers[0], numbers[0])\n    } else\
    \ {\n        let mut min_number = numbers[0];\n        let mut max_number = numbers[0];\n\
    \        for i in 1..numbers.len() {\n            let n = numbers[i];\n      \
    \      if n < min_number {\n                min_number = n;\n            }\n \
    \           if n > max_number {\n                max_number = n;\n           \
    \ }\n        }\n        (min_number, max_number)\n    }", "    let mut closest_number1\
    \ = f64::INFINITY;\n    let mut closest_number2 = f64::INFINITY;\n\n    for i\
    \ in numbers {\n        let mut current_difference = f64::INFINITY;\n        for\
    \ j in numbers {\n            if i == j {\n                continue;\n       \
    \     }\n\n            let new_difference = i - j;\n            if new_difference\
    \ < current_difference {\n                current_difference = new_difference;\n\
    \                closest_number1 = i;\n                closest_number2 = j;\n\
    \            }\n        }\n    }\n\n    (closest_number1, closest_number2)", " \
    \   let mut min_dist = Vec::new();\n    let mut min_num = Vec::new();\n\n    let\
    \ mut num_found = 0;\n    for (i, n) in numbers.into_iter().enumerate() {\n  \
    \      min_dist.push(n);\n        if min_dist.len() == 2 {\n            min_num.push(min_dist[0]);\n\
    \            min_num.push(min_dist[1]);\n            num_found += 1;\n       \
    \ }\n\n        if num_found == 2 {\n            break;\n        }\n    }\n\n \
    \   (min_num[0], min_num[1])", "    if numbers.is_empty() {\n        (1, 1)\n\
    \    } else {\n        let mut current_value = numbers[0];\n        let mut best_value\
    \ = numbers[0];\n        let mut best_distance = numbers[0] as f64;\n        let\
    \ mut current_index = 1;\n        for &number in &numbers {\n            let new_distance\
    \ = current_value - number;\n            if new_distance < best_distance {\n \
    \               best_value = number;\n                best_distance = new_distance;\n\
    \            } else {\n                best_value = number;\n            }\n \
    \           current_value = number;\n            current_index += 1;\n       \
    \ }\n        (best_value, best_distance)\n    }", "    let mut a = numbers.clone();\n\
    \    let mut b = numbers.clone();\n    let mut max_dist = std::f64::MAX;\n   \
    \ let mut min_dist = std::f64::MIN;\n    let mut min_i = -1;\n    let mut max_i\
    \ = 0;\n\n    for i in 0..a.len() {\n        for j in 0..b.len() {\n         \
    \   let dist = (*a.get(i) - *b.get(j)).abs();\n            if min_dist > dist\
    \ {\n                min_dist = dist;\n                min_i = i;\n          \
    \  }\n            if max_dist < dist {\n                max_dist = dist;\n   \
    \             max_i = j;\n            }\n        }\n    }\n    (min_dist, max_dist)",
  "    let mut min_distance = 2.0;\n    let mut max_number = numbers[0];\n    let\
    \ mut min_number = numbers[0];\n    for &n in numbers {\n        if n == min_number\
    \ {\n            max_number = n;\n        } else if n != max_number {\n      \
    \      if f64::from(min_distance) < f64::from(n - min_number) {\n            \
    \    min_distance = n - min_number;\n                min_number = n;\n       \
    \     }\n        }\n    }\n    (min_number, max_number)", "    let mut min_dist\
    \ = std::f64::MAX;\n    let mut min_number = numbers[0];\n    let mut max_number\
    \ = numbers[0];\n    for &n in &numbers[1..] {\n        let dist = n.abs();\n\
    \        if dist < min_dist {\n            min_dist = dist;\n            min_number\
    \ = n;\n        } else if dist > max_dist {\n            max_dist = dist;\n  \
    \          max_number = n;\n        }\n    }\n    (min_number, max_number)", " \
    \   let mut min1 = numbers[0];\n    let mut max1 = numbers[0];\n    let mut min2\
    \ = numbers[0];\n    let mut max2 = numbers[0];\n\n    for i in numbers {\n  \
    \      if i < min1 {\n            min1 = i;\n        }\n        if i > max1 {\n\
    \            max1 = i;\n        }\n        if i < min2 {\n            min2 = i;\n\
    \        }\n        if i > max2 {\n            max2 = i;\n        }\n    }\n \
    \   (*min1, *max1)", "    // Sort the input numbers by their absolute value from\
    \ large to small\n    let mut sorted_numbers = numbers.iter().cloned().collect::<Vec<f64>>();\n\
    \    sorted_numbers.sort_by(|a, b| std::cmp::lt(a, b));\n\n    // Find the two\
    \ numbers in sorted order\n    let mut closest = std::cmp::max(f64::MAX, 0.);\n\
    \    let mut second = std::cmp::max(f64::MAX, 0.);\n    for num in &mut sorted_numbers[..2]\
    \ {\n        match std::cmp::min(num, closest.clone()) {\n            None =>\
    \ break,\n            Some(closest) => {\n                if closest.abs() < num.abs()\
    \ {\n                    second = closest;\n                } else {\n       \
    \             closest = num;\n                }\n            }\n        }\n  \
    \  }\n\n    (closest, second)", "    assert!(numbers.len() >= 2);\n\n    let mut\
    \ low = numbers[0].clone() + 0.01;\n    let mut high = numbers[0].clone() - 0.01;\n\
    \n    for i in 1..numbers.len() {\n        if numbers[i] > high {\n          \
    \  high = numbers[i].clone();\n        }\n\n        if numbers[i] < low {\n  \
    \          low = numbers[i].clone();\n        }\n    }\n\n    (low, high)", " \
    \   if numbers.len() < 2 {\n        return (0., 0.);\n    }\n    let mut min1\
    \ = numbers[0];\n    let mut min2 = numbers[0];\n    let mut min3 = numbers[0];\n\
    \    for n in numbers {\n        if n < min1 {\n            min1 = n;\n      \
    \  } else if n < min2 {\n            min2 = n;\n        } else if n < min3 {\n\
    \            min3 = n;\n        }\n    }\n    (min1, min2)", "    if numbers[0]\
    \ < numbers[1] {\n        (numbers[0], numbers[1])\n    } else {\n        (numbers[1],\
    \ numbers[0])\n    }", "    let mut smallest_number = numbers[0];\n    let mut\
    \ largest_number = numbers[0];\n\n    for number in numbers {\n        if number\
    \ < smallest_number {\n            smallest_number = number;\n        }\n\n  \
    \      if number > largest_number {\n            largest_number = number;\n  \
    \      }\n    }\n\n    (smallest_number, largest_number)", "    let mut min =\
    \ numbers[0];\n    let mut max = numbers[0];\n\n    for i in 1..numbers.len()\
    \ {\n        if numbers[i] < min {\n            min = numbers[i];\n        }\n\
    \n        if numbers[i] > max {\n            max = numbers[i];\n        }\n  \
    \  }\n\n    min, max", "    let len = numbers.len();\n    if len < 2 {\n     \
    \   (numbers[0], numbers[1])\n    } else {\n        let mut closest: Vec<f64>\
    \ = numbers.iter().cloned().collect();\n        let mut closest2: Vec<f64> = numbers.iter().cloned().collect();\n\
    \        let mut lower = 0.0f64;\n        let mut upper = numbers.iter().cloned().collect::<Vec<_>>()[0];\n\
    \        for n in numbers.iter().cloned().collect::<Vec<_>>() {\n            if\
    \ n < lower {\n                lower = n;\n            }\n            if n > upper\
    \ {\n                upper = n;\n            }\n        }\n        if upper -\
    \ lower < 1E-4 {\n            for n in numbers.iter().cloned().collect::<Vec<_>>()\
    \ {\n                if n < lower {\n                    lower = n;\n        \
    \        }\n                if n > upper {\n                    upper = n;\n \
    \               }\n            }\n        }\n        if closest == closest2 {\n\
    \            (0.f64, upper)\n        } else {\n            let mut lower = 0.0f64;\n\
    \            let mut upper = numbers.iter().cloned().collect::<Vec<_>>()[0];\n\
    \            for n in numbers.iter().cloned().collect::<Vec<_>>() {\n        \
    \        if n < lower {\n                    lower = n;\n                }\n \
    \               if n > upper {\n                    upper = n;\n             \
    \   }\n            }\n            if upper - lower < 1E-4 {\n                for\
    \ n in numbers.iter().cloned().collect::<Vec<_>>() {\n                    if n\
    \ < lower {\n                        lower = n;\n                    }\n     \
    \               if n > upper {\n                        upper = n;\n         \
    \           }\n                }\n            }\n            (lower, upper)\n\
    \        }\n    }"]
stop_tokens:
- "\n}"
