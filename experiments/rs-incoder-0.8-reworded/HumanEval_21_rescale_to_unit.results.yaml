language: rs
name: HumanEval_21_rescale_to_unit
results:
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    // Find the midpoint of the numbers vector.\n    let mut\
    \ midpoint = numbers[2];\n    for i in 2..numbers.len() {\n        midpoint =\
    \ midpoint / 2.0;\n        numbers[i] -= midpoint;\n    }\n    numbers\n}\n\n\
    fn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `numbers` as mutable, as it is not declared\
    \ as mutable\n  --> /tmp/tmp5fk1osmy.rs:10:9\n   |\n5  | fn rescale_to_unit(numbers:\
    \ Vec<f64>) -> Vec<f64> {\n   |                    ------- help: consider changing\
    \ this to be mutable: `mut numbers`\n...\n10 |         numbers[i] -= midpoint;\n\
    \   |         ^^^^^^^ cannot borrow as mutable\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    // find the min/max number\n    let min = numbers.iter().min().unwrap();\n\
    \    let max = numbers.iter().max().unwrap();\n\n    // scale the numbers to [0,\
    \ 1]\n    let res = (numbers - min) / (max - min) as f64;\n\n    // return the\
    \ rescaled vector\n    vec![0...res.len()].into_iter().map(|v| v * 0.1).collect::<Vec<_>>()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `...`\n  --> /tmp/tmpgz2m1a4m.rs:14:11\n   |\n\
    14 |     vec![0...res.len()].into_iter().map(|v| v * 0.1).collect::<Vec<_>>()\n\
    \   |           ^^^\n   |\nhelp: use `..` for an exclusive range\n   |\n14 | \
    \    vec![0..res.len()].into_iter().map(|v| v * 0.1).collect::<Vec<_>>()\n   |\
    \           ~~\nhelp: or `..=` for an inclusive range\n   |\n14 |     vec![0..=res.len()].into_iter().map(|v|\
    \ v * 0.1).collect::<Vec<_>>()\n   |           ~~~\n\nerror[E0277]: the trait\
    \ bound `f64: Ord` is not satisfied\n    --> /tmp/tmpgz2m1a4m.rs:7:30\n     |\n\
    7    |     let min = numbers.iter().min().unwrap();\n     |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n     |\n     =\
    \ help: the following other types implement trait `Ord`:\n               i128\n\
    \               i16\n               i32\n               i64\n               i8\n\
    \               isize\n               u128\n               u16\n             and\
    \ 4 others\n     = note: required because of the requirements on the impl of `Ord`\
    \ for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpgz2m1a4m.rs:8:30\n\
    \     |\n8    |     let max = numbers.iter().max().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0369]: cannot subtract `&f64` from `Vec<f64>`\n  --> /tmp/tmpgz2m1a4m.rs:11:24\n\
    \   |\n11 |     let res = (numbers - min) / (max - min) as f64;\n   |        \
    \        ------- ^ --- &f64\n   |                |\n   |                Vec<f64>\n\
    \nerror[E0369]: cannot multiply `RangeInclusive<{integer}>` by `{float}`\n  -->\
    \ /tmp/tmpgz2m1a4m.rs:14:47\n   |\n14 | "
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut new_vec: Vec<f64> = numbers.clone();\n    new_vec.sort_unstable();\n\
    \n    let mut new_min: f64 = 0.0;\n    let mut new_max: f64 = 1.0;\n    for num\
    \ in &new_vec {\n        new_min = f64::min(new_min, num);\n        new_max =\
    \ f64::max(new_max, num);\n    }\n    new_vec.truncate(1);\n    new_vec.extend(&mut\
    \ new_vec[0..numbers.len()]);\n    let new_range = new_max - new_min;\n    new_vec.iter_mut().for_each(|num|\
    \ {\n        *num = num / new_range;\n    });\n    new_vec\n}\n\nfn main() {\n\
    \    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp8n8f54as.rs:7:13\n\
    \     |\n7    |     new_vec.sort_unstable();\n     |             ^^^^^^^^^^^^^\
    \ the trait `Ord` is not implemented for `f64`\n     |\n     = help: the following\
    \ other types implement trait `Ord`:\n               i128\n               i16\n\
    \               i32\n               i64\n               i8\n               isize\n\
    \               u128\n               u16\n             and 4 others\nnote: required\
    \ by a bound in `core::slice::<impl [T]>::sort_unstable`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp8n8f54as.rs:12:37\n   |\n12 |         new_min = f64::min(new_min,\
    \ num);\n   |                                     ^^^ expected `f64`, found `&f64`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n12 |         new_min = f64::min(new_min,\
    \ *num);\n   |                                     +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp8n8f54as.rs:13:37\n   |\n13 |         new_max = f64::max(new_max,\
    \ num);\n   |                                     ^^^ expected `f64`, found `&f64`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n13 |         new_max = f64::max(new_max,\
    \ *num);\n   |                                     +\n\nerror[E0277]: the trait\
    \ bound `Vec<f64>: Extend<&mut f64>` is not satisfied\n  --> /tmp/tmp8n8f54as.rs:16:13\n\
    \   |\n16 |     new_vec.extend(&mut new_vec[0..numbers.len()]);\n   |        \
    \     ^^^^^^ the trait `Extend<&mut f64>` is not implemented for `Vec<f64>`\n\
    \   |\n   = help: the following other types implement trait `Extend<A>`:\n   \
    \          <Vec<T, A> as Extend<&'a T>>\n             <Vec<T, A> as Extend<T>>\n\
    \nerror[E0369]: cannot divide `&mut f64` by `f64`\n  --> /tmp/tmp8n8f54as.rs:19:20\n\
    \   |\n19 |         *num = num / new_range;\n   |                --- ^ ---------\
    \ f64\n   |                |\n   |                &mut f64\n   |\nhelp: `/` can\
    \ be used on `f64`, you can dereference `num`\n   |\n19 |         *num = *num\
    \ / new_range;\n   |                +\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308, E0369."
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    assert!(numbers.len() > 0);\n    let mut min_number = numbers[0];\n\
    \    let mut max_number = numbers[0];\n    for (i, n) in numbers.iter().enumerate()\
    \ {\n        let mut n = *n;\n        if n < min_number {\n            min_number\
    \ = n;\n        }\n        if n > max_number {\n            max_number = n;\n\
    \        }\n    }\n    let mut scale = 1.0\n    let mut offset = 0.0\n    if min_number\
    \ == 0.0 {\n        scale = 0.0;\n        offset = 0.0;\n    } else {\n      \
    \  scale = (max_number - min_number) / (numbers.len() - 1);\n        offset =\
    \ -min_number / scale;\n    }\n    let mut transformed_numbers = Vec::new();\n\
    \    for n in numbers {\n        *n -= offset;\n        *n /= scale;\n       \
    \ transformed_numbers.push(*n);\n    }\n    transformed_numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found keyword `let`\n  --> /tmp/tmpmo6r81_9.rs:18:24\n\
    \   |\n18 |     let mut scale = 1.0\n   |                        ^ help: add `;`\
    \ here\n19 |     let mut offset = 0.0\n   |     --- unexpected token\n\nerror:\
    \ expected `;`, found keyword `if`\n  --> /tmp/tmpmo6r81_9.rs:19:25\n   |\n19\
    \ |     let mut offset = 0.0\n   |                         ^ help: add `;` here\n\
    20 |     if min_number == 0.0 {\n   |     -- unexpected token\n\nerror[E0277]:\
    \ cannot divide `f64` by `usize`\n  --> /tmp/tmpmo6r81_9.rs:24:43\n   |\n24 |\
    \         scale = (max_number - min_number) / (numbers.len() - 1);\n   |     \
    \                                      ^ no implementation for `f64 / usize`\n\
    \   |\n   = help: the trait `Div<usize>` is not implemented for `f64`\n   = help:\
    \ the following other types implement trait `Div<Rhs>`:\n             <&'a f32\
    \ as Div<f32>>\n             <&'a f64 as Div<f64>>\n             <&'a i128 as\
    \ Div<i128>>\n             <&'a i16 as Div<i16>>\n             <&'a i32 as Div<i32>>\n\
    \             <&'a i64 as Div<i64>>\n             <&'a i8 as Div<i8>>\n      \
    \       <&'a isize as Div<isize>>\n           and 54 others\n\nerror[E0614]: type\
    \ `f64` cannot be dereferenced\n  --> /tmp/tmpmo6r81_9.rs:29:9\n   |\n29 |   \
    \      *n -= offset;\n   |         ^^\n\nerror[E0614]: type `f64` cannot be dereferenced\n\
    \  --> /tmp/tmpmo6r81_9.rs:30:9\n   |\n30 |         *n /= scale;\n   |       \
    \  ^^\n\nerror[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmpmo6r81_9.rs:31:34\n\
    \   |\n31 |         transformed_numbers.push(*n);\n   |                      \
    \            ^^\n\nerror: aborting due to 6 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0614.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut res: Vec<f64> = numbers.clone();\n    res.sort();\n\
    \    let mut min: f64 = numbers[0];\n    let mut max: f64 = numbers[0];\n    let\
    \ mut rescaled: f64 = numbers[0];\n    for (i, n) in res.iter().enumerate() {\n\
    \        max = max;\n        min = min;\n        if n == 0 {\n            continue;\n\
    \        }\n        rescaled = min + (max - min) * (n as f64) / (n - 1);\n   \
    \     res[i] = rescaled;\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n   --> /tmp/tmpr5a_am_u.rs:7:9\n\
    \    |\n7   |     res.sort();\n    |         ^^^^ the trait `Ord` is not implemented\
    \ for `f64`\n    |\n    = help: the following other types implement trait `Ord`:\n\
    \              i128\n              i16\n              i32\n              i64\n\
    \              i8\n              isize\n              u128\n              u16\n\
    \            and 4 others\nnote: required by a bound in `slice::<impl [T]>::sort`\n\
    \nerror[E0277]: can't compare `&f64` with `{integer}`\n  --> /tmp/tmpr5a_am_u.rs:14:14\n\
    \   |\n14 |         if n == 0 {\n   |              ^^ no implementation for `&f64\
    \ == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&f64`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpr5a_am_u.rs:14:17\n\
    \   |\n14 |         if n == 0 {\n   |                 ^\n   |                \
    \ |\n   |                 expected `f64`, found integer\n   |                \
    \ help: use a float literal: `0.0`\n\nerror[E0277]: cannot subtract `{integer}`\
    \ from `&f64`\n  --> /tmp/tmpr5a_am_u.rs:17:56\n   |\n17 |         rescaled =\
    \ min + (max - min) * (n as f64) / (n - 1);\n   |                            \
    \                            ^ no implementation for `&f64 - {integer}`\n   |\n\
    \   = help: the trait `Sub<{integer}>` is not implemented for `&f64`\n   = help:\
    \ the following other types implement trait `Sub<Rhs>`:\n             <&'a f32\
    \ as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n             <&'a i128 as\
    \ Sub<i128>>\n             <&'a i16 as Sub<i16>>\n             <&'a i32 as Sub<i32>>\n\
    \             <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n      \
    \       <&'a isize as Sub<isize>>\n           and 48 others\n\nerror[E0606]: casting\
    \ `&f64` as `f64` is invalid\n  --> /tmp/tmpr5a_am_u.rs:17:40\n   |\n17 |    \
    \     rescaled = min + (max - min) *"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    if numbers.len() < 2 {\n        numbers\n    } else {\n \
    \       let smallest = numbers[0];\n        let largest = numbers[0];\n      \
    \  for number in numbers.iter().skip(1) {\n            if *number < smallest {\n\
    \                smallest = *number;\n            } else if *number > largest\
    \ {\n                largest = *number;\n            }\n        }\n        let\
    \ mut scale = largest - smallest;\n        if scale < 1e-6 {\n            numbers.clone()\
    \ + [0.01]\n        } else {\n            let mut out = Vec::<f64>::new();\n \
    \           for number in numbers {\n                let number = (number - smallest)\
    \ / scale;\n                out.push(number);\n            }\n            out\n\
    \        }\n    }\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n  \
    \  assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot add `[{float}; 1]` to `Vec<f64>`\n  --> /tmp/tmp__fxspmp.rs:20:29\n\
    \   |\n20 |             numbers.clone() + [0.01]\n   |             ---------------\
    \ ^ ------ [{float}; 1]\n   |             |\n   |             Vec<f64>\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    numbers.iter().map(|f| f * 0.5).min(|a, b| a < b as f64).max(|a,\
    \ b| a > b as f64) as Vec<f64>\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpbdvl0uki.rs:6:37\n\
    \     |\n6    |     numbers.iter().map(|f| f * 0.5).min(|a, b| a < b as f64).max(|a,\
    \ b| a > b as f64) as Vec<f64>\n     |                                     ^^^\
    \ the trait `Ord` is not implemented for `f64`\n     |\n     = help: the following\
    \ other types implement trait `Ord`:\n               i128\n               i16\n\
    \               i32\n               i64\n               i8\n               isize\n\
    \               u128\n               u16\n             and 4 others\nnote: required\
    \ by a bound in `std::iter::Iterator::min`\n\nerror[E0061]: this function takes\
    \ 0 arguments but 1 argument was supplied\n    --> /tmp/tmpbdvl0uki.rs:6:37\n\
    \     |\n6    |     numbers.iter().map(|f| f * 0.5).min(|a, b| a < b as f64).max(|a,\
    \ b| a > b as f64) as Vec<f64>\n     |                                     ^^^\
    \ ------------------- supplied 1 argument\n     |                            \
    \         |\n     |                                     expected 0 arguments\n\
    \     |\nnote: associated function defined here\n\nerror[E0599]: the method `max`\
    \ exists for enum `Option<f64>`, but its trait bounds were not satisfied\n   -->\
    \ /tmp/tmpbdvl0uki.rs:6:62\n    |\n6   |       numbers.iter().map(|f| f * 0.5).min(|a,\
    \ b| a < b as f64).max(|a, b| a > b as f64) as Vec<f64>\n    |               \
    \                                                 ^^^\n    |\n    = note: the\
    \ following trait bounds were not satisfied:\n            `f64: Ord`\n       \
    \     which is required by `Option<f64>: Ord`\n            `Option<f64>: Ord`\n\
    \            which is required by `&Option<f64>: Ord`\n            `Option<f64>:\
    \ Ord`\n            which is required by `&mut Option<f64>: Ord`\n           \
    \ `Option<f64>: Iterator`\n            which is required by `&mut Option<f64>:\
    \ Iterator`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0061, E0277, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = std::f64::MAX;\n    let mut max = std::f64::MIN;\n\
    \    for i in numbers.iter() {\n        min = std::cmp::min(min, i);\n       \
    \ max = std::cmp::max(max, i);\n    }\n\n    let mut res: Vec<f64> = Vec::new();\n\
    \    for n in numbers.iter() {\n        match n {\n            min => {\n    \
    \            res.push(0.0);\n            }\n            max => {\n           \
    \     res.push(1.0);\n            }\n            _ => res.push((n - min) / (max\
    \ - min)),\n        }\n    }\n\n    res\n}\n\nfn main() {\n    let candidate =\
    \ rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp5n44_mkq.rs:9:34\n  |\n9 |\
    \         min = std::cmp::min(min, i);\n  |                                  ^\
    \ expected `f64`, found `&f64`\n  |\nhelp: consider dereferencing the borrow\n\
    \  |\n9 |         min = std::cmp::min(min, *i);\n  |                         \
    \         +\n\nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n   \
    \ --> /tmp/tmp5n44_mkq.rs:9:15\n     |\n9    |         min = std::cmp::min(min,\
    \ i);\n     |               ^^^^^^^^^^^^^ the trait `Ord` is not implemented for\
    \ `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\nnote: required by a bound in `std::cmp::min`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp5n44_mkq.rs:10:34\n   |\n10 |\
    \         max = std::cmp::max(max, i);\n   |                                 \
    \ ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n10 |         max = std::cmp::max(max, *i);\n   |                      \
    \            +\n\nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n\
    \    --> /tmp/tmp5n44_mkq.rs:10:15\n     |\n10   |         max = std::cmp::max(max,\
    \ i);\n     |               ^^^^^^^^^^^^^ the trait `Ord` is not implemented for\
    \ `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\nnote: required by a bound in `std::cmp::max`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut largest = numbers[0];\n    let mut smallest = numbers[0];\n\
    \n    for &n in numbers {\n        if n > largest {\n            largest = n;\n\
    \        }\n        if n < smallest {\n            smallest = n;\n        }\n\
    \    }\n\n    Vec::from(\n        largest\n            + smallest / numbers.len()\n\
    \            * (numbers.iter().rev().fold(1.0, |max, n| max + (n / numbers.len())))\n\
    \    )\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpkj3vohps.rs:9:9\n  |\n9 |\
    \     for &n in numbers {\n  |         ^^    ------- this expression has type\
    \ `Option<f64>`\n  |         |\n  |         expected `f64`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `n`\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror[E0277]:\
    \ cannot divide `f64` by `usize`\n  --> /tmp/tmpkj3vohps.rs:20:24\n   |\n20 |\
    \             + smallest / numbers.len()\n   |                        ^ no implementation\
    \ for `f64 / usize`\n   |\n   = help: the trait `Div<usize>` is not implemented\
    \ for `f64`\n   = help: the following other types implement trait `Div<Rhs>`:\n\
    \             <&'a f32 as Div<f32>>\n             <&'a f64 as Div<f64>>\n    \
    \         <&'a i128 as Div<i128>>\n             <&'a i16 as Div<i16>>\n      \
    \       <&'a i32 as Div<i32>>\n             <&'a i64 as Div<i64>>\n          \
    \   <&'a i8 as Div<i8>>\n             <&'a isize as Div<isize>>\n           and\
    \ 54 others\n\nerror[E0277]: cannot divide `&f64` by `usize`\n  --> /tmp/tmpkj3vohps.rs:21:65\n\
    \   |\n21 |             * (numbers.iter().rev().fold(1.0, |max, n| max + (n /\
    \ numbers.len())))\n   |                                                     \
    \            ^ no implementation for `&f64 / usize`\n   |\n   = help: the trait\
    \ `Div<usize>` is not implemented for `&f64`\n   = help: the following other types\
    \ implement trait `Div<Rhs>`:\n             <&'a f32 as Div<f32>>\n          \
    \   <&'a f64 as Div<f64>>\n             <&'a i128 as Div<i128>>\n            \
    \ <&'a i16 as Div<i16>>\n             <&'a i32 as Div<i32>>\n             <&'a\
    \ i64 as Div<i64>>\n             <&'a i8 as Div<i8>>\n             <&'a isize\
    \ as Div<isize>>\n           and 54 others\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    if numbers.len() == 0 {\n        return vec![];\n    }\n\
    \    if numbers.len() == 1 {\n        return vec![numbers[0]];\n    }\n\n    let\
    \ mut smallest = numbers[0];\n    let mut largest = numbers[0];\n\n    for i in\
    \ 1..numbers.len() {\n        smallest = std::min(i, smallest);\n        largest\
    \ = std::max(i, largest);\n    }\n\n    let new_range = smallest..largest;\n \
    \   let new_range = new_range.into_iter().map(|x| x / numbers[new_range.last().unwrap()\
    \ as usize]).collect();\n    let new_range = new_range.iter().cloned().collect();\n\
    \    new_range.push(largest);\n    new_range\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `min` in crate `std`\n  --> /tmp/tmp3gnxt1ob.rs:17:25\n\
    \   |\n17 |         smallest = std::min(i, smallest);\n   |                  \
    \       ^^^ not found in `std`\n   |\nhelp: consider importing this function\n\
    \   |\n1  | use std::cmp::min;\n   |\nhelp: if you import `min`, refer to it directly\n\
    \   |\n17 -         smallest = std::min(i, smallest);\n17 +         smallest =\
    \ min(i, smallest);\n   | \n\nerror[E0425]: cannot find function `max` in crate\
    \ `std`\n  --> /tmp/tmp3gnxt1ob.rs:18:24\n   |\n18 |         largest = std::max(i,\
    \ largest);\n   |                        ^^^ not found in `std`\n   |\nhelp: consider\
    \ importing this function\n   |\n1  | use std::cmp::max;\n   |\nhelp: if you import\
    \ `max`, refer to it directly\n   |\n18 -         largest = std::max(i, largest);\n\
    18 +         largest = max(i, largest);\n   | \n\nerror[E0599]: `std::ops::Range<f64>`\
    \ is not an iterator\n  --> /tmp/tmp3gnxt1ob.rs:22:31\n   |\n22 |       let new_range\
    \ = new_range.into_iter().map(|x| x / numbers[new_range.last().unwrap() as usize]).collect();\n\
    \   |                                 ^^^^^^^^^ `std::ops::Range<f64>` is not\
    \ an iterator\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `std::ops::Range<f64>: Iterator`\n           which is required by\
    \ `std::ops::Range<f64>: IntoIterator`\n           `&std::ops::Range<f64>: Iterator`\n\
    \           which is required by `&std::ops::Range<f64>: IntoIterator`\n     \
    \      `&mut std::ops::Range<f64>: Iterator`\n           which is required by\
    \ `&mut std::ops::Range<f64>: IntoIterator`\n\nerror[E0599]: the method `last`\
    \ exists for struct `std::ops::Range<f64>`, but its trait bounds were not satisfied\n\
    \  --> /tmp/tmp3gnxt1ob.rs:22:73\n   |\n22 |       let new_range = new_range.into_iter().map(|x|\
    \ x / numbers[new_range.last().unwrap() as usize]).collect();\n   |          \
    \                                                                 ^^^^ method\
    \ cannot be called on `std::ops::Range<f64>` due to unsatisfied trait bounds\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n      "
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_num = numbers[0];\n    let mut max_num = numbers[0];\n\
    \    for n in numbers {\n        if n < min_num {\n            min_num = n;\n\
    \        }\n        if n > max_num {\n            max_num = n;\n        }\n  \
    \  }\n    let scale: f64 = max_num - min_num;\n    let mut result: Vec<f64> =\
    \ Vec::new();\n    for n in numbers {\n        if n == 0.0 {\n            result.push(n);\n\
    \        } else {\n            result.push((n - min_num) / scale);\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n \
    \   assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpvcyjyq8z.rs:18:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n18  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    if numbers.len() == 0 {\n        return vec![];\n    }\n\n\
    \    let min: f64 = numbers[0];\n    let max: f64 = numbers[0];\n    for num in\
    \ numbers {\n        let num = num;\n        if min > num {\n            min =\
    \ num;\n        }\n\n        if max < num {\n            max = num;\n        }\n\
    \    }\n\n    let len = numbers[0].abs();\n    let rescale_factor = 1.0 / len;\n\
    \n    let mut new_numbers = vec![];\n    for num in numbers {\n        let num\
    \ = num * rescale_factor;\n        if num == 0.0 {\n            continue;\n  \
    \      }\n        new_numbers.push(num);\n    }\n\n    new_numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign twice to immutable variable `min`\n  --> /tmp/tmpewdl18og.rs:15:13\n\
    \   |\n10 |     let min: f64 = numbers[0];\n   |         ---\n   |         |\n\
    \   |         first assignment to `min`\n   |         help: consider making this\
    \ binding mutable: `mut min`\n...\n15 |             min = num;\n   |         \
    \    ^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot\
    \ assign twice to immutable variable `max`\n  --> /tmp/tmpewdl18og.rs:19:13\n\
    \   |\n11 |     let max: f64 = numbers[0];\n   |         ---\n   |         |\n\
    \   |         first assignment to `max`\n   |         help: consider making this\
    \ binding mutable: `mut max`\n...\n19 |             max = num;\n   |         \
    \    ^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: borrow\
    \ of moved value: `numbers`\n   --> /tmp/tmpewdl18og.rs:23:15\n    |\n5   | fn\
    \ rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |                    -------\
    \ move occurs because `numbers` has type `Vec<f64>`, which does not implement\
    \ the `Copy` trait\n...\n12  |     for num in numbers {\n    |               \
    \ ------- `numbers` moved due to this implicit call to `.into_iter()`\n...\n23\
    \  |     let len = numbers[0].abs();\n    |               ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `numbers`\nhelp: consider iterating over a slice of the\
    \ `Vec<f64>`'s content to avoid moving into the `for` loop\n    |\n12  |     for\
    \ num in &numbers {\n    |                +\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information\
    \ about an error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_val = numbers[0];\n    let mut max_val = numbers[0];\n\
    \    for val in numbers {\n        if val < min_val {\n            min_val = val;\n\
    \        }\n        if val > max_val {\n            max_val = val;\n        }\n\
    \    }\n    min_val\n        .iter()\n        .for_each(|v| v as f64 / min_val\
    \ as f64)\n        .collect::<Vec<f64>>()\n        .iter()\n        .for_each(|v|\
    \ v * max_val as f64);\n    max_val\n        .iter()\n        .for_each(|v| v\
    \ as f64 / max_val as f64)\n        .collect::<Vec<f64>>()\n        .iter()\n\
    \        .for_each(|v| v + 0.0);\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmposx4n095.rs:17:10\n   |\n17 |         .iter()\n   |   \
    \       ^^^^ method not found in `f64`\n\nerror[E0599]: no method named `iter`\
    \ found for type `f64` in the current scope\n  --> /tmp/tmposx4n095.rs:23:10\n\
    \   |\n23 |         .iter()\n   |          ^^^^ method not found in `f64`\n\n\
    error[E0308]: mismatched types\n --> /tmp/tmposx4n095.rs:5:42\n  |\n5 | fn rescale_to_unit(numbers:\
    \ Vec<f64>) -> Vec<f64> {\n  |    ---------------                       ^^^^^^^^\
    \ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n  |\n  = note: expected struct\
    \ `Vec<f64>`\n          found unit type `()`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut scaled_numbers = Vec::new();\n    for number in numbers\
    \ {\n        let ratio: f64 = number.min(1.0).max(0.0);\n        let mut scaled_number\
    \ = number / ratio;\n        scaled_numbers.push_back(scaled_number);\n    }\n\
    \    scaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `push_back` found for struct `Vec<_>` in\
    \ the current scope\n  --> /tmp/tmphwv5rux1.rs:10:24\n   |\n10 |         scaled_numbers.push_back(scaled_number);\n\
    \   |                        ^^^^^^^^^ method not found in `Vec<_>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    if numbers.len() < 2 {\n        return numbers;\n    }\n\
    \    let mut min_val = numbers[0];\n    let mut max_val = numbers[0];\n    for\
    \ val in numbers.iter().skip(1) {\n        if val < min_val {\n            min_val\
    \ = val;\n        }\n        if val > max_val {\n            max_val = val;\n\
    \        }\n    }\n    let new_min = 0;\n    let new_max = std::f64::MAX;\n  \
    \  let scale = (new_max - new_min) / (max_val - min_val);\n    for val in numbers.iter()\
    \ {\n        let val = val - min_val + new_min;\n        *val = val * scale;\n\
    \    }\n    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpn7_uclfe.rs:12:18\n   |\n\
    12 |         if val < min_val {\n   |                  ^^^^^^^\n   |         \
    \         |\n   |                  expected `&f64`, found `f64`\n   |        \
    \          help: consider borrowing here: `&min_val`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpn7_uclfe.rs:13:23\n   |\n9  |     let mut min_val = numbers[0];\n\
    \   |                       ---------- expected due to this value\n...\n13 | \
    \            min_val = val;\n   |                       ^^^ expected `f64`, found\
    \ `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n13 |          \
    \   min_val = *val;\n   |                       +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpn7_uclfe.rs:15:18\n   |\n15 |         if val > max_val\
    \ {\n   |                  ^^^^^^^\n   |                  |\n   |            \
    \      expected `&f64`, found `f64`\n   |                  help: consider borrowing\
    \ here: `&max_val`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn7_uclfe.rs:16:23\n\
    \   |\n10 |     let mut max_val = numbers[0];\n   |                       ----------\
    \ expected due to this value\n...\n16 |             max_val = val;\n   |     \
    \                  ^^^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n16 |             max_val = *val;\n   |                   \
    \    +\n\nerror[E0277]: cannot subtract `{integer}` from `f64`\n  --> /tmp/tmpn7_uclfe.rs:21:26\n\
    \   |\n21 |     let scale = (new_max - new_min) / (max_val - min_val);\n   | \
    \                         ^ no implementation for `f64 - {integer}`\n   |\n  \
    \ = help: the trait `Sub<{integer}>` is not implemented for `f64`\n   = help:\
    \ the following other types implement trait `Sub<Rhs>`:\n             <&'a f32\
    \ as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n             <&'a i128 as\
    \ Sub<i128>>\n             <&'a i16 as Sub<i16>>\n             <&'a i32 as Sub<i32>>\n\
    \             <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n      \
    \       <&'a isize as Sub<isize>>\n           and 48 others\n\nerror[E0277]: cannot\
    \ add `{integer}` to `f64`\n  --> /tmp/tmpn7_uclfe.rs:2"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    if numbers.len() < 2 {\n        return numbers;\n    }\n\
    \    let mut min_value = numbers[0];\n    let mut max_value = numbers[0];\n  \
    \  for i in numbers.iter().rev() {\n        if i < min_value {\n            min_value\
    \ = i;\n        }\n        if i > max_value {\n            max_value = i;\n  \
    \      }\n    }\n    let scale = 1.0f64 / std::f64::from(max_value - min_value);\n\
    \    let mut result: Vec<f64> = Vec::with_capacity(numbers.len());\n    for i\
    \ in numbers.iter() {\n        result.append(scale * (i - min_value));\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `from` in module `std::f64`\n  --> /tmp/tmpmkwgw8co.rs:19:36\n\
    \   |\n19 |     let scale = 1.0f64 / std::f64::from(max_value - min_value);\n\
    \   |                                    ^^^^ not found in `std::f64`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpmkwgw8co.rs:12:16\n   |\n12 |         if i <\
    \ min_value {\n   |                ^^^^^^^^^\n   |                |\n   |    \
    \            expected `&f64`, found `f64`\n   |                help: consider\
    \ borrowing here: `&min_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmkwgw8co.rs:13:25\n\
    \   |\n9  |     let mut min_value = numbers[0];\n   |                        \
    \ ---------- expected due to this value\n...\n13 |             min_value = i;\n\
    \   |                         ^ expected `f64`, found `&f64`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n13 |             min_value = *i;\n   |     \
    \                    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmkwgw8co.rs:15:16\n\
    \   |\n15 |         if i > max_value {\n   |                ^^^^^^^^^\n   |  \
    \              |\n   |                expected `&f64`, found `f64`\n   |     \
    \           help: consider borrowing here: `&max_value`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpmkwgw8co.rs:16:25\n   |\n10 |     let mut max_value = numbers[0];\n\
    \   |                         ---------- expected due to this value\n...\n16 |\
    \             max_value = i;\n   |                         ^ expected `f64`, found\
    \ `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n16 |          \
    \   max_value = *i;\n   |                         +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpmkwgw8co.rs:22:23\n   |\n22 |         result.append(scale\
    \ * (i - min_value));\n   |                       ^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `&mut Vec<f64>`, found `f64`\n   |\n   = note: expected mutable reference `&mut\
    \ Vec<f64>`\n                           found type `f64`\n\nerror: aborting due\
    \ to 6 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 0
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for i in 1..numbers.len() {\n        if numbers[i] < min {\n            min\
    \ = numbers[i];\n        }\n        if numbers[i] > max {\n            max = numbers[i];\n\
    \        }\n    }\n    let mut scaled_numbers = vec![0.0; numbers.len()];\n  \
    \  for i in 0..numbers.len() {\n        scaled_numbers[i] = numbers[i] - min;\n\
    \        scaled_numbers[i] *= 1.0 / (max - min);\n    }\n    scaled_numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    numbers\n        .iter()\n        .enumerate()\n        .map(|(i,\
    \ number)| {\n            if number == 0 {\n                return i as f64;\n\
    \            }\n            number as f64 / number.norm()\n        })\n      \
    \  .collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&f64` with `{integer}`\n  --> /tmp/tmp38sqgvqh.rs:10:23\n\
    \   |\n10 |             if number == 0 {\n   |                       ^^ no implementation\
    \ for `&f64 == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is\
    \ not implemented for `&f64`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp38sqgvqh.rs:10:26\n   |\n10 |             if number == 0 {\n   |   \
    \                       ^\n   |                          |\n   |             \
    \             expected `f64`, found integer\n   |                          help:\
    \ use a float literal: `0.0`\n\nerror[E0599]: no method named `norm` found for\
    \ reference `&f64` in the current scope\n  --> /tmp/tmp38sqgvqh.rs:13:36\n   |\n\
    13 |             number as f64 / number.norm()\n   |                         \
    \           ^^^^ method not found in `&f64`\n\nerror[E0606]: casting `&f64` as\
    \ `f64` is invalid\n  --> /tmp/tmp38sqgvqh.rs:13:13\n   |\n13 |             number\
    \ as f64 / number.norm()\n   |             ------^^^^^^^\n   |             |\n\
    \   |             cannot cast `&f64` as `f64`\n   |             help: dereference\
    \ the expression: `*number`\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308, E0599, E0606.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \n    for x in numbers.iter() {\n        if x > max {\n            max = x;\n\
    \        }\n        if x < min {\n            min = x;\n        }\n    }\n\n \
    \   let delta = (max - min).recip();\n    numbers = numbers.iter().map(|x| x -\
    \ min).map(|x| x / delta).collect();\n    numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpev919s2y.rs:10:16\n   |\n\
    10 |         if x > max {\n   |                ^^^\n   |                |\n  \
    \ |                expected `&f64`, found `f64`\n   |                help: consider\
    \ borrowing here: `&max`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpev919s2y.rs:11:19\n\
    \   |\n7  |     let mut max = numbers[0];\n   |                   ---------- expected\
    \ due to this value\n...\n11 |             max = x;\n   |                   ^\
    \ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n11 |             max = *x;\n   |                   +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpev919s2y.rs:13:16\n   |\n13 |         if x < min {\n  \
    \ |                ^^^\n   |                |\n   |                expected `&f64`,\
    \ found `f64`\n   |                help: consider borrowing here: `&min`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpev919s2y.rs:14:19\n   |\n6  |     let mut min\
    \ = numbers[0];\n   |                   ---------- expected due to this value\n\
    ...\n14 |             min = x;\n   |                   ^ expected `f64`, found\
    \ `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n14 |          \
    \   min = *x;\n   |                   +\n\nerror: aborting due to 4 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let min = numbers.min();\n    let max = numbers.max();\n\
    \    numbers\n        .iter()\n        .map(|number| number.checked_div(max -\
    \ min).unwrap())\n        .collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: the method `min` exists for struct `Vec<f64>`, but its trait\
    \ bounds were not satisfied\n   --> /tmp/tmpz362yebw.rs:6:23\n    |\n6   |   \
    \    let min = numbers.min();\n    |                         ^^^ method cannot\
    \ be called on `Vec<f64>` due to unsatisfied trait bounds\n    |\n    = note:\
    \ the following trait bounds were not satisfied:\n            `f64: Ord`\n   \
    \         which is required by `Vec<f64>: Ord`\n            `Vec<f64>: Ord`\n\
    \            which is required by `&Vec<f64>: Ord`\n            `Vec<f64>: Ord`\n\
    \            which is required by `&mut Vec<f64>: Ord`\n            `Vec<f64>:\
    \ Iterator`\n            which is required by `&mut Vec<f64>: Iterator`\n    \
    \        `f64: Ord`\n            which is required by `[f64]: Ord`\n         \
    \   `[f64]: Ord`\n            which is required by `&[f64]: Ord`\n           \
    \ `[f64]: Ord`\n            which is required by `&mut [f64]: Ord`\n         \
    \   `[f64]: Iterator`\n            which is required by `&mut [f64]: Iterator`\n\
    \nerror[E0599]: the method `max` exists for struct `Vec<f64>`, but its trait bounds\
    \ were not satisfied\n   --> /tmp/tmpz362yebw.rs:7:23\n    |\n7   |       let\
    \ max = numbers.max();\n    |                         ^^^ method cannot be called\
    \ on `Vec<f64>` due to unsatisfied trait bounds\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `f64: Ord`\n            which\
    \ is required by `Vec<f64>: Ord`\n            `Vec<f64>: Ord`\n            which\
    \ is required by `&Vec<f64>: Ord`\n            `Vec<f64>: Ord`\n            which\
    \ is required by `&mut Vec<f64>: Ord`\n            `Vec<f64>: Iterator`\n    \
    \        which is required by `&mut Vec<f64>: Iterator`\n            `f64: Ord`\n\
    \            which is required by `[f64]: Ord`\n            `[f64]: Ord`\n   \
    \         which is required by `&[f64]: Ord`\n            `[f64]: Ord`\n     \
    \       which is required by `&mut [f64]: Ord`\n            `[f64]: Iterator`\n\
    \            which is required by `&mut [f64]: Iterator`\n\nerror[E0599]: no method\
    \ named `checked_div` found for reference `&f64` in the current scope\n  --> /tmp"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    assert!((numbers[..]) >= 0.0);\n    assert!(numbers.len()\
    \ > 1);\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for\
    \ n in numbers {\n        if n <= min {\n            min = n;\n        }\n   \
    \     if n > max {\n            max = n;\n        }\n    }\n    let mut newvec:\
    \ Vec<f64> = vec![];\n    for n in numbers {\n        let mut nnew: f64 = 0.0;\n\
    \        let mut nmin: f64 = min;\n        let mut nmax: f64 = max;\n        if\
    \ n != min {\n            nnew += nmin / n;\n            nmin = 0.0;\n       \
    \ }\n        if n != max {\n            nnew += nmax / n;\n            nmax =\
    \ 1.0;\n        }\n        newvec.push(nnew);\n    }\n    newvec\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpypzgme8i.rs:6:30\n  |\n6 |\
    \     assert!((numbers[..]) >= 0.0);\n  |                              ^^^ expected\
    \ slice `[f64]`, found floating-point number\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_number = numbers[0];\n    let mut max_number\
    \ = numbers[0];\n    for (i, &v) in numbers.iter().enumerate() {\n        if v\
    \ < min_number {\n            min_number = v;\n        }\n        if v > max_number\
    \ {\n            max_number = v;\n        }\n    }\n    let mut range = (max_number\
    \ - min_number).abs();\n    if range > 0.0 {\n        for &v in numbers {\n  \
    \          v /= range;\n        }\n    }\n    numbers\n}\n\nfn main() {\n    let\
    \ candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0,\
    \ 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_xq4_gg0.rs:18:13\n   |\n\
    18 |         for &v in numbers {\n   |             ^^    ------- this expression\
    \ has type `Option<f64>`\n   |             |\n   |             expected `f64`,\
    \ found reference\n   |             help: you can probably remove the explicit\
    \ borrow: `v`\n   |\n   = note:   expected type `f64`\n           found reference\
    \ `&_`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_num = numbers[0];\n    let mut max_num = numbers[0];\n\
    \    for &number in numbers {\n        if number < min_num {\n            min_num\
    \ = number;\n        }\n        if number > max_num {\n            max_num = number;\n\
    \        }\n    }\n    let mut rescaled: Vec<f64> = vec![0.0; numbers.len()];\n\
    \    for &number in numbers {\n        rescaled[numbers.iter().position(|n| n\
    \ == &number).unwrap()] = number;\n    }\n    for &number in numbers {\n     \
    \   rescaled[numbers.iter().position(|n| n == &min_num).unwrap()] = 0.0;\n   \
    \ }\n    for &number in numbers {\n        rescaled[numbers.iter().position(|n|\
    \ n == &max_num).unwrap()] = 1.0;\n    }\n    rescaled\n}\n\nfn main() {\n   \
    \ let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpm01ud0nz.rs:8:9\n  |\n8 |\
    \     for &number in numbers {\n  |         ^^^^^^^    ------- this expression\
    \ has type `Option<f64>`\n  |         |\n  |         expected `f64`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `number`\n  |\n\
    \  = note:   expected type `f64`\n          found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpm01ud0nz.rs:17:9\n   |\n17 |     for &number\
    \ in numbers {\n   |         ^^^^^^^    ------- this expression has type `Option<f64>`\n\
    \   |         |\n   |         expected `f64`, found reference\n   |         help:\
    \ you can probably remove the explicit borrow: `number`\n   |\n   = note:   expected\
    \ type `f64`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpm01ud0nz.rs:20:9\n   |\n20 |     for &number in numbers {\n   |\
    \         ^^^^^^^    ------- this expression has type `Option<f64>`\n   |    \
    \     |\n   |         expected `f64`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `number`\n   |\n   = note:   expected\
    \ type `f64`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpm01ud0nz.rs:23:9\n   |\n23 |     for &number in numbers {\n   |\
    \         ^^^^^^^    ------- this expression has type `Option<f64>`\n   |    \
    \     |\n   |         expected `f64`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `number`\n   |\n   = note:   expected\
    \ type `f64`\n           found reference `&_`\n\nerror: aborting due to 4 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut n = numbers[0];\n    for number in numbers.iter().skip(1)\
    \ {\n        n.scale_by(number);\n    }\n    Vec::new()\n}\n\nfn main() {\n  \
    \  let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `scale_by` found for type `f64` in the current\
    \ scope\n --> /tmp/tmp1h3niqi0.rs:8:11\n  |\n8 |         n.scale_by(number);\n\
    \  |           ^^^^^^^^ method not found in `f64`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min: f64 = numbers[0];\n    let mut max: f64 = numbers[0];\n\
    \    for &n in numbers {\n        if n < min {\n            min = n;\n       \
    \ }\n        if n > max {\n            max = n;\n        }\n    }\n    let mut\
    \ range = max - min;\n    for &n in numbers {\n        n -= min;\n        n /=\
    \ range;\n    }\n    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpb7wslzzu.rs:8:9\n  |\n8 |\
    \     for &n in numbers {\n  |         ^^    ------- this expression has type\
    \ `Option<f64>`\n  |         |\n  |         expected `f64`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `n`\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpb7wslzzu.rs:17:9\n   |\n17 |     for &n in numbers\
    \ {\n   |         ^^    ------- this expression has type `Option<f64>`\n   | \
    \        |\n   |         expected `f64`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `n`\n   |\n   = note:   expected type\
    \ `f64`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut minimum = numbers[0];\n    let mut maximum = numbers[0];\n\
    \n    // find smallest and greatest number\n    for &number in numbers {\n   \
    \     if number < minimum {\n            minimum = number;\n        }\n      \
    \  if number > maximum {\n            maximum = number;\n        }\n    }\n\n\
    \    let mut new_numbers = Vec::new();\n    new_numbers.extend_from_slice(&[minimum]);\n\
    \    new_numbers.extend_from_slice(&[maximum]);\n\n    let mut current_max = maximum;\n\
    \    let mut current_min = minimum;\n    for &number in numbers {\n        let\
    \ new_number = (number - current_min) / (current_max - current_min) * (maximum\
    \ - minimum) + minimum;\n        current_max = new_number;\n        current_min\
    \ = new_number;\n        new_numbers.push(*new_number);\n    }\n\n    new_numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnlyhe0_r.rs:10:9\n   |\n\
    10 |     for &number in numbers {\n   |         ^^^^^^^    ------- this expression\
    \ has type `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `number`\n  \
    \ |\n   = note:   expected type `f64`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpnlyhe0_r.rs:25:9\n   |\n25 |     for &number\
    \ in numbers {\n   |         ^^^^^^^    ------- this expression has type `Option<f64>`\n\
    \   |         |\n   |         expected `f64`, found reference\n   |         help:\
    \ you can probably remove the explicit borrow: `number`\n   |\n   = note:   expected\
    \ type `f64`\n           found reference `&_`\n\nerror[E0614]: type `f64` cannot\
    \ be dereferenced\n  --> /tmp/tmpnlyhe0_r.rs:29:26\n   |\n29 |         new_numbers.push(*new_number);\n\
    \   |                          ^^^^^^^^^^^\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0614.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 101
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    numbers.iter().cloned().map(|n| n / numbers.last().unwrap()).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0.04008016032064128, 1.0]`,\n right: `[0.0, 1.0]`', /tmp/tmpvt_rv4_b.rs:11:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for number in numbers.iter_mut() {\n        if number < min {\n         \
    \   min = number;\n        }\n        if number > max {\n            max = number;\n\
    \        }\n        *number /= max - min;\n    }\n    numbers.iter_mut().map(|&x|\
    \ x - min).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp21i7a7cd.rs:9:21\n  |\n9 |\
    \         if number < min {\n  |                     ^^^\n  |                \
    \     |\n  |                     expected `&mut f64`, found `f64`\n  |       \
    \              help: consider mutably borrowing here: `&mut min`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp21i7a7cd.rs:10:19\n   |\n6  |     let mut min\
    \ = numbers[0];\n   |                   ---------- expected due to this value\n\
    ...\n10 |             min = number;\n   |                   ^^^^^^ expected `f64`,\
    \ found `&mut f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n10 |\
    \             min = *number;\n   |                   +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp21i7a7cd.rs:12:21\n   |\n12 |         if number > max {\n\
    \   |                     ^^^\n   |                     |\n   |              \
    \       expected `&mut f64`, found `f64`\n   |                     help: consider\
    \ mutably borrowing here: `&mut max`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp21i7a7cd.rs:13:19\n   |\n7  |     let mut max = numbers[0];\n   |  \
    \                 ---------- expected due to this value\n...\n13 |           \
    \  max = number;\n   |                   ^^^^^^ expected `f64`, found `&mut f64`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n13 |             max = *number;\n\
    \   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp21i7a7cd.rs:17:29\n\
    \   |\n17 |     numbers.iter_mut().map(|&x| x - min).collect()\n   |         \
    \                    ^--\n   |                             ||\n   |          \
    \                   |expected due to this\n   |                             types\
    \ differ in mutability\n   |                             help: did you mean `x`:\
    \ `&&mut f64`\n   |\n   = note: expected mutable reference `&mut f64`\n      \
    \                found reference `&_`\n\nerror: aborting due to 5 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut result = numbers;\n    result.sort();\n    for i\
    \ in 0..result.len() - 1 {\n        if result[i] == result[i + 1] {\n        \
    \    result[i] = 0.0;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0,\
    \ 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n   --> /tmp/tmprl1pp7hg.rs:7:12\n\
    \    |\n7   |     result.sort();\n    |            ^^^^ the trait `Ord` is not\
    \ implemented for `f64`\n    |\n    = help: the following other types implement\
    \ trait `Ord`:\n              i128\n              i16\n              i32\n   \
    \           i64\n              i8\n              isize\n              u128\n \
    \             u16\n            and 4 others\nnote: required by a bound in `slice::<impl\
    \ [T]>::sort`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    if numbers.len() < 2 {\n        return vec![];\n    }\n \
    \   let mut min = numbers[0];\n    let mut max = numbers[0];\n    for i in numbers.iter().rev()\
    \ {\n        if i < min {\n            min = i;\n        }\n        if i > max\
    \ {\n            max = i;\n        }\n    }\n    let mut scaled: Vec<f64> = vec![];\n\
    \    for i in numbers.iter() {\n        if i < min {\n            scaled.append(0.0);\n\
    \        } else if i > max {\n            scaled.append(1.0);\n        } else\
    \ {\n            scaled.append(i / (max - min));\n        }\n    }\n    scaled\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpm7nqrbi1.rs:12:16\n   |\n\
    12 |         if i < min {\n   |                ^^^\n   |                |\n  \
    \ |                expected `&f64`, found `f64`\n   |                help: consider\
    \ borrowing here: `&min`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpm7nqrbi1.rs:13:19\n\
    \   |\n9  |     let mut min = numbers[0];\n   |                   ---------- expected\
    \ due to this value\n...\n13 |             min = i;\n   |                   ^\
    \ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n13 |             min = *i;\n   |                   +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpm7nqrbi1.rs:15:16\n   |\n15 |         if i > max {\n  \
    \ |                ^^^\n   |                |\n   |                expected `&f64`,\
    \ found `f64`\n   |                help: consider borrowing here: `&max`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpm7nqrbi1.rs:16:19\n   |\n10 |     let mut max\
    \ = numbers[0];\n   |                   ---------- expected due to this value\n\
    ...\n16 |             max = i;\n   |                   ^ expected `f64`, found\
    \ `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n16 |          \
    \   max = *i;\n   |                   +\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpm7nqrbi1.rs:21:16\n   |\n21 |         if i < min {\n   |           \
    \     ^^^\n   |                |\n   |                expected `&f64`, found `f64`\n\
    \   |                help: consider borrowing here: `&min`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpm7nqrbi1.rs:22:27\n   |\n22 |             scaled.append(0.0);\n\
    \   |                           ^^^ expected `&mut Vec<f64>`, found floating-point\
    \ number\n   |\n   = note: expected mutable reference `&mut Vec<f64>`\n      \
    \                     found type `{float}`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpm7nqrbi1.rs:23:23\n   |\n23 |         } else if i > max {\n   |\
    \                       ^^^\n   |                       |\n   |              \
    \         expected `&f64`, found `f64`\n   |                       help: consider\
    \ borrowing here: `&max`\n\nerror[E0308]: mis"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    numbers\n        .iter()\n        .map(|num| num / numbers.iter().min().unwrap())\n\
    \        .collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp_fp656z_.rs:8:41\n\
    \     |\n8    |         .map(|num| num / numbers.iter().min().unwrap())\n    \
    \ |                                         ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers.iter().min().unwrap();\n    let mut\
    \ max = numbers.iter().max().unwrap();\n\n    if min == max {\n        numbers\n\
    \    } else {\n        let mut min = numbers.iter().min().unwrap();\n        let\
    \ mut max = numbers.iter().max().unwrap();\n        max -= min;\n        min =\
    \ min - max;\n        let min_number = (min + max) / 2;\n        let max_number\
    \ = (min + max) / 2;\n        for n in numbers {\n            n -= min_number;\n\
    \            n /= max_number - min_number;\n            n = n.max(std::f64::EPSILON);\n\
    \        }\n    }\n    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpvba00ufu.rs:6:34\n\
    \     |\n6    |     let mut min = numbers.iter().min().unwrap();\n     |     \
    \                             ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpvba00ufu.rs:7:34\n\
    \     |\n7    |     let mut max = numbers.iter().max().unwrap();\n     |     \
    \                             ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpvba00ufu.rs:10:9\n   |\n9  | /\
    \     if min == max {\n10 | |         numbers\n   | |         ^^^^^^^ expected\
    \ `()`, found struct `Vec`\n11 | |     } else {\n12 | |         let mut min =\
    \ numbers.iter().min().unwrap();\n...  |\n22 | |         }\n23 | |     }\n   |\
    \ |_____- expected this to be `()`\n   |\n   = note: expected unit type `()`\n\
    \                 found struct `Vec<f64>`\nhelp: you might have meant to return\
    \ this value\n   |\n10 |         return numbers;\n   |         ++++++        +\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpvba00ufu.rs:12:38\n\
    \     |\n12   |         let mut min = numbers.iter().min().unwrap();\n     | \
    \                                     ^^^ the trait `Ord` is not implemented for\
    \ `f64`\n     |\n   "
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    numbers\n        .iter()\n        .fold(vec![numbers[0] as\
    \ f64; 2], |mut acc, x| {\n            if x <= acc[0] {\n                *acc\
    \ = x;\n            }\n            acc\n        })\n}\n\nfn main() {\n    let\
    \ candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0,\
    \ 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpc0z3wv08.rs:9:21\n  |\n9 |\
    \             if x <= acc[0] {\n  |                     ^^^^^^\n  |          \
    \           |\n  |                     expected `&f64`, found `f64`\n  |     \
    \                help: consider borrowing here: `&acc[0]`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpc0z3wv08.rs:10:24\n   |\n10 |                 *acc = x;\n\
    \   |                 ----   ^ expected slice `[f64]`, found `&f64`\n   |    \
    \             |\n   |                 expected due to the type of this binding\n\
    \nerror[E0277]: the size for values of type `[f64]` cannot be known at compilation\
    \ time\n  --> /tmp/tmpc0z3wv08.rs:10:17\n   |\n10 |                 *acc = x;\n\
    \   |                 ^^^^ doesn't have a size known at compile-time\n   |\n \
    \  = help: the trait `Sized` is not implemented for `[f64]`\n   = note: the left-hand-side\
    \ of an assignment must have a statically known size\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    numbers.iter()\n        .map(|x| x as f64 - std::min(numbers))\n\
    \        .map(|x| x / std::max(numbers))\n        .collect()\n}\n\nfn main() {\n\
    \    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `min` in crate `std`\n --> /tmp/tmpnz0cfp9j.rs:7:34\n\
    \  |\n7 |         .map(|x| x as f64 - std::min(numbers))\n  |                \
    \                  ^^^ not found in `std`\n  |\nhelp: consider importing this\
    \ function\n  |\n1 | use std::cmp::min;\n  |\nhelp: if you import `min`, refer\
    \ to it directly\n  |\n7 -         .map(|x| x as f64 - std::min(numbers))\n7 +\
    \         .map(|x| x as f64 - min(numbers))\n  | \n\nerror[E0425]: cannot find\
    \ function `max` in crate `std`\n --> /tmp/tmpnz0cfp9j.rs:8:27\n  |\n8 |     \
    \    .map(|x| x / std::max(numbers))\n  |                           ^^^ not found\
    \ in `std`\n  |\nhelp: consider importing this function\n  |\n1 | use std::cmp::max;\n\
    \  |\nhelp: if you import `max`, refer to it directly\n  |\n8 -         .map(|x|\
    \ x / std::max(numbers))\n8 +         .map(|x| x / max(numbers))\n  | \n\nerror[E0606]:\
    \ casting `&f64` as `f64` is invalid\n --> /tmp/tmpnz0cfp9j.rs:7:18\n  |\n7 |\
    \         .map(|x| x as f64 - std::min(numbers))\n  |                  -^^^^^^^\n\
    \  |                  |\n  |                  cannot cast `&f64` as `f64`\n  |\
    \                  help: dereference the expression: `*x`\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0606.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    if numbers.len() > 1 {\n        let min: f64 = numbers.iter().min().unwrap();\n\
    \        let max: f64 = numbers.iter().max().unwrap();\n        let diff = max\
    \ - min;\n        numbers.into_iter().map(|x| x / diff + min).collect()\n    }\
    \ else {\n        vec![numbers[0]]\n    }\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp3io12y9o.rs:7:39\n\
    \     |\n7    |         let min: f64 = numbers.iter().min().unwrap();\n     |\
    \                                       ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmp3io12y9o.rs:7:24\n  |\n7 |    \
    \     let min: f64 = numbers.iter().min().unwrap();\n  |                  ---\
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `f64`, found `&f64`\n  |          \
    \        |\n  |                  expected due to this\n  |\nhelp: consider dereferencing\
    \ the borrow\n  |\n7 |         let min: f64 = *numbers.iter().min().unwrap();\n\
    \  |                        +\n\nerror[E0277]: the trait bound `f64: Ord` is not\
    \ satisfied\n    --> /tmp/tmp3io12y9o.rs:8:39\n     |\n8    |         let max:\
    \ f64 = numbers.iter().max().unwrap();\n     |                               \
    \        ^^^ the trait `Ord` is not implemented for `f64`\n     |\n     = help:\
    \ the following other types implement trait `Ord`:\n               i128\n    \
    \           i16\n               i32\n               i64\n               i8\n \
    \              isize\n               u128\n               u16\n             and\
    \ 4 others\n     = note: required because of the requirements on the impl of `Ord`\
    \ for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp3io12y9o.rs:8:24\n  |\n8 |         let max: f64\
    \ = numbers.iter().max().unwrap();\n  |                  ---   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `f64`, found `&f64`\n  |                  |\n  |                  expected\
    \ due to this\n  |\nhelp: consider dereferencing the borrow\n  |\n8 |        \
    \ let max: f64 = *num"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    if numbers.len() == 1 {\n        numbers\n    } else {\n\
    \        let mut min_number = numbers.iter().min();\n        let mut max_number\
    \ = numbers.iter().max();\n        let mut range = max_number - min_number;\n\
    \        if range == 0.0 {\n            return vec![numbers[0]];\n        }\n\
    \        let mut min_rescale = numbers[0] - min_number as f64;\n        let mut\
    \ max_rescale = 1.0 / (range as f64);\n        for n in numbers {\n          \
    \  min_rescale *= n as f64;\n            max_rescale *= n as f64;\n        }\n\
    \        vec![min_rescale as f64, max_rescale as f64]\n    }\n}\n\nfn main() {\n\
    \    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp9kfzzlou.rs:9:45\n\
    \     |\n9    |         let mut min_number = numbers.iter().min();\n     |   \
    \                                          ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp9kfzzlou.rs:10:45\n\
    \     |\n10   |         let mut max_number = numbers.iter().max();\n     |   \
    \                                          ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0369]: cannot subtract `Option<&f64>` from `Option<&f64>`\n  --> /tmp/tmp9kfzzlou.rs:11:36\n\
    \   |\n11 |         let mut range = max_number - min_number;\n   |           \
    \              ---------- ^ ---------- Option<&f64>\n   |                    \
    \     |\n   |                         Option<&f64>\n\nerror[E0605]: non-primitive\
    \ cast: `Option<&f64>` as `f64`\n  --> /tmp/tmp9kfzzlou.rs:15:44\n   |\n15 | \
    \        let mut min_rescale = numbers[0] - min_number as f64;\n   |         \
    \                                   ^^^^^^^^^^^^^^^^^ an `as` expression can only\
    \ be used to convert between primitive types or to coerce to a specific trait\
    \ object\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0369, E0605.\nFor more informati"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_val = numbers[0];\n    let mut max_val = numbers[0];\n\
    \    let mut min_idx = 1;\n    let mut max_idx = 1;\n    for i in numbers {\n\
    \        if i < min_val {\n            min_val = i;\n            min_idx = 1;\n\
    \        } else if i > max_val {\n            max_val = i;\n            max_idx\
    \ = 1;\n        }\n    }\n    let new_size = (max_idx - min_idx) + 1;\n    numbers[min_idx..(numbers.len()\
    \ - 1)].iter().cloned().map(|n| n * max_val / min_val).collect::<Vec<_>>()\n \
    \       .as_slice()\n        .resize(new_size);\n    numbers\n}\n\nfn main() {\n\
    \    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `resize` found for reference `&[f64]` in\
    \ the current scope\n  --> /tmp/tmprnd8o5ob.rs:22:10\n   |\n22 |         .resize(new_size);\n\
    \   |          ^^^^^^ method not found in `&[f64]`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let min_number = numbers.iter().min().unwrap();\n    let\
    \ max_number = numbers.iter().max().unwrap();\n    let range = max_number - min_number;\n\
    \    let new_min = min_number - range * 0.5;\n    let new_max = max_number + range\
    \ * 0.5;\n    numbers.iter_mut().map(|x| {\n        if x > max_number || x < min_number\
    \ {\n            x\n        } else {\n            (x - new_min) / (new_max - new_min)\n\
    \        }\n    }).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpx8yl2hpl.rs:6:37\n\
    \     |\n6    |     let min_number = numbers.iter().min().unwrap();\n     |  \
    \                                   ^^^ the trait `Ord` is not implemented for\
    \ `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpx8yl2hpl.rs:7:37\n\
    \     |\n7    |     let max_number = numbers.iter().max().unwrap();\n     |  \
    \                                   ^^^ the trait `Ord` is not implemented for\
    \ `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpx8yl2hpl.rs:12:16\n   |\n12 |\
    \         if x > max_number || x < min_number {\n   |                ^^^^^^^^^^\
    \ types differ in mutability\n   |\n   = note: expected mutable reference `&mut\
    \ f64`\n                      found reference `&f64`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpx8yl2hpl.rs:12:34\n   |\n12 |         if x > max_number\
    \ || x < min_number {\n   |                                  ^^^^^^^^^^ types\
    \ differ in mutability\n   |\n   = note: expected mutable reference `&mut f64`\n\
    \                      found reference `&f64`\n\nerror[E0369]: cannot subtract\
    \ `f64` from `&mut f64`\n  --> /tmp/tmpx8yl2hpl.rs:15:16\n   |\n15 |         \
    \    (x - new_min) / (new_max - new_min)\n   |              - ^ ------- f64\n\
    \   |              |\n   |"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    numbers.iter().cloned().collect::<Vec<f64>>().min(|a, b|\
    \ f64::max(a, b)).map(|n| {\n        if n < 0.0 {\n            0.0\n        }\
    \ else {\n            1.0\n        }\n    }).collect()\n}\n\nfn main() {\n   \
    \ let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: the method `min` exists for struct `Vec<f64>`, but its trait\
    \ bounds were not satisfied\n   --> /tmp/tmp9iw7wpo5.rs:6:51\n    |\n6   |   \
    \    numbers.iter().cloned().collect::<Vec<f64>>().min(|a, b| f64::max(a, b)).map(|n|\
    \ {\n    |                                                     ^^^ method cannot\
    \ be called on `Vec<f64>` due to unsatisfied trait bounds\n    |\n    = note:\
    \ the following trait bounds were not satisfied:\n            `f64: Ord`\n   \
    \         which is required by `Vec<f64>: Ord`\n            `Vec<f64>: Ord`\n\
    \            which is required by `&Vec<f64>: Ord`\n            `Vec<f64>: Ord`\n\
    \            which is required by `&mut Vec<f64>: Ord`\n            `Vec<f64>:\
    \ Iterator`\n            which is required by `&mut Vec<f64>: Iterator`\n    \
    \        `f64: Ord`\n            which is required by `[f64]: Ord`\n         \
    \   `[f64]: Ord`\n            which is required by `&[f64]: Ord`\n           \
    \ `[f64]: Ord`\n            which is required by `&mut [f64]: Ord`\n         \
    \   `[f64]: Iterator`\n            which is required by `&mut [f64]: Iterator`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    numbers.iter()\n        .map(|x| x / numbers.iter().max().unwrap())\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpi6tupouf.rs:7:37\n\
    \     |\n7    |         .map(|x| x / numbers.iter().max().unwrap())\n     |  \
    \                                   ^^^ the trait `Ord` is not implemented for\
    \ `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut result: Vec<f64> = vec![];\n    let mut min = numbers[0]\
    \ as f64;\n    let mut max = numbers[0] as f64;\n\n    for n in numbers {\n  \
    \      if n < min {\n            min = n;\n        }\n\n        if n > max {\n\
    \            max = n;\n        }\n    }\n\n    for i in numbers {\n        result.append(i\
    \ as f64 / max - min);\n    }\n\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpt3rc2lts.rs:21:23\n   |\n\
    21 |         result.append(i as f64 / max - min);\n   |                      \
    \ ^^^^^^^^^^^^^^^^^^^^ expected `&mut Vec<f64>`, found `f64`\n   |\n   = note:\
    \ expected mutable reference `&mut Vec<f64>`\n                           found\
    \ type `f64`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    // If the smallest element is less than or equal to zero,\
    \ set it to zero\n    if numbers.iter().min().unwrap() <= 0 {\n        numbers.iter_mut().for_each(|x|\
    \ x = 0.0);\n    }\n    // If the largest element is greater than one, reset it\
    \ to one\n    if numbers.iter().max().unwrap() > 1.0 {\n        numbers.iter_mut().for_each(|x|\
    \ x = 1.0);\n    }\n    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmph2myfbrg.rs:7:23\n\
    \     |\n7    |     if numbers.iter().min().unwrap() <= 0 {\n     |          \
    \             ^^^ the trait `Ord` is not implemented for `f64`\n     |\n     =\
    \ help: the following other types implement trait `Ord`:\n               i128\n\
    \               i16\n               i32\n               i64\n               i8\n\
    \               isize\n               u128\n               u16\n             and\
    \ 4 others\n     = note: required because of the requirements on the impl of `Ord`\
    \ for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmph2myfbrg.rs:7:41\n  |\n7 |     if numbers.iter().min().unwrap()\
    \ <= 0 {\n  |                                         ^ expected `&f64`, found\
    \ integer\n\nerror[E0308]: mismatched types\n --> /tmp/tmph2myfbrg.rs:8:45\n \
    \ |\n8 |         numbers.iter_mut().for_each(|x| x = 0.0);\n  |              \
    \                        -      ^^^ expected `&mut f64`, found floating-point\
    \ number\n  |                                      |\n  |                    \
    \                  expected due to this parameter type\n  |\nhelp: consider dereferencing\
    \ here to assign to the mutable borrowed piece of memory\n  |\n8 |         numbers.iter_mut().for_each(|x|\
    \ *x = 0.0);\n  |                                         +\n\nerror[E0277]: the\
    \ trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmph2myfbrg.rs:11:23\n\
    \     |\n11   |     if numbers.iter().max().unwrap() > 1.0 {\n     |         \
    \              ^^^ the trait `Ord` is not implemented for `f64`\n     |\n    \
    \ = help: the following other types implement trait `Ord`:\n               i128\n\
    \               i16\n               i32\n               i64\n               i8\n\
    \               isize\n               u128\n               u16\n             and\
    \ 4 others\n     = note: required because of the requirements on the impl of `Ord`\
    \ for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmph2myfbrg.rs:11:40\n   |\n11 |     if numbers.i"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    // Check we have more than one number\n    let size = numbers.len();\n\
    \    if size == 0 {\n        return vec![];\n    }\n    if size <= 1 {\n     \
    \   // Return single number if only one number present\n        return vec![0];\n\
    \    }\n    // Calculate min and max values for rescaling\n    let min = numbers.iter().min().unwrap();\n\
    \    let max = numbers.iter().max().unwrap();\n    let mut rescaled: Vec<f64>\
    \ = vec![min];\n    let mut count = 0;\n    // Transform all numbers in vector\
    \ to [0, 1]\n    for n in numbers {\n        rescaled.push(n.powi(1.0 / size)\
    \ as f64);\n        if n == max {\n            count = 1;\n        }\n       \
    \ if n == min {\n            count = 0;\n        }\n    }\n    if count == 0 {\n\
    \        rescaled = vec![];\n    }\n    rescaled\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpysirmwh6.rs:13:21\n   |\n\
    13 |         return vec![0];\n   |                     ^\n   |               \
    \      |\n   |                     expected `f64`, found integer\n   |       \
    \              help: use a float literal: `0.0`\n\nerror[E0277]: the trait bound\
    \ `f64: Ord` is not satisfied\n    --> /tmp/tmpysirmwh6.rs:16:30\n     |\n16 \
    \  |     let min = numbers.iter().min().unwrap();\n     |                    \
    \          ^^^ the trait `Ord` is not implemented for `f64`\n     |\n     = help:\
    \ the following other types implement trait `Ord`:\n               i128\n    \
    \           i16\n               i32\n               i64\n               i8\n \
    \              isize\n               u128\n               u16\n             and\
    \ 4 others\n     = note: required because of the requirements on the impl of `Ord`\
    \ for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpysirmwh6.rs:17:30\n\
    \     |\n17   |     let max = numbers.iter().max().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpysirmwh6.rs:18:39\n   |\n18 |\
    \     let mut rescaled: Vec<f64> = vec![min];\n   |                          \
    \             ^^^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n18 |     let mut rescaled: Vec<f64> = vec![*min];\n   |  \
    \                                     +\n\nerror[E0277]: cannot divide `{float}`\
    \ by `usize`\n  --> /tmp/tmpysirmwh6.rs:22:34\n   |\n22 |         rescaled.push(n.powi(1.0\
    \ / size) as f64);\n   |                                  ^ no implementa"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut range\
    \ = max - min;\n    if range == 0.0 {\n        return vec![];\n    }\n    let\
    \ mut scaled: Vec<f64> = vec![];\n    for (i, n) in numbers.iter().enumerate()\
    \ {\n        scaled.append(n / range - min / range);\n    }\n    scaled\n}\n\n\
    fn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpn3_ciy8i.rs:22:23\n   |\n\
    22 |         scaled.append(n / range - min / range);\n   |                   \
    \    ^^^^^^^^^^^^^^^^^^^^^^^ expected `&mut Vec<f64>`, found `f64`\n   |\n   =\
    \ note: expected mutable reference `&mut Vec<f64>`\n                         \
    \  found type `f64`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    if numbers.len() < 2 {\n        numbers\n    } else {\n \
    \       let mut min_number = numbers[0];\n        let mut max_number = numbers[0];\n\
    \n        for num in numbers {\n            if num < min_number {\n          \
    \      min_number = num;\n            }\n\n            if num > max_number {\n\
    \                max_number = num;\n            }\n        }\n\n        let mut\
    \ new_numbers = Vec::new();\n\n        for num in numbers {\n            new_numbers.push((num\
    \ - min_number) / (max_number - min_number));\n        }\n\n        new_numbers\n\
    \    }\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp5vbme1xu.rs:24:20\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n12  |         for num in numbers {\n\
    \    |                    ------- `numbers` moved due to this implicit call to\
    \ `.into_iter()`\n...\n24  |         for num in numbers {\n    |             \
    \       ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\nhelp: consider iterating over\
    \ a slice of the `Vec<f64>`'s content to avoid moving into the `for` loop\n  \
    \  |\n12  |         for num in &numbers {\n    |                    +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    if numbers.len() < 2 {\n        return vec![];\n    }\n \
    \   if numbers.len() == 2 {\n        let min: f64 = numbers[0];\n        let max:\
    \ f64 = numbers[1];\n        if min > 0 {\n            vec![0.0, min / max]\n\
    \        } else {\n            vec![1.0, max / min]\n        }\n    } else {\n\
    \        let min: f64 = numbers[0];\n        let max: f64 = numbers[1];\n    \
    \    let mut vec: Vec<f64> = Vec::new();\n        let mut x: f64 = 0.0;\n    \
    \    let mut y: f64 = 0.0;\n        let mut last_x: f64 = 0.0;\n        let mut\
    \ last_y: f64 = 0.0;\n        for i in numbers.iter().rev() {\n            if\
    \ x > 0 {\n                vec.push((x - last_x) / (y - last_y));\n          \
    \      last_x = x;\n                last_y = y;\n            }\n            x\
    \ = i;\n            y = numbers[numbers.len() - i - 1];\n        }\n        vec.push(1.0\
    \ - x);\n        vec\n    }\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2ofi_p_2.rs:12:18\n   |\n\
    12 |         if min > 0 {\n   |                  ^\n   |                  |\n\
    \   |                  expected `f64`, found integer\n   |                  help:\
    \ use a float literal: `0.0`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2ofi_p_2.rs:26:20\n\
    \   |\n26 |             if x > 0 {\n   |                    ^\n   |          \
    \          |\n   |                    expected `f64`, found integer\n   |    \
    \                help: use a float literal: `0.0`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2ofi_p_2.rs:31:17\n   |\n21 |         let mut x: f64 =\
    \ 0.0;\n   |                    --- expected due to this type\n...\n31 |     \
    \        x = i;\n   |                 ^ expected `f64`, found `&f64`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n31 |             x = *i;\n   |    \
    \             +\n\nerror[E0277]: cannot subtract `&f64` from `usize`\n  --> /tmp/tmp2ofi_p_2.rs:32:39\n\
    \   |\n32 |             y = numbers[numbers.len() - i - 1];\n   |            \
    \                           ^ no implementation for `usize - &f64`\n   |\n   =\
    \ help: the trait `Sub<&f64>` is not implemented for `usize`\n   = help: the following\
    \ other types implement trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n\
    \             <&'a f64 as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n  \
    \           <&'a i16 as Sub<i16>>\n             <&'a i32 as Sub<i32>>\n      \
    \       <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n            \
    \ <&'a isize as Sub<isize>>\n           and 48 others\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    numbers.into_iter().map(|x| x / numbers.len() as f64).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `numbers`\n   --> /tmp/tmpolf1isoj.rs:6:29\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n6   |     numbers.into_iter().map(|x| x\
    \ / numbers.len() as f64).collect()\n    |             -----------     ^^^   \
    \  ------- borrow occurs due to use in closure\n    |             |          \
    \     |\n    |             |               value borrowed here after move\n  \
    \  |             `numbers` moved due to this method call\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `numbers`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut new_vec = Vec::new();\n    for i in 0..numbers.len()\
    \ {\n        let old_value = numbers[i];\n        let new_value = old_value /\
    \ std::f64::consts::ONE;\n        new_vec.push(new_value);\n    }\n    new_vec\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `ONE` in module `std::f64::consts`\n -->\
    \ /tmp/tmp7mca5yii.rs:9:55\n  |\n9 |         let new_value = old_value / std::f64::consts::ONE;\n\
    \  |                                                       ^^^ not found in `std::f64::consts`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    if numbers.len() == 0 {\n        return vec![];\n    }\n\
    \    let mut res = vec![numbers[0]];\n    for i in 1..numbers.len() {\n      \
    \  if numbers[i] < res[0] {\n            res[0] = numbers[i];\n        }\n   \
    \     if numbers[i] > res[res.len() - 1] {\n            res[res.len() - 1] = numbers[i];\n\
    \        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0502]: cannot borrow `res` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmpq6s4_oif.rs:15:17\n   |\n15 |             res[res.len()\
    \ - 1] = numbers[i];\n   |             ----^^^^^^^^^-----\n   |             |\
    \   |\n   |             |   immutable borrow occurs here\n   |             mutable\
    \ borrow occurs here\n   |             mutable borrow later used here\n   |\n\
    help: try adding a local storing this...\n  --> /tmp/tmpq6s4_oif.rs:15:17\n  \
    \ |\n15 |             res[res.len() - 1] = numbers[i];\n   |                 ^^^^^^^^^\n\
    help: ...and then using that local here\n  --> /tmp/tmpq6s4_oif.rs:15:13\n   |\n\
    15 |             res[res.len() - 1] = numbers[i];\n   |             ^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0502`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers.min();\n    let mut max = numbers.max();\n\
    \    let mut length = numbers.len();\n    numbers.sort_unstable();\n\n    while\
    \ min < max {\n        if numbers[length - 1] == 0.0 {\n            min = 0.0;\n\
    \        }\n\n        if numbers[0] == 0.0 {\n            max = 0.0;\n       \
    \ }\n\n        if max - min < std::f64::EPSILON {\n            return vec![min,\
    \ max];\n        }\n\n        let mid = (min + max) / 2.0;\n        let new_min\
    \ = numbers[length - 1] / mid;\n        let new_max = numbers[0] / mid;\n\n  \
    \      if new_min != 0.0 {\n            min = new_min;\n        }\n\n        if\
    \ new_max != 1.0 {\n            max = new_max;\n        }\n\n        length =\
    \ length - 1;\n    }\n\n    vec![min, max]\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: the method `min` exists for struct `Vec<f64>`, but its trait\
    \ bounds were not satisfied\n   --> /tmp/tmpjbhueqer.rs:6:27\n    |\n6   |   \
    \    let mut min = numbers.min();\n    |                             ^^^ method\
    \ cannot be called on `Vec<f64>` due to unsatisfied trait bounds\n    |\n    =\
    \ note: the following trait bounds were not satisfied:\n            `f64: Ord`\n\
    \            which is required by `Vec<f64>: Ord`\n            `Vec<f64>: Ord`\n\
    \            which is required by `&Vec<f64>: Ord`\n            `Vec<f64>: Ord`\n\
    \            which is required by `&mut Vec<f64>: Ord`\n            `Vec<f64>:\
    \ Iterator`\n            which is required by `&mut Vec<f64>: Iterator`\n    \
    \        `f64: Ord`\n            which is required by `[f64]: Ord`\n         \
    \   `[f64]: Ord`\n            which is required by `&[f64]: Ord`\n           \
    \ `[f64]: Ord`\n            which is required by `&mut [f64]: Ord`\n         \
    \   `[f64]: Iterator`\n            which is required by `&mut [f64]: Iterator`\n\
    \nerror[E0599]: the method `max` exists for struct `Vec<f64>`, but its trait bounds\
    \ were not satisfied\n   --> /tmp/tmpjbhueqer.rs:7:27\n    |\n7   |       let\
    \ mut max = numbers.max();\n    |                             ^^^ method cannot\
    \ be called on `Vec<f64>` due to unsatisfied trait bounds\n    |\n    = note:\
    \ the following trait bounds were not satisfied:\n            `f64: Ord`\n   \
    \         which is required by `Vec<f64>: Ord`\n            `Vec<f64>: Ord`\n\
    \            which is required by `&Vec<f64>: Ord`\n            `Vec<f64>: Ord`\n\
    \            which is required by `&mut Vec<f64>: Ord`\n            `Vec<f64>:\
    \ Iterator`\n            which is required by `&mut Vec<f64>: Iterator`\n    \
    \        `f64: Ord`\n            which is required by `[f64]: Ord`\n         \
    \   `[f64]: Ord`\n            which is required by `&[f64]: Ord`\n           \
    \ `[f64]: Ord`\n            which is required by `&mut [f64]: Ord`\n         \
    \   `[f64]: Iterator`\n            which is required by `&mut [f64]: Iterator`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpjbhueqer.rs:"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let len = numbers.len();\n    if len == 0 {\n        vec![0.]\n\
    \    }\n    if len == 1 || numbers.iter().any(|&x| x == 0.0) {\n        numbers\n\
    \    } else {\n        let mut sum = 0.;\n        for number in numbers {\n  \
    \          sum += number;\n        }\n        let ratio = sum / (len as f64);\n\
    \        let mut scale = 1.;\n        for (idx, number) in numbers.iter().enumerate()\
    \ {\n            scale = (scale * (number as f64 / ratio)) as f64;\n        }\n\
    \        numbers * scale\n    }\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpujyyixjw.rs:8:9\n  |\n7 |\
    \ /     if len == 0 {\n8 | |         vec![0.]\n  | |         ^^^^^^^^ expected\
    \ `()`, found struct `Vec`\n9 | |     }\n  | |_____- expected this to be `()`\n\
    \  |\n  = note: expected unit type `()`\n                found struct `Vec<{float}>`\n\
    \  = note: this error originates in the macro `vec` (in Nightly builds, run with\
    \ -Z macro-backtrace for more info)\nhelp: consider using a semicolon here\n \
    \ |\n9 |     };\n  |      +\n\nerror[E0369]: cannot multiply `Vec<f64>` by `f64`\n\
    \  --> /tmp/tmpujyyixjw.rs:22:17\n   |\n22 |         numbers * scale\n   |   \
    \      ------- ^ ----- f64\n   |         |\n   |         Vec<f64>\n\nerror[E0606]:\
    \ casting `&f64` as `f64` is invalid\n  --> /tmp/tmpujyyixjw.rs:20:31\n   |\n\
    20 |             scale = (scale * (number as f64 / ratio)) as f64;\n   |     \
    \                          ------^^^^^^^\n   |                               |\n\
    \   |                               cannot cast `&f64` as `f64`\n   |        \
    \                       help: dereference the expression: `*number`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369, E0606.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut smallest = numbers[0];\n    let mut largest = numbers[0];\n\
    \    for n in numbers {\n        if n < smallest {\n            smallest = 0.0;\n\
    \        }\n        if n > largest {\n            largest = 1.0;\n        }\n\
    \    }\n    numbers.map(|x| x / smallest - 1.0);\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `Vec<f64>` is not an iterator\n   --> /tmp/tmp8u8epilw.rs:16:13\n\
    \    |\n16  |       numbers.map(|x| x / smallest - 1.0);\n    |              \
    \ ^^^ `Vec<f64>` is not an iterator\n    |\n    = note: the following trait bounds\
    \ were not satisfied:\n            `Vec<f64>: Iterator`\n            which is\
    \ required by `&mut Vec<f64>: Iterator`\n            `[f64]: Iterator`\n     \
    \       which is required by `&mut [f64]: Iterator`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp8u8epilw.rs:5:42\n  |\n5 | fn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n  |    ---------------                       ^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n  |\n  = note: expected struct `Vec<f64>`\n\
    \          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let max_number = numbers.iter().max().unwrap();\n    let\
    \ min_number = numbers.iter().min().unwrap();\n    let scaling_factor = max_number\
    \ - min_number;\n    numbers\n        .iter()\n        .map(|f| f / scaling_factor)\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpd4lw5eg8.rs:6:37\n\
    \     |\n6    |     let max_number = numbers.iter().max().unwrap();\n     |  \
    \                                   ^^^ the trait `Ord` is not implemented for\
    \ `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpd4lw5eg8.rs:7:37\n\
    \     |\n7    |     let min_number = numbers.iter().min().unwrap();\n     |  \
    \                                   ^^^ the trait `Ord` is not implemented for\
    \ `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    // We want to transform the numbers into [0, 1], so scale\
    \ by (number - min(numbers))\n    // / max(numbers)\n    let mut rescaled = numbers;\n\
    \    rescaled.sort();\n    rescaled.push(0.0);\n    rescaled.push(-rescaled.max().unwrap());\n\
    \    rescaled * rescaled.len()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n   --> /tmp/tmpntr_dm76.rs:9:14\n\
    \    |\n9   |     rescaled.sort();\n    |              ^^^^ the trait `Ord` is\
    \ not implemented for `f64`\n    |\n    = help: the following other types implement\
    \ trait `Ord`:\n              i128\n              i16\n              i32\n   \
    \           i64\n              i8\n              isize\n              u128\n \
    \             u16\n            and 4 others\nnote: required by a bound in `slice::<impl\
    \ [T]>::sort`\n\nerror[E0599]: the method `max` exists for struct `Vec<f64>`,\
    \ but its trait bounds were not satisfied\n   --> /tmp/tmpntr_dm76.rs:11:29\n\
    \    |\n11  |       rescaled.push(-rescaled.max().unwrap());\n    |          \
    \                     ^^^ method cannot be called on `Vec<f64>` due to unsatisfied\
    \ trait bounds\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `f64: Ord`\n            which is required by `Vec<f64>: Ord`\n  \
    \          `Vec<f64>: Ord`\n            which is required by `&Vec<f64>: Ord`\n\
    \            `Vec<f64>: Ord`\n            which is required by `&mut Vec<f64>:\
    \ Ord`\n            `Vec<f64>: Iterator`\n            which is required by `&mut\
    \ Vec<f64>: Iterator`\n            `f64: Ord`\n            which is required by\
    \ `[f64]: Ord`\n            `[f64]: Ord`\n            which is required by `&[f64]:\
    \ Ord`\n            `[f64]: Ord`\n            which is required by `&mut [f64]:\
    \ Ord`\n            `[f64]: Iterator`\n            which is required by `&mut\
    \ [f64]: Iterator`\n\nerror[E0369]: cannot multiply `Vec<f64>` by `usize`\n  -->\
    \ /tmp/tmpntr_dm76.rs:12:14\n   |\n12 |     rescaled * rescaled.len()\n   |  \
    \   -------- ^ -------------- usize\n   |     |\n   |     Vec<f64>\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0369,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers.min().unwrap();\n    let mut max =\
    \ numbers.max().unwrap();\n    // Make sure the largest value is exactly 1, to\
    \ avoid overflow and divide by 0 errors.\n    if max == 1.0 {\n        max = 0.0;\n\
    \    }\n    numbers.iter().map(|x| min + (x - min) / (max - min)).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: the method `min` exists for struct `Vec<f64>`, but its trait\
    \ bounds were not satisfied\n   --> /tmp/tmpi9ze5489.rs:6:27\n    |\n6   |   \
    \    let mut min = numbers.min().unwrap();\n    |                            \
    \ ^^^ method cannot be called on `Vec<f64>` due to unsatisfied trait bounds\n\
    \    |\n    = note: the following trait bounds were not satisfied:\n         \
    \   `f64: Ord`\n            which is required by `Vec<f64>: Ord`\n           \
    \ `Vec<f64>: Ord`\n            which is required by `&Vec<f64>: Ord`\n       \
    \     `Vec<f64>: Ord`\n            which is required by `&mut Vec<f64>: Ord`\n\
    \            `Vec<f64>: Iterator`\n            which is required by `&mut Vec<f64>:\
    \ Iterator`\n            `f64: Ord`\n            which is required by `[f64]:\
    \ Ord`\n            `[f64]: Ord`\n            which is required by `&[f64]: Ord`\n\
    \            `[f64]: Ord`\n            which is required by `&mut [f64]: Ord`\n\
    \            `[f64]: Iterator`\n            which is required by `&mut [f64]:\
    \ Iterator`\n\nerror[E0599]: the method `max` exists for struct `Vec<f64>`, but\
    \ its trait bounds were not satisfied\n   --> /tmp/tmpi9ze5489.rs:7:27\n    |\n\
    7   |       let mut max = numbers.max().unwrap();\n    |                     \
    \        ^^^ method cannot be called on `Vec<f64>` due to unsatisfied trait bounds\n\
    \    |\n    = note: the following trait bounds were not satisfied:\n         \
    \   `f64: Ord`\n            which is required by `Vec<f64>: Ord`\n           \
    \ `Vec<f64>: Ord`\n            which is required by `&Vec<f64>: Ord`\n       \
    \     `Vec<f64>: Ord`\n            which is required by `&mut Vec<f64>: Ord`\n\
    \            `Vec<f64>: Iterator`\n            which is required by `&mut Vec<f64>:\
    \ Iterator`\n            `f64: Ord`\n            which is required by `[f64]:\
    \ Ord`\n            `[f64]: Ord`\n            which is required by `&[f64]: Ord`\n\
    \            `[f64]: Ord`\n            which is required by `&mut [f64]: Ord`\n\
    \            `[f64]: Iterator`\n            which is required by `&mut [f64]:\
    \ Iterator`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0] as f64;\n    let mut max = numbers[0]\
    \ as f64;\n    for number in numbers.iter().skip(1) {\n        min = min(number,\
    \ min);\n        max = max(number, max);\n    }\n    for number in numbers.iter().skip(1)\
    \ {\n        *number /= (max - min);\n    }\n    numbers.iter().cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around assigned value\n  --> /tmp/tmpv49z6uaz.rs:13:20\n\
    \   |\n13 |         *number /= (max - min);\n   |                    ^       \
    \  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these\
    \ parentheses\n   |\n13 -         *number /= (max - min);\n13 +         *number\
    \ /= max - min;\n   | \n\nerror[E0618]: expected function, found `f64`\n --> /tmp/tmpv49z6uaz.rs:9:15\n\
    \  |\n6 |     let mut min = numbers[0] as f64;\n  |         ------- `min` has\
    \ type `f64`\n...\n9 |         min = min(number, min);\n  |               ^^^-------------\n\
    \  |               |\n  |               call expression requires function\n\n\
    error[E0618]: expected function, found `f64`\n  --> /tmp/tmpv49z6uaz.rs:10:15\n\
    \   |\n7  |     let mut max = numbers[0] as f64;\n   |         ------- `max` has\
    \ type `f64`\n...\n10 |         max = max(number, max);\n   |               ^^^-------------\n\
    \   |               |\n   |               call expression requires function\n\n\
    error: aborting due to 2 previous errors; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0618`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min: f64 = numbers[0];\n    let mut max: f64 = numbers[0];\n\
    \    for n in numbers {\n        if n > max {\n            max = n;\n        }\n\
    \        if n < min {\n            min = n;\n        }\n    }\n    for n in numbers\
    \ {\n        *n = (*n - min) / (max - min);\n    }\n    numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmpsemzjrrv.rs:17:9\n\
    \   |\n17 |         *n = (*n - min) / (max - min);\n   |         ^^\n\nerror[E0614]:\
    \ type `f64` cannot be dereferenced\n  --> /tmp/tmpsemzjrrv.rs:17:15\n   |\n17\
    \ |         *n = (*n - min) / (max - min);\n   |               ^^\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0614`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut new_numbers = Vec::new();\n    for i in numbers.iter()\
    \ {\n        new_numbers.push(i as f64 / numbers[0]);\n    }\n    new_numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0606]: casting `&f64` as `f64` is invalid\n --> /tmp/tmpe52b8syc.rs:8:26\n\
    \  |\n8 |         new_numbers.push(i as f64 / numbers[0]);\n  |              \
    \            -^^^^^^^\n  |                          |\n  |                   \
    \       cannot cast `&f64` as `f64`\n  |                          help: dereference\
    \ the expression: `*i`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0606`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut max_value = numbers[0];\n    for n in numbers {\n\
    \        if n > max_value {\n            max_value = n;\n        }\n    }\n  \
    \  let mut min_value = numbers[0];\n    for n in numbers {\n        if n < min_value\
    \ {\n            min_value = n;\n        }\n    }\n    let delta = max_value -\
    \ min_value;\n    if delta == 0.0 {\n        return Vec::new();\n    }\n    let\
    \ mut result = Vec::new();\n    for n in numbers {\n        let scaled_value =\
    \ n / delta;\n        result.push(scaled_value + min_value);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `numbers`\n   --> /tmp/tmpyaybclbv.rs:12:25\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n6   |     let mut max_value = numbers[0];\n\
    7   |     for n in numbers {\n    |              ------- `numbers` moved due to\
    \ this implicit call to `.into_iter()`\n...\n12  |     let mut min_value = numbers[0];\n\
    \    |                         ^^^^^^^ value borrowed here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    help: consider iterating over a slice of the `Vec<f64>`'s content to avoid moving\
    \ into the `for` loop\n    |\n7   |     for n in &numbers {\n    |           \
    \   +\n\nerror[E0382]: use of moved value: `numbers`\n  --> /tmp/tmpyaybclbv.rs:23:14\n\
    \   |\n5  | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n   |        \
    \            ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n13 |     for n in numbers {\n   |\
    \              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n23 |     for n in numbers {\n   |              ^^^^^^^ value used here after\
    \ move\n   |\nhelp: consider iterating over a slice of the `Vec<f64>`'s content\
    \ to avoid moving into the `for` loop\n   |\n13 |     for n in &numbers {\n  \
    \ |              +\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut scaled_vec: Vec<f64> = numbers.into_iter().collect();\n\
    \    scaled_vec.sort();\n    let mut min_val = scaled_vec[0];\n    let mut max_val\
    \ = scaled_vec[0];\n    let mut range = max_val - min_val;\n    let mut new_min\
    \ = scaled_vec[0];\n    let mut new_max = scaled_vec[0];\n    for &x in scaled_vec.iter_mut()\
    \ {\n        let min_val = x;\n        let max_val = x;\n        range = max_val\
    \ - min_val;\n        if range < 0.0 {\n            new_min = x;\n           \
    \ new_max = x;\n        } else {\n            if min_val > 0.0 {\n           \
    \     new_min = min_val;\n            }\n            if max_val < 1.0 {\n    \
    \            new_max = max_val;\n            }\n        }\n    }\n    new_vec.push(new_min);\n\
    \    new_vec.push(new_max);\n    new_vec\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `new_vec` in this scope\n  --> /tmp/tmpwga0z16x.rs:29:5\n\
    \   |\n29 |     new_vec.push(new_min);\n   |     ^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find value `new_vec` in this scope\n  --> /tmp/tmpwga0z16x.rs:30:5\n\
    \   |\n30 |     new_vec.push(new_max);\n   |     ^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find value `new_vec` in this scope\n  --> /tmp/tmpwga0z16x.rs:31:5\n\
    \   |\n31 |     new_vec\n   |     ^^^^^^^ not found in this scope\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n   --> /tmp/tmpwga0z16x.rs:7:16\n\
    \    |\n7   |     scaled_vec.sort();\n    |                ^^^^ the trait `Ord`\
    \ is not implemented for `f64`\n    |\n    = help: the following other types implement\
    \ trait `Ord`:\n              i128\n              i16\n              i32\n   \
    \           i64\n              i8\n              isize\n              u128\n \
    \             u16\n            and 4 others\nnote: required by a bound in `slice::<impl\
    \ [T]>::sort`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwga0z16x.rs:13:9\n\
    \   |\n13 |     for &x in scaled_vec.iter_mut() {\n   |         ^^    ---------------------\
    \ this expression has type `Option<&mut f64>`\n   |         |\n   |         types\
    \ differ in mutability\n   |         help: you can probably remove the explicit\
    \ borrow: `x`\n   |\n   = note: expected mutable reference `&mut f64`\n      \
    \                found reference `&_`\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    if numbers.len() <= 2 {\n        numbers\n    } else {\n\
    \        let mut min_value: f64 = numbers.iter().min().unwrap();\n        let\
    \ mut max_value: f64 = numbers.iter().max().unwrap();\n        max_value = (max_value\
    \ - min_value) / (numbers[1] - numbers[0]);\n        numbers.iter_mut().for_each(|x|\
    \ {\n            x = x.min(max_value).max(min_value).unwrap();\n        });\n\
    \        numbers\n    }\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmph0gntj9s.rs:9:49\n\
    \     |\n9    |         let mut min_value: f64 = numbers.iter().min().unwrap();\n\
    \     |                                                 ^^^ the trait `Ord` is\
    \ not implemented for `f64`\n     |\n     = help: the following other types implement\
    \ trait `Ord`:\n               i128\n               i16\n               i32\n\
    \               i64\n               i8\n               isize\n               u128\n\
    \               u16\n             and 4 others\n     = note: required because\
    \ of the requirements on the impl of `Ord` for `&f64`\nnote: required by a bound\
    \ in `std::iter::Iterator::min`\n\nerror[E0308]: mismatched types\n --> /tmp/tmph0gntj9s.rs:9:34\n\
    \  |\n9 |         let mut min_value: f64 = numbers.iter().min().unwrap();\n  |\
    \                            ---   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `f64`,\
    \ found `&f64`\n  |                            |\n  |                        \
    \    expected due to this\n  |\nhelp: consider dereferencing the borrow\n  |\n\
    9 |         let mut min_value: f64 = *numbers.iter().min().unwrap();\n  |    \
    \                              +\n\nerror[E0277]: the trait bound `f64: Ord` is\
    \ not satisfied\n    --> /tmp/tmph0gntj9s.rs:10:49\n     |\n10   |         let\
    \ mut max_value: f64 = numbers.iter().max().unwrap();\n     |                \
    \                                 ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmph0gntj9s.rs:10:34\n   |\n10 |\
    \         let mut max_value: f64 = numbers.iter().max().unwrap();\n   |      \
    \                      ---   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `f64`, found\
    \ `&f64`\n   |              "
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    assert!(numbers.len() > 1, \"Vector should have at least\
    \ 2 elements\");\n    if numbers.len() == 1 {\n        return vec![0.0];\n   \
    \ }\n    numbers.iter()\n        .map(|n| minmax::<f64>(n, 0.0, 1.0).min)\n  \
    \      .collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n  \
    \  assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `minmax` in this scope\n  --> /tmp/tmppnbfx8sx.rs:11:18\n\
    \   |\n11 |         .map(|n| minmax::<f64>(n, 0.0, 1.0).min)\n   |           \
    \       ^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    if numbers.len() < 2 {\n        return numbers;\n    }\n\n\
    \    let mut min_number = numbers.iter().min().unwrap();\n    let mut max_number\
    \ = numbers.iter().max().unwrap();\n    let mut new_numbers = Vec::with_capacity(numbers.len());\n\
    \n    while min_number < 0 {\n        min_number += 1.0;\n    }\n    while max_number\
    \ < 1.0 {\n        max_number += 1.0;\n    }\n\n    new_numbers.push(min_number);\n\
    \    new_numbers.push(max_number);\n\n    for i in 1..numbers.len() {\n      \
    \  let mut new_number = numbers[i];\n        if new_number < 0.0 {\n         \
    \   new_number += 1.0;\n        }\n        new_numbers[i] = new_number;\n    }\n\
    \n    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n  \
    \  assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpnn7yor1n.rs:10:41\n\
    \     |\n10   |     let mut min_number = numbers.iter().min().unwrap();\n    \
    \ |                                         ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpnn7yor1n.rs:11:41\n\
    \     |\n11   |     let mut max_number = numbers.iter().max().unwrap();\n    \
    \ |                                         ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpnn7yor1n.rs:14:24\n   |\n14 |\
    \     while min_number < 0 {\n   |                        ^ expected `&f64`, found\
    \ integer\n\nerror[E0368]: binary assignment operation `+=` cannot be applied\
    \ to type `&f64`\n  --> /tmp/tmpnn7yor1n.rs:15:9\n   |\n15 |         min_number\
    \ += 1.0;\n   |         ----------^^^^^^^\n   |         |\n   |         cannot\
    \ use `+=` on type `&f64`\n   |\nhelp: `+=` can be used on `f64`, you can dereference\
    \ `min_number`\n   |\n15 |         *min_number += 1.0;\n   |         +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpnn7yor1n.rs:17:24\n   |\n17 |     while max_number\
    \ < 1.0 {\n   |                        ^^^\n   |                        |\n  \
    \ |                        expected `&f64`, found floating-point"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    if numbers.len() < 2 {\n        return numbers;\n    }\n\
    \    let mut min: f64 = numbers[0];\n    let mut max: f64 = numbers[0];\n    for\
    \ &n in numbers {\n        if min > n {\n            min = n;\n        }\n   \
    \     if max < n {\n            max = n;\n        }\n    }\n    let delta = (max\
    \ - min) as f64;\n    let mut newvals: Vec<f64> = Vec::with_capacity(numbers.len());\n\
    \    for n in numbers {\n        if n < min {\n            newvals.push((min -\
    \ n) / delta);\n        } else {\n            newvals.push((n - min) / delta);\n\
    \        }\n    }\n    newvals\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvugsoc66.rs:11:9\n   |\n\
    11 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut output: Vec<f64> = Vec::new();\n    let mut min_value:\
    \ f64 = std::f64::MAX;\n    let mut max_value: f64 = std::f64::MIN;\n\n    for\
    \ i in numbers {\n        let current_min_value: f64 = std::f64::MIN;\n      \
    \  let current_max_value: f64 = std::f64::MAX;\n        let current: f64 = std::f64::MAX;\n\
    \        let current: f64 = std::f64::MIN;\n        let current: f64 = i;\n  \
    \  }\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpm6qtlmh7.rs:10:5\n   |\n\
    5  |   fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n   |             \
    \                               -------- expected `Vec<f64>` because of return\
    \ type\n...\n10 | /     for i in numbers {\n11 | |         let current_min_value:\
    \ f64 = std::f64::MIN;\n12 | |         let current_max_value: f64 = std::f64::MAX;\n\
    13 | |         let current: f64 = std::f64::MAX;\n14 | |         let current:\
    \ f64 = std::f64::MIN;\n15 | |         let current: f64 = i;\n16 | |     }\n \
    \  | |_____^ expected struct `Vec`, found `()`\n   |\n   = note: expected struct\
    \ `Vec<f64>`\n           found unit type `()`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut max_value: f64;\n    for number in numbers {\n  \
    \      if number > max_value {\n            max_value = number;\n        }\n \
    \   }\n\n    let mut min_value: f64;\n    for number in numbers {\n        if\
    \ number < min_value {\n            min_value = number;\n        }\n    }\n\n\
    \    let mut rescaled_numbers = Vec::new();\n    for number in numbers {\n   \
    \     let rescaled_number = (number - min_value) / (max_value - min_value);\n\
    \        rescaled_numbers.push(rescaled_number);\n    }\n\n    rescaled_numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0381]: use of possibly-uninitialized variable: `max_value`\n -->\
    \ /tmp/tmpxo9odz1u.rs:8:21\n  |\n8 |         if number > max_value {\n  |    \
    \                 ^^^^^^^^^ use of possibly-uninitialized `max_value`\n\nerror[E0382]:\
    \ use of moved value: `numbers`\n   --> /tmp/tmpxo9odz1u.rs:14:19\n    |\n5  \
    \ | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |               \
    \     ------- move occurs because `numbers` has type `Vec<f64>`, which does not\
    \ implement the `Copy` trait\n6   |     let mut max_value: f64;\n7   |     for\
    \ number in numbers {\n    |                   ------- `numbers` moved due to\
    \ this implicit call to `.into_iter()`\n...\n14  |     for number in numbers {\n\
    \    |                   ^^^^^^^ value used here after move\n    |\nnote: this\
    \ function takes ownership of the receiver `self`, which moves `numbers`\nhelp:\
    \ consider iterating over a slice of the `Vec<f64>`'s content to avoid moving\
    \ into the `for` loop\n    |\n7   |     for number in &numbers {\n    |      \
    \             +\n\nerror[E0381]: use of possibly-uninitialized variable: `min_value`\n\
    \  --> /tmp/tmpxo9odz1u.rs:15:21\n   |\n15 |         if number < min_value {\n\
    \   |                     ^^^^^^^^^ use of possibly-uninitialized `min_value`\n\
    \nerror[E0382]: use of moved value: `numbers`\n  --> /tmp/tmpxo9odz1u.rs:21:19\n\
    \   |\n5  | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n   |        \
    \            ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n14 |     for number in numbers {\n\
    \   |                   ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n21 |     for number in numbers {\n   |                   ^^^^^^^ value used\
    \ here after move\n   |\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n   |\n14 |     for number in &numbers\
    \ {\n   |                   +\n\nerror: aborting due to 4 previous errors\n\n\
    Some errors have detailed explanations: E0381, E0382.\nFor more information about\
    \ an error, try `rustc --explain E0381`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_value_f64 = numbers[0];\n    let mut max_value_f64\
    \ = numbers[0];\n    for n in numbers {\n        if n > max_value_f64 {\n    \
    \        max_value_f64 = n;\n        }\n        if n < min_value_f64 {\n     \
    \       min_value_f64 = n;\n        }\n    }\n    let mut result: Vec<f64> = Vec::new();\n\
    \    for i in numbers.iter() {\n        result.push((i - min_value_f64) / (max_value_f64\
    \ - min_value_f64));\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `numbers`\n   --> /tmp/tmpg4blcl4w.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     for i in numbers.iter() {\n    |              ^^^^^^^^^^^^^^ value\
    \ borrowed here after move\n    |\nnote: this function takes ownership of the\
    \ receiver `self`, which moves `numbers`\n    = note: borrow occurs due to deref\
    \ coercion to `[f64]`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min: f64 = numbers.iter().min().unwrap();\n    let\
    \ mut max: f64 = numbers.iter().max().unwrap();\n    max -= min;\n    min /= 2.0;\n\
    \    let mut vec: Vec<f64> = vec![min; numbers.len()];\n    for (i, n) in numbers.iter().enumerate()\
    \ {\n        vec[i] = n - (n - min) * max / min;\n    }\n    vec\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp_e8b_u5e.rs:6:39\n\
    \     |\n6    |     let mut min: f64 = numbers.iter().min().unwrap();\n     |\
    \                                       ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmp_e8b_u5e.rs:6:24\n  |\n6 |    \
    \ let mut min: f64 = numbers.iter().min().unwrap();\n  |                  ---\
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `f64`, found `&f64`\n  |          \
    \        |\n  |                  expected due to this\n  |\nhelp: consider dereferencing\
    \ the borrow\n  |\n6 |     let mut min: f64 = *numbers.iter().min().unwrap();\n\
    \  |                        +\n\nerror[E0277]: the trait bound `f64: Ord` is not\
    \ satisfied\n    --> /tmp/tmp_e8b_u5e.rs:7:39\n     |\n7    |     let mut max:\
    \ f64 = numbers.iter().max().unwrap();\n     |                               \
    \        ^^^ the trait `Ord` is not implemented for `f64`\n     |\n     = help:\
    \ the following other types implement trait `Ord`:\n               i128\n    \
    \           i16\n               i32\n               i64\n               i8\n \
    \              isize\n               u128\n               u16\n             and\
    \ 4 others\n     = note: required because of the requirements on the impl of `Ord`\
    \ for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp_e8b_u5e.rs:7:24\n  |\n7 |     let mut max: f64\
    \ = numbers.iter().max().unwrap();\n  |                  ---   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `f64`, found `&f64`\n  |                  |\n  |                  expected\
    \ due to this\n  |\nhelp: consider dereferencing the borrow\n  |\n7 |     let\
    \ mut max: f64 = *num"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_value = numbers.iter().min().unwrap();\n    let\
    \ mut max_value = numbers.iter().max().unwrap();\n    min_value += 1.0;\n    max_value\
    \ -= 1.0;\n    numbers.iter_mut().map(|n| {\n        *n /= max_value - min_value;\n\
    \        *n += min_value;\n        *n\n    }).collect()\n}\n\nfn main() {\n  \
    \  let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpyep7sa7g.rs:6:40\n\
    \     |\n6    |     let mut min_value = numbers.iter().min().unwrap();\n     |\
    \                                        ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpyep7sa7g.rs:7:40\n\
    \     |\n7    |     let mut max_value = numbers.iter().max().unwrap();\n     |\
    \                                        ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0368]: binary assignment operation `+=` cannot be applied to type `&f64`\n\
    \ --> /tmp/tmpyep7sa7g.rs:8:5\n  |\n8 |     min_value += 1.0;\n  |     ---------^^^^^^^\n\
    \  |     |\n  |     cannot use `+=` on type `&f64`\n  |\nhelp: `+=` can be used\
    \ on `f64`, you can dereference `min_value`\n  |\n8 |     *min_value += 1.0;\n\
    \  |     +\n\nerror[E0368]: binary assignment operation `-=` cannot be applied\
    \ to type `&f64`\n --> /tmp/tmpyep7sa7g.rs:9:5\n  |\n9 |     max_value -= 1.0;\n\
    \  |     ---------^^^^^^^\n  |     |\n  |     cannot use `-=` on type `&f64`\n\
    \  |\nhelp: `-=` can be used on `f64`, you can dereference `max_value`\n  |\n\
    9 |     *max_value -= 1.0;\n  |     +\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0368.\nFor more informa"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min: f64 = numbers.iter().min().unwrap();\n    let\
    \ mut max: f64 = numbers.iter().max().unwrap();\n\n    let mut scale: f64 = max\
    \ - min;\n    max = 1.0 * max + 0.0;\n    scale = (max - min) / max;\n\n    for\
    \ n in numbers {\n        *n /= scale;\n    }\n    return numbers;\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpta0vgwpw.rs:6:39\n\
    \     |\n6    |     let mut min: f64 = numbers.iter().min().unwrap();\n     |\
    \                                       ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmpta0vgwpw.rs:6:24\n  |\n6 |    \
    \ let mut min: f64 = numbers.iter().min().unwrap();\n  |                  ---\
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `f64`, found `&f64`\n  |          \
    \        |\n  |                  expected due to this\n  |\nhelp: consider dereferencing\
    \ the borrow\n  |\n6 |     let mut min: f64 = *numbers.iter().min().unwrap();\n\
    \  |                        +\n\nerror[E0277]: the trait bound `f64: Ord` is not\
    \ satisfied\n    --> /tmp/tmpta0vgwpw.rs:7:39\n     |\n7    |     let mut max:\
    \ f64 = numbers.iter().max().unwrap();\n     |                               \
    \        ^^^ the trait `Ord` is not implemented for `f64`\n     |\n     = help:\
    \ the following other types implement trait `Ord`:\n               i128\n    \
    \           i16\n               i32\n               i64\n               i8\n \
    \              isize\n               u128\n               u16\n             and\
    \ 4 others\n     = note: required because of the requirements on the impl of `Ord`\
    \ for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpta0vgwpw.rs:7:24\n  |\n7 |     let mut max: f64\
    \ = numbers.iter().max().unwrap();\n  |                  ---   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `f64`, found `&f64`\n  |                  |\n  |                  expected\
    \ due to this\n  |\nhelp: consider dereferencing the borrow\n  |\n7 |     let\
    \ mut max: f64 = *num"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    if numbers.len() == 1 {\n        vec![numbers[0], numbers[0]]\n\
    \    } else {\n        let mut min_x = numbers[0];\n        let mut max_x = numbers[0];\n\
    \        let mut min_y = numbers[0];\n        let mut max_y = numbers[0];\n  \
    \      for &n in &numbers[1:] {\n            min_x = min(min_x, n);\n        \
    \    max_x = max(max_x, n);\n            min_y = min(min_y, min_x);\n        \
    \    max_y = max(max_y, max_x);\n        }\n        vec![min_x, (max_x + 1) /\
    \ 2, min_y, (max_y + 1) / 2, max_y]\n    }\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error: expected type, found `]`\n  --> /tmp/tmpm85rq_uk.rs:13:30\n   |\n\
    13 |         for &n in &numbers[1:] {\n   |                             -^ expected\
    \ type\n   |                             |\n   |                             help:\
    \ maybe write a path separator here: `::`\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    assert!(numbers.len() >= 2);\n    let mut min = numbers[0];\n\
    \    let mut max = numbers[0];\n\n    for x in numbers.iter().rev() {\n      \
    \  if x < min {\n            min = x;\n        }\n        if x > max {\n     \
    \       max = x;\n        }\n    }\n\n    let mut normalized = Vec::with_capacity(numbers.len()\
    \ - 1);\n    for x in numbers.iter() {\n        let delta = x - min;\n       \
    \ normalized.push(delta * ((max - min) / delta + 1));\n    }\n    normalized\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxo0gedw4.rs:11:16\n   |\n\
    11 |         if x < min {\n   |                ^^^\n   |                |\n  \
    \ |                expected `&f64`, found `f64`\n   |                help: consider\
    \ borrowing here: `&min`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxo0gedw4.rs:12:19\n\
    \   |\n7  |     let mut min = numbers[0];\n   |                   ---------- expected\
    \ due to this value\n...\n12 |             min = x;\n   |                   ^\
    \ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n12 |             min = *x;\n   |                   +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpxo0gedw4.rs:14:16\n   |\n14 |         if x > max {\n  \
    \ |                ^^^\n   |                |\n   |                expected `&f64`,\
    \ found `f64`\n   |                help: consider borrowing here: `&max`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpxo0gedw4.rs:15:19\n   |\n8  |     let mut max\
    \ = numbers[0];\n   |                   ---------- expected due to this value\n\
    ...\n15 |             max = x;\n   |                   ^ expected `f64`, found\
    \ `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n15 |          \
    \   max = *x;\n   |                   +\n\nerror[E0277]: cannot add `{integer}`\
    \ to `f64`\n  --> /tmp/tmpxo0gedw4.rs:22:54\n   |\n22 |         normalized.push(delta\
    \ * ((max - min) / delta + 1));\n   |                                        \
    \              ^ no implementation for `f64 + {integer}`\n   |\n   = help: the\
    \ trait `Add<{integer}>` is not implemented for `f64`\n   = help: the following\
    \ other types implement trait `Add<Rhs>`:\n             <&'a f32 as Add<f32>>\n\
    \             <&'a f64 as Add<f64>>\n             <&'a i128 as Add<i128>>\n  \
    \           <&'a i16 as Add<i16>>\n             <&'a i32 as Add<i32>>\n      \
    \       <&'a i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n            \
    \ <&'a isize as Add<isize>>\n           and 48 others\nhelp: consider using a\
    \ floating-point literal by writing it with `.0`\n   |\n22 |         normalized.push(delta\
    \ * ((max - min) / delta + 1.0));\n   |          "
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers.iter().min().unwrap();\n    let mut\
    \ max = numbers.iter().max().unwrap();\n    let mut min = min as f64;\n    let\
    \ mut max = max as f64;\n    while min == 0 && max == 0 {\n        min = numbers.iter().min().unwrap();\n\
    \        max = numbers.iter().max().unwrap();\n    }\n    while min != 0.0 {\n\
    \        min = min - min / max.abs() * min;\n    }\n    while max != 1.0 {\n \
    \       max = max / min * max;\n    }\n    min\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmppvkib792.rs:6:34\n\
    \     |\n6    |     let mut min = numbers.iter().min().unwrap();\n     |     \
    \                             ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmppvkib792.rs:7:34\n\
    \     |\n7    |     let mut max = numbers.iter().max().unwrap();\n     |     \
    \                             ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmppvkib792.rs:10:18\n   |\n10 |\
    \     while min == 0 && max == 0 {\n   |                  ^\n   |            \
    \      |\n   |                  expected `f64`, found integer\n   |          \
    \        help: use a float literal: `0.0`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmppvkib792.rs:10:30\n   |\n10 |     while min == 0 && max == 0 {\n\
    \   |                              ^\n   |                              |\n  \
    \ |                              expected `f64`, found integer\n   |         \
    \                     help: use a float literal: `0.0`\n\nerror[E0277]: the trait\
    \ bound `f64: Ord` is not satisfied\n    --> /tmp/tmppvkib792.rs:11:30\n     |\n\
    11   |         min = numbers.iter().min().unwrap();\n     |                  \
    \            ^^^ the trait `Ord` is no"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    numbers.iter()\n        .map(|number| number / numbers.min())\n\
    \        .map(|number| number * (1 / numbers.max()))\n        .collect()\n}\n\n\
    fn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: the method `min` exists for struct `Vec<f64>`, but its trait\
    \ bounds were not satisfied\n   --> /tmp/tmp547v6opb.rs:7:40\n    |\n7   |   \
    \        .map(|number| number / numbers.min())\n    |                        \
    \                  ^^^ method cannot be called on `Vec<f64>` due to unsatisfied\
    \ trait bounds\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `f64: Ord`\n            which is required by `Vec<f64>: Ord`\n  \
    \          `Vec<f64>: Ord`\n            which is required by `&Vec<f64>: Ord`\n\
    \            `Vec<f64>: Ord`\n            which is required by `&mut Vec<f64>:\
    \ Ord`\n            `Vec<f64>: Iterator`\n            which is required by `&mut\
    \ Vec<f64>: Iterator`\n            `f64: Ord`\n            which is required by\
    \ `[f64]: Ord`\n            `[f64]: Ord`\n            which is required by `&[f64]:\
    \ Ord`\n            `[f64]: Ord`\n            which is required by `&mut [f64]:\
    \ Ord`\n            `[f64]: Iterator`\n            which is required by `&mut\
    \ [f64]: Iterator`\n\nerror[E0599]: the method `max` exists for struct `Vec<f64>`,\
    \ but its trait bounds were not satisfied\n   --> /tmp/tmp547v6opb.rs:8:45\n \
    \   |\n8   |           .map(|number| number * (1 / numbers.max()))\n    |    \
    \                                           ^^^ method cannot be called on `Vec<f64>`\
    \ due to unsatisfied trait bounds\n    |\n    = note: the following trait bounds\
    \ were not satisfied:\n            `f64: Ord`\n            which is required by\
    \ `Vec<f64>: Ord`\n            `Vec<f64>: Ord`\n            which is required\
    \ by `&Vec<f64>: Ord`\n            `Vec<f64>: Ord`\n            which is required\
    \ by `&mut Vec<f64>: Ord`\n            `Vec<f64>: Iterator`\n            which\
    \ is required by `&mut Vec<f64>: Iterator`\n            `f64: Ord`\n         \
    \   which is required by `[f64]: Ord`\n            `[f64]: Ord`\n            which\
    \ is required by `&[f64]: Ord`\n            `[f64]: Ord`\n            which is\
    \ required by `&mut [f64]: Ord`\n            `[f64]: Iterator`\n            which\
    \ is required by `&mut [f64]: Iterator`\n\nerror[E0277]: cannot mu"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_val = numbers[0];\n    let mut max_val = numbers[0];\n\
    \n    // Find the smallest number and largest number\n    for i in numbers.iter().skip(1)\
    \ {\n        if *i < min_val {\n            min_val = *i;\n        }\n\n     \
    \   if *i > max_val {\n            max_val = *i;\n        }\n    }\n\n    // Scale\
    \ the vector to (min_val, max_val]\n    let mut scaled_numbers = Vec::new();\n\
    \    for i in numbers.iter() {\n        *i = (*i - min_val) / (max_val - min_val)\
    \ as f64;\n        scaled_numbers.push(*i);\n    }\n\n    scaled_numbers\n}\n\n\
    fn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0594]: cannot assign to `*i`, which is behind a `&` reference\n\
    \  --> /tmp/tmp3sliqfm9.rs:23:9\n   |\n22 |     for i in numbers.iter() {\n  \
    \ |              -------------- this iterator yields `&` references\n23 |    \
    \     *i = (*i - min_val) / (max_val - min_val) as f64;\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `i` is a `&` reference, so the data it refers to cannot be written\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0594`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    assert!(numbers.len() > 1);\n    let mut min: float::consts::INFINITY;\n\
    \    let mut max: float::consts::INFINITY;\n\n    for n in numbers.iter() {\n\
    \        if n > max {\n            max = n;\n        }\n        if n < min {\n\
    \            min = n;\n        }\n    }\n\n    // Convert to [min, min+max]\n\
    \    let mut res: Vec<f64> = vec![min];\n\n    for i in 1..numbers.len() {\n \
    \       let new_value: f64 = numbers[i] - min;\n        res.push((new_value -\
    \ min) / (max - min));\n    }\n\n    res\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `float`\n\
    \ --> /tmp/tmp7w7z9wnj.rs:7:18\n  |\n7 |     let mut min: float::consts::INFINITY;\n\
    \  |                  ^^^^^ use of undeclared crate or module `float`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared crate or module `float`\n --> /tmp/tmp7w7z9wnj.rs:8:18\n\
    \  |\n8 |     let mut max: float::consts::INFINITY;\n  |                  ^^^^^\
    \ use of undeclared crate or module `float`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut new_numbers = numbers;\n    new_numbers.sort();\n\
    \    let first_number = new_numbers[0];\n    let last_number = new_numbers[new_numbers.len()\
    \ - 1];\n    new_numbers = new_numbers.map(|number| number / first_number);\n\
    \    new_numbers.push(1.0);\n    new_numbers.push(-last_number);\n    new_numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n   --> /tmp/tmpblgby6yt.rs:7:17\n\
    \    |\n7   |     new_numbers.sort();\n    |                 ^^^^ the trait `Ord`\
    \ is not implemented for `f64`\n    |\n    = help: the following other types implement\
    \ trait `Ord`:\n              i128\n              i16\n              i32\n   \
    \           i64\n              i8\n              isize\n              u128\n \
    \             u16\n            and 4 others\nnote: required by a bound in `slice::<impl\
    \ [T]>::sort`\n\nerror[E0599]: `Vec<f64>` is not an iterator\n   --> /tmp/tmpblgby6yt.rs:10:31\n\
    \    |\n10  |       new_numbers = new_numbers.map(|number| number / first_number);\n\
    \    |                                 ^^^ `Vec<f64>` is not an iterator\n   \
    \ |\n    = note: the following trait bounds were not satisfied:\n            `Vec<f64>:\
    \ Iterator`\n            which is required by `&mut Vec<f64>: Iterator`\n    \
    \        `[f64]: Iterator`\n            which is required by `&mut [f64]: Iterator`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n > max {\n            max = n;\n        }\n\
    \        if n < min {\n            min = n;\n        }\n    }\n    let mut rescaled\
    \ = Vec::new();\n    for n in numbers {\n        let mut x = n - min;\n      \
    \  x = x * 100.0 / max - min;\n        rescaled.push(x);\n    }\n    rescaled\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpdkvhdfwh.rs:17:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n17  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    if numbers.len() < 2 {\n        return numbers;\n    }\n\n\
    \    let mut min: f64 = numbers[0];\n    let mut max: f64 = numbers[0];\n    let\
    \ mut sum: f64 = 0.0;\n\n    for n in numbers {\n        if n < min {\n      \
    \      min = n;\n        }\n\n        if n > max {\n            max = n;\n   \
    \     }\n\n        sum += n;\n    }\n\n    numbers.iter_mut().for_each(|n| {\n\
    \        *n = ((n - min) / (max - min)) * sum + min;\n    });\n\n    numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot subtract `f64` from `&mut f64`\n  --> /tmp/tmpj_50dr1c.rs:27:18\n\
    \   |\n27 |         *n = ((n - min) / (max - min)) * sum + min;\n   |        \
    \        - ^ --- f64\n   |                |\n   |                &mut f64\n  \
    \ |\nhelp: `-` can be used on `f64`, you can dereference `n`\n   |\n27 |     \
    \    *n = ((*n - min) / (max - min)) * sum + min;\n   |                +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut scale = numbers.iter().min().unwrap_or(numbers.iter().max().unwrap_or(0.0))\n\
    \        .unwrap_or(1.0 as f64);\n\n    for n in numbers.iter() {\n        scale\
    \ /= n;\n    }\n\n    numbers.iter().map(|n| n * scale).collect()\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpjuqw4ec2.rs:6:36\n\
    \     |\n6    |     let mut scale = numbers.iter().min().unwrap_or(numbers.iter().max().unwrap_or(0.0))\n\
    \     |                                    ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpjuqw4ec2.rs:6:67\n\
    \     |\n6    |     let mut scale = numbers.iter().min().unwrap_or(numbers.iter().max().unwrap_or(0.0))\n\
    \     |                                                                   ^^^\
    \ the trait `Ord` is not implemented for `f64`\n     |\n     = help: the following\
    \ other types implement trait `Ord`:\n               i128\n               i16\n\
    \               i32\n               i64\n               i8\n               isize\n\
    \               u128\n               u16\n             and 4 others\n     = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\nnote:\
    \ required by a bound in `std::iter::Iterator::max`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpjuqw4ec2.rs:6:83\n  |\n6 |     let mut scale = numbers.iter().min().unwrap_or(numbers.iter().max().unwrap_or(0.0))\n\
    \  |                                                                         \
    \          ^^^\n  |                                                          \
    \                         |\n  |                                             \
    \                                      expected `&f64`, found floating-point number\n\
    \  |                                                                         \
    \          help: consider borrowing here: `&0.0`\n\nerror[E0599]: no method named\
    \ `unwrap_or` found for reference `&f64` in the curr"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    numbers.iter()\n        .map(|x| if x > 1.0 { x/2.0 } else\
    \ { x })\n        .collect::<Vec<f64>>()\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpzw277stn.rs:7:25\n  |\n7 |\
    \         .map(|x| if x > 1.0 { x/2.0 } else { x })\n  |                     \
    \    ^^^\n  |                         |\n  |                         expected\
    \ `&f64`, found floating-point number\n  |                         help: consider\
    \ borrowing here: `&1.0`\n\nerror[E0308]: `if` and `else` have incompatible types\n\
    \ --> /tmp/tmpzw277stn.rs:7:46\n  |\n7 |         .map(|x| if x > 1.0 { x/2.0 }\
    \ else { x })\n  |                               -----          ^ expected `f64`,\
    \ found `&f64`\n  |                               |\n  |                     \
    \          expected because of this\n  |\nhelp: consider dereferencing the borrow\n\
    \  |\n7 |         .map(|x| if x > 1.0 { x/2.0 } else { *x })\n  |            \
    \                                  +\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let min_number = numbers.iter().min();\n    let max_number\
    \ = numbers.iter().max();\n    numbers.iter().map(|x| {\n        let rescale =\
    \ if x == min_number { 0 } else { 1 };\n        x * rescale\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpuq_shcae.rs:6:37\n\
    \     |\n6    |     let min_number = numbers.iter().min();\n     |           \
    \                          ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpuq_shcae.rs:7:37\n\
    \     |\n7    |     let max_number = numbers.iter().max();\n     |           \
    \                          ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0277]: can't compare `&f64` with `Option<&f64>`\n --> /tmp/tmpuq_shcae.rs:9:28\n\
    \  |\n9 |         let rescale = if x == min_number { 0 } else { 1 };\n  |    \
    \                        ^^ no implementation for `&f64 == Option<&f64>`\n  |\n\
    \  = help: the trait `PartialEq<Option<&f64>>` is not implemented for `&f64`\n\
    \  = help: the following other types implement trait `PartialEq<Rhs>`:\n     \
    \       f32\n            f64\n            i128\n            i16\n            i32\n\
    \            i64\n            i8\n            isize\n          and 6 others\n\n\
    error[E0277]: cannot multiply `&f64` by `{integer}`\n  --> /tmp/tmpuq_shcae.rs:10:11\n\
    \   |\n10 |         x * rescale\n   |           ^ no implementation for `&f64\
    \ * {integer}`\n   |\n   = help: the trait `Mul<{integer}>` is not implemented\
    \ for `&f64`\n   = help:"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    // The min and max are computed separately because we want\
    \ the min to be 0 and the max\n    // to be 1, rather than 0 and the maximum value\
    \ of a vector with multiple elements.\n    let max_value = numbers.iter().fold(std::f64::MAX\
    \ as f64, |max, value| {\n        max > value ? max : value\n    });\n    let\
    \ min_value = numbers.iter().fold(std::f64::MIN as f64, |min, value| {\n     \
    \   min < value ? min : value\n    });\n\n    // Compute the scaling factor for\
    \ the smallest number to be 0 and the largest to be 1.\n    let factor = min_value\
    \ / max_value;\n\n    // Scale the numbers.\n    let mut scaled_numbers = Vec::new();\n\
    \    for &number in numbers {\n        scaled_numbers.push((number as f64) * factor)\n\
    \    }\n\n    scaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `max`\n\
    \ --> /tmp/tmp2kf0l39l.rs:9:23\n  |\n9 |         max > value ? max : value\n \
    \ |                       ^^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\
    \nerror: expected one of `.`, `;`, `?`, `}`, or an operator, found `min`\n  -->\
    \ /tmp/tmp2kf0l39l.rs:12:23\n   |\n12 |         min < value ? min : value\n  \
    \ |                       ^^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp2kf0l39l.rs:20:9\n   |\n20 | \
    \    for &number in numbers {\n   |         ^^^^^^^    ------- this expression\
    \ has type `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `number`\n  \
    \ |\n   = note:   expected type `f64`\n           found reference `&_`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    if numbers.len() <= 2 {\n        return numbers;\n    }\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let scale = 1.0 / (max - min);\n\
    \    for i in 1..numbers.len() {\n        numbers[i] *= scale;\n    }\n    numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `numbers`\n   --> /tmp/tmpum5r478k.rs:20:17\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n11  |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n20  |     for i in 1..numbers.len() {\n    |                 ^^^^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `numbers`\nhelp: consider iterating over a\
    \ slice of the `Vec<f64>`'s content to avoid moving into the `for` loop\n    |\n\
    11  |     for n in &numbers {\n    |              +\n\nerror[E0596]: cannot borrow\
    \ `numbers` as mutable, as it is not declared as mutable\n  --> /tmp/tmpum5r478k.rs:21:9\n\
    \   |\n5  | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n   |        \
    \            ------- help: consider changing this to be mutable: `mut numbers`\n\
    ...\n21 |         numbers[i] *= scale;\n   |         ^^^^^^^ cannot borrow as\
    \ mutable\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0382, E0596.\nFor more information about an error, try `rustc\
    \ --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers.iter().min().unwrap();\n    let mut\
    \ max = numbers.iter().max().unwrap();\n    let mut result = vec![0.0; numbers.len()];\n\
    \    for i in 0..numbers.len() {\n        result[i] = numbers[i] / max - min;\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n \
    \   assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmplr8l0xyy.rs:6:34\n\
    \     |\n6    |     let mut min = numbers.iter().min().unwrap();\n     |     \
    \                             ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmplr8l0xyy.rs:7:34\n\
    \     |\n7    |     let mut max = numbers.iter().max().unwrap();\n     |     \
    \                             ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut scale = 1.0f64;\n    let mut min: f64;\n    let mut\
    \ max: f64;\n    for i in 0..numbers.len() {\n        // We want to make sure\
    \ that minimum number is 0\n        if min == 0.0 {\n            min = numbers[i];\n\
    \        }\n        // We want to make sure that maximum number is 1\n       \
    \ if max == 0.0 {\n            max = numbers[i];\n        }\n        // We want\
    \ to make sure that minimum and maximum are consistent\n        if numbers[i]\
    \ > max {\n            max = numbers[i];\n        }\n        if numbers[i] < min\
    \ {\n            min = numbers[i];\n        }\n        // We want to make sure\
    \ that minimum and maximum are consistent (for numerical stability)\n        if\
    \ min > max * 0.5 {\n            max = min;\n            min = numbers[i];\n \
    \       }\n        numbers[i] = (numbers[i] - min) / (max - min) * scale;\n  \
    \      scale *= 0.5f;\n    }\n    numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error: invalid suffix `f` for float literal\n  --> /tmp/tmpyd4uwrpv.rs:31:18\n\
    \   |\n31 |         scale *= 0.5f;\n   |                  ^^^^ invalid suffix\
    \ `f`\n   |\n   = help: valid suffixes are `f32` and `f64`\n\nerror: aborting\
    \ due to previous error\n\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    numbers.iter().cloned().map(bn => bn.min(1.0).max(0.0))\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator,\
    \ found `=>`\n --> /tmp/tmp5x4935yt.rs:6:36\n  |\n6 |     numbers.iter().cloned().map(bn\
    \ => bn.min(1.0).max(0.0))\n  |                                    ^^ expected\
    \ one of 8 possible tokens\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers.iter() {\n        if n < min {\n            min = n;\n \
    \       }\n        if n > max {\n            max = n;\n        }\n    }\n    (max\
    \ - min).map((n / max) as f64).collect::<Vec<f64>>()\n}\n\nfn main() {\n    let\
    \ candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0,\
    \ 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `n` in this scope\n  --> /tmp/tmpo_m5r2vc.rs:16:22\n\
    \   |\n16 |     (max - min).map((n / max) as f64).collect::<Vec<f64>>()\n   |\
    \                      ^ not found in this scope\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpo_m5r2vc.rs:9:16\n  |\n9 |         if n < min {\n  |           \
    \     ^^^\n  |                |\n  |                expected `&f64`, found `f64`\n\
    \  |                help: consider borrowing here: `&min`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpo_m5r2vc.rs:10:19\n   |\n6  |     let mut min = numbers[0];\n\
    \   |                   ---------- expected due to this value\n...\n10 |     \
    \        min = n;\n   |                   ^ expected `f64`, found `&f64`\n   |\n\
    help: consider dereferencing the borrow\n   |\n10 |             min = *n;\n  \
    \ |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo_m5r2vc.rs:12:16\n\
    \   |\n12 |         if n > max {\n   |                ^^^\n   |              \
    \  |\n   |                expected `&f64`, found `f64`\n   |                help:\
    \ consider borrowing here: `&max`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo_m5r2vc.rs:13:19\n\
    \   |\n7  |     let mut max = numbers[0];\n   |                   ---------- expected\
    \ due to this value\n...\n13 |             max = n;\n   |                   ^\
    \ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n13 |             max = *n;\n   |                   +\n\nerror[E0599]: `f64`\
    \ is not an iterator\n  --> /tmp/tmpo_m5r2vc.rs:16:17\n   |\n16 |     (max - min).map((n\
    \ / max) as f64).collect::<Vec<f64>>()\n   |                 ^^^ `f64` is not\
    \ an iterator\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `f64: Iterator`\n           which is required by `&mut f64: Iterator`\n\
    \nerror: aborting due to 6 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_val = numbers[0];\n    let mut max_val = numbers[0];\n\
    \    for val in numbers {\n        if val < min_val {\n            min_val = val;\n\
    \        }\n        if val > max_val {\n            max_val = val;\n        }\n\
    \    }\n    let scale = max_val - min_val;\n    numbers\n        .iter()\n   \
    \     .map(|val| val * scale) // multiply each value by the scaling factor\n \
    \       .collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n \
    \   assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `numbers`\n   --> /tmp/tmpd3h66xho.rs:17:5\n\
    \    |\n5   |   fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |   \
    \                   ------- move occurs because `numbers` has type `Vec<f64>`,\
    \ which does not implement the `Copy` trait\n...\n8   |       for val in numbers\
    \ {\n    |                  ------- `numbers` moved due to this implicit call\
    \ to `.into_iter()`\n...\n17  | /     numbers\n18  | |         .iter()\n    |\
    \ |_______________^ value borrowed here after move\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `numbers`\n    = note: borrow\
    \ occurs due to deref coercion to `[f64]`\nhelp: consider iterating over a slice\
    \ of the `Vec<f64>`'s content to avoid moving into the `for` loop\n    |\n8  \
    \ |     for val in &numbers {\n    |                +\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0] as f64;\n    let mut max = numbers[0]\
    \ as f64;\n\n    for i in numbers.iter().rev() {\n        if *i < min {\n    \
    \        min = *i;\n        }\n        if *i > max {\n            max = *i;\n\
    \        }\n    }\n\n    let mut scale = 1.0 / (max - min);\n    for i in numbers.iter()\
    \ {\n        *i = (*i - min) * scale;\n    }\n    numbers\n}\n\nfn main() {\n\
    \    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmp7j_ksf2n.rs:18:9\n\
    \   |\n18 |     let mut scale = 1.0 / (max - min);\n   |         ----^^^^^\n \
    \  |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0594]: cannot assign to `*i`, which is behind a `&`\
    \ reference\n  --> /tmp/tmp7j_ksf2n.rs:20:9\n   |\n19 |     for i in numbers.iter()\
    \ {\n   |              -------------- this iterator yields `&` references\n20\
    \ |         *i = (*i - min) * scale;\n   |         ^^^^^^^^^^^^^^^^^^^^^^^ `i`\
    \ is a `&` reference, so the data it refers to cannot be written\n\nerror: aborting\
    \ due to previous error; 1 warning emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0594`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \n    for &n in numbers {\n        if n < min {\n            min = n;\n      \
    \  }\n\n        if n > max {\n            max = n;\n        }\n    }\n\n    numbers.iter_mut().for_each(|x|\
    \ {\n        *x = *x / max;\n        *x = *x - min;\n    });\n\n    numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpywpyxp_1.rs:9:9\n  |\n9 |\
    \     for &n in numbers {\n  |         ^^    ------- this expression has type\
    \ `Option<f64>`\n  |         |\n  |         expected `f64`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `n`\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 101
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    if numbers.len() < 2 {\n        return numbers;\n    }\n\n\
    \    let mut min_val = numbers[0];\n    let mut max_val = numbers[0];\n    for\
    \ i in 1..numbers.len() {\n        if numbers[i] < min_val {\n            min_val\
    \ = numbers[i];\n        }\n\n        if numbers[i] > max_val {\n            max_val\
    \ = numbers[i];\n        }\n    }\n\n    numbers.iter().map(|n| n / max_val -\
    \ min_val).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-1.9599198396793587, -1.0]`,\n right: `[0.0, 1.0]`', /tmp/tmpxl9bfo3i.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976458
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    numbers.iter().map(|x| x / numbers.min().unwrap()).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: the method `min` exists for struct `Vec<f64>`, but its trait\
    \ bounds were not satisfied\n   --> /tmp/tmp1gguqup4.rs:6:40\n    |\n6   |   \
    \    numbers.iter().map(|x| x / numbers.min().unwrap()).collect()\n    |     \
    \                                     ^^^ method cannot be called on `Vec<f64>`\
    \ due to unsatisfied trait bounds\n    |\n    = note: the following trait bounds\
    \ were not satisfied:\n            `f64: Ord`\n            which is required by\
    \ `Vec<f64>: Ord`\n            `Vec<f64>: Ord`\n            which is required\
    \ by `&Vec<f64>: Ord`\n            `Vec<f64>: Ord`\n            which is required\
    \ by `&mut Vec<f64>: Ord`\n            `Vec<f64>: Iterator`\n            which\
    \ is required by `&mut Vec<f64>: Iterator`\n            `f64: Ord`\n         \
    \   which is required by `[f64]: Ord`\n            `[f64]: Ord`\n            which\
    \ is required by `&[f64]: Ord`\n            `[f64]: Ord`\n            which is\
    \ required by `&mut [f64]: Ord`\n            `[f64]: Iterator`\n            which\
    \ is required by `&mut [f64]: Iterator`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0].clone();\n    let mut max = numbers[0].clone();\n\
    \    for &n in numbers {\n        min = min.min(&n);\n        max = max.max(&n);\n\
    \    }\n    Vec::from_iter(numbers.iter().map(|n| n.div(max - min).unwrap()).collect())\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp9oifnw8p.rs:8:9\n  |\n8 |\
    \     for &n in numbers {\n  |         ^^    ------- this expression has type\
    \ `Option<f64>`\n  |         |\n  |         expected `f64`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `n`\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp9oifnw8p.rs:9:23\n  |\n9 |         min = min.min(&n);\n\
    \  |                       ^^ expected `f64`, found reference\n  |\n  = note:\
    \   expected type `f64`\n          found reference `&_`\nhelp: consider removing\
    \ the borrow\n  |\n9 -         min = min.min(&n);\n9 +         min = min.min(n);\n\
    \  | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9oifnw8p.rs:10:23\n   |\n\
    10 |         max = max.max(&n);\n   |                       ^^ expected `f64`,\
    \ found reference\n   |\n   = note:   expected type `f64`\n           found reference\
    \ `&_`\nhelp: consider removing the borrow\n   |\n10 -         max = max.max(&n);\n\
    10 +         max = max.max(n);\n   | \n\nerror[E0599]: no function or associated\
    \ item named `from_iter` found for struct `Vec<_, _>` in the current scope\n \
    \ --> /tmp/tmp9oifnw8p.rs:12:10\n   |\n12 |     Vec::from_iter(numbers.iter().map(|n|\
    \ n.div(max - min).unwrap()).collect())\n   |          ^^^^^^^^^ function or associated\
    \ item not found in `Vec<_, _>`\n   |\n   = help: items from traits can only be\
    \ used if the trait is in scope\nhelp: the following trait is implemented but\
    \ not in scope; perhaps add a `use` for it:\n   |\n1  | use std::iter::FromIterator;\n\
    \   |\n\nerror[E0599]: no method named `div` found for reference `&f64` in the\
    \ current scope\n  --> /tmp/tmp9oifnw8p.rs:12:45\n   |\n12 |     Vec::from_iter(numbers.iter().map(|n|\
    \ n.div(max - min).unwrap()).collect())\n   |                                \
    \             ^^^ method not found in `&f64`\n   |\n   = help: items from traits\
    \ can only be used if the trait is in scope\nhelp: the following trait is implemented\
    \ but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::ops::Div;\n\
    \   |\n\nerror: aborting due to"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for &n in numbers {\n        if n < min {\n            min = n;\n       \
    \ }\n        if n > max {\n            max = n;\n        }\n    }\n    (max -\
    \ min) as f64 / numbers.len() as f64\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpfex63dyg.rs:8:9\n  |\n8 |\
    \     for &n in numbers {\n  |         ^^    ------- this expression has type\
    \ `Option<f64>`\n  |         |\n  |         expected `f64`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `n`\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpfex63dyg.rs:16:5\n   |\n5  | fn rescale_to_unit(numbers:\
    \ Vec<f64>) -> Vec<f64> {\n   |                                          --------\
    \ expected `Vec<f64>` because of return type\n...\n16 |     (max - min) as f64\
    \ / numbers.len() as f64\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `f64`\n   |\n   = note: expected struct `Vec<f64>`\n   \
    \             found type `f64`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_val = numbers[0];\n    let mut max_val = numbers[0];\n\
    \    for i in 1..numbers.len() {\n        if numbers[i] < min_val {\n        \
    \    min_val = numbers[i];\n        }\n        if numbers[i] > max_val {\n   \
    \         max_val = numbers[i];\n        }\n    }\n    for i in 0..numbers.len()\
    \ {\n        let delta = numbers[i] - min_val;\n        let norm = delta.sqrt()\
    \ * max_val;\n        numbers[i] += norm;\n    }\n    numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `numbers` as mutable, as it is not declared\
    \ as mutable\n  --> /tmp/tmpr84dlolh.rs:19:9\n   |\n5  | fn rescale_to_unit(numbers:\
    \ Vec<f64>) -> Vec<f64> {\n   |                    ------- help: consider changing\
    \ this to be mutable: `mut numbers`\n...\n19 |         numbers[i] += norm;\n \
    \  |         ^^^^^^^ cannot borrow as mutable\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut result = Vec::new();\n    if numbers.len() < 2 {\n\
    \        result.push(numbers[0]);\n        return result;\n    }\n    let mut\
    \ min = numbers[0];\n    let mut max = numbers[0];\n    for i in numbers.iter().skip(1)\
    \ {\n        if i < min {\n            min = i;\n        }\n        if i > max\
    \ {\n            max = i;\n        }\n    }\n    for i in numbers.iter().skip(1)\
    \ {\n        let new_i = ((i - min) / (max - min)).powi(2);\n        result.push(new_i);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n \
    \   assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1iyrgiap.rs:14:16\n   |\n\
    14 |         if i < min {\n   |                ^^^\n   |                |\n  \
    \ |                expected `&f64`, found `f64`\n   |                help: consider\
    \ borrowing here: `&min`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1iyrgiap.rs:15:19\n\
    \   |\n11 |     let mut min = numbers[0];\n   |                   ---------- expected\
    \ due to this value\n...\n15 |             min = i;\n   |                   ^\
    \ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n15 |             min = *i;\n   |                   +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp1iyrgiap.rs:17:16\n   |\n17 |         if i > max {\n  \
    \ |                ^^^\n   |                |\n   |                expected `&f64`,\
    \ found `f64`\n   |                help: consider borrowing here: `&max`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp1iyrgiap.rs:18:19\n   |\n12 |     let mut max\
    \ = numbers[0];\n   |                   ---------- expected due to this value\n\
    ...\n18 |             max = i;\n   |                   ^ expected `f64`, found\
    \ `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n18 |          \
    \   max = *i;\n   |                   +\n\nerror: aborting due to 4 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 101
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut res = Vec::new();\n    for num in numbers {\n   \
    \     if num < 0.0 {\n            res.push(-num);\n        } else {\n        \
    \    res.push(num);\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2.0, 49.9]`,\n right: `[0.0, 1.0]`', /tmp/tmp9knpp8rc.rs:19:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976458
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    if numbers.len() < 2 {\n        return numbers;\n    }\n\n\
    \    let mut min_val = numbers[0];\n    let mut max_val = numbers[0];\n    for\
    \ n in numbers {\n        if n < min_val {\n            min_val = n;\n       \
    \ }\n\n        if n > max_val {\n            max_val = n;\n        }\n    }\n\n\
    \    let min_len = std::cmp::min(numbers.len(), std::cmp::min(min_val, max_val));\n\
    \    for i in 0..min_len {\n        numbers[i] = numbers[i] * ((max_val - min_val)\
    \ / ((numbers[i - 1] as f64) + (numbers[i] as f64)));\n    }\n\n    numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp61k031rg.rs:22:62\n   |\n\
    22 |     let min_len = std::cmp::min(numbers.len(), std::cmp::min(min_val, max_val));\n\
    \   |                                                              ^^^^^^^ expected\
    \ `usize`, found `f64`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp61k031rg.rs:22:71\n\
    \   |\n22 |     let min_len = std::cmp::min(numbers.len(), std::cmp::min(min_val,\
    \ max_val));\n   |                                                           \
    \            ^^^^^^^ expected `usize`, found `f64`\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_num = numbers[0];\n    let mut max_num = numbers[0];\n\
    \    for i in numbers {\n        if i < min_num {\n            min_num = i;\n\
    \        }\n        if i > max_num {\n            max_num = i;\n        }\n  \
    \  }\n    for i in numbers {\n        *i = *i / max_num * 2 - 1;\n    }\n    numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmpue5evwum.rs:17:9\n\
    \   |\n17 |         *i = *i / max_num * 2 - 1;\n   |         ^^\n\nerror[E0614]:\
    \ type `f64` cannot be dereferenced\n  --> /tmp/tmpue5evwum.rs:17:14\n   |\n17\
    \ |         *i = *i / max_num * 2 - 1;\n   |              ^^\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0614`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    numbers.iter().fold(0.0, |acc, num| acc + num / 2)\n}\n\n\
    fn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpcila21d4.rs:6:25\n  |\n6 |\
    \     numbers.iter().fold(0.0, |acc, num| acc + num / 2)\n  |                \
    \         ^^^ expected struct `Vec`, found floating-point number\n  |\n  = note:\
    \ expected struct `Vec<f64>`\n               found type `{float}`\n\nerror[E0277]:\
    \ cannot divide `&f64` by `{integer}`\n --> /tmp/tmpcila21d4.rs:6:51\n  |\n6 |\
    \     numbers.iter().fold(0.0, |acc, num| acc + num / 2)\n  |                \
    \                                   ^ no implementation for `&f64 / {integer}`\n\
    \  |\n  = help: the trait `Div<{integer}>` is not implemented for `&f64`\n  =\
    \ help: the following other types implement trait `Div<Rhs>`:\n            <&'a\
    \ f32 as Div<f32>>\n            <&'a f64 as Div<f64>>\n            <&'a i128 as\
    \ Div<i128>>\n            <&'a i16 as Div<i16>>\n            <&'a i32 as Div<i32>>\n\
    \            <&'a i64 as Div<i64>>\n            <&'a i8 as Div<i8>>\n        \
    \    <&'a isize as Div<isize>>\n          and 54 others\n\nerror[E0369]: cannot\
    \ add `_` to `Vec<f64>`\n --> /tmp/tmpcila21d4.rs:6:45\n  |\n6 |     numbers.iter().fold(0.0,\
    \ |acc, num| acc + num / 2)\n  |                                         --- ^\
    \ ------- _\n  |                                         |\n  |              \
    \                           Vec<f64>\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308, E0369.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut smallest_number = numbers.iter().min();\n    let\
    \ mut largest = numbers.iter().max();\n    smallest_number.map!(|x| x.abs() /\
    \ (largest - smallest_number));\n    let mut new_numbers = numbers.clone();\n\
    \    new_numbers.iter_mut().for_each(|x| {\n        *x = (*x).abs() / (largest\
    \ - smallest_number);\n    });\n    new_numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `(`, `.`, `::`, `;`, `?`, `}`, or an operator, found\
    \ `!`\n --> /tmp/tmpedjdx3rm.rs:8:24\n  |\n8 |     smallest_number.map!(|x| x.abs()\
    \ / (largest - smallest_number));\n  |                        ^ expected one of\
    \ 7 possible tokens\n\nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n\
    \    --> /tmp/tmpedjdx3rm.rs:6:46\n     |\n6    |     let mut smallest_number\
    \ = numbers.iter().min();\n     |                                            \
    \  ^^^ the trait `Ord` is not implemented for `f64`\n     |\n     = help: the\
    \ following other types implement trait `Ord`:\n               i128\n        \
    \       i16\n               i32\n               i64\n               i8\n     \
    \          isize\n               u128\n               u16\n             and 4\
    \ others\n     = note: required because of the requirements on the impl of `Ord`\
    \ for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpedjdx3rm.rs:7:38\n\
    \     |\n7    |     let mut largest = numbers.iter().max();\n     |          \
    \                            ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut scale\
    \ = max - min;\n    numbers.iter().for_each(|n| n = ((n - min) / scale) as f64);\n\
    \    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjv1g9lsk.rs:17:37\n   |\n\
    17 |     numbers.iter().for_each(|n| n = ((n - min) / scale) as f64);\n   |  \
    \                            -      ^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |         \
    \                     |      |\n   |                              |      expected\
    \ `&f64`, found `f64`\n   |                              |      help: consider\
    \ borrowing here: `&(((n - min) / scale) as f64)`\n   |                      \
    \        expected due to this parameter type\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut new_vec: Vec<f64> = Vec::with_capacity(numbers.len()\
    \ * 2);\n    for (i, f) in numbers.iter().enumerate() {\n        new_vec.push((f\
    \ - numbers.min())/(numbers.max() - numbers.min()));\n    }\n    new_vec\n}\n\n\
    fn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: the method `min` exists for struct `Vec<f64>`, but its trait\
    \ bounds were not satisfied\n   --> /tmp/tmpak4fsnny.rs:8:35\n    |\n8   |   \
    \        new_vec.push((f - numbers.min())/(numbers.max() - numbers.min()));\n\
    \    |                                     ^^^ method cannot be called on `Vec<f64>`\
    \ due to unsatisfied trait bounds\n    |\n    = note: the following trait bounds\
    \ were not satisfied:\n            `f64: Ord`\n            which is required by\
    \ `Vec<f64>: Ord`\n            `Vec<f64>: Ord`\n            which is required\
    \ by `&Vec<f64>: Ord`\n            `Vec<f64>: Ord`\n            which is required\
    \ by `&mut Vec<f64>: Ord`\n            `Vec<f64>: Iterator`\n            which\
    \ is required by `&mut Vec<f64>: Iterator`\n            `f64: Ord`\n         \
    \   which is required by `[f64]: Ord`\n            `[f64]: Ord`\n            which\
    \ is required by `&[f64]: Ord`\n            `[f64]: Ord`\n            which is\
    \ required by `&mut [f64]: Ord`\n            `[f64]: Iterator`\n            which\
    \ is required by `&mut [f64]: Iterator`\n\nerror[E0599]: the method `max` exists\
    \ for struct `Vec<f64>`, but its trait bounds were not satisfied\n   --> /tmp/tmpak4fsnny.rs:8:51\n\
    \    |\n8   |           new_vec.push((f - numbers.min())/(numbers.max() - numbers.min()));\n\
    \    |                                                     ^^^ method cannot be\
    \ called on `Vec<f64>` due to unsatisfied trait bounds\n    |\n    = note: the\
    \ following trait bounds were not satisfied:\n            `f64: Ord`\n       \
    \     which is required by `Vec<f64>: Ord`\n            `Vec<f64>: Ord`\n    \
    \        which is required by `&Vec<f64>: Ord`\n            `Vec<f64>: Ord`\n\
    \            which is required by `&mut Vec<f64>: Ord`\n            `Vec<f64>:\
    \ Iterator`\n            which is required by `&mut Vec<f64>: Iterator`\n    \
    \        `f64: Ord`\n            which is required by `[f64]: Ord`\n         \
    \   `[f64]: Ord`\n            which is required by `&[f64]: Ord`\n           \
    \ `[f64]: Ord`\n            which is required by `&mut [f64]: Ord`\n         \
    \   `[f64]: Iterator`\n            which is requir"
  stdout: ''
  timestamp: 1659976457
- exit_code: 101
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    if numbers.len() > 1 {\n        numbers.iter().map(|x| x\
    \ / numbers.len() as f64).collect()\n    } else {\n        numbers.to_vec()\n\
    \    }\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1.0, 24.95]`,\n right: `[0.0, 1.0]`', /tmp/tmpbv031tvv.rs:15:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976458
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers.iter().min().unwrap();\n    let mut\
    \ max = numbers.iter().max().unwrap();\n    min = min - 1.0; // Make the smallest\
    \ number zero (effectively subtracting 1)\n    max = max + 1.0; // Make the largest\
    \ number one\n    numbers.iter_mut().for_each(|num| *num = num / max(min as f64,\
    \ 1.0 as f64));\n    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpdrny8ip7.rs:6:34\n\
    \     |\n6    |     let mut min = numbers.iter().min().unwrap();\n     |     \
    \                             ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpdrny8ip7.rs:7:34\n\
    \     |\n7    |     let mut max = numbers.iter().max().unwrap();\n     |     \
    \                             ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmpdrny8ip7.rs:8:11\n  |\n6 |    \
    \ let mut min = numbers.iter().min().unwrap();\n  |                   -----------------------------\
    \ expected due to this value\n7 |     let mut max = numbers.iter().max().unwrap();\n\
    8 |     min = min - 1.0; // Make the smallest number zero (effectively subtracting\
    \ 1)\n  |           ^^^^^^^^^\n  |           |\n  |           expected `&f64`,\
    \ found `f64`\n  |           help: consider borrowing here: `&(min - 1.0)`\n\n\
    error[E0308]: mismatched types\n --> /tmp/tmpdrny8ip7.rs:9:11\n  |\n7 |     let\
    \ mut max = numbers.iter().max().unwrap();\n  |                   -----------------------------\
    \ expected due to this value\n8 |     min = min - 1.0; // Make the smallest number\
    \ zero (effectively subtracting 1)\n9 |     max = max + 1"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let smallest_number = numbers.iter().min(|a, b| {\n     \
    \   a.partial_cmp(b)\n    }).unwrap();\n    let biggest_number = numbers.iter().max(|a,\
    \ b| {\n        a.partial_cmp(b)\n    }).unwrap();\n    let factor = biggest_number\
    \ - smallest_number;\n    numbers.iter().map(|n| n / factor).collect()\n}\n\n\
    fn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpyh5668rq.rs:6:42\n\
    \     |\n6    |     let smallest_number = numbers.iter().min(|a, b| {\n     |\
    \                                          ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmpyh5668rq.rs:6:42\n     |\n6    |       let smallest_number =\
    \ numbers.iter().min(|a, b| {\n     |  __________________________________________^^^_-\n\
    \     | |                                          |\n     | |               \
    \                           expected 0 arguments\n7    | |         a.partial_cmp(b)\n\
    8    | |     }).unwrap();\n     | |_____- supplied 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n\
    \    --> /tmp/tmpyh5668rq.rs:9:41\n     |\n9    |     let biggest_number = numbers.iter().max(|a,\
    \ b| {\n     |                                         ^^^ the trait `Ord` is\
    \ not implemented for `f64`\n     |\n     = help: the following other types implement\
    \ trait `Ord`:\n               i128\n               i16\n               i32\n\
    \               i64\n               i8\n               isize\n               u128\n\
    \               u16\n             and 4 others\n     = note: required because\
    \ of the requirements on the impl of `Ord` for `&f64`\nnote: required by a bound\
    \ in `std::iter::Iterator::max`\n\nerror[E0061]: this function takes 0 arguments\
    \ but 1 argument was supplied\n    --> /tmp/tmpyh5668rq.rs:9:41\n     |\n9   \
    \ |       let biggest_number = numbers.iter().max(|a, b| {\n     |  _________________________________________^^^_-\n\
    \     | |                       "
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut smallest_number = numbers.iter().min().unwrap();\n\
    \    let mut largest_number = numbers.iter().max().unwrap();\n    let mut scale:\
    \ f64 = 1.0;\n\n    // this can be done much faster using binary search to find\
    \ the smallest and largest number\n    while smallest_number > 0 && largest_number\
    \ < 1 {\n        smallest_number /= 2.0;\n        largest_number *= 2.0;\n   \
    \ }\n\n    numbers.iter()\n        .zip(numbers.iter().skip(1))\n        .map(|(first,\
    \ second)| {\n            let delta = second - first;\n            first * scale\
    \ + delta * (1.0 / scale)\n        })\n        .collect()\n}\n\nfn main() {\n\
    \    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp4q02qskc.rs:6:46\n\
    \     |\n6    |     let mut smallest_number = numbers.iter().min().unwrap();\n\
    \     |                                              ^^^ the trait `Ord` is not\
    \ implemented for `f64`\n     |\n     = help: the following other types implement\
    \ trait `Ord`:\n               i128\n               i16\n               i32\n\
    \               i64\n               i8\n               isize\n               u128\n\
    \               u16\n             and 4 others\n     = note: required because\
    \ of the requirements on the impl of `Ord` for `&f64`\nnote: required by a bound\
    \ in `std::iter::Iterator::min`\n\nerror[E0277]: the trait bound `f64: Ord` is\
    \ not satisfied\n    --> /tmp/tmp4q02qskc.rs:7:45\n     |\n7    |     let mut\
    \ largest_number = numbers.iter().max().unwrap();\n     |                    \
    \                         ^^^ the trait `Ord` is not implemented for `f64`\n \
    \    |\n     = help: the following other types implement trait `Ord`:\n      \
    \         i128\n               i16\n               i32\n               i64\n \
    \              i8\n               isize\n               u128\n               u16\n\
    \             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp4q02qskc.rs:11:29\n   |\n11 |\
    \     while smallest_number > 0 && largest_number < 1 {\n   |                \
    \             ^ expected `&f64`, found integer\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp4q02qskc.rs:11:51\n   |\n11 |     while smallest_number > 0 &&\
    \ largest_number < 1 {\n   |                                                 \
    \  ^ expected `&f64`, found integer\n\nerror[E0368]: binary assignment operation\
    \ `/=` cannot be applied to type `&f64`\n  --> /tmp/tmp4q02qskc.rs:12:9\n   |\n\
    12 |         smallest_number /= 2.0;\n   |         ---------------^^^^^^^\n  \
    \ |         |\n   |         cannot use `/=` on type `&f64`\n   |\nhelp: `/=` can\
    \ be used on `f64`, you can dereference `smallest_number`\n   |"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    let mut result\
    \ = Vec::new();\n    let mut n = 0;\n    for n in numbers {\n        result.push(n\
    \ * (max - min) / (max - min));\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0,\
    \ 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `n`\n  --> /tmp/tmpj4u2zp4q.rs:17:13\n   |\n\
    17 |     let mut n = 0;\n   |             ^ help: if this is intentional, prefix\
    \ it with an underscore: `_n`\n   |\n   = note: `#[warn(unused_variables)]` on\
    \ by default\n\nwarning: variable does not need to be mutable\n  --> /tmp/tmpj4u2zp4q.rs:17:9\n\
    \   |\n17 |     let mut n = 0;\n   |         ----^\n   |         |\n   |     \
    \    help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]` on by default\n\
    \nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpj4u2zp4q.rs:18:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n18  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error; 2 warnings\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_num = numbers[0];\n    let mut max_num = numbers[0];\n\
    \n    for x in numbers {\n        if x < min_num {\n            min_num = x;\n\
    \        }\n\n        if x > max_num {\n            max_num = x;\n        }\n\
    \    }\n\n    let scale = min_num.abs() / (max_num.abs());\n    let mut res: Vec<f64>\
    \ = Vec::new();\n    for x in numbers {\n        res.push((x * scale).floor()\
    \ as f64);\n    }\n    res\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp0qi35inf.rs:21:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n9   |     for x in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n21  |     for x in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n9   |     for x in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut output: Vec<f64> = Vec::new();\n    let min: f64\
    \ = numbers.iter().min().unwrap();\n    let max: f64 = numbers.iter().max().unwrap();\n\
    \    let length = numbers.len() as f64;\n    \n    if min < 0.0 {\n        output.push(0.0);\n\
    \    }\n    \n    for i in 0..(length as usize) {\n        output.push((numbers[i]\
    \ / max) as f64);\n    }\n    \n    output\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpx63jc28c.rs:7:35\n\
    \     |\n7    |     let min: f64 = numbers.iter().min().unwrap();\n     |    \
    \                               ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmpx63jc28c.rs:7:20\n  |\n7 |    \
    \ let min: f64 = numbers.iter().min().unwrap();\n  |              ---   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `f64`, found `&f64`\n  |              |\n  |              expected\
    \ due to this\n  |\nhelp: consider dereferencing the borrow\n  |\n7 |     let\
    \ min: f64 = *numbers.iter().min().unwrap();\n  |                    +\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpx63jc28c.rs:8:35\n\
    \     |\n8    |     let max: f64 = numbers.iter().max().unwrap();\n     |    \
    \                               ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmpx63jc28c.rs:8:20\n  |\n8 |    \
    \ let max: f64 = numbers.iter().max().unwrap();\n  |              ---   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `f64`, found `&f64`\n  |              |\n  |              expected\
    \ due to this\n  |\nhelp: consider dereferencing the borrow\n  |\n8 |     let\
    \ max: f64 = *numbers.iter().max().unwrap();\n  |                    +\n\nerror:"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    // Find out if there a vector with zero elements\n    let\
    \ first_nonzero_element: Option<f64> = numbers\n        .iter()\n        .filter(|n|\
    \ n > 0.0)\n        .next()\n        .cloned();\n    let mut last_nonzero_element:\
    \ Option<f64> = numbers\n        .iter()\n        .filter_map(|n| Some(n))\n \
    \       .skip_while(|n| n == 0.0)\n        .last()\n        .cloned();\n\n   \
    \ // If the first element of vector is non-zero, make it zero\n    if let Some(first_nonzero_element)\
    \ = first_nonzero_element {\n        if first_nonzero_element > 0.0 {\n      \
    \      numbers[0] = 0.0;\n        } else {\n            numbers[numbers.len()\
    \ - 1] = 0.0;\n        }\n    }\n\n    // If the last element of vector is non-zero,\
    \ make it zero\n    if let Some(last_nonzero_element) = last_nonzero_element {\n\
    \        if last_nonzero_element > 0.0 {\n            numbers[numbers.len() -\
    \ 1] = 0.0;\n        } else {\n            numbers[0] = 0.0;\n        }\n    }\n\
    \n    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpnm15qar0.rs:9:25\n  |\n9 |\
    \         .filter(|n| n > 0.0)\n  |                         ^^^ expected `&&f64`,\
    \ found floating-point number\n\nerror[E0277]: can't compare `&&f64` with `{float}`\n\
    \  --> /tmp/tmpnm15qar0.rs:15:27\n   |\n15 |         .skip_while(|n| n == 0.0)\n\
    \   |                           ^^ no implementation for `&&f64 == {float}`\n\
    \   |\n   = help: the trait `PartialEq<{float}>` is not implemented for `&&f64`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for x in numbers {\n        if x < min {\n            min = x;\n        }\n\
    \        if x > max {\n            max = x;\n        }\n    }\n    let scale =\
    \ max - min;\n    for x in numbers {\n        x -= min;\n        x * 1.0f / scale\n\
    \    }\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error: invalid suffix `f` for float literal\n  --> /tmp/tmp8pceaxhb.rs:19:13\n\
    \   |\n19 |         x * 1.0f / scale\n   |             ^^^^ invalid suffix `f`\n\
    \   |\n   = help: valid suffixes are `f32` and `f64`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp8pceaxhb.rs:19:9\n   |\n19 |         x * 1.0f / scale\n\
    \   |         ^^^^^^^^^^^^^^^^ expected `()`, found `f64`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp8pceaxhb.rs:17:5\n   |\n5  |   fn rescale_to_unit(numbers:\
    \ Vec<f64>) -> Vec<f64> {\n   |                                            --------\
    \ expected `Vec<f64>` because of return type\n...\n17 | /     for x in numbers\
    \ {\n18 | |         x -= min;\n19 | |         x * 1.0f / scale\n20 | |     }\n\
    \   | |_____^ expected struct `Vec`, found `()`\n   |\n   = note: expected struct\
    \ `Vec<f64>`\n           found unit type `()`\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 101
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    numbers.iter()\n        .zip(numbers.iter().rev())\n    \
    \    .map(|(x, y)| x - y)\n        .collect::<Vec<_>>()\n}\n\nfn main() {\n  \
    \  let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-47.9, 47.9]`,\n right: `[0.0, 1.0]`', /tmp/tmpwgyh3hx1.rs:14:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976458
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut output: Vec<f64> = numbers.clone();\n\n    let mut\
    \ min_value: f64 = numbers[0];\n    let mut max_value: f64 = numbers[0];\n   \
    \ for value in numbers.iter() {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n\n    if min_value < 0.0 {\n        output.reverse();\n\
    \    }\n    output = output.iter().map(|value| value / (max_value - min_value)).collect();\n\
    \    if min_value < 0.0 {\n        output.reverse();\n    }\n    output\n}\n\n\
    fn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcb7zelnv.rs:11:20\n   |\n\
    11 |         if value < min_value {\n   |                    ^^^^^^^^^\n   | \
    \                   |\n   |                    expected `&f64`, found `f64`\n\
    \   |                    help: consider borrowing here: `&min_value`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpcb7zelnv.rs:12:25\n   |\n8  |     let mut min_value:\
    \ f64 = numbers[0];\n   |                        --- expected due to this type\n\
    ...\n12 |             min_value = value;\n   |                         ^^^^^ expected\
    \ `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n12\
    \ |             min_value = *value;\n   |                         +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpcb7zelnv.rs:14:20\n   |\n14 |         if value\
    \ > max_value {\n   |                    ^^^^^^^^^\n   |                    |\n\
    \   |                    expected `&f64`, found `f64`\n   |                  \
    \  help: consider borrowing here: `&max_value`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpcb7zelnv.rs:15:25\n   |\n9  |     let mut max_value: f64 = numbers[0];\n\
    \   |                        --- expected due to this type\n...\n15 |        \
    \     max_value = value;\n   |                         ^^^^^ expected `f64`, found\
    \ `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n15 |          \
    \   max_value = *value;\n   |                         +\n\nerror: aborting due\
    \ to 4 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = std::f64::MAX;\n    let mut max = std::f64::MIN;\n\
    \    for n in numbers {\n        min = std::min(min, n);\n        max = std::max(max,\
    \ n);\n    }\n    let mut norm = max - min;\n    for n in numbers {\n        let\
    \ n = (n - min) / norm;\n        if n == 0.0 {\n            continue;\n      \
    \  }\n        norm += n;\n    }\n    let mut out: Vec<f64> = Vec::new();\n   \
    \ for n in numbers {\n        let n = n * norm;\n        if n > std::f64::MAX\
    \ {\n            n = std::f64::MAX;\n        }\n        if n < std::f64::MIN {\n\
    \            n = std::f64::MIN;\n        }\n        out.push(n);\n    }\n    out\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `min` in crate `std`\n --> /tmp/tmp9d9fvqvr.rs:9:20\n\
    \  |\n9 |         min = std::min(min, n);\n  |                    ^^^ not found\
    \ in `std`\n  |\nhelp: consider importing this function\n  |\n1 | use std::cmp::min;\n\
    \  |\nhelp: if you import `min`, refer to it directly\n  |\n9 -         min =\
    \ std::min(min, n);\n9 +         min = min(min, n);\n  | \n\nerror[E0425]: cannot\
    \ find function `max` in crate `std`\n  --> /tmp/tmp9d9fvqvr.rs:10:20\n   |\n\
    10 |         max = std::max(max, n);\n   |                    ^^^ not found in\
    \ `std`\n   |\nhelp: consider importing this function\n   |\n1  | use std::cmp::max;\n\
    \   |\nhelp: if you import `max`, refer to it directly\n   |\n10 -         max\
    \ = std::max(max, n);\n10 +         max = max(max, n);\n   | \n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut result = Vec::new();\n    let mut min: f64 = 0.0;\n\
    \    let mut max: f64 = 1.0;\n\n    for n in numbers.iter() {\n        match n\
    \ < min {\n            true => {\n                result = result.extend_from_slice(&[0.0,\
    \ 0.0]);\n                min = n;\n            }\n            false => {}\n \
    \       }\n\n        match n > max {\n            true => {\n                result\
    \ = result.extend_from_slice(&[1.0, 1.0]);\n                max = n;\n       \
    \     }\n            false => {}\n        }\n\n        result.append(n / max -\
    \ min).unwrap();\n    }\n\n    result\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpruzslim5.rs:11:19\n   |\n\
    11 |         match n < min {\n   |                   ^^^\n   |               \
    \    |\n   |                   expected `&f64`, found `f64`\n   |            \
    \       help: consider borrowing here: `&min`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpruzslim5.rs:13:26\n   |\n6  |     let mut result = Vec::new();\n\
    \   |                      ---------- expected due to this value\n...\n13 |  \
    \               result = result.extend_from_slice(&[0.0, 0.0]);\n   |        \
    \                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n   |\n   = note: expected struct `Vec<{float}>`\n           found\
    \ unit type `()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpruzslim5.rs:14:23\n\
    \   |\n7  |     let mut min: f64 = 0.0;\n   |                  --- expected due\
    \ to this type\n...\n14 |                 min = n;\n   |                     \
    \  ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n14 |                 min = *n;\n   |                       +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpruzslim5.rs:19:19\n   |\n19 |         match\
    \ n > max {\n   |                   ^^^\n   |                   |\n   |      \
    \             expected `&f64`, found `f64`\n   |                   help: consider\
    \ borrowing here: `&max`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpruzslim5.rs:21:26\n\
    \   |\n6  |     let mut result = Vec::new();\n   |                      ----------\
    \ expected due to this value\n...\n21 |                 result = result.extend_from_slice(&[1.0,\
    \ 1.0]);\n   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<{float}>`\n\
    \           found unit type `()`\nnote: method `extend_from_slice` modifies its\
    \ receiver in-place\n  --> /tmp/tmpruzslim5.rs:21:33\n   |\n21 |             \
    \    result = result.extend_from_slice(&[1.0, 1.0]);\n   |                   \
    \       ------ ^^^^^^^^^^^^^^^^^ this call modifies `result` in-place\n   |  \
    \                        |\n   |                   "
  stdout: ''
  timestamp: 1659976458
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let min_number = numbers.min().unwrap();\n    let max_number\
    \ = numbers.max().unwrap();\n    let mut result: Vec<f64> = Vec::new();\n    for\
    \ n in numbers {\n        let scale = (n - min_number) / (max_number - min_number);\n\
    \        result.push(scale);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: the method `min` exists for struct `Vec<f64>`, but its trait\
    \ bounds were not satisfied\n   --> /tmp/tmplxc99qp9.rs:6:30\n    |\n6   |   \
    \    let min_number = numbers.min().unwrap();\n    |                         \
    \       ^^^ method cannot be called on `Vec<f64>` due to unsatisfied trait bounds\n\
    \    |\n    = note: the following trait bounds were not satisfied:\n         \
    \   `f64: Ord`\n            which is required by `Vec<f64>: Ord`\n           \
    \ `Vec<f64>: Ord`\n            which is required by `&Vec<f64>: Ord`\n       \
    \     `Vec<f64>: Ord`\n            which is required by `&mut Vec<f64>: Ord`\n\
    \            `Vec<f64>: Iterator`\n            which is required by `&mut Vec<f64>:\
    \ Iterator`\n            `f64: Ord`\n            which is required by `[f64]:\
    \ Ord`\n            `[f64]: Ord`\n            which is required by `&[f64]: Ord`\n\
    \            `[f64]: Ord`\n            which is required by `&mut [f64]: Ord`\n\
    \            `[f64]: Iterator`\n            which is required by `&mut [f64]:\
    \ Iterator`\n\nerror[E0599]: the method `max` exists for struct `Vec<f64>`, but\
    \ its trait bounds were not satisfied\n   --> /tmp/tmplxc99qp9.rs:7:30\n    |\n\
    7   |       let max_number = numbers.max().unwrap();\n    |                  \
    \              ^^^ method cannot be called on `Vec<f64>` due to unsatisfied trait\
    \ bounds\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `f64: Ord`\n            which is required by `Vec<f64>: Ord`\n  \
    \          `Vec<f64>: Ord`\n            which is required by `&Vec<f64>: Ord`\n\
    \            `Vec<f64>: Ord`\n            which is required by `&mut Vec<f64>:\
    \ Ord`\n            `Vec<f64>: Iterator`\n            which is required by `&mut\
    \ Vec<f64>: Iterator`\n            `f64: Ord`\n            which is required by\
    \ `[f64]: Ord`\n            `[f64]: Ord`\n            which is required by `&[f64]:\
    \ Ord`\n            `[f64]: Ord`\n            which is required by `&mut [f64]:\
    \ Ord`\n            `[f64]: Iterator`\n            which is required by `&mut\
    \ [f64]: Iterator`\n\nerror: aborting due to 2 previous errors\n\nFor more infor"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0] as f64;\n    let mut max = numbers[0]\
    \ as f64;\n    for n in numbers {\n        if n < min {\n            min = n;\n\
    \        }\n        if n > max {\n            max = n;\n        }\n    }\n   \
    \ let range = (max - min).abs() as f64;\n    let mut newmin = min as f64;\n  \
    \  let mut newmax = max as f64;\n    for n in numbers {\n        if n > newmax\
    \ {\n            newmax = n;\n        }\n        if n < newmin {\n           \
    \ newmin = n;\n        }\n    }\n    let mut newrange = range;\n    for n in numbers\
    \ {\n        newrange *= (n - newmin).abs() as f64;\n    }\n    let rescaled =\
    \ (newmax - newmin).sqrt() as f64;\n    let scale = newrange / rescaled;\n   \
    \ numbers.iter().map(|x| x * scale).collect::<Vec<f64>>()\n}\n\nfn main() {\n\
    \    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpwthe2g9d.rs:19:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror[E0382]: use of moved value: `numbers`\n  -->\
    \ /tmp/tmpwthe2g9d.rs:28:14\n   |\n5  | fn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n   |                    ------- move occurs because `numbers`\
    \ has type `Vec<f64>`, which does not implement the `Copy` trait\n...\n19 |  \
    \   for n in numbers {\n   |              ------- `numbers` moved due to this\
    \ implicit call to `.into_iter()`\n...\n28 |     for n in numbers {\n   |    \
    \          ^^^^^^^ value used here after move\n   |\nhelp: consider iterating\
    \ over a slice of the `Vec<f64>`'s content to avoid moving into the `for` loop\n\
    \   |\n19 |     for n in &numbers {\n   |              +\n\nerror[E0382]: borrow\
    \ of moved value: `numbers`\n  --> /tmp/tmpwthe2g9d.rs:33:5\n   |\n5  | fn rescale_to_unit(numbers:\
    \ Vec<f64>) -> Vec<f64> {\n   |                    ------- move occurs because\
    \ `numbers` has type `Vec<f64>`, which does not implement the `Copy` trait\n...\n\
    28 |     for n in numbers {\n   |              ------- `numbers` moved due to\
    \ this implicit call to `.into_iter()`\n...\n33 |     numbers.iter().map(|x| x\
    \ * scale).collect::<Vec<f64>>()\n   |     ^^^^^^^^^^^^^^ value borrowed here\
    \ after move\n   |\n   = note: borrow occurs due to deref coercion to `[f64]`\n\
    help: consider iterating over a slice of the `Vec<f64>`'s content to avoid moving\
    \ into the `for` loop\n   |\n28 |     for n in &nu"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut result: Vec<f64> = Vec::new();\n    let mut smallest\
    \ = f64::MAX;\n    let mut largest = f64::MIN;\n    for i in numbers.iter() {\n\
    \        if smallest > i {\n            smallest = i;\n        }\n        if largest\
    \ < i {\n            largest = i;\n        }\n    }\n    for i in numbers.iter()\
    \ {\n        result += i / largest - i / smallest as f64;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbyke92vi.rs:10:23\n   |\n\
    10 |         if smallest > i {\n   |                       ^ expected `f64`, found\
    \ `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n10 |         if\
    \ smallest > *i {\n   |                       +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpbyke92vi.rs:11:24\n   |\n7  |     let mut smallest = f64::MAX;\n\
    \   |                        -------- expected due to this value\n...\n11 |  \
    \           smallest = i;\n   |                        ^ expected `f64`, found\
    \ `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n11 |          \
    \   smallest = *i;\n   |                        +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpbyke92vi.rs:13:22\n   |\n13 |         if largest < i {\n\
    \   |                      ^ expected `f64`, found `&f64`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n13 |         if largest < *i {\n   |       \
    \               +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbyke92vi.rs:14:23\n\
    \   |\n8  |     let mut largest = f64::MIN;\n   |                       --------\
    \ expected due to this value\n...\n14 |             largest = i;\n   |       \
    \                ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n14 |             largest = *i;\n   |                     \
    \  +\n\nerror[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `Vec<f64>`\n  --> /tmp/tmpbyke92vi.rs:18:9\n   |\n18 |         result += i /\
    \ largest - i / smallest as f64;\n   |         ------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |         |\n   |         cannot use `+=` on type `Vec<f64>`\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0308, E0368.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let max_value = numbers.iter().max();\n    let min_value\
    \ = numbers.iter().min();\n\n    numbers.iter_mut().map(|num| num / max_value\
    \ - min_value).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpgvv_cl_q.rs:6:36\n\
    \     |\n6    |     let max_value = numbers.iter().max();\n     |            \
    \                        ^^^ the trait `Ord` is not implemented for `f64`\n  \
    \   |\n     = help: the following other types implement trait `Ord`:\n       \
    \        i128\n               i16\n               i32\n               i64\n  \
    \             i8\n               isize\n               u128\n               u16\n\
    \             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpgvv_cl_q.rs:7:36\n\
    \     |\n7    |     let min_value = numbers.iter().min();\n     |            \
    \                        ^^^ the trait `Ord` is not implemented for `f64`\n  \
    \   |\n     = help: the following other types implement trait `Ord`:\n       \
    \        i128\n               i16\n               i32\n               i64\n  \
    \             i8\n               isize\n               u128\n               u16\n\
    \             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0369]: cannot divide `&mut f64` by `Option<&f64>`\n --> /tmp/tmpgvv_cl_q.rs:9:38\n\
    \  |\n9 |     numbers.iter_mut().map(|num| num / max_value - min_value).collect()\n\
    \  |                                  --- ^ --------- Option<&f64>\n  |      \
    \                            |\n  |                                  &mut f64\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0369.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    // find min/max of the vec\n    let max = numbers.iter().max().unwrap();\n\
    \    let min = numbers.iter().min().unwrap();\n\n    // scale each value by the\
    \ max and min\n    numbers.iter_mut().map(|x| {\n        if x < min { x } else\
    \ { x - min }\n    }).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmppamynjdn.rs:7:30\n\
    \     |\n7    |     let max = numbers.iter().max().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmppamynjdn.rs:8:30\n\
    \     |\n8    |     let min = numbers.iter().min().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmppamynjdn.rs:12:16\n   |\n12 |\
    \         if x < min { x } else { x - min }\n   |                ^^^ types differ\
    \ in mutability\n   |\n   = note: expected mutable reference `&mut f64`\n    \
    \                  found reference `&f64`\n\nerror[E0369]: cannot subtract `&f64`\
    \ from `&mut f64`\n  --> /tmp/tmppamynjdn.rs:12:35\n   |\n12 |         if x <\
    \ min { x } else { x - min }\n   |                                 - ^ --- &f64\n\
    \   |                                 |\n   |                                \
    \ &mut f64\n   |\nhelp: `-` can be used on `f64`, you can dereference `x`\n  \
    \ |\n12 |         if x < min { x } else { *x - min }\n   |                   \
    \              +\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308, E0369.\nFor m"
  stdout: ''
  timestamp: 1659976458
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut norm = numbers.iter().sum::<f64>() / numbers.len();\n\
    \    if norm == 0.0 {\n        return vec![];\n    }\n    numbers.iter().map(|n|\
    \ n * norm).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot divide `f64` by `usize`\n --> /tmp/tmpbqixmvco.rs:6:48\n\
    \  |\n6 |     let mut norm = numbers.iter().sum::<f64>() / numbers.len();\n  |\
    \                                                ^ no implementation for `f64\
    \ / usize`\n  |\n  = help: the trait `Div<usize>` is not implemented for `f64`\n\
    \  = help: the following other types implement trait `Div<Rhs>`:\n           \
    \ <&'a f32 as Div<f32>>\n            <&'a f64 as Div<f64>>\n            <&'a i128\
    \ as Div<i128>>\n            <&'a i16 as Div<i16>>\n            <&'a i32 as Div<i32>>\n\
    \            <&'a i64 as Div<i64>>\n            <&'a i8 as Div<i8>>\n        \
    \    <&'a isize as Div<isize>>\n          and 54 others\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for &n in numbers {\n        if n < min {\n            min = n;\n       \
    \ } else if n > max {\n            max = n;\n        }\n    }\n    let delta =\
    \ (max - min).abs();\n    if delta == 0 {\n        return vec![1.0];\n    }\n\
    \    let mut out: Vec<f64> = vec![];\n    for i in 0..numbers.len() {\n      \
    \  let n = numbers[i];\n        let m = min + (n / delta).abs();\n        out.push(m);\n\
    \    }\n    out\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpepmsleup.rs:8:9\n  |\n8 |\
    \     for &n in numbers {\n  |         ^^    ------- this expression has type\
    \ `Option<f64>`\n  |         |\n  |         expected `f64`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `n`\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpepmsleup.rs:16:17\n   |\n16 |     if delta ==\
    \ 0 {\n   |                 ^\n   |                 |\n   |                 expected\
    \ `f64`, found integer\n   |                 help: use a float literal: `0.0`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_val: f64 = numbers[0] as f64;\n    let mut max_val:\
    \ f64 = numbers[0] as f64;\n\n    for (i, x) in numbers.iter().enumerate() {\n\
    \        min_val = std::cmp::min(min_val, x);\n        max_val = std::cmp::max(max_val,\
    \ x);\n    }\n\n    (min_val + max_val) / 2.0\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpez2bi03y.rs:10:42\n   |\n\
    10 |         min_val = std::cmp::min(min_val, x);\n   |                      \
    \                    ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n10 |         min_val = std::cmp::min(min_val, *x);\n   | \
    \                                         +\n\nerror[E0277]: the trait bound `f64:\
    \ Ord` is not satisfied\n    --> /tmp/tmpez2bi03y.rs:10:19\n     |\n10   |   \
    \      min_val = std::cmp::min(min_val, x);\n     |                   ^^^^^^^^^^^^^\
    \ the trait `Ord` is not implemented for `f64`\n     |\n     = help: the following\
    \ other types implement trait `Ord`:\n               i128\n               i16\n\
    \               i32\n               i64\n               i8\n               isize\n\
    \               u128\n               u16\n             and 4 others\nnote: required\
    \ by a bound in `std::cmp::min`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpez2bi03y.rs:11:42\n\
    \   |\n11 |         max_val = std::cmp::max(max_val, x);\n   |               \
    \                           ^ expected `f64`, found `&f64`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n11 |         max_val = std::cmp::max(max_val,\
    \ *x);\n   |                                          +\n\nerror[E0277]: the trait\
    \ bound `f64: Ord` is not satisfied\n    --> /tmp/tmpez2bi03y.rs:11:19\n     |\n\
    11   |         max_val = std::cmp::max(max_val, x);\n     |                  \
    \ ^^^^^^^^^^^^^ the trait `Ord` is not implemented for `f64`\n     |\n     = help:\
    \ the following other types implement trait `Ord`:\n               i128\n    \
    \           i16\n               i32\n               i64\n               i8\n \
    \              isize\n               u128\n               u16\n             and\
    \ 4 others\nnote: required by a bound in `std::cmp::max`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpez2bi03y.rs:14:5\n   |\n5  | fn rescale_to_unit(numbers:\
    \ Vec<f64>) -> Vec<f64> {\n   |                                          --------\
    \ expected `Vec<f64>` because of return type\n...\n14 |     (min_val + max_val)\
    \ / 2.0\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ "
  stdout: ''
  timestamp: 1659976457
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let min_number = numbers.min();\n    let max_number = numbers.max();\n\
    \    if min_number == max_number {\n        numbers\n    } else {\n        let\
    \ mut new_numbers = Vec::with_capacity(numbers.len());\n        for number in\
    \ numbers {\n            new_numbers.push((number - min_number) / (max_number\
    \ - min_number));\n        }\n        new_numbers\n    }\n}\n\nfn main() {\n \
    \   let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: the method `min` exists for struct `Vec<f64>`, but its trait\
    \ bounds were not satisfied\n   --> /tmp/tmp4f7cqd1s.rs:6:30\n    |\n6   |   \
    \    let min_number = numbers.min();\n    |                                ^^^\
    \ method cannot be called on `Vec<f64>` due to unsatisfied trait bounds\n    |\n\
    \    = note: the following trait bounds were not satisfied:\n            `f64:\
    \ Ord`\n            which is required by `Vec<f64>: Ord`\n            `Vec<f64>:\
    \ Ord`\n            which is required by `&Vec<f64>: Ord`\n            `Vec<f64>:\
    \ Ord`\n            which is required by `&mut Vec<f64>: Ord`\n            `Vec<f64>:\
    \ Iterator`\n            which is required by `&mut Vec<f64>: Iterator`\n    \
    \        `f64: Ord`\n            which is required by `[f64]: Ord`\n         \
    \   `[f64]: Ord`\n            which is required by `&[f64]: Ord`\n           \
    \ `[f64]: Ord`\n            which is required by `&mut [f64]: Ord`\n         \
    \   `[f64]: Iterator`\n            which is required by `&mut [f64]: Iterator`\n\
    \nerror[E0599]: the method `max` exists for struct `Vec<f64>`, but its trait bounds\
    \ were not satisfied\n   --> /tmp/tmp4f7cqd1s.rs:7:30\n    |\n7   |       let\
    \ max_number = numbers.max();\n    |                                ^^^ method\
    \ cannot be called on `Vec<f64>` due to unsatisfied trait bounds\n    |\n    =\
    \ note: the following trait bounds were not satisfied:\n            `f64: Ord`\n\
    \            which is required by `Vec<f64>: Ord`\n            `Vec<f64>: Ord`\n\
    \            which is required by `&Vec<f64>: Ord`\n            `Vec<f64>: Ord`\n\
    \            which is required by `&mut Vec<f64>: Ord`\n            `Vec<f64>:\
    \ Iterator`\n            which is required by `&mut Vec<f64>: Iterator`\n    \
    \        `f64: Ord`\n            which is required by `[f64]: Ord`\n         \
    \   `[f64]: Ord`\n            which is required by `&[f64]: Ord`\n           \
    \ `[f64]: Ord`\n            which is required by `&mut [f64]: Ord`\n         \
    \   `[f64]: Iterator`\n            which is required by `&mut [f64]: Iterator`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this "
  stdout: ''
  timestamp: 1659976457
- exit_code: 101
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    if numbers.len() < 2 {\n        return vec![1.0];\n    }\n\
    \n    let mut min = 0.;\n    let mut max = 1.;\n\n    let mut new_min: f64 = 0.;\n\
    \    let mut new_max: f64 = 1.;\n\n    for i in numbers {\n        if i < min\
    \ {\n            min = i;\n            new_min = i;\n        }\n\n        if i\
    \ > max {\n            max = i;\n            new_max = i;\n        }\n    }\n\n\
    \    vec![\n        (new_min - min) / (max - min),\n        (new_max - max) /\
    \ (max - min),\n    ]\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0.0, 0.0]`,\n right: `[0.0, 1.0]`', /tmp/tmpqrsatnkj.rs:36:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976458
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = 0.0;\n    let mut max = numbers[0];\n    for\
    \ num in numbers.iter_mut() {\n        if num < min {\n            num = min;\n\
    \        }\n        if num > max {\n            num = max;\n        }\n    }\n\
    \    Vec::from(numbers).iter().map(|x| x * num / max - min).collect()\n}\n\nfn\
    \ main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `num` in this scope\n  --> /tmp/tmpgj7qidp0.rs:16:43\n\
    \   |\n16 |     Vec::from(numbers).iter().map(|x| x * num / max - min).collect()\n\
    \   |                                           ^^^ not found in this scope\n\n\
    error[E0308]: mismatched types\n --> /tmp/tmpgj7qidp0.rs:9:18\n  |\n9 |      \
    \   if num < min {\n  |                  ^^^\n  |                  |\n  |    \
    \              expected `&mut f64`, found floating-point number\n  |         \
    \         help: consider mutably borrowing here: `&mut min`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpgj7qidp0.rs:10:19\n   |\n8  |     for num in numbers.iter_mut()\
    \ {\n   |         --- expected due to the type of this binding\n9  |         if\
    \ num < min {\n10 |             num = min;\n   |                   ^^^ expected\
    \ `&mut f64`, found floating-point number\n   |\nhelp: consider dereferencing\
    \ here to assign to the mutable borrowed piece of memory\n   |\n10 |         \
    \    *num = min;\n   |             +\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpgj7qidp0.rs:12:18\n   |\n12 |         if num > max {\n   |         \
    \         ^^^\n   |                  |\n   |                  expected `&mut f64`,\
    \ found `f64`\n   |                  help: consider mutably borrowing here: `&mut\
    \ max`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgj7qidp0.rs:13:19\n  \
    \ |\n8  |     for num in numbers.iter_mut() {\n   |         --- expected due to\
    \ the type of this binding\n...\n13 |             num = max;\n   |           \
    \        ^^^ expected `&mut f64`, found `f64`\n   |\nhelp: consider dereferencing\
    \ here to assign to the mutable borrowed piece of memory\n   |\n13 |         \
    \    *num = max;\n   |             +\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976458
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let min = numbers[0];\n    let max = numbers[0];\n\n    for\
    \ n in numbers {\n        if n < min {\n            min = n;\n        }\n    \
    \    if n > max {\n            max = n;\n        }\n    }\n\n    let n = numbers.len();\n\
    \n    for i in 0..n {\n        let d = numbers[i] - min;\n        numbers[i] =\
    \ ((n - i) / n) * d + (min * d / n);\n    }\n\n    numbers\n}\n\nfn main() {\n\
    \    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot multiply `usize` by `f64`\n  --> /tmp/tmpxd4aqdgj.rs:22:36\n\
    \   |\n22 |         numbers[i] = ((n - i) / n) * d + (min * d / n);\n   |    \
    \                                ^ no implementation for `usize * f64`\n   |\n\
    \   = help: the trait `Mul<f64>` is not implemented for `usize`\n   = help: the\
    \ following other types implement trait `Mul<Rhs>`:\n             <&'a f32 as\
    \ Mul<f32>>\n             <&'a f64 as Mul<f64>>\n             <&'a i128 as Mul<i128>>\n\
    \             <&'a i16 as Mul<i16>>\n             <&'a i32 as Mul<i32>>\n    \
    \         <&'a i64 as Mul<i64>>\n             <&'a i8 as Mul<i8>>\n          \
    \   <&'a isize as Mul<isize>>\n           and 49 others\n\nerror[E0277]: cannot\
    \ divide `f64` by `usize`\n  --> /tmp/tmpxd4aqdgj.rs:22:51\n   |\n22 |       \
    \  numbers[i] = ((n - i) / n) * d + (min * d / n);\n   |                     \
    \                              ^ no implementation for `f64 / usize`\n   |\n \
    \  = help: the trait `Div<usize>` is not implemented for `f64`\n   = help: the\
    \ following other types implement trait `Div<Rhs>`:\n             <&'a f32 as\
    \ Div<f32>>\n             <&'a f64 as Div<f64>>\n             <&'a i128 as Div<i128>>\n\
    \             <&'a i16 as Div<i16>>\n             <&'a i32 as Div<i32>>\n    \
    \         <&'a i64 as Div<i64>>\n             <&'a i8 as Div<i8>>\n          \
    \   <&'a isize as Div<isize>>\n           and 54 others\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976458
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    if numbers.len() < 2 {\n        return vec![];\n    }\n \
    \   let max_value = numbers.iter().max();\n    let min_value = numbers.iter().min();\n\
    \    let total_count = numbers.len();\n    let total_value = numbers.iter().sum();\n\
    \n    let result = vec![min_value, max_value];\n    let mut scale = vec![(max_value\
    \ - min_value) / (total_value - total_count)];\n\n    for number in numbers {\n\
    \        let mut new_val = result.0;\n        for (i, &mut new_val) in scale.iter().zip((&mut\
    \ result.0).iter_mut()) {\n            *new_val += (*number - min_value) * &mut\
    \ scale[i];\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpm18a_sne.rs:9:36\n\
    \     |\n9    |     let max_value = numbers.iter().max();\n     |            \
    \                        ^^^ the trait `Ord` is not implemented for `f64`\n  \
    \   |\n     = help: the following other types implement trait `Ord`:\n       \
    \        i128\n               i16\n               i32\n               i64\n  \
    \             i8\n               isize\n               u128\n               u16\n\
    \             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpm18a_sne.rs:10:36\n\
    \     |\n10   |     let min_value = numbers.iter().min();\n     |            \
    \                        ^^^ the trait `Ord` is not implemented for `f64`\n  \
    \   |\n     = help: the following other types implement trait `Ord`:\n       \
    \        i128\n               i16\n               i32\n               i64\n  \
    \             i8\n               isize\n               u128\n               u16\n\
    \             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0369]: cannot subtract `Option<&f64>` from `Option<&f64>`\n  --> /tmp/tmpm18a_sne.rs:15:37\n\
    \   |\n15 |     let mut scale = vec![(max_value - min_value) / (total_value -\
    \ total_count)];\n   |                           --------- ^ --------- Option<&f64>\n\
    \   |                           |\n   |                           Option<&f64>\n\
    \nerror[E0609]: no field `0` on type `Vec<Option<&f64>>`\n  --> /tmp/tmpm18a_sne.rs:18:34\n\
    \   |\n18 |         let mut new_val = result.0;\n   |                        \
    \          ^ unknown field\n\nerror[E0609]: no field `0` on type `Vec<Option<&f64>>`\n\
    \  --> /tmp/tmpm18a_sne.rs:19:64\n   |\n19 |         for (i, &mut new_val) in\
    \ scale.iter().zip((&mut result.0).iter_mut()) {\n   |                       \
    \                                         ^ unknown field\n\nerror[E0614"
  stdout: ''
  timestamp: 1659976458
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    numbers\n        .iter()\n        .map(|x| x / numbers.iter().min().unwrap_or(numbers.iter().max().unwrap_or(1)))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmptt0zhjfy.rs:8:37\n\
    \     |\n8    |         .map(|x| x / numbers.iter().min().unwrap_or(numbers.iter().max().unwrap_or(1)))\n\
    \     |                                     ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmptt0zhjfy.rs:8:68\n\
    \     |\n8    |         .map(|x| x / numbers.iter().min().unwrap_or(numbers.iter().max().unwrap_or(1)))\n\
    \     |                                                                    ^^^\
    \ the trait `Ord` is not implemented for `f64`\n     |\n     = help: the following\
    \ other types implement trait `Ord`:\n               i128\n               i16\n\
    \               i32\n               i64\n               i8\n               isize\n\
    \               u128\n               u16\n             and 4 others\n     = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\nnote:\
    \ required by a bound in `std::iter::Iterator::max`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmptt0zhjfy.rs:8:84\n  |\n8 |         .map(|x| x / numbers.iter().min().unwrap_or(numbers.iter().max().unwrap_or(1)))\n\
    \  |                                                                         \
    \           ^ expected `&f64`, found integer\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976458
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0] as f64;\n    let mut max = numbers[0]\
    \ as f64;\n    for (i, number) in numbers.iter().enumerate() {\n        if number\
    \ < min {\n            min = number;\n        }\n        if number > max {\n \
    \           max = number;\n        }\n    }\n    numbers\n        .iter()\n  \
    \      .map(|number| if number == min { 0.0 } else if number == max { 1.0 } else\
    \ { number as f64 })\n        .collect()\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpgff1ys20.rs:9:21\n  |\n9 |\
    \         if number < min {\n  |                     ^^^\n  |                \
    \     |\n  |                     expected `&f64`, found `f64`\n  |           \
    \          help: consider borrowing here: `&min`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpgff1ys20.rs:10:19\n   |\n6  |     let mut min = numbers[0] as f64;\n\
    \   |                   ----------------- expected due to this value\n...\n10\
    \ |             min = number;\n   |                   ^^^^^^ expected `f64`, found\
    \ `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n10 |          \
    \   min = *number;\n   |                   +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpgff1ys20.rs:12:21\n   |\n12 |         if number > max {\n   | \
    \                    ^^^\n   |                     |\n   |                   \
    \  expected `&f64`, found `f64`\n   |                     help: consider borrowing\
    \ here: `&max`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgff1ys20.rs:13:19\n\
    \   |\n7  |     let mut max = numbers[0] as f64;\n   |                   -----------------\
    \ expected due to this value\n...\n13 |             max = number;\n   |      \
    \             ^^^^^^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n13 |             max = *number;\n   |                   +\n\
    \nerror[E0277]: can't compare `&f64` with `f64`\n  --> /tmp/tmpgff1ys20.rs:18:33\n\
    \   |\n18 |         .map(|number| if number == min { 0.0 } else if number == max\
    \ { 1.0 } else { number as f64 })\n   |                                 ^^ no\
    \ implementation for `&f64 == f64`\n   |\n   = help: the trait `PartialEq<f64>`\
    \ is not implemented for `&f64`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0277]: can't compare `&f64`\
    \ with `f64`\n  --> /tmp/tmpgff1ys20.rs:18:63\n   |\n18 |         .map(|number|\
    \ if number == min { 0.0 } else if number == max { 1.0 } else { number"
  stdout: ''
  timestamp: 1659976458
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let len = numbers[0].abs();\n    let mut new_numbers = vec![];\n\
    \    for i in 0..len {\n        new_numbers.push(numbers[i] / len);\n    }\n \
    \   new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp6lmf0anp.rs:8:17\n  |\n8 |\
    \     for i in 0..len {\n  |                 ^^^ expected integer, found `f64`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976458
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    if numbers.len() < 2 {\n        numbers\n    } else {\n \
    \       let mid = numbers.len() / 2;\n        numbers.iter().cloned().chain(\n\
    \            numbers[mid..mid],\n        )\n            .iter()\n            .cloned()\n\
    \            .map(|&x| {\n                if x == 0.0 {\n                    1.0\n\
    \                } else {\n                    x / 2.0\n                }\n  \
    \          })\n            .collect()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the size for values of type `[f64]` cannot be known at compilation\
    \ time\n   --> /tmp/tmpyix7khrw.rs:11:13\n    |\n10  |         numbers.iter().cloned().chain(\n\
    \    |                                 ----- required by a bound introduced by\
    \ this call\n11  |             numbers[mid..mid],\n    |             ^^^^^^^^^^^^^^^^^\
    \ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized`\
    \ is not implemented for `[f64]`\nnote: required by a bound in `std::iter::Iterator::chain`\n\
    \nerror[E0277]: `[f64]` is not an iterator\n  --> /tmp/tmpyix7khrw.rs:11:13\n\
    \   |\n10 |         numbers.iter().cloned().chain(\n   |                     \
    \            ----- required by a bound introduced by this call\n11 |         \
    \    numbers[mid..mid],\n   |             ^^^^^^^^^^^^^^^^^ expected an implementor\
    \ of trait `IntoIterator`\n   |\n   = note: the trait bound `[f64]: IntoIterator`\
    \ is not satisfied\n   = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `[f64]`\nhelp: consider borrowing here\n   |\n11 |   \
    \          &numbers[mid..mid],\n   |             +\n11 |             &mut numbers[mid..mid],\n\
    \   |             ++++\n\nerror[E0599]: no method named `iter` found for struct\
    \ `std::iter::Chain` in the current scope\n  --> /tmp/tmpyix7khrw.rs:13:14\n \
    \  |\n13 |             .iter()\n   |              ^^^^ method not found in `std::iter::Chain<Cloned<std::slice::Iter<'_,\
    \ f64>>, [f64]>`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976458
- exit_code: 101
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let len = numbers[0].abs();\n    if len == 0.0 {\n      \
    \  return numbers;\n    }\n    let mut min_value = numbers[0];\n    let mut max_value\
    \ = numbers[0];\n    for i in 1..numbers.len() {\n        let v = numbers[i];\n\
    \        if v < min_value {\n            min_value = v;\n        }\n        if\
    \ v > max_value {\n            max_value = v;\n        }\n    }\n    let mut new_vec\
    \ = Vec::new();\n    new_vec.push((min_value - max_value) / len);\n    for i in\
    \ 1..numbers.len() {\n        let v = numbers[i];\n        new_vec.push((v - min_value)\
    \ / (max_value - min_value));\n    }\n    new_vec\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-23.95, 1.0]`,\n right: `[0.0, 1.0]`', /tmp/tmpk8r4sc4t.rs:32:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976458
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let min_number = numbers[0];\n    let max_number = numbers[0];\n\
    \    for i in numbers.iter_mut() {\n        *i = min_number + (*i as f64) / (max_number\
    \ as f64 - min_number as f64);\n        if *i <= 0.0 {\n            *i = 0.0;\n\
    \        }\n        if *i >= 1.0 {\n            *i = 1.0;\n        }\n       \
    \ min_number = *i;\n        if max_number < 0.0 {\n            max_number = *i;\n\
    \        }\n    }\n    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `numbers` as mutable, as it is not declared\
    \ as mutable\n --> /tmp/tmpsco7k09u.rs:8:14\n  |\n5 | fn rescale_to_unit(numbers:\
    \ Vec<f64>) -> Vec<f64> {\n  |                    ------- help: consider changing\
    \ this to be mutable: `mut numbers`\n...\n8 |     for i in numbers.iter_mut()\
    \ {\n  |              ^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0384]:\
    \ cannot assign twice to immutable variable `min_number`\n  --> /tmp/tmpsco7k09u.rs:16:9\n\
    \   |\n6  |     let min_number = numbers[0];\n   |         ----------\n   |  \
    \       |\n   |         first assignment to `min_number`\n   |         help: consider\
    \ making this binding mutable: `mut min_number`\n...\n16 |         min_number\
    \ = *i;\n   |         ^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\
    \nerror[E0384]: cannot assign twice to immutable variable `max_number`\n  -->\
    \ /tmp/tmpsco7k09u.rs:18:13\n   |\n7  |     let max_number = numbers[0];\n   |\
    \         ----------\n   |         |\n   |         first assignment to `max_number`\n\
    \   |         help: consider making this binding mutable: `mut max_number`\n...\n\
    18 |             max_number = *i;\n   |             ^^^^^^^^^^^^^^^ cannot assign\
    \ twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0384, E0596.\nFor more information about\
    \ an error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976458
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    numbers\n        .iter()\n        .fold(0.0, |acc, value|\
    \ acc.min(&value))\n        .map(|value| value / 2.0)\n        .collect()\n}\n\
    \nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0689]: can't call method `min` on ambiguous numeric type `{float}`\n\
    \ --> /tmp/tmpq7g4ialz.rs:8:37\n  |\n8 |         .fold(0.0, |acc, value| acc.min(&value))\n\
    \  |                     ---             ^^^\n  |                     |\n  | \
    \                    you must specify a type for this binding, like `f32`\n\n\
    error[E0689]: can't call method `map` on ambiguous numeric type `{float}`\n -->\
    \ /tmp/tmpq7g4ialz.rs:9:10\n  |\n9 |         .map(|value| value / 2.0)\n  |  \
    \        ^^^\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0689`.\n"
  stdout: ''
  timestamp: 1659976458
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let min_number = std::f64::min(numbers);\n    let max_number\
    \ = std::f64::max(numbers);\n    let diff = max_number - min_number;\n    let\
    \ mut scale = 0.01;\n    let new_number = min_number + diff * scale;\n    let\
    \ mut res = vec![];\n    for i in numbers {\n        res.push(i * scale);\n  \
    \  }\n    res.sort_unstable();\n    res\n}\n\nfn main() {\n    let candidate =\
    \ rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `min` in module `std::f64`\n   --> /tmp/tmpt013jbml.rs:6:32\n\
    \    |\n6   |     let min_number = std::f64::min(numbers);\n    |            \
    \                    ^^^\n    |\nhelp: a constant with a similar name exists\n\
    \    |\n6   |     let min_number = std::f64::MIN(numbers);\n    |            \
    \                    ~~~\nhelp: consider importing this function\n    |\n1   |\
    \ use std::cmp::min;\n    |\nhelp: if you import `min`, refer to it directly\n\
    \    |\n6   -     let min_number = std::f64::min(numbers);\n6   +     let min_number\
    \ = min(numbers);\n    | \n\nerror[E0425]: cannot find function `max` in module\
    \ `std::f64`\n   --> /tmp/tmpt013jbml.rs:7:32\n    |\n7   |     let max_number\
    \ = std::f64::max(numbers);\n    |                                ^^^\n    |\n\
    help: a constant with a similar name exists\n    |\n7   |     let max_number =\
    \ std::f64::MAX(numbers);\n    |                                ~~~\nhelp: consider\
    \ importing this function\n    |\n1   | use std::cmp::max;\n    |\nhelp: if you\
    \ import `max`, refer to it directly\n    |\n7   -     let max_number = std::f64::max(numbers);\n\
    7   +     let max_number = max(numbers);\n    | \n\nerror[E0277]: the trait bound\
    \ `f64: Ord` is not satisfied\n    --> /tmp/tmpt013jbml.rs:15:9\n     |\n15  \
    \ |     res.sort_unstable();\n     |         ^^^^^^^^^^^^^ the trait `Ord` is\
    \ not implemented for `f64`\n     |\n     = help: the following other types implement\
    \ trait `Ord`:\n               i128\n               i16\n               i32\n\
    \               i64\n               i8\n               isize\n               u128\n\
    \               u16\n             and 4 others\nnote: required by a bound in `core::slice::<impl\
    \ [T]>::sort_unstable`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0425.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976458
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut result = numbers.clone();\n    let min_number = result.min();\n\
    \    let max_number = result.max();\n    if min_number == 0.0 && max_number ==\
    \ 1.0 {\n        result.pop();\n    }\n    let min_number = f64::min(min_number,\
    \ 0.);\n    let max_number = f64::max(max_number, 1.);\n    let scale = (max_number\
    \ as f64 - min_number) as f64 / 2.;\n    for (i, n) in result.iter().enumerate()\
    \ {\n        result[i] = n * scale + min_number;\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: the method `min` exists for struct `Vec<f64>`, but its trait\
    \ bounds were not satisfied\n   --> /tmp/tmp3s_s73h0.rs:7:29\n    |\n7   |   \
    \    let min_number = result.min();\n    |                               ^^^ method\
    \ cannot be called on `Vec<f64>` due to unsatisfied trait bounds\n    |\n    =\
    \ note: the following trait bounds were not satisfied:\n            `f64: Ord`\n\
    \            which is required by `Vec<f64>: Ord`\n            `Vec<f64>: Ord`\n\
    \            which is required by `&Vec<f64>: Ord`\n            `Vec<f64>: Ord`\n\
    \            which is required by `&mut Vec<f64>: Ord`\n            `Vec<f64>:\
    \ Iterator`\n            which is required by `&mut Vec<f64>: Iterator`\n    \
    \        `f64: Ord`\n            which is required by `[f64]: Ord`\n         \
    \   `[f64]: Ord`\n            which is required by `&[f64]: Ord`\n           \
    \ `[f64]: Ord`\n            which is required by `&mut [f64]: Ord`\n         \
    \   `[f64]: Iterator`\n            which is required by `&mut [f64]: Iterator`\n\
    \nerror[E0599]: the method `max` exists for struct `Vec<f64>`, but its trait bounds\
    \ were not satisfied\n   --> /tmp/tmp3s_s73h0.rs:8:29\n    |\n8   |       let\
    \ max_number = result.max();\n    |                               ^^^ method cannot\
    \ be called on `Vec<f64>` due to unsatisfied trait bounds\n    |\n    = note:\
    \ the following trait bounds were not satisfied:\n            `f64: Ord`\n   \
    \         which is required by `Vec<f64>: Ord`\n            `Vec<f64>: Ord`\n\
    \            which is required by `&Vec<f64>: Ord`\n            `Vec<f64>: Ord`\n\
    \            which is required by `&mut Vec<f64>: Ord`\n            `Vec<f64>:\
    \ Iterator`\n            which is required by `&mut Vec<f64>: Iterator`\n    \
    \        `f64: Ord`\n            which is required by `[f64]: Ord`\n         \
    \   `[f64]: Ord`\n            which is required by `&[f64]: Ord`\n           \
    \ `[f64]: Ord`\n            which is required by `&mut [f64]: Ord`\n         \
    \   `[f64]: Iterator`\n            which is required by `&mut [f64]: Iterator`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ erro"
  stdout: ''
  timestamp: 1659976458
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n\n    let mut rescaled_numbers\
    \ = Vec::new();\n    for i in numbers.iter() {\n        rescaled_numbers.push((i\
    \ - min) / (max - min));\n    }\n    rescaled_numbers\n}\n\nfn main() {\n    let\
    \ candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0,\
    \ 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `numbers`\n   --> /tmp/tmprurrwx6a.rs:18:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n18  |     for i in numbers.iter() {\n    |              ^^^^^^^^^^^^^^ value\
    \ borrowed here after move\n    |\nnote: this function takes ownership of the\
    \ receiver `self`, which moves `numbers`\n    = note: borrow occurs due to deref\
    \ coercion to `[f64]`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976458
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let minval = std::min(numbers[..1].iter().min().unwrap(),\
    \ numbers[1..].iter().min().unwrap());\n    let maxval = std::max(numbers[..1].iter().max().unwrap(),\
    \ numbers[1..].iter().max().unwrap());\n    vec![minval / maxval]\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `min` in crate `std`\n --> /tmp/tmplowo82mr.rs:6:23\n\
    \  |\n6 |     let minval = std::min(numbers[..1].iter().min().unwrap(), numbers[1..].iter().min().unwrap());\n\
    \  |                       ^^^ not found in `std`\n  |\nhelp: consider importing\
    \ this function\n  |\n1 | use std::cmp::min;\n  |\nhelp: if you import `min`,\
    \ refer to it directly\n  |\n6 -     let minval = std::min(numbers[..1].iter().min().unwrap(),\
    \ numbers[1..].iter().min().unwrap());\n6 +     let minval = min(numbers[..1].iter().min().unwrap(),\
    \ numbers[1..].iter().min().unwrap());\n  | \n\nerror[E0425]: cannot find function\
    \ `max` in crate `std`\n --> /tmp/tmplowo82mr.rs:7:23\n  |\n7 |     let maxval\
    \ = std::max(numbers[..1].iter().max().unwrap(), numbers[1..].iter().max().unwrap());\n\
    \  |                       ^^^ not found in `std`\n  |\nhelp: consider importing\
    \ this function\n  |\n1 | use std::cmp::max;\n  |\nhelp: if you import `max`,\
    \ refer to it directly\n  |\n7 -     let maxval = std::max(numbers[..1].iter().max().unwrap(),\
    \ numbers[1..].iter().max().unwrap());\n7 +     let maxval = max(numbers[..1].iter().max().unwrap(),\
    \ numbers[1..].iter().max().unwrap());\n  | \n\nerror[E0277]: the trait bound\
    \ `f64: Ord` is not satisfied\n    --> /tmp/tmplowo82mr.rs:6:47\n     |\n6   \
    \ |     let minval = std::min(numbers[..1].iter().min().unwrap(), numbers[1..].iter().min().unwrap());\n\
    \     |                                               ^^^ the trait `Ord` is not\
    \ implemented for `f64`\n     |\n     = help: the following other types implement\
    \ trait `Ord`:\n               i128\n               i16\n               i32\n\
    \               i64\n               i8\n               isize\n               u128\n\
    \               u16\n             and 4 others\n     = note: required because\
    \ of the requirements on the impl of `Ord` for `&f64`\nnote: required by a bound\
    \ in `std::iter::Iterator::min`\n\nerror[E0277]: the trait bound `f64: Ord` is\
    \ not satisfied\n    --> /tmp/tmplowo82mr.rs:6:83\n     |\n6    |     let minval\
    \ = std::min(numbers[..1].iter().min().unwrap(), numbers[1..].iter().min().unwrap());"
  stdout: ''
  timestamp: 1659976458
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    numbers.iter().map(|x| x / numbers.iter().max())\n}\n\nfn\
    \ main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpytbdnw70.rs:6:47\n\
    \     |\n6    |     numbers.iter().map(|x| x / numbers.iter().max())\n     | \
    \                                              ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0277]: cannot divide `&f64` by `Option<&f64>`\n --> /tmp/tmpytbdnw70.rs:6:30\n\
    \  |\n6 |     numbers.iter().map(|x| x / numbers.iter().max())\n  |          \
    \                    ^ no implementation for `&f64 / Option<&f64>`\n  |\n  = help:\
    \ the trait `Div<Option<&f64>>` is not implemented for `&f64`\n  = help: the following\
    \ other types implement trait `Div<Rhs>`:\n            <&'a f32 as Div<f32>>\n\
    \            <&'a f64 as Div<f64>>\n            <&'a i128 as Div<i128>>\n    \
    \        <&'a i16 as Div<i16>>\n            <&'a i32 as Div<i32>>\n          \
    \  <&'a i64 as Div<i64>>\n            <&'a i8 as Div<i8>>\n            <&'a isize\
    \ as Div<isize>>\n          and 54 others\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpytbdnw70.rs:6:5\n  |\n5 | fn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n  |                                          -------- expected\
    \ `Vec<f64>` because of return type\n6 |     numbers.iter().map(|x| x / numbers.iter().max())\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`,\
    \ found struct `Map`\n  |\n  = note: expected struct `Vec<f64>`\n            \
    \ found struct `Map<std::slice::Iter<'_, f64>, [closure@/tmp/tmpytbdnw70.rs:6:24:\
    \ 6:52]>`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976458
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_value = numbers.min(|a, b| std::cmp::min(std::f64::MIN,\
    \ std::f64::MAX as f64 - b as f64 - a));\n    let mut max_value = numbers.max(|a,\
    \ b| std::cmp::max(std::f64::MIN, std::f64::MAX as f64 - b as f64 - a));\n   \
    \ match min_value {\n        None => min_value = max_value = 0.0,\n        Some(val)\
    \ => min_value = val as f64,\n    }\n    match max_value {\n        None => max_value\
    \ = 1.0,\n        Some(val) => max_value = val as f64,\n    }\n    numbers.map(|n|\
    \ n / max_value - min_value / max_value)\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: the method `min` exists for struct `Vec<f64>`, but its trait\
    \ bounds were not satisfied\n   --> /tmp/tmpjklvz5vv.rs:6:33\n    |\n6   |   \
    \    let mut min_value = numbers.min(|a, b| std::cmp::min(std::f64::MIN, std::f64::MAX\
    \ as f64 - b as f64 - a));\n    |                                   ^^^ method\
    \ cannot be called on `Vec<f64>` due to unsatisfied trait bounds\n    |\n    =\
    \ note: the following trait bounds were not satisfied:\n            `f64: Ord`\n\
    \            which is required by `Vec<f64>: Ord`\n            `Vec<f64>: Ord`\n\
    \            which is required by `&Vec<f64>: Ord`\n            `Vec<f64>: Ord`\n\
    \            which is required by `&mut Vec<f64>: Ord`\n            `Vec<f64>:\
    \ Iterator`\n            which is required by `&mut Vec<f64>: Iterator`\n    \
    \        `f64: Ord`\n            which is required by `[f64]: Ord`\n         \
    \   `[f64]: Ord`\n            which is required by `&[f64]: Ord`\n           \
    \ `[f64]: Ord`\n            which is required by `&mut [f64]: Ord`\n         \
    \   `[f64]: Iterator`\n            which is required by `&mut [f64]: Iterator`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpjklvz5vv.rs:6:44\n\
    \     |\n6    |     let mut min_value = numbers.min(|a, b| std::cmp::min(std::f64::MIN,\
    \ std::f64::MAX as f64 - b as f64 - a));\n     |                             \
    \               ^^^^^^^^^^^^^ the trait `Ord` is not implemented for `f64`\n \
    \    |\n     = help: the following other types implement trait `Ord`:\n      \
    \         i128\n               i16\n               i32\n               i64\n \
    \              i8\n               isize\n               u128\n               u16\n\
    \             and 4 others\nnote: required by a bound in `std::cmp::min`\n\nerror[E0599]:\
    \ the method `max` exists for struct `Vec<f64>`, but its trait bounds were not\
    \ satisfied\n   --> /tmp/tmpjklvz5vv.rs:7:33\n    |\n7   |       let mut max_value\
    \ = numbers.max(|a, b| std::cmp::max(std::f64::MIN, std::f64::MAX as f64 - b as\
    \ f64 - a));\n    |                                   ^^^ method cannot be called\
    \ on `Vec<f64>` due to unsatisfied tra"
  stdout: ''
  timestamp: 1659976458
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut sum: f64 = 0.0;\n\n    for x in numbers {\n     \
    \   sum += x;\n    }\n\n    let scale = 1.0 / sum;\n    for x in numbers {\n \
    \       *x = *x * scale;\n    }\n\n    numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmpgmq360_6.rs:14:9\n\
    \   |\n14 |         *x = *x * scale;\n   |         ^^\n\nerror[E0614]: type `f64`\
    \ cannot be dereferenced\n  --> /tmp/tmpgmq360_6.rs:14:14\n   |\n14 |        \
    \ *x = *x * scale;\n   |              ^^\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659976458
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_val = numbers.iter().min().unwrap();\n    let\
    \ mut max_val = numbers.iter().max().unwrap();\n\n    min_val = min_val * -1.0;\n\
    \    max_val = max_val * 1.0;\n    min_val\n        .try_into()\n        .unwrap()\n\
    \        .unwrap_or(0.0);\n    max_val\n        .try_into()\n        .unwrap()\n\
    \        .unwrap_or(0.0);\n    numbers.iter().map(|x| x * 1.0 / max_val).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp0c0qlst6.rs:6:38\n\
    \     |\n6    |     let mut min_val = numbers.iter().min().unwrap();\n     | \
    \                                     ^^^ the trait `Ord` is not implemented for\
    \ `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp0c0qlst6.rs:7:38\n\
    \     |\n7    |     let mut max_val = numbers.iter().max().unwrap();\n     | \
    \                                     ^^^ the trait `Ord` is not implemented for\
    \ `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmp0c0qlst6.rs:9:15\n  |\n6 |    \
    \ let mut min_val = numbers.iter().min().unwrap();\n  |                      \
    \ ----------------------------- expected due to this value\n...\n9 |     min_val\
    \ = min_val * -1.0;\n  |               ^^^^^^^^^^^^^^\n  |               |\n \
    \ |               expected `&f64`, found `f64`\n  |               help: consider\
    \ borrowing here: `&(min_val * -1.0)`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp0c0qlst6.rs:10:15\n   |\n7  |     let mut max_val = numbers.iter().max().unwrap();\n\
    \   |                       ----------------------------- expected due to this\
    \ value\n...\n10 |     max_val = max_val * 1.0;\n   |               ^^^^^^^^^^^^^\n\
    \   |               |\n   |               expected `&f64`, found `f64`\n   | "
  stdout: ''
  timestamp: 1659976458
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let mut output = Vec::new();\n    numbers.iter().for_each(|num| {\n     \
    \   let output = num / max as f64;\n        if output < min {\n            output\
    \ = min as f64;\n        }\n        output.push_raw((output - min) / (max - min)\
    \ as u8);\n    });\n    output\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp3sw3dd6t.rs:6:30\n\
    \     |\n6    |     let min = numbers.iter().min().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp3sw3dd6t.rs:7:30\n\
    \     |\n7    |     let max = numbers.iter().max().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp3sw3dd6t.rs:11:21\n   |\n11 |\
    \         if output < min {\n   |                     ^^^ expected `f64`, found\
    \ `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n11 |         if\
    \ output < *min {\n   |                     +\n\nerror[E0599]: no method named\
    \ `push_raw` found for type `f64` in the current scope\n  --> /tmp/tmp3sw3dd6t.rs:14:16\n\
    \   |\n14 |         output.push_raw((output - min) / (max - min) as u8);\n   |\
    \                ^^^^^^^^ method not found in `f64`\n\nerror[E0277]: cannot divide\
    \ `f64` by `u8`\n  --> /tmp/tmp3sw3dd6t.rs:14:40\n   |\n14 |         output.push_raw((output\
    \ - min) / (max - min) as u8);\n   |                                        ^\
    \ no implementation for `f64 / u8`\n   |\n   = help: the trait `Div<u8>` is not\
    \ implemented for `f64`\n  "
  stdout: ''
  timestamp: 1659976458
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        let mut diff = n - min;\n        if diff > max\
    \ {\n            max = diff;\n        }\n        diff = n - max;\n        if diff\
    \ < min {\n            min = diff;\n        }\n    }\n\n    let mut norm = max\
    \ - min;\n    if norm == 0 {\n        // avoid division by zero errors\n     \
    \   norm = 1.0;\n    }\n\n    let mut result: Vec<f64> = vec![];\n    for n in\
    \ numbers {\n        let mut rescaled = min + ((n-min) / norm) * (max-min);\n\
    \        result.push(rescaled);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0,\
    \ 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj_65f9uw.rs:20:16\n   |\n\
    20 |     if norm == 0 {\n   |                ^\n   |                |\n   |  \
    \              expected `f64`, found integer\n   |                help: use a\
    \ float literal: `0.0`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976458
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    numbers.iter().map(|x| x / max - min).collect()\n}\n\nfn main() {\n    let\
    \ candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0,\
    \ 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpm4nq06by.rs:6:30\n\
    \     |\n6    |     let min = numbers.iter().min().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpm4nq06by.rs:7:30\n\
    \     |\n7    |     let max = numbers.iter().max().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976458
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        let ratio = (n - min) / (max - min);\n      \
    \  min = n;\n        max = n * ratio;\n    }\n    numbers\n}\n\nfn main() {\n\
    \    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpa_us9q99.rs:13:5\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n13  |     numbers\n    |     ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    help: consider iterating over a slice of the `Vec<f64>`'s content to avoid moving\
    \ into the `for` loop\n    |\n8   |     for n in &numbers {\n    |           \
    \   +\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976458
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let len = numbers.len();\n    if len < 2 {\n        return\
    \ vec![numbers[0]];\n    }\n\n    let mut max = numbers[0];\n    let mut min =\
    \ numbers[0];\n    for i in 1..len {\n        max = if numbers[i] > max { numbers[i]\
    \ } else { max };\n        min = if numbers[i] < min { numbers[i] } else { min\
    \ };\n    }\n\n    let mut range = max - min;\n    if range == 0 {\n        return\
    \ vec![1.0];\n    }\n    range = 1.0 * range / len;\n    vec![min + range * (numbers[0]\
    \ - min)]\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnvzmx9zv.rs:19:17\n   |\n\
    19 |     if range == 0 {\n   |                 ^\n   |                 |\n   |\
    \                 expected `f64`, found integer\n   |                 help: use\
    \ a float literal: `0.0`\n\nerror[E0277]: cannot divide `f64` by `usize`\n  -->\
    \ /tmp/tmpnvzmx9zv.rs:22:25\n   |\n22 |     range = 1.0 * range / len;\n   | \
    \                        ^ no implementation for `f64 / usize`\n   |\n   = help:\
    \ the trait `Div<usize>` is not implemented for `f64`\n   = help: the following\
    \ other types implement trait `Div<Rhs>`:\n             <&'a f32 as Div<f32>>\n\
    \             <&'a f64 as Div<f64>>\n             <&'a i128 as Div<i128>>\n  \
    \           <&'a i16 as Div<i16>>\n             <&'a i32 as Div<i32>>\n      \
    \       <&'a i64 as Div<i64>>\n             <&'a i8 as Div<i8>>\n            \
    \ <&'a isize as Div<isize>>\n           and 54 others\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976458
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min {\n            min = n;\n        }\n\
    \        if n > max {\n            max = n;\n        }\n    }\n    // We assume\
    \ that all numbers are positive\n    if min > 0.0 {\n        // Scale the vector\
    \ so that the minimum becomes 0 and maximum becomes 1\n        let scale = max\
    \ - min;\n        for n in numbers {\n            n /= scale;\n        }\n   \
    \ }\n    return numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable `n` is assigned to, but never used\n  --> /tmp/tmpicjzx9ks.rs:20:13\n\
    \   |\n20 |         for n in numbers {\n   |             ^\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n   = note: consider using `_n` instead\n\nwarning: value assigned\
    \ to `n` is never read\n  --> /tmp/tmpicjzx9ks.rs:21:13\n   |\n21 |          \
    \   n /= scale;\n   |             ^\n   |\n   = note: `#[warn(unused_assignments)]`\
    \ on by default\n   = help: maybe it is overwritten before being read?\n\nerror[E0382]:\
    \ use of moved value: `numbers`\n   --> /tmp/tmpicjzx9ks.rs:20:18\n    |\n5  \
    \ | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |               \
    \     ------- move occurs because `numbers` has type `Vec<f64>`, which does not\
    \ implement the `Copy` trait\n...\n8   |     for n in numbers {\n    |       \
    \       ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n20  |         for n in numbers {\n    |                  ^^^^^^^ value used\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `numbers`\nhelp: consider iterating over a slice of the\
    \ `Vec<f64>`'s content to avoid moving into the `for` loop\n    |\n8   |     for\
    \ n in &numbers {\n    |              +\n\nerror[E0384]: cannot assign twice to\
    \ immutable variable `n`\n  --> /tmp/tmpicjzx9ks.rs:21:13\n   |\n20 |        \
    \ for n in numbers {\n   |             -\n   |             |\n   |           \
    \  first assignment to `n`\n   |             help: consider making this binding\
    \ mutable: `mut n`\n21 |             n /= scale;\n   |             ^^^^^^^^^^\
    \ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value:\
    \ `numbers`\n  --> /tmp/tmpicjzx9ks.rs:24:12\n   |\n5  | fn rescale_to_unit(numbers:\
    \ Vec<f64>) -> Vec<f64> {\n   |                    ------- move occurs because\
    \ `numbers` has type `Vec<f64>`, which does not implement the `Copy` trait\n...\n\
    8  |     for n in numbers {\n   |              ------- `numbers` moved due to\
    \ this implicit call to `.into_iter()`\n...\n20 |         for n in numbers {\n\
    \   |                  ------- `numbers` "
  stdout: ''
  timestamp: 1659976458
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min: f64;\n    let mut max: f64;\n    let mut scale\
    \ = 1.0;\n    let mut sum = 0;\n    for n in numbers {\n        sum += n;\n  \
    \      if n < min {\n            min = n;\n        }\n        if n > max {\n \
    \           max = n;\n        }\n    }\n    for n in numbers {\n        scale\
    \ = scale / sum;\n        sum += n * scale;\n    }\n    let mut result = vec![0.0;\
    \ numbers.len()];\n    for &n in numbers {\n        result[numbers.iter().position(|&x|\
    \ x > n).unwrap()] += n * scale;\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0,\
    \ 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot add-assign `f64` to `{integer}`\n  --> /tmp/tmp0wn77xgi.rs:11:13\n\
    \   |\n11 |         sum += n;\n   |             ^^ no implementation for `{integer}\
    \ += f64`\n   |\n   = help: the trait `AddAssign<f64>` is not implemented for\
    \ `{integer}`\n   = help: the following other types implement trait `AddAssign<Rhs>`:\n\
    \             <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n    \
    \         <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n        \
    \     <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n         \
    \    <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and\
    \ 20 others\n\nerror[E0277]: cannot divide `{float}` by `{integer}`\n  --> /tmp/tmp0wn77xgi.rs:20:23\n\
    \   |\n20 |         scale = scale / sum;\n   |                       ^ no implementation\
    \ for `{float} / {integer}`\n   |\n   = help: the trait `Div<{integer}>` is not\
    \ implemented for `{float}`\n   = help: the following other types implement trait\
    \ `Div<Rhs>`:\n             <&'a f32 as Div<f32>>\n             <&'a f64 as Div<f64>>\n\
    \             <&'a i128 as Div<i128>>\n             <&'a i16 as Div<i16>>\n  \
    \           <&'a i32 as Div<i32>>\n             <&'a i64 as Div<i64>>\n      \
    \       <&'a i8 as Div<i8>>\n             <&'a isize as Div<isize>>\n        \
    \   and 54 others\n\nerror[E0277]: cannot add-assign `f64` to `{integer}`\n  -->\
    \ /tmp/tmp0wn77xgi.rs:21:13\n   |\n21 |         sum += n * scale;\n   |      \
    \       ^^ no implementation for `{integer} += f64`\n   |\n   = help: the trait\
    \ `AddAssign<f64>` is not implemented for `{integer}`\n   = help: the following\
    \ other types implement trait `AddAssign<Rhs>`:\n             <f32 as AddAssign<&f32>>\n\
    \             <f32 as AddAssign>\n             <f64 as AddAssign<&f64>>\n    \
    \         <f64 as AddAssign>\n             <i128 as AddAssign<&i128>>\n      \
    \       <i128 as AddAssign>\n             <i16 as AddAssign<&i16>>\n         \
    \    <i16 as AddAssign>\n           and 20 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp0wn77xgi.rs:24:9\n   |\n24 |     for &n in numbers {\n\
    \   |         ^^    ------- this "
  stdout: ''
  timestamp: 1659976458
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    assert!(numbers.size() >= 2);\n    numbers\n        .iter()\n\
    \        .filter_map(|x| {\n            if x < 0.0 {\n                0.0\n  \
    \          } else if x > 1.0 {\n                1.0\n            } else {\n  \
    \              x\n            }\n        })\n        .collect()\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `size` found for struct `Vec<f64>` in the\
    \ current scope\n --> /tmp/tmp11b9xffc.rs:6:21\n  |\n6 |     assert!(numbers.size()\
    \ >= 2);\n  |                     ^^^^ help: there is an associated function with\
    \ a similar name: `resize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp11b9xffc.rs:10:20\n\
    \   |\n10 |             if x < 0.0 {\n   |                    ^^^\n   |      \
    \              |\n   |                    expected `&f64`, found floating-point\
    \ number\n   |                    help: consider borrowing here: `&0.0`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp11b9xffc.rs:11:17\n   |\n11 |              \
    \   0.0\n   |                 ^^^ expected enum `Option`, found floating-point\
    \ number\n   |\n   = note: expected enum `Option<_>`\n              found type\
    \ `{float}`\nhelp: try wrapping the expression in `Some`\n   |\n11 |         \
    \        Some(0.0)\n   |                 +++++   +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp11b9xffc.rs:12:27\n   |\n12 |             } else if x >\
    \ 1.0 {\n   |                           ^^^\n   |                           |\n\
    \   |                           expected `&f64`, found floating-point number\n\
    \   |                           help: consider borrowing here: `&1.0`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp11b9xffc.rs:13:17\n   |\n13 |              \
    \   1.0\n   |                 ^^^ expected enum `Option`, found floating-point\
    \ number\n   |\n   = note: expected enum `Option<_>`\n              found type\
    \ `{float}`\nhelp: try wrapping the expression in `Some`\n   |\n13 |         \
    \        Some(1.0)\n   |                 +++++   +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp11b9xffc.rs:15:17\n   |\n15 |                 x\n   | \
    \                ^ expected enum `Option`, found `&f64`\n   |\n   = note:   expected\
    \ enum `Option<_>`\n           found reference `&f64`\nhelp: try wrapping the\
    \ expression in `Some`\n   |\n15 |                 Some(x)\n   |             \
    \    +++++ +\n\nerror: aborting due to 6 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, t"
  stdout: ''
  timestamp: 1659976458
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut max_value = numbers[0];\n    let mut min_value =\
    \ numbers[0];\n\n    for &x in numbers {\n        if x < min_value {\n       \
    \     min_value = x;\n        }\n        if x > max_value {\n            max_value\
    \ = x;\n        }\n    }\n\n    let scale = max_value - min_value;\n    let mut\
    \ rescaled_numbers = Vec::new();\n\n    for n in numbers {\n        let scale_value\
    \ = n.saturating_sub(f64::from(min_value)).sqrt().round() as f64;\n        if\
    \ scale_value == 0.0 {\n            rescaled_numbers.push(0.0);\n        } else\
    \ {\n            rescaled_numbers.push((n - min_value).powi(scale.ln() as i32));\n\
    \        }\n    }\n\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpnek3255j.rs:9:9\n  |\n9 |\
    \     for &x in numbers {\n  |         ^^    ------- this expression has type\
    \ `Option<f64>`\n  |         |\n  |         expected `f64`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `x`\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror[E0599]:\
    \ no method named `saturating_sub` found for type `f64` in the current scope\n\
    \  --> /tmp/tmpnek3255j.rs:22:29\n   |\n22 |         let scale_value = n.saturating_sub(f64::from(min_value)).sqrt().round()\
    \ as f64;\n   |                             ^^^^^^^^^^^^^^ method not found in\
    \ `f64`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976458
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for i in numbers.iter() {\n        min = std::min(min, i);\n        max =\
    \ std::max(max, i);\n    }\n\n    let mut new_numbers = Vec::new();\n    for i\
    \ in numbers.iter() {\n        new_numbers.push((i - min) / (max - min));\n  \
    \  }\n\n    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `min` in crate `std`\n --> /tmp/tmpx4f2evrp.rs:9:20\n\
    \  |\n9 |         min = std::min(min, i);\n  |                    ^^^ not found\
    \ in `std`\n  |\nhelp: consider importing this function\n  |\n1 | use std::cmp::min;\n\
    \  |\nhelp: if you import `min`, refer to it directly\n  |\n9 -         min =\
    \ std::min(min, i);\n9 +         min = min(min, i);\n  | \n\nerror[E0425]: cannot\
    \ find function `max` in crate `std`\n  --> /tmp/tmpx4f2evrp.rs:10:20\n   |\n\
    10 |         max = std::max(max, i);\n   |                    ^^^ not found in\
    \ `std`\n   |\nhelp: consider importing this function\n   |\n1  | use std::cmp::max;\n\
    \   |\nhelp: if you import `max`, refer to it directly\n   |\n10 -         max\
    \ = std::max(max, i);\n10 +         max = max(max, i);\n   | \n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976458
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut scaled = Vec::new();\n    let min_number = numbers.iter().min().unwrap();\n\
    \    let max_number = numbers.iter().max().unwrap();\n    numbers.iter().for_each(|number|\
    \ {\n        let rescaled = number * (max_number - min_number) / (number - min_number);\n\
    \        scaled.append(rescaled);\n    });\n    scaled\n}\n\nfn main() {\n   \
    \ let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmptk1tcpxw.rs:7:37\n\
    \     |\n7    |     let min_number = numbers.iter().min().unwrap();\n     |  \
    \                                   ^^^ the trait `Ord` is not implemented for\
    \ `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmptk1tcpxw.rs:8:37\n\
    \     |\n8    |     let max_number = numbers.iter().max().unwrap();\n     |  \
    \                                   ^^^ the trait `Ord` is not implemented for\
    \ `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmptk1tcpxw.rs:11:23\n   |\n11 |\
    \         scaled.append(rescaled);\n   |                       ^^^^^^^^ expected\
    \ `&mut Vec<_>`, found `f64`\n   |\n   = note: expected mutable reference `&mut\
    \ Vec<_>`\n                           found type `f64`\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976458
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let sum = numbers.iter().reduce::<f64>(0.);\n    let mut\
    \ min: f64;\n    let mut max: f64;\n\n    if numbers.len() > 1 {\n        let\
    \ mut min_f64: f64 = numbers[0];\n        let mut max_f64: f64 = numbers[0];\n\
    \n        for number in numbers {\n            if number < min_f64 {\n       \
    \         min_f64 = number;\n            }\n            if number > max_f64 {\n\
    \                max_f64 = number;\n            }\n        }\n\n        if min_f64\
    \ == max {\n            max = max_f64;\n        } else {\n            min = min_f64;\n\
    \        }\n    } else {\n        min = numbers[0];\n        max = numbers[0];\n\
    \    }\n\n    let mut scaled_numbers = Vec::new();\n\n    for number in numbers\
    \ {\n        scaled_numbers.push((number - min) / (max - min).powf(0.5));\n  \
    \  }\n\n    scaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `FnMut<(&f64, &f64)>` closure, found `f64`\n \
    \   --> /tmp/tmp_b59g346.rs:6:44\n     |\n6    |     let sum = numbers.iter().reduce::<f64>(0.);\n\
    \     |                              ------        ^^ expected an `FnMut<(&f64,\
    \ &f64)>` closure, found `f64`\n     |                              |\n     |\
    \                              required by a bound introduced by this call\n \
    \    |\n     = help: the trait `FnMut<(&f64, &f64)>` is not implemented for `f64`\n\
    note: required by a bound in `reduce`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976458
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_element = numbers.iter().min().unwrap();\n  \
    \  let mut max_element = numbers.iter().max().unwrap();\n    numbers.iter_mut().for_each(|&mut\
    \ elem| {\n        elem = elem - min_element as f64;\n        elem = elem / max_element\
    \ as f64;\n    });\n    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpfjm984ue.rs:6:42\n\
    \     |\n6    |     let mut min_element = numbers.iter().min().unwrap();\n   \
    \  |                                          ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpfjm984ue.rs:7:42\n\
    \     |\n7    |     let mut max_element = numbers.iter().max().unwrap();\n   \
    \  |                                          ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0606]: casting `&f64` as `f64` is invalid\n --> /tmp/tmpfjm984ue.rs:9:23\n\
    \  |\n9 |         elem = elem - min_element as f64;\n  |                     \
    \  -----------^^^^^^^\n  |                       |\n  |                      \
    \ cannot cast `&f64` as `f64`\n  |                       help: dereference the\
    \ expression: `*min_element`\n\nerror[E0606]: casting `&f64` as `f64` is invalid\n\
    \  --> /tmp/tmpfjm984ue.rs:10:23\n   |\n10 |         elem = elem / max_element\
    \ as f64;\n   |                       -----------^^^^^^^\n   |               \
    \        |\n   |                       cannot cast `&f64` as `f64`\n   |     \
    \                  help: dereference the expression: `*max_element`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations"
  stdout: ''
  timestamp: 1659976458
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    if numbers.len() < 2 {\n        numbers\n    } else {\n \
    \       let min_num = numbers.iter().min().unwrap();\n        let max_num = numbers.iter().max().unwrap();\n\
    \        let inv_max_num = 1.0f64 / max_num;\n        let inv_min_num = 1.0f64\
    \ / min_num;\n        numbers.iter().map(|n| n * inv_max_num).collect::<Vec<_>>()\
    \ + (numbers.iter().map(|n| n * inv_min_num).collect::<Vec<_>>() + [min_num]).collect::<Vec<_>>()\n\
    \    }\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmprl9nkqiq.rs:9:38\n\
    \     |\n9    |         let min_num = numbers.iter().min().unwrap();\n     | \
    \                                     ^^^ the trait `Ord` is not implemented for\
    \ `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmprl9nkqiq.rs:10:38\n\
    \     |\n10   |         let max_num = numbers.iter().max().unwrap();\n     | \
    \                                     ^^^ the trait `Ord` is not implemented for\
    \ `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0369]: cannot add `[&f64; 1]` to `Vec<f64>`\n  --> /tmp/tmprl9nkqiq.rs:13:132\n\
    \   |\n13 | ...m).collect::<Vec<_>>() + (numbers.iter().map(|n| n * inv_min_num).collect::<Vec<_>>()\
    \ + [min_num]).collect::<Vec<_>>()\n   |                              -----------------------------------------------------------\
    \ ^ --------- [&f64; 1]\n   |                              |\n   |           \
    \                   Vec<f64>\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976458
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut rescaled_numbers = Vec::with_capacity(numbers.len()\
    \ + 1);\n    rescaled_numbers.extend_from_slice(numbers.iter().map(|x| *x).collect::<Vec<_>>());\n\
    \    rescaled_numbers[0] = 0.0;\n    rescaled_numbers[numbers.len() - 1] = 1.0;\n\
    \    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp0wzgz89q.rs:7:40\n  |\n7 |\
    \     rescaled_numbers.extend_from_slice(numbers.iter().map(|x| *x).collect::<Vec<_>>());\n\
    \  |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \  |                                        |\n  |                           \
    \             expected `&[_]`, found struct `Vec`\n  |                       \
    \                 help: consider borrowing here: `&numbers.iter().map(|x| *x).collect::<Vec<_>>()`\n\
    \  |\n  = note: expected reference `&[_]`\n                found struct `Vec<f64>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976458
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut result = Vec::new();\n    if numbers.len() >= 2 {\n\
    \        let mut smallest = numbers[0];\n        let mut largest = numbers[0];\n\
    \        for &x in numbers {\n            if x < smallest {\n                smallest\
    \ = x;\n            }\n            if x > largest {\n                largest =\
    \ x;\n            }\n        }\n        let scale = smallest - largest;\n    \
    \    for &x in numbers {\n            result.append(x - largest) * scale;\n  \
    \      }\n    }\n    result\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphjird9t7.rs:10:13\n   |\n\
    10 |         for &x in numbers {\n   |             ^^    ------- this expression\
    \ has type `Option<f64>`\n   |             |\n   |             expected `f64`,\
    \ found reference\n   |             help: you can probably remove the explicit\
    \ borrow: `x`\n   |\n   = note:   expected type `f64`\n           found reference\
    \ `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphjird9t7.rs:19:13\n  \
    \ |\n19 |         for &x in numbers {\n   |             ^^    ------- this expression\
    \ has type `Option<f64>`\n   |             |\n   |             expected `f64`,\
    \ found reference\n   |             help: you can probably remove the explicit\
    \ borrow: `x`\n   |\n   = note:   expected type `f64`\n           found reference\
    \ `&_`\n\nerror[E0369]: cannot multiply `()` by `f64`\n  --> /tmp/tmphjird9t7.rs:20:40\n\
    \   |\n20 |             result.append(x - largest) * scale;\n   |            \
    \ -------------------------- ^ ----- f64\n   |             |\n   |           \
    \  ()\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976458
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    assert!(numbers.len() > 1);\n    let mut norm = numbers.iter().cloned().sum();\n\
    \    let mut min_max_scale = vec![1.0, 0.0];\n\n    for n in numbers {\n     \
    \   let scale = (n - norm) as f64 / norm;\n        norm = n;\n        min_max_scale\
    \ = [min(min_max_scale[0], scale), max(min_max_scale[1], scale)];\n    }\n\n \
    \   (numbers - min_max_scale[1]) * min_max_scale[0] + min_max_scale[1]\n}\n\n\
    fn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `min` in this scope\n  --> /tmp/tmpuexghk0q.rs:13:26\n\
    \   |\n13 |         min_max_scale = [min(min_max_scale[0], scale), max(min_max_scale[1],\
    \ scale)];\n   |                          ^^^\n...\n19 | fn main() {\n   | ---------\
    \ similarly named function `main` defined here\n   |\nhelp: a function with a\
    \ similar name exists\n   |\n13 |         min_max_scale = [main(min_max_scale[0],\
    \ scale), max(min_max_scale[1], scale)];\n   |                          ~~~~\n\
    help: consider importing this function\n   |\n1  | use std::cmp::min;\n   |\n\n\
    error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpuexghk0q.rs:13:56\n\
    \   |\n13 |         min_max_scale = [min(min_max_scale[0], scale), max(min_max_scale[1],\
    \ scale)];\n   |                                                        ^^^ not\
    \ found in this scope\n   |\nhelp: consider importing this function\n   |\n1 \
    \ | use std::cmp::max;\n   |\n\nerror[E0369]: cannot subtract `{float}` from `Vec<f64>`\n\
    \  --> /tmp/tmpuexghk0q.rs:16:14\n   |\n16 |     (numbers - min_max_scale[1])\
    \ * min_max_scale[0] + min_max_scale[1]\n   |      ------- ^ ----------------\
    \ {float}\n   |      |\n   |      Vec<f64>\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0369, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659976458
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_val = numbers.iter().min();\n    let mut max_val\
    \ = numbers.iter().max();\n    min_val = 0.0;\n    max_val = 1.0;\n    numbers.iter().map(|n|\
    \ n * (max_val - min_val) / (n - 1)).collect()\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpex6v2b4s.rs:6:38\n\
    \     |\n6    |     let mut min_val = numbers.iter().min();\n     |          \
    \                            ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpex6v2b4s.rs:7:38\n\
    \     |\n7    |     let mut max_val = numbers.iter().max();\n     |          \
    \                            ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmpex6v2b4s.rs:8:15\n  |\n6 |    \
    \ let mut min_val = numbers.iter().min();\n  |                       --------------------\
    \ expected due to this value\n7 |     let mut max_val = numbers.iter().max();\n\
    8 |     min_val = 0.0;\n  |               ^^^ expected enum `Option`, found floating-point\
    \ number\n  |\n  = note: expected enum `Option<&f64>`\n             found type\
    \ `{float}`\n\nerror[E0308]: mismatched types\n --> /tmp/tmpex6v2b4s.rs:9:15\n\
    \  |\n7 |     let mut max_val = numbers.iter().max();\n  |                   \
    \    -------------------- expected due to this value\n8 |     min_val = 0.0;\n\
    9 |     max_val = 1.0;\n  |               ^^^ expected enum `Option`, found floating-point\
    \ number\n  |\n  = note: expected enum `Option<&f64>`\n             found type\
    \ `{"
  stdout: ''
  timestamp: 1659976458
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers.iter().min();\n    let mut max = numbers.iter().max();\n\
    \    let range = max - min;\n    let scale_factor: f64 = 1.0 / (range as f64);\n\
    \    let mut result: Vec<f64> = numbers.iter().map(|number| scale_factor * number).collect();\n\
    \    if min != 0.0 {\n        result.push(0.0);\n    }\n    result.push(1.0);\n\
    \    result\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpcphm5yke.rs:6:34\n\
    \     |\n6    |     let mut min = numbers.iter().min();\n     |              \
    \                    ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpcphm5yke.rs:7:34\n\
    \     |\n7    |     let mut max = numbers.iter().max();\n     |              \
    \                    ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0369]: cannot subtract `Option<&f64>` from `Option<&f64>`\n --> /tmp/tmpcphm5yke.rs:8:21\n\
    \  |\n8 |     let range = max - min;\n  |                 --- ^ --- Option<&f64>\n\
    \  |                 |\n  |                 Option<&f64>\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpcphm5yke.rs:11:15\n   |\n11 |     if min != 0.0 {\n   |\
    \               ^^^ expected enum `Option`, found floating-point number\n   |\n\
    \   = note: expected enum `Option<&f64>`\n              found type `{float}`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0369.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976458
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        min = min.min(n.clone());\n        max = max.max(n.clone());\n\
    \    }\n    numbers.iter_mut().for_each(|n| n.scale_by(max - min));\n    numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `scale_by` found for mutable reference `&mut\
    \ f64` in the current scope\n  --> /tmp/tmpi4taoida.rs:12:39\n   |\n12 |     numbers.iter_mut().for_each(|n|\
    \ n.scale_by(max - min));\n   |                                       ^^^^^^^^\
    \ method not found in `&mut f64`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976458
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let range = max - min;\n    numbers.iter_mut().map(|x| {\n        *x += range\
    \ * 0.5\n    }).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpz5f_2zww.rs:6:30\n\
    \     |\n6    |     let min = numbers.iter().min().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpz5f_2zww.rs:7:30\n\
    \     |\n7    |     let max = numbers.iter().max().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0277]: a value of type `Vec<f64>` cannot be built from an iterator over\
    \ elements of type `()`\n    --> /tmp/tmpz5f_2zww.rs:11:8\n     |\n11   |    \
    \ }).collect()\n     |        ^^^^^^^ value of type `Vec<f64>` cannot be built\
    \ from `std::iter::Iterator<Item=()>`\n     |\n     = help: the trait `FromIterator<()>`\
    \ is not implemented for `Vec<f64>`\n     = help: the trait `FromIterator<T>`\
    \ is implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976458
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    assert!(numbers.len() > 1);\n    let mut min_number = numbers[0];\n\
    \    let mut max_number = numbers[0];\n    for i in 1..numbers.len() {\n     \
    \   let current_number = numbers[i];\n        if current_number < min_number {\n\
    \            min_number = current_number;\n        }\n        if current_number\
    \ > max_number {\n            max_number = current_number;\n        }\n    }\n\
    \n    let min = std::cmp::min(min_number, max_number);\n    let max = std::cmp::max(min_number,\
    \ max_number);\n    let mut rescaled = vec![];\n    for i in 0..numbers.len()\
    \ {\n        rescaled.push((numbers[i] - min) / (max - min));\n    }\n    rescaled\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpxxet7tjd.rs:19:15\n\
    \     |\n19   |     let min = std::cmp::min(min_number, max_number);\n     | \
    \              ^^^^^^^^^^^^^ the trait `Ord` is not implemented for `f64`\n  \
    \   |\n     = help: the following other types implement trait `Ord`:\n       \
    \        i128\n               i16\n               i32\n               i64\n  \
    \             i8\n               isize\n               u128\n               u16\n\
    \             and 4 others\nnote: required by a bound in `std::cmp::min`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpxxet7tjd.rs:20:15\n\
    \     |\n20   |     let max = std::cmp::max(min_number, max_number);\n     | \
    \              ^^^^^^^^^^^^^ the trait `Ord` is not implemented for `f64`\n  \
    \   |\n     = help: the following other types implement trait `Ord`:\n       \
    \        i128\n               i16\n               i32\n               i64\n  \
    \             i8\n               isize\n               u128\n               u16\n\
    \             and 4 others\nnote: required by a bound in `std::cmp::max`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976458
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for &n in numbers {\n        if n < min {\n            min = n;\n       \
    \ }\n        if n > max {\n            max = n;\n        }\n    }\n    let mut\
    \ scale = 1.0f / (max - min);\n    for (i, &n) in numbers.iter().enumerate() {\n\
    \        if n < min {\n            numbers[i] = 0.0;\n        }\n        if n\
    \ > max {\n            numbers[i] = 1.0;\n        }\n        numbers[i] *= scale;\n\
    \    }\n    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error: invalid suffix `f` for float literal\n  --> /tmp/tmp8zemt1mb.rs:16:21\n\
    \   |\n16 |     let mut scale = 1.0f / (max - min);\n   |                    \
    \ ^^^^ invalid suffix `f`\n   |\n   = help: valid suffixes are `f32` and `f64`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmp8zemt1mb.rs:8:9\n  |\n8 |     for\
    \ &n in numbers {\n  |         ^^    ------- this expression has type `Option<f64>`\n\
    \  |         |\n  |         expected `f64`, found reference\n  |         help:\
    \ you can probably remove the explicit borrow: `n`\n  |\n  = note:   expected\
    \ type `f64`\n          found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976458
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut scaled = vec![];\n    for n in numbers {\n      \
    \  scaled.push(n);\n        if n < numbers[0] {\n            scaled.push((n -\
    \ numbers[0]) / (n - numbers[0]))\n        }\n    }\n    scaled\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `numbers`\n   --> /tmp/tmp_b7i5wjf.rs:9:16\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n6   |     let mut scaled = vec![];\n7 \
    \  |     for n in numbers {\n    |              ------- `numbers` moved due to\
    \ this implicit call to `.into_iter()`\n8   |         scaled.push(n);\n9   | \
    \        if n < numbers[0] {\n    |                ^^^^^^^ value borrowed here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n7   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976458
- exit_code: 101
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut scale = 1.0;\n    let mut result: Vec<f64> = vec![];\n\
    \    for (number, offset) in numbers.iter().zip(numbers.iter().skip(1)) {\n  \
    \      let n = number.abs() / offset;\n        if n < 1e-10 {\n            result.push(0.0);\n\
    \        } else {\n            result.push(n * scale);\n            scale = n.abs();\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0.04008016032064128]`,\n right: `[0.0, 1.0]`', /tmp/tmpkimzt8fn.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976458
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut max = numbers[0];\n    let mut min = numbers[0];\n\
    \    let mut x = numbers[0];\n    for &n in numbers {\n        if n < min {\n\
    \            min = n;\n        }\n        if n > max {\n            max = n;\n\
    \        }\n        x += n;\n    }\n\n    // Scale the numbers between min/max\
    \ by (max-min)/2\n    (numbers as f64) / (max - min).powf(2.0)\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpvoene4ss.rs:9:9\n  |\n9 |\
    \     for &n in numbers {\n  |         ^^    ------- this expression has type\
    \ `Option<f64>`\n  |         |\n  |         expected `f64`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `n`\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpvoene4ss.rs:20:5\n   |\n5  | fn rescale_to_unit(numbers:\
    \ Vec<f64>) -> Vec<f64> {\n   |                                          --------\
    \ expected `Vec<f64>` because of return type\n...\n20 |     (numbers as f64) /\
    \ (max - min).powf(2.0)\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `f64`\n   |\n   = note: expected struct `Vec<f64>`\n   \
    \             found type `f64`\n\nerror[E0605]: non-primitive cast: `Vec<f64>`\
    \ as `f64`\n  --> /tmp/tmpvoene4ss.rs:20:5\n   |\n20 |     (numbers as f64) /\
    \ (max - min).powf(2.0)\n   |     ^^^^^^^^^^^^^^^^ an `as` expression can only\
    \ be used to convert between primitive types or to coerce to a specific trait\
    \ object\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0605.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976458
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut max = numbers[0];\n    let mut min = numbers[0];\n\
    \    let mut current_max = numbers[0];\n    let mut current_min = numbers[0];\n\
    \n    let mut scale: f64;\n\n    for i in 0..numbers.len() {\n        let number\
    \ = numbers[i];\n\n        if number > max {\n            max = number;\n    \
    \    }\n\n        if number < min {\n            min = number;\n        }\n\n\
    \        if number < current_max {\n            current_max = number;\n      \
    \  }\n\n        if number > current_min {\n            current_min = number;\n\
    \        }\n\n        scale = max as f64 - min as f64;\n        let new_number:\
    \ f64 = (number - min) as f64 / scale as f64;\n        numbers[i] = new_number;\n\
    \    }\n\n    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `numbers` as mutable, as it is not declared\
    \ as mutable\n  --> /tmp/tmpx2fxhswr.rs:34:9\n   |\n5  | fn rescale_to_unit(numbers:\
    \ Vec<f64>) -> Vec<f64> {\n   |                    ------- help: consider changing\
    \ this to be mutable: `mut numbers`\n...\n34 |         numbers[i] = new_number;\n\
    \   |         ^^^^^^^ cannot borrow as mutable\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659976458
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    if numbers.len() < 2 {\n        return vec![];\n    }\n \
    \   let mut vec = Vec::new();\n    let mut min_number = numbers.first().unwrap();\n\
    \    let mut max_number = numbers.last().unwrap();\n    vec.push(min_number as\
    \ f64);\n    let mut scaling_factor;\n    // Find scaling factor for smallest\
    \ number\n    for &n in numbers {\n        if n == min_number {\n            scaling_factor\
    \ = n as f64;\n        } else {\n            scaling_factor = (n - min_number)\
    \ / (max_number - min_number);\n        }\n    }\n    for &n in numbers {\n  \
    \      vec.push(n * scaling_factor);\n    }\n    vec\n}\n\nfn main() {\n    let\
    \ candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0,\
    \ 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0hcqb1b5.rs:15:9\n   |\n\
    15 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp0hcqb1b5.rs:22:9\n   |\n22 |     for &n in numbers\
    \ {\n   |         ^^    ------- this expression has type `Option<f64>`\n   | \
    \        |\n   |         expected `f64`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `n`\n   |\n   = note:   expected type\
    \ `f64`\n           found reference `&_`\n\nerror[E0606]: casting `&f64` as `f64`\
    \ is invalid\n  --> /tmp/tmp0hcqb1b5.rs:12:14\n   |\n12 |     vec.push(min_number\
    \ as f64);\n   |              ----------^^^^^^^\n   |              |\n   |   \
    \           cannot cast `&f64` as `f64`\n   |              help: dereference the\
    \ expression: `*min_number`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0606.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976458
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_number = numbers.iter().min().unwrap();\n   \
    \ let mut max_number = numbers.iter().max().unwrap();\n    let rescaled_numbers\
    \ = numbers.iter().map(|x| {\n        x / (max_number - min_number)\n    });\n\
    \    rescaled_numbers.collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpyki4x4oj.rs:6:41\n\
    \     |\n6    |     let mut min_number = numbers.iter().min().unwrap();\n    \
    \ |                                         ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpyki4x4oj.rs:7:41\n\
    \     |\n7    |     let mut max_number = numbers.iter().max().unwrap();\n    \
    \ |                                         ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976458
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let min_number = numbers.iter().min().unwrap();\n    let\
    \ max_number = numbers.iter().max().unwrap();\n\n    numbers.iter().map(|x| x\
    \ / max_number).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpore8ny7k.rs:6:37\n\
    \     |\n6    |     let min_number = numbers.iter().min().unwrap();\n     |  \
    \                                   ^^^ the trait `Ord` is not implemented for\
    \ `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpore8ny7k.rs:7:37\n\
    \     |\n7    |     let max_number = numbers.iter().max().unwrap();\n     |  \
    \                                   ^^^ the trait `Ord` is not implemented for\
    \ `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976458
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_value = numbers[0];\n    let mut max_value =\
    \ numbers[0];\n    let mut current_value = numbers[0];\n\n    for number in numbers\
    \ {\n        min_value = std::cmp::min(min_value, number);\n        max_value\
    \ = std::cmp::max(max_value, number);\n        current_value = number + (current_value\
    \ - min_value) / (max_value - min_value);\n    }\n    let mut result = Vec::with_capacity(numbers.len());\n\
    \    for i in 0..numbers.len() {\n        let value = current_value * numbers.len()\
    \ + min_value;\n        result.push(value);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpanjcqmg7.rs:11:21\n\
    \     |\n11   |         min_value = std::cmp::min(min_value, number);\n     |\
    \                     ^^^^^^^^^^^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\nnote: required by a bound in `std::cmp::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpanjcqmg7.rs:12:21\n\
    \     |\n12   |         max_value = std::cmp::max(max_value, number);\n     |\
    \                     ^^^^^^^^^^^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\nnote: required by a bound in `std::cmp::max`\n\
    \nerror[E0277]: cannot multiply `f64` by `usize`\n  --> /tmp/tmpanjcqmg7.rs:17:35\n\
    \   |\n17 |         let value = current_value * numbers.len() + min_value;\n \
    \  |                                   ^ no implementation for `f64 * usize`\n\
    \   |\n   = help: the trait `Mul<usize>` is not implemented for `f64`\n   = help:\
    \ the following other types implement trait `Mul<Rhs>`:\n             <&'a f32\
    \ as Mul<f32>>\n             <&'a f64 as Mul<f64>>\n             <&'a i128 as\
    \ Mul<i128>>\n             <&'a i16 as Mul<i16>>\n             <&'a i32 as Mul<i32>>\n\
    \             <&'a i64 as Mul<i64>>\n             <&'a i8 as Mul<i8>>\n      \
    \       <&'a isize as Mul<isize>>\n           and 49 others\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976458
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let min_num = numbers.iter().min();\n    let max_num = numbers.iter().max();\n\
    \n    let len = numbers.len() as f64;\n\n    numbers * max_num.powi(len) - min_num.powi(len)\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmppwb_ouis.rs:6:34\n\
    \     |\n6    |     let min_num = numbers.iter().min();\n     |              \
    \                    ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmppwb_ouis.rs:7:34\n\
    \     |\n7    |     let max_num = numbers.iter().max();\n     |              \
    \                    ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0599]: no method named `powi` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmppwb_ouis.rs:11:23\n   |\n11 |     numbers * max_num.powi(len)\
    \ - min_num.powi(len)\n   |                       ^^^^ method not found in `Option<&f64>`\n\
    \nerror[E0599]: no method named `powi` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmppwb_ouis.rs:11:43\n   |\n11 |     numbers * max_num.powi(len)\
    \ - min_num.powi(len)\n   |                                           ^^^^ method\
    \ not found in `Option<&f64>`\n\nerror: aborting due to 4 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976458
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_value = numbers.iter().min().unwrap();\n    let\
    \ mut max_value = numbers.iter().max().unwrap();\n\n    while max_value - min_value\
    \ > 1e-5 {\n        if min_value > 0.0 {\n            min_value -= 1e-5;\n   \
    \     }\n        if max_value < 1.0 {\n            max_value += 1e-5;\n      \
    \  }\n    }\n\n    let mut rescaled_numbers = Vec::new();\n\n    for num in numbers\
    \ {\n        if num < min_value {\n            rescaled_numbers.push(0.0);\n \
    \       }\n        if num > max_value {\n            rescaled_numbers.push(1.0);\n\
    \        }\n        rescaled_numbers.push(num);\n    }\n\n    rescaled_numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpbhgcsb40.rs:6:40\n\
    \     |\n6    |     let mut min_value = numbers.iter().min().unwrap();\n     |\
    \                                        ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpbhgcsb40.rs:7:40\n\
    \     |\n7    |     let mut max_value = numbers.iter().max().unwrap();\n     |\
    \                                        ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpbhgcsb40.rs:10:24\n   |\n10 |\
    \         if min_value > 0.0 {\n   |                        ^^^\n   |        \
    \                |\n   |                        expected `&f64`, found floating-point\
    \ number\n   |                        help: consider borrowing here: `&0.0`\n\n\
    error[E0368]: binary assignment operation `-=` cannot be applied to type `&f64`\n\
    \  --> /tmp/tmpbhgcsb40.rs:11:13\n   |\n11 |             min_value -= 1e-5;\n\
    \   |             ---------^^^^^^^^\n   |             |\n   |             cannot\
    \ use `-=` on type `&f64`\n   |\nhelp: `-=` can be used on `f64`, you can dereference\
    \ `min_value`\n   |\n11 |             *min_value -= 1e-5;\n   |             +\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpbhgcsb40.rs:13:24\n   |\n1"
  stdout: ''
  timestamp: 1659976458
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let min_number = numbers.iter().min();\n    let max_number\
    \ = numbers.iter().max();\n\n    if min_number == 0.0 && max_number == 1.0 {\n\
    \        return numbers;\n    }\n    else {\n        let mut new_numbers = vec![min_number];\n\
    \        for i in numbers.iter().rev() {\n            new_numbers.append(i / max_number);\n\
    \        }\n        new_numbers.reverse();\n        return new_numbers\n    }\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp3i6tfhrw.rs:6:37\n\
    \     |\n6    |     let min_number = numbers.iter().min();\n     |           \
    \                          ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp3i6tfhrw.rs:7:37\n\
    \     |\n7    |     let max_number = numbers.iter().max();\n     |           \
    \                          ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmp3i6tfhrw.rs:9:22\n  |\n9 |    \
    \ if min_number == 0.0 && max_number == 1.0 {\n  |                      ^^^ expected\
    \ enum `Option`, found floating-point number\n  |\n  = note: expected enum `Option<&f64>`\n\
    \             found type `{float}`\n\nerror[E0308]: mismatched types\n --> /tmp/tmp3i6tfhrw.rs:9:43\n\
    \  |\n9 |     if min_number == 0.0 && max_number == 1.0 {\n  |               \
    \                            ^^^ expected enum `Option`, found floating-point\
    \ number\n  |\n  = note: expected enum `Option<&f64>`\n             found type\
    \ `{float}`\n\nerror[E0277]: cannot divide `&f64` by `Option<&f64>`\n  --> /tmp/tmp3i6tfhrw.rs:15:34\n\
    \   |\n15 |             new_numbers.append(i / max_number);\n   |            \
    \                      ^ no implementation for `&f64 / Opti"
  stdout: ''
  timestamp: 1659976458
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut smallest = numbers[0];\n    let mut largest = numbers[0];\n\
    \    for i in numbers.iter_mut() {\n        if *i < smallest {\n            smallest\
    \ = *i;\n        }\n        if *i > largest {\n            largest = *i;\n   \
    \     }\n    }\n    let mut res: Vec<f64> = Vec::new();\n    res.push(smallest\
    \ as f64);\n    for i in numbers.iter_mut() {\n        *i -= smallest as f64;\n\
    \        res.push(*i as f64);\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `numbers` as mutable, as it is not declared\
    \ as mutable\n --> /tmp/tmp3t2b9ib9.rs:8:14\n  |\n5 | fn rescale_to_unit(numbers:\
    \ Vec<f64>) -> Vec<f64> {\n  |                    ------- help: consider changing\
    \ this to be mutable: `mut numbers`\n...\n8 |     for i in numbers.iter_mut()\
    \ {\n  |              ^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0596]:\
    \ cannot borrow `numbers` as mutable, as it is not declared as mutable\n  -->\
    \ /tmp/tmp3t2b9ib9.rs:18:14\n   |\n5  | fn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n   |                    ------- help: consider changing this\
    \ to be mutable: `mut numbers`\n...\n18 |     for i in numbers.iter_mut() {\n\
    \   |              ^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0596`.\n"
  stdout: ''
  timestamp: 1659976458
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_value = numbers.iter().min().unwrap();\n    let\
    \ mut max_value = numbers.iter().max().unwrap();\n    if max_value < min_value\
    \ {\n        // the min() value is greater than the max() value, so flip them\n\
    \        min_value = max_value;\n        max_value = min_value;\n    }\n    let\
    \ range = max_value - min_value;\n    let mut scale = 0.0;\n    numbers.iter().for_each(|n|\
    \ scale += (n-min_value)/range);\n    if scale == 0.0 {\n        // we can't rescale\
    \ the vector because it has zero elements\n        return numbers;\n    }\n  \
    \  let mut numbers_scaled = vec![0.0; numbers.len()];\n    numbers.iter().for_each(|n|\
    \ numbers_scaled[(numbers.iter().position(|x| x <= n) - numbers.iter().position(|x|\
    \ x > n)).unwrap()] += (n - min_value)/range);\n    numbers_scaled * scale\n}\n\
    \nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp09qtpu9o.rs:6:40\n\
    \     |\n6    |     let mut min_value = numbers.iter().min().unwrap();\n     |\
    \                                        ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp09qtpu9o.rs:7:40\n\
    \     |\n7    |     let mut max_value = numbers.iter().max().unwrap();\n     |\
    \                                        ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0369]: cannot subtract `Option<usize>` from `Option<usize>`\n  --> /tmp/tmp09qtpu9o.rs:21:85\n\
    \   |\n21 |     numbers.iter().for_each(|n| numbers_scaled[(numbers.iter().position(|x|\
    \ x <= n) - numbers.iter().position(|x| x > n)).unwrap()] += (n...\n   |     \
    \                                            -----------------------------------\
    \ ^ ---------------------------------- Option<usize>\n   |                   \
    \                              |\n   |                                       \
    \          Option<usize>\n\nerror[E0369]: cannot multiply `Vec<{float}>` by `f64`\n\
    \  --> /tmp/tmp09qtpu9o.rs:22:20\n   |\n22 |     numbers_scaled * scale\n   |\
    \     -------------- ^ ----- f64\n   |     |\n   |     Vec<{float}>\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors "
  stdout: ''
  timestamp: 1659976458
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let min_number = numbers.iter().min().unwrap();\n    let\
    \ max_number = numbers.iter().max().unwrap();\n    let min_number = min_number\
    \ + 0.5;\n    let max_number = max_number - 0.5;\n    numbers.iter_mut().map(|x|\
    \ if x < min_number { x = min_number } else { x = x }).collect::<Vec<_>>()\n}\n\
    \nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp3dumk15u.rs:6:37\n\
    \     |\n6    |     let min_number = numbers.iter().min().unwrap();\n     |  \
    \                                   ^^^ the trait `Ord` is not implemented for\
    \ `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp3dumk15u.rs:7:37\n\
    \     |\n7    |     let max_number = numbers.iter().max().unwrap();\n     |  \
    \                                   ^^^ the trait `Ord` is not implemented for\
    \ `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp3dumk15u.rs:10:39\n   |\n10 |\
    \     numbers.iter_mut().map(|x| if x < min_number { x = min_number } else { x\
    \ = x }).collect::<Vec<_>>()\n   |                                       ^^^^^^^^^^\n\
    \   |                                       |\n   |                          \
    \             expected `&mut f64`, found `f64`\n   |                         \
    \              help: consider mutably borrowing here: `&mut min_number`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp3dumk15u.rs:10:56\n   |\n10 |     numbers.iter_mut().map(|x|\
    \ if x < min_number { x = min_number } else { x = x }).collect::<Vec<_>>()\n \
    \  |                             -                          ^^^^^^^^^^ expected\
    \ `&mut f64`, found `f64`\n   |                             |\n   "
  stdout: ''
  timestamp: 1659976458
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers.iter().min().unwrap();\n    let mut\
    \ max = numbers.iter().max().unwrap();\n    let mut length = numbers[0].abs();\n\
    \    for (i, val) in numbers.iter().enumerate() {\n        if val < min {\n  \
    \          min = val as f64;\n        }\n        if val > max {\n            max\
    \ = val as f64;\n        }\n        length += val.abs();\n    }\n    let mut scale\
    \ = 1.0 * min / length as f64;\n    for val in numbers {\n        if val < min\
    \ {\n            val -= scale * min;\n        }\n        if val > max {\n    \
    \        val -= scale * (max - min);\n        }\n    }\n    numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpk6prr0_z.rs:6:34\n\
    \     |\n6    |     let mut min = numbers.iter().min().unwrap();\n     |     \
    \                             ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpk6prr0_z.rs:7:34\n\
    \     |\n7    |     let mut max = numbers.iter().max().unwrap();\n     |     \
    \                             ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpk6prr0_z.rs:11:19\n   |\n6  |\
    \     let mut min = numbers.iter().min().unwrap();\n   |                   -----------------------------\
    \ expected due to this value\n...\n11 |             min = val as f64;\n   |  \
    \                 ^^^^^^^^^^\n   |                   |\n   |                 \
    \  expected `&f64`, found `f64`\n   |                   help: consider borrowing\
    \ here: `&(val as f64)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk6prr0_z.rs:14:19\n\
    \   |\n7  |     let mut max = numbers.iter().max().unwrap();\n   |           \
    \        ----------------------------- expected due to this value\n...\n14 | \
    \            max = val as f64;\n   |                   ^^^^^^^^^^\n   |      \
    \             |\n   |                   expected `&f64`, found `f64`\n   |   \
    \  "
  stdout: ''
  timestamp: 1659976458
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    if numbers.len() == 0 {\n        return vec![];\n    }\n\
    \    numbers.iter().map(|x| x / numbers.len()).collect::<Vec<_>>()\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot divide `&f64` by `usize`\n --> /tmp/tmp6m3kfl57.rs:9:30\n\
    \  |\n9 |     numbers.iter().map(|x| x / numbers.len()).collect::<Vec<_>>()\n\
    \  |                              ^ no implementation for `&f64 / usize`\n  |\n\
    \  = help: the trait `Div<usize>` is not implemented for `&f64`\n  = help: the\
    \ following other types implement trait `Div<Rhs>`:\n            <&'a f32 as Div<f32>>\n\
    \            <&'a f64 as Div<f64>>\n            <&'a i128 as Div<i128>>\n    \
    \        <&'a i16 as Div<i16>>\n            <&'a i32 as Div<i32>>\n          \
    \  <&'a i64 as Div<i64>>\n            <&'a i8 as Div<i8>>\n            <&'a isize\
    \ as Div<isize>>\n          and 54 others\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976458
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut max_value = 0.;\n    let mut min_value = 1.;\n  \
    \  for &n in numbers {\n        if n > max_value {\n            max_value = *n;\n\
    \        }\n        if n < min_value {\n            min_value = *n;\n        }\n\
    \    }\n    let mut new_numbers = Vec::new();\n    new_numbers.extend_from_slice(&[min_value]);\n\
    \    new_numbers.extend_from_slice(&[max_value]);\n    new_numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp9yy2t2pk.rs:8:9\n  |\n8 |\
    \     for &n in numbers {\n  |         ^^    ------- this expression has type\
    \ `Option<f64>`\n  |         |\n  |         expected `f64`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `n`\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976458
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for n in numbers {\n        if n < min { min = n; }\n        if n > max {\
    \ max = n; }\n    }\n    let mut new_min = max - 1;\n    let mut new_max = min\
    \ + 1;\n    for n in numbers {\n        let mut old_min = min;\n        let mut\
    \ old_max = max;\n        while n > old_max {\n            old_max += 1;\n   \
    \     }\n        while n < old_min {\n            old_min -= 1;\n        }\n \
    \       if n == old_max { new_max = old_max; }\n        if n == old_min { new_min\
    \ = old_min; }\n    }\n    numbers.iter().map(|x| {\n        assert!(x >= new_min\
    \ && x <= new_max);\n        (x - new_min) / (new_max - new_min + 1.)\n    })\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot subtract `{integer}` from `f64`\n  --> /tmp/tmpo3r_1hon.rs:12:27\n\
    \   |\n12 |     let mut new_min = max - 1;\n   |                           ^ no\
    \ implementation for `f64 - {integer}`\n   |\n   = help: the trait `Sub<{integer}>`\
    \ is not implemented for `f64`\n   = help: the following other types implement\
    \ trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n             <&'a f64\
    \ as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n             <&'a i16 as\
    \ Sub<i16>>\n             <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n\
    \             <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n  \
    \         and 48 others\nhelp: consider using a floating-point literal by writing\
    \ it with `.0`\n   |\n12 |     let mut new_min = max - 1.0;\n   |            \
    \                  ++\n\nerror[E0277]: cannot add `{integer}` to `f64`\n  -->\
    \ /tmp/tmpo3r_1hon.rs:13:27\n   |\n13 |     let mut new_max = min + 1;\n   | \
    \                          ^ no implementation for `f64 + {integer}`\n   |\n \
    \  = help: the trait `Add<{integer}>` is not implemented for `f64`\n   = help:\
    \ the following other types implement trait `Add<Rhs>`:\n             <&'a f32\
    \ as Add<f32>>\n             <&'a f64 as Add<f64>>\n             <&'a i128 as\
    \ Add<i128>>\n             <&'a i16 as Add<i16>>\n             <&'a i32 as Add<i32>>\n\
    \             <&'a i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n      \
    \       <&'a isize as Add<isize>>\n           and 48 others\nhelp: consider using\
    \ a floating-point literal by writing it with `.0`\n   |\n13 |     let mut new_max\
    \ = min + 1.0;\n   |                              ++\n\nerror[E0277]: cannot add-assign\
    \ `{integer}` to `f64`\n  --> /tmp/tmpo3r_1hon.rs:18:21\n   |\n18 |          \
    \   old_max += 1;\n   |                     ^^ no implementation for `f64 += {integer}`\n\
    \   |\n   = help: the trait `AddAssign<{integer}>` is not implemented for `f64`\n\
    \   = help: the following other types implement trait `AddAssign<Rhs>`:\n    \
    \         <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n        \
    \     <f64 as AddAssign<&f64>>\n             <f6"
  stdout: ''
  timestamp: 1659976458
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min: f64 = numbers[0];\n    let mut max: f64 = numbers[0];\n\
    \    for &x in numbers {\n        if x < min {\n            min = x;\n       \
    \ }\n        if x > max {\n            max = x;\n        }\n    }\n    let mut\
    \ res: Vec<f64> = Vec::new();\n    for &x in numbers {\n        res.push((x -\
    \ min) / (max - min));\n    }\n    res\n}\n\nfn main() {\n    let candidate =\
    \ rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpe9qhf6eo.rs:8:9\n  |\n8 |\
    \     for &x in numbers {\n  |         ^^    ------- this expression has type\
    \ `Option<f64>`\n  |         |\n  |         expected `f64`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `x`\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpe9qhf6eo.rs:17:9\n   |\n17 |     for &x in numbers\
    \ {\n   |         ^^    ------- this expression has type `Option<f64>`\n   | \
    \        |\n   |         expected `f64`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `x`\n   |\n   = note:   expected type\
    \ `f64`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976458
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let min: f64 = numbers.iter().min().unwrap();\n    let max:\
    \ f64 = numbers.iter().max().unwrap();\n    numbers.iter().map(|x| (x - min) /\
    \ (max - min)).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp69o91haz.rs:6:35\n\
    \     |\n6    |     let min: f64 = numbers.iter().min().unwrap();\n     |    \
    \                               ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmp69o91haz.rs:6:20\n  |\n6 |    \
    \ let min: f64 = numbers.iter().min().unwrap();\n  |              ---   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `f64`, found `&f64`\n  |              |\n  |              expected\
    \ due to this\n  |\nhelp: consider dereferencing the borrow\n  |\n6 |     let\
    \ min: f64 = *numbers.iter().min().unwrap();\n  |                    +\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp69o91haz.rs:7:35\n\
    \     |\n7    |     let max: f64 = numbers.iter().max().unwrap();\n     |    \
    \                               ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmp69o91haz.rs:7:20\n  |\n7 |    \
    \ let max: f64 = numbers.iter().max().unwrap();\n  |              ---   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `f64`, found `&f64`\n  |              |\n  |              expected\
    \ due to this\n  |\nhelp: consider dereferencing the borrow\n  |\n7 |     let\
    \ max: f64 = *numbers.iter().max().unwrap();\n  |                    +\n\nerror:"
  stdout: ''
  timestamp: 1659976458
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    if numbers.len() <= 1 {\n        return numbers;\n    }\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for i in 1..numbers.len()\
    \ {\n        if numbers[i] < min {\n            min = numbers[i];\n        }\n\
    \        if numbers[i] > max {\n            max = numbers[i];\n        }\n   \
    \ }\n    let mut range = (max - min) / numbers.len() as f64;\n    if range ==\
    \ 0 {\n        return numbers;\n    }\n    let mut scaled: Vec<f64> = numbers.iter().cloned().map(|x|\
    \ x - min).collect();\n    scaled.resize(numbers.len(), (range / numbers[0]) as\
    \ f64);\n    scaled\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvi26exgm.rs:20:17\n   |\n\
    20 |     if range == 0 {\n   |                 ^\n   |                 |\n   |\
    \                 expected `f64`, found integer\n   |                 help: use\
    \ a float literal: `0.0`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976458
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min_ind = numbers.iter().min().unwrap();\n    let\
    \ mut max_ind = numbers.iter().max().unwrap();\n\n    for ind in numbers.iter()\
    \ {\n        if ind < min_ind {\n            min_ind = ind;\n        }\n\n   \
    \     if ind > max_ind {\n            max_ind = ind;\n        }\n    }\n\n   \
    \ let mut scale: f64 = (max_ind - min_ind).powi(2) as f64;\n    for ind in numbers.iter()\
    \ {\n        *ind = (ind-min_ind)*scale;\n    }\n    numbers\n}\n\nfn main() {\n\
    \    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpal5s8lq2.rs:6:38\n\
    \     |\n6    |     let mut min_ind = numbers.iter().min().unwrap();\n     | \
    \                                     ^^^ the trait `Ord` is not implemented for\
    \ `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpal5s8lq2.rs:7:38\n\
    \     |\n7    |     let mut max_ind = numbers.iter().max().unwrap();\n     | \
    \                                     ^^^ the trait `Ord` is not implemented for\
    \ `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976458
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for (i, n) in numbers.iter().enumerate() {\n        if n < min {\n      \
    \      min = n;\n        } else if n > max {\n            max = n;\n        }\n\
    \    }\n    // The formula is min + min / (max - min) where max is max - min\n\
    \    // But we want the max to be 1\n    let scale = (max - min) / 2.0 + 1.0;\n\
    \    numbers.iter().map(|n| n * scale).collect()\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp2ggmaq_w.rs:9:16\n  |\n9 |\
    \         if n < min {\n  |                ^^^\n  |                |\n  |    \
    \            expected `&f64`, found `f64`\n  |                help: consider borrowing\
    \ here: `&min`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2ggmaq_w.rs:10:19\n\
    \   |\n6  |     let mut min = numbers[0];\n   |                   ---------- expected\
    \ due to this value\n...\n10 |             min = n;\n   |                   ^\
    \ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n10 |             min = *n;\n   |                   +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2ggmaq_w.rs:11:23\n   |\n11 |         } else if n > max\
    \ {\n   |                       ^^^\n   |                       |\n   |      \
    \                 expected `&f64`, found `f64`\n   |                       help:\
    \ consider borrowing here: `&max`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2ggmaq_w.rs:12:19\n\
    \   |\n7  |     let mut max = numbers[0];\n   |                   ---------- expected\
    \ due to this value\n...\n12 |             max = n;\n   |                   ^\
    \ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n12 |             max = *n;\n   |                   +\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976458
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let diff = max - min;\n    let mut new_numbers = Vec::with_capacity(numbers.len());\n\
    \    for number in numbers {\n        if number - min == diff {\n            new_numbers.push(0.0);\n\
    \        } else {\n            new_numbers.push(number / diff);\n        }\n \
    \   }\n    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp1af1oekc.rs:6:30\n\
    \     |\n6    |     let min = numbers.iter().min().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp1af1oekc.rs:7:30\n\
    \     |\n7    |     let max = numbers.iter().max().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976458
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    assert!(numbers.len() >= 2);\n    let min_element = numbers.iter().min().unwrap();\n\
    \    let max_element = numbers.iter().max().unwrap();\n\n    let mut result: Vec<f64>\
    \ = Vec::new();\n\n    for number in numbers {\n        let mut element: f64 =\
    \ number;\n        if element < min_element {\n            element = min_element;\n\
    \        } else if element > max_element {\n            element = max_element;\n\
    \        }\n        result.push(element);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpggghhgwg.rs:7:38\n\
    \     |\n7    |     let min_element = numbers.iter().min().unwrap();\n     | \
    \                                     ^^^ the trait `Ord` is not implemented for\
    \ `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpggghhgwg.rs:8:38\n\
    \     |\n8    |     let max_element = numbers.iter().max().unwrap();\n     | \
    \                                     ^^^ the trait `Ord` is not implemented for\
    \ `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpggghhgwg.rs:14:22\n   |\n14 |\
    \         if element < min_element {\n   |                      ^^^^^^^^^^^ expected\
    \ `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n14\
    \ |         if element < *min_element {\n   |                      +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpggghhgwg.rs:15:23\n   |\n13 |         let mut\
    \ element: f64 = number;\n   |                          --- expected due to this\
    \ type\n14 |         if element < min_element {\n15 |             element = min_element;\n\
    \   |                       ^^^^^^^^^^^ expected `f64`, found `&f64`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n15 |             element = *min_element;\n\
    \   |                       +\n\nerror[E0308]: mismatched types\n "
  stdout: ''
  timestamp: 1659976458
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let min_number = numbers.iter().min();\n    let max_number\
    \ = numbers.iter().max();\n    let mut rescaled_numbers = Vec::new();\n    for\
    \ number in numbers {\n        rescaled_numbers.push(number / max_number);\n \
    \   }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpxsg6jsiy.rs:6:37\n\
    \     |\n6    |     let min_number = numbers.iter().min();\n     |           \
    \                          ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpxsg6jsiy.rs:7:37\n\
    \     |\n7    |     let max_number = numbers.iter().max();\n     |           \
    \                          ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0277]: cannot divide `f64` by `Option<&f64>`\n  --> /tmp/tmpxsg6jsiy.rs:10:38\n\
    \   |\n10 |         rescaled_numbers.push(number / max_number);\n   |        \
    \                              ^ no implementation for `f64 / Option<&f64>`\n\
    \   |\n   = help: the trait `Div<Option<&f64>>` is not implemented for `f64`\n\
    \   = help: the following other types implement trait `Div<Rhs>`:\n          \
    \   <&'a f32 as Div<f32>>\n             <&'a f64 as Div<f64>>\n             <&'a\
    \ i128 as Div<i128>>\n             <&'a i16 as Div<i16>>\n             <&'a i32\
    \ as Div<i32>>\n             <&'a i64 as Div<i64>>\n             <&'a i8 as Div<i8>>\n\
    \             <&'a isize as Div<isize>>\n           and 54 others\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277"
  stdout: ''
  timestamp: 1659976458
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n\
    \    for x in numbers {\n        if x < min {\n            min = x;\n        }\n\
    \        if x > max {\n            max = x;\n        }\n    }\n    let mut rescaled\
    \ = vec![];\n    let mut factor = max - min;\n    for x in numbers {\n       \
    \ rescaled.push(x - min * factor);\n        factor = factor / 2.0;\n    }\n  \
    \  rescaled\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpfv10q83y.rs:18:14\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for x in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n18  |     for x in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n8   |     for x in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976458
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut smallest_number = numbers.iter().min().unwrap();\n\
    \    let mut largest_number = numbers.iter().max().unwrap();\n    let mut new_numbers\
    \ = vec![smallest_number];\n    let mut new_numbers_2 = vec![largest_number];\n\
    \n    for element in numbers.iter() {\n        let mut new_number = element;\n\
    \n        if element < smallest_number {\n            new_number = smallest_number;\n\
    \        } else if element > largest_number {\n            new_number = largest_number;\n\
    \        }\n\n        new_numbers.push(new_number);\n    }\n\n    new_numbers.sort_unstable();\n\
    \    new_numbers.reverse();\n    new_numbers_2.sort_unstable();\n    new_numbers_2.reverse();\n\
    \n    vec![new_numbers[0], new_numbers_2[0]]\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpusa67h_k.rs:6:46\n\
    \     |\n6    |     let mut smallest_number = numbers.iter().min().unwrap();\n\
    \     |                                              ^^^ the trait `Ord` is not\
    \ implemented for `f64`\n     |\n     = help: the following other types implement\
    \ trait `Ord`:\n               i128\n               i16\n               i32\n\
    \               i64\n               i8\n               isize\n               u128\n\
    \               u16\n             and 4 others\n     = note: required because\
    \ of the requirements on the impl of `Ord` for `&f64`\nnote: required by a bound\
    \ in `std::iter::Iterator::min`\n\nerror[E0277]: the trait bound `f64: Ord` is\
    \ not satisfied\n    --> /tmp/tmpusa67h_k.rs:7:45\n     |\n7    |     let mut\
    \ largest_number = numbers.iter().max().unwrap();\n     |                    \
    \                         ^^^ the trait `Ord` is not implemented for `f64`\n \
    \    |\n     = help: the following other types implement trait `Ord`:\n      \
    \         i128\n               i16\n               i32\n               i64\n \
    \              i8\n               isize\n               u128\n               u16\n\
    \             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpusa67h_k.rs:23:17\n\
    \     |\n23   |     new_numbers.sort_unstable();\n     |                 ^^^^^^^^^^^^^\
    \ the trait `Ord` is not implemented for `f64`\n     |\n     = help: the following\
    \ other types implement trait `Ord`:\n               i128\n               i16\n\
    \               i32\n               i64\n               i8\n               isize\n\
    \               u128\n               u16\n             and 4 others\n     = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\nnote:\
    \ required by a bound in `core::slice::<impl [T]>::sort_unstable`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpusa67h_k.rs:25:19\n\
    \     |\n25   |     new_"
  stdout: ''
  timestamp: 1659976458
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    numbers\n        .iter()\n        .map(|x| {\n          \
    \  if x == 0.0 {\n                0.0\n            } else {\n                1\
    \ / x\n            }\n        })\n        .collect()\n}\n\nfn main() {\n    let\
    \ candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0,\
    \ 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&f64` with `{float}`\n --> /tmp/tmpg1s3glln.rs:9:18\n\
    \  |\n9 |             if x == 0.0 {\n  |                  ^^ no implementation\
    \ for `&f64 == {float}`\n  |\n  = help: the trait `PartialEq<{float}>` is not\
    \ implemented for `&f64`\n  = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n            f32\n            f64\n            i128\n    \
    \        i16\n            i32\n            i64\n            i8\n            isize\n\
    \          and 6 others\n\nerror[E0277]: cannot divide `{integer}` by `&f64`\n\
    \  --> /tmp/tmpg1s3glln.rs:12:19\n   |\n12 |                 1 / x\n   |     \
    \              ^ no implementation for `{integer} / &f64`\n   |\n   = help: the\
    \ trait `Div<&f64>` is not implemented for `{integer}`\n   = help: the following\
    \ other types implement trait `Div<Rhs>`:\n             <&'a f32 as Div<f32>>\n\
    \             <&'a f64 as Div<f64>>\n             <&'a i128 as Div<i128>>\n  \
    \           <&'a i16 as Div<i16>>\n             <&'a i32 as Div<i32>>\n      \
    \       <&'a i64 as Div<i64>>\n             <&'a i8 as Div<i8>>\n            \
    \ <&'a isize as Div<isize>>\n           and 54 others\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976458
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min = numbers[0] as f64;\n    let mut max = numbers[0]\
    \ as f64;\n    for &num in numbers {\n        if min > num {\n            min\
    \ = num as f64;\n        }\n        if max < num {\n            max = num as f64;\n\
    \        }\n    }\n    let mut scale = 1.0 + 2.0 * (max - min);\n    if scale\
    \ > 1.0 {\n        scale = 1.0;\n    }\n    numbers.iter().map(|num| num / scale).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpu3jw2j52.rs:8:9\n  |\n8 |\
    \     for &num in numbers {\n  |         ^^^^    ------- this expression has type\
    \ `Option<f64>`\n  |         |\n  |         expected `f64`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `num`\n  |\n \
    \ = note:   expected type `f64`\n          found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976458
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut min: f64 = numbers.iter().min().unwrap();\n    let\
    \ mut max: f64 = numbers.iter().max().unwrap();\n\n    for i in 0..numbers.len()\
    \ {\n        let mut numerator = if i == 0 {\n            numbers[i]\n       \
    \ } else {\n            numbers[i] - min\n        };\n\n        let mut denominator\
    \ = max - min;\n\n        if numerator == 0.0 {\n            continue;\n     \
    \   }\n\n        numerator /= denominator;\n        numbers[i] = numerator;\n\
    \    }\n\n    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp9_4lfwuu.rs:6:39\n\
    \     |\n6    |     let mut min: f64 = numbers.iter().min().unwrap();\n     |\
    \                                       ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmp9_4lfwuu.rs:6:24\n  |\n6 |    \
    \ let mut min: f64 = numbers.iter().min().unwrap();\n  |                  ---\
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `f64`, found `&f64`\n  |          \
    \        |\n  |                  expected due to this\n  |\nhelp: consider dereferencing\
    \ the borrow\n  |\n6 |     let mut min: f64 = *numbers.iter().min().unwrap();\n\
    \  |                        +\n\nerror[E0277]: the trait bound `f64: Ord` is not\
    \ satisfied\n    --> /tmp/tmp9_4lfwuu.rs:7:39\n     |\n7    |     let mut max:\
    \ f64 = numbers.iter().max().unwrap();\n     |                               \
    \        ^^^ the trait `Ord` is not implemented for `f64`\n     |\n     = help:\
    \ the following other types implement trait `Ord`:\n               i128\n    \
    \           i16\n               i32\n               i64\n               i8\n \
    \              isize\n               u128\n               u16\n             and\
    \ 4 others\n     = note: required because of the requirements on the impl of `Ord`\
    \ for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp9_4lfwuu.rs:7:24\n  |\n7 |     let mut max: f64\
    \ = numbers.iter().max().unwrap();\n  |                  ---   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `f64`, found `&f64`\n  |                  |\n  |                  expected\
    \ due to this\n  |\nhelp: consider dereferencing the borrow\n  |\n7 |     let\
    \ mut max: f64 = *num"
  stdout: ''
  timestamp: 1659976458
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut sum = numbers.reduce((0.0 + 1.0) / 2.0, 0.0);\n \
    \   numbers.iter().for_each(|n| {\n        sum += (n - sum) * n / sum;\n    });\n\
    \    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `Vec<f64>` is not an iterator\n   --> /tmp/tmpndj998lk.rs:6:27\n\
    \    |\n6   |       let mut sum = numbers.reduce((0.0 + 1.0) / 2.0, 0.0);\n  \
    \  |                             ^^^^^^ `Vec<f64>` is not an iterator\n    |\n\
    \    = note: the following trait bounds were not satisfied:\n            `Vec<f64>:\
    \ Iterator`\n            which is required by `&mut Vec<f64>: Iterator`\n    \
    \        `[f64]: Iterator`\n            which is required by `&mut [f64]: Iterator`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976458
