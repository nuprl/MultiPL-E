name: HumanEval_45_triangle_area
language: rs
prompt: "/// Given length of a side and high return area for a triangle.\n/// >>>\
  \ triangle_area(5, 3)\n/// 7.5\nfn triangle_area(a: isize, h: isize) -> f64 {\n"
tests: "}\n\nfn main() {\n    let candidate = triangle_area;\n    assert_eq!(candidate(5,\
  \ 3), 7.5);\n    assert_eq!(candidate(2, 2), 2.0);\n    assert_eq!(candidate(10,\
  \ 8), 40.0);\n}\n"
completions: ["    let b = 2.0 * (3.0 * a as f64 / h as f64);\n    (a as f64 / b as\
    \ f64).sqrt()", '    a + h * 0.5', '    (a * h) / 2.0', "    let mut side_1: f64\
    \ = a + h;\n    let mut side_2: f64 = h;\n    let mut side_3: f64 = a + h;\n \
    \   if side_1 > side_2 && side_1 > side_3 {\n        side_1 = side_2;\n    }\n\
    \    if side_2 > side_3 {\n        side_2 = side_3;\n    }\n    side_1 + side_2\
    \ + side_3", '    (2.0 * (a + h) - (a - h)) / (a + h)', "    let area = std::f64::consts::PI\
    \ * a * h;\n    area", '    sqrt(a * a + h * h) * 0.5', '    (a / 2.0) * (h /
    2.0)', '    2. * ((a / h) * h) - (a / 2.) * ((a / h) * h)', "    let mut tri =\
    \ (0..a).collect::<Vec<_>>();\n    tri.push(h);\n    tri.push(-h);\n    let area\
    \ = tri\n        .iter()\n        .zip(tri.iter().skip(1))\n        .fold(0.0,\
    \ |area, (a, h)| area + ((-h) * (-a) / 2.0))\n        .abs();\n    area / 2.0",
  '    sqrt(pow((2 * a), 2.0) + pow((h * h), 2.0))', "    let mut area = 0.0;\n  \
    \  for _ in 0..a {\n        area += h;\n        h -= 1;\n    }\n    for _ in 0..h\
    \ {\n        area += a;\n        a -= 1;\n    }\n    area / 2.0", '    (a * h
    + b * h + c * h) / 2', '    ((h / 2) * a * a + (h / 2) * (a - 2) * a) / (6.0 *
    (a * a - h * a))', "    if a == 0 && h == 0 {\n        return 1.0;\n    }\n  \
    \  let mut s = 0.0;\n    for i in (0..a).rev() {\n        s += ((2.0 * i + 1.0)\
    \ / (2.0 * a + h + 2.0 * i)) * (1.0 / h);\n    }\n    s", '    (0.25 * a + 0.25
    * b) * (b + h + a)', "  use std::sqrt::{sqrt};\n  sqrt((a * a) + (h * a * (h +\
    \ 1)))", '    (0..(h - 1)).fold(0.0, |sum, index| sum + ((a / 2.0) * (1.0 - (index
    % 2))))', '    (a * (a + h) * 2.0) / (a + h)', "    let mut area = 0.0;\n    for\
    \ i in 0..a {\n        for j in 0..a {\n            area += (i * i + j * j) *\
    \ (i + j + h);\n        }\n    }\n    area / 4.", '    sqrt(3.0 * a * h / 4.0
    - 2.0 * a * a / 4.0 + 1.0 * a)', '    (a + h) * 0.5', '    (a * h) / 2', '  (a
    * a * h) / 2.0', '    (a ** 2) * h / (a + h)', '    (2.0 * a * h) / (a + h)',
  '    (a * h) / (2.0 * a * h)', '    (a * h).powi(2) * 0.5', '    4.0 - ((2.0 * a
    + h) * 4.0) / 6.0', "    // triangle area = (side * side * base) / 2\n    let\
    \ area = (a * a * h) / 2;\n    area", "    let mut area: f64 = 0.0;\n    for i\
    \ in 0..h {\n        for j in 0..i {\n            if i != j {\n              \
    \  area += f64::sqrt(i.mul(i) + j.mul(j));\n            }\n        }\n    }\n\
    \    area / 2.0", "    (0..a).map(|x| {\n        (0..h).map(|y| (x / (x + y)))\n\
    \    }).sum()", '    a * h / 2.', '  (-a / h).sin().cos()', "    // https://stackoverflow.com/questions/3961850/calculate-the-area-of-a-triangle-given-its-legnth-and-the-height\n\
    \    (a + h) * h / 2", "    let mut area = 0.0; \n    let mut s = 0.0; \n    for\
    \ i in 0..(h - a) {\n        let j = ia + a + 1;\n        area = area + (h / j)\
    \ * (i / j);\n        s += h / j;\n    }\n    area / s", "    let r = a * h;\n\
    \    if a == 0 {\n        return 0.0;\n    }\n    if r > 0.0 {\n        return\
    \ a * r * r / 2.0;\n    } else {\n        return 0.0;\n    }", '    (a * a + h
    * h) as f64 / 2', '    a / 2 * (h + a) - (a / 2 + h) * (a / 2 - h) + h', "   \
    \ let b = (h * h) / 2.0;\n    let c = (h * h) / 2.0 - b;\n    (-b + c) as f64",
  "    let area_side = 4.0 / (h * h);\n    a * area_side", '    2.0 * a * h', '    (a
    * b) / 2.0', '  (h * a) / 2', '    (a ** 2) * std::pow((h - a), 2)', '    (a *
    h) / (4.0 * 3.14 * a)', '    (f64::from(a) * f64::from(h)) / ((2.0 * f64::from(a))
    * (f64::from(h)))', "    let mut area = 0.0f;\n    for x in (-a + h) / (a - 1)\
    \ {\n        let y = x - a / (a - 1);\n        area += x * y;\n    }\n    area",
  "    if a < 3 {\n        return 0.0;\n    }\n\n    let area = a * (h / 2.0);\n\n\
    \    if area > Double::infinity() {\n        return area as f64;\n    }\n\n  \
    \  return sqrt(area - 2 * f64::from(&area));", '    (a * (a + 1) * (h + h + 3))
    / 6.', "    let mut area = 0.0;\n    for y in 0..a {\n        area += y\n    \
    \        .iter()\n            .fold(0.0, |x, y| x + y) / h;\n    }\n    area",
  "    if a == 0 || h == 0 {\n        return 0.0;\n    }\n    let s = (a * (a + 1)\
    \ * (h - 1)) / (4.0 * (h + h + 2.0 * a - a));\n    2.0 * s / 3.0", '    6.0 /
    (a + h)', "    let area = (a*(a+h) - a*h)/(2.0*h);\n    area", "    // Calculate\
    \ area of triangle defined by side and height\n    let mut area = 0.0;\n    for\
    \ i in 0..a {\n        let mut x = 0.0;\n        let mut y = 0.0;\n        let\
    \ mut z = 0.0;\n        for j in 0..h {\n            x += j;\n            y +=\
    \ i;\n            z += j;\n        }\n        area = area + z * (z + 1.0);\n \
    \   }\n    area", '    (sqrt(3) * (a + b - a * b) / 2) / (sqrt(3 * b * b + a -
    a * a + h))', '    (a * h) / 2.0', "    (a*a + h*h) / (2.0 * std::pow(a, 2.0))\
    \ - (h * h) / (2.0 * std::pow(a+h, 2.0)) -\n        (a*a + h*h) / (2.0 * std::pow(a,\
    \ 2.0))", '    (a * (a + h) - h * h) / 2.', '    (a * a + h * h) / 2.', '    (a
    + h) / (2.0 * a)', "    if h == 0 {\n        return 0;\n    }\n    return a *\
    \ (a + h) * h / 2;", '    (a * h) / (a + h)', '    (a / 2) * (h / 2)', '    (a
    * a + h * a) * (a + a + h - a)', '    3.0 / (3.0 * 3.0 - 2.0 * 2.0 * a * b + h
    * a * h)', "    let mut ret = 0.0\n    for i in 0..a {\n        ret += ((i * (i\
    \ as f64)) / 2.0) * ((i as f64) + (h - i) * ((i as f64) - h))\n    }\n    ret",
  '    (h * h) / (a * a)', '    (2.0 * a * (h + 1.0)).sqrt()', '    (a * (a + h) -
    (a * h)) / (a * 2)', "    let mut area = 0.;\n    for _ in 0..a {\n        for\
    \ _ in 0..h {\n            area += 1.;\n        }\n    }\n    area", '    (2.0
    * (a * h) - a * h) / 2.0', '    math.sqrt(3. * 3. * (-a * a + h * b + h * c).sqrt())',
  "    (0..(a+h)).map(|x| {\n        x / h\n    }).product()", '    (a * (h + h))',
  "    let b = a + h;\n    let area = b * b - a * a;\n    area / (2 * b)", '    4.0
    * a.powi(2.0) + h * a.powi(2.0).sqrt()', '    (a * a) / 2 + h / 2', "    let d\
    \ = a*a + b*b + c*c - h*h;\n    if d < 0.0 {\n        return 0.0;\n    }\n   \
    \ d / 2.0 as f64", '    (a * h) / (a + h)', "    let mut a = a as f64;\n    let\
    \ mut h = h as f64;\n    if h > 0.0 {\n        a = a * h;\n        h = h / 2.0;\n\
    \    }\n    let s = (a * a) + (h * a);\n    if s > 0.0 {\n        s / 2.0;\n \
    \   }\n    a", "    // Based on https://en.wikipedia.org/wiki/Equilateral_triangle#Equilateral_triangle\n\
    \    // https://stackoverflow.com/questions/27982713/equilateral-triangle-with-an-equilateral-side-equal-to-a-triangle-side\n\
    \    (a + h) * ((a + h + 1) / 2 - a * a * h / (a + h))", "    // Area of a triangle\
    \ is: \u221A((\u221A(4 \xD7 b^2)\u2212\u221A(a \xD7 c))^2 \xD7 h)\n    let b =\
    \ a*a - (h*h)/2;\n    let c = a*h + (b*h)/2;\n    (sqrt(a * a + b * b) - (sqrt(c\
    \ * c + a * a))).sqrt()", "    let mut r = 0.;\n    for i in 1..h {\n        r\
    \ += a / (i * i);\n    }\n    r", '    (a / 2) / h', '    sqrt(2.0 * h * a) *
    atan2(a, h)', '    (a * b) / 2.0', "    let x = 2.0 * h as f64 / 4.0;\n    let\
    \ y = 2.0 * a as f64 / 4.0;\n    (x * x - y * y) as f64", '    (a * h) / 4.0',
  '    (a * h) / 2.0', '    (3.0 * a + 4.0 * h).sqrt()', '    a * h / 4.0 - b * h
    / 2.0 + b * h / 3.0 * c', "    ((b - a) * (b - h))\n        / ((a + b) * (a +\
    \ h))\n        / ((a + b) * (a - h))", '    0.5 * ::std::sqrt(::std::pow(a, 2.0)
    + ::std::pow((h / 3), 2.0))', "    if a < 3 {\n        return 0.0;\n    }\n\n\
    \    let mut tri = (0.0, 0.0);\n\n    fn area_helper(a: isize, b: isize, c: isize)\
    \ -> f64 {\n        if a == 0 || b == 0 || c == 0 {\n            return 0.0;\n\
    \        }\n        let mut s = (a + b + c) * 0.5;\n        let mut tri = (0.0,\
    \ 0.0);\n        let mut t = 0.0;\n        loop {\n            t = 0.5 * (s -\
    \ a);\n            s = t;\n            if s == 0.0 {\n                break;\n\
    \            }\n            t -= 1.0 / s;\n            let mut tri = (1.0 - t,\
    \ t);\n        }\n        tri as f64\n    }\n\n    let mut b = a * 0.5;\n    let\
    \ mut c = b * 0.5;\n\n    while b < h && c < h {\n        b += 1;\n        c +=\
    \ 1;\n    }\n\n    area_helper(a, c, b)", '    (0..(a+h) - 1).collect::<Vec<_>>().iter().fold(1.0,
    |sum, index| sum + 1 / a * index * a)', "    let mut area: f64 = 1.0;\n    for\
    \ i in 0..a-1 {\n        let area = (-h)*(2.0*i + 1.0);\n        area = area *\
    \ area / (2.0 * i + 1.0);\n        area = (area + 4.0) as f64;\n        area =\
    \ area / i as f64;\n        area = (area + h) as f64;\n        area = area / (i\
    \ + 1.0) as f64;\n        area = (area / 2.0) as f64;\n    }\n    area", "   \
    \ if a > h {\n        return 0.0;\n    }\n\n    let mut area: f64;\n\n    for\
    \ n in 0..a {\n        area += (1 / 3) * f64::from(n - h) * (1 - (n / a));\n \
    \   }\n\n    area", '    (6. * a + h) * 0.5', '    (2 * h + f64::pow(a, 2) / 2.0
    - h) / a', '    (a * (h / 2)) / (1 + ((a * a - 1) * (h / 2)))', "    let s = 2.0\
    \ * 3.0 * a * h;\n    (s / 6.0).sqrt()", '    (1 / 2) * a.powi(2) * h', "    (2.0\
    \ * a.powi(2.0) - h.powi(2.0))\n        .powi(0.5)\n        .powi(0.5)", '    (a
    * a * (a * h + h * (-a + 3)).sqrt()).floor() / 4', "    let mut a = a / 2;\n \
    \   let mut h = h / 2;\n\n    if h < a {\n        a = h;\n    }\n\n    if a >\
    \ h {\n        h = a;\n    }\n\n    (h - a) * (h + a) / 2", '    (a * h) / 2',
  '    (a * (a + 1)) / 2 + h * h', "    let mut sum = 0.0f;\n    for i in 0..a {\n\
    \        for j in 0..a {\n            if i != j && i < h {\n                let\
    \ x1 = i;\n                let x2 = j;\n                let y1 = x1;\n       \
    \         let y2 = x2;\n                sum += (x1 * y2 - x2 * y1);\n        \
    \    }\n        }\n    }\n    sum / 3.0", "    1.\n        .powf((3 * a * h) /\
    \ ((2. * a * a + h) * (2. * a + h))) * (((2. * a * a + h) * (h + 2. * a))\n  \
    \      .powf(1./(2. * a + h)))\n        .powf((h + 2. * a))\n        .powf(1./a)",
  '    (h * h * a - h * a + a * h) * (h * a * h + h * a) / ((h * a * a) - (h * a)
    + a * h)', '    a / 2.0 * h', "    let mut area = 0.0\n    for i in 0..(a / 2\
    \ + 1) {\n        area += h * (1.0 - i / a);\n    }\n    for i in 0..(a / 2) {\n\
    \        area += (i + 1) * h;\n    }\n    for i in 0..(a / 2 + 1) {\n        area\
    \ -= i * (i + 1) / 2;\n    }\n    area / 2", '    4.0 + (a * (6.0 * a + 5.0) *
    h) / (6.0 * 3.0)', '    (2.0 * M_PI * a * h) / (M_PI * h * a)', '    (a * a +
    h * h) / (4.0 * a * h)', '    (a * a + h * h) / 4.0', '    sqrt(2.0 * h * h /
    a)', '    (a * h) / 2', '    2.0 * a.powi(1.0 / 3.0) - h * (a.powi(3.0 / 2.0)
    - a.powi(1.0 / 3.0))', '    (a * h) - (a * w * h)', "    let mut area = 0.0;\n\
    \    for i in 0..a {\n        let p = i / a;\n        let s = (i + h) / (a + 1.0);\n\
    \        let h = s - (a + 1.0);\n        area += p * h * h;\n    }\n    area",
  "    let mut area = 0.;\n    let mut s = 0.;\n    for i in 0..a {\n        for j\
    \ in 0..a{\n            if i == j{\n                area += 1.;\n            \
    \    continue;\n            }\n            let height = sqrt(i * i + j * j);\n\
    \            let area = h * height;\n            area += area;\n            s\
    \ += 1.;\n        }\n    }\n    area / s", '    (a * a * h) / (b::square(a) +
    h::square(h))', '    (a * (a + b) / 2.0) * (h / 2.0)', '    4.0 * f64::sin(1.0
    * h / a)', '    (h * h) - ((a - a + a) * a * (a + 1) / (h + a + 1))', "    let\
    \ mut c = 0.0 * (f64::consts::PI * 2.0) / 360.0; // Pi*2/360\n    for _ in 0..(a\
    \ / h) {\n        c = c + f64::consts::PI / 2.0; // Pi/2 = Pi/360\n    }\n   \
    \ c", '    (2.0 * 3.0 * a * h) / 4.0', '    (2.0 * pow::<f64, 2>(4.0 * a * a)
    + (2.0 * h * a) + (2.0 * pow::<f64, 2>(4.0 * h * h))) / (4.0 * a * a)', '    2.
    * (a + h) * (a + a + h + h) / 2.', '    sqrt((f64::pow(a, 2) - f64::pow((h / 2.0),
    2)).as_f64())', '    (4.0 / (6.0 * 3.0)) * std::pow(3.0, h) * std::pow(a, 3 -
    h) - std::pow(a, 3)', '    (4.0 - (3.0 * a + 6.0 * b + 2.0 * c) / 6.0).sqrt()',
  '    (a * h) / (4.0 * 3.0)', '    (2.0 * a.pow(2.0) - h).sqrt()', '    (a * b) /
    2.0', "    let _a: f64 = a.powi(2);\n    let _b: f64 = b.powi(2);\n    let _c:\
    \ f64 = c.powi(2);\n    let _d: f64 = d.powi(2);\n    let _x: f64 = a.powi(2);\n\
    \    let _y: f64 = h.powi(2);\n    let _z: f64 = d.powi(2);\n\n    (_a + _b +\
    \ _c + _d) / (_x + _y + _z)", '    (0.5 * (b - a) * (b + a + h)) / (b + a + h)',
  '    (a * h) / (a + h)', "    let mut area = 0.;\n    for y in 0..a {\n        for\
    \ x in 0..h {\n            area += (*(x + y) as f64) ** (3./2.);\n        }\n\
    \    }\n    area / (2. * a * h) as f64", '    (a*a) / 2.0', "    // https://en.wikipedia.org/wiki/Triangle_area\n\
    \    // https://en.wikipedia.org/wiki/Dihedral_group\n    match a {\n        1\
    \ => 1.0,\n        2 => a ** 2.0 / (2.0 * a + 1.0),\n        3 => a ** 3.0 / (3.0\
    \ * a + 2.0),\n        4 => a ** 4.0 / (4.0 * a + 3.0),\n        5 => a ** 5.0\
    \ / (5.0 * a + 4.0),\n        6 => a ** 6.0 / (6.0 * a + 5.0),\n        _ => 0.0\n\
    \    }\n    + (h * h * a - 6.0 * a * a + 6.0 * a * (a - (a + 1.0))) / 6.0", " \
    \   // https://en.wikipedia.org/wiki/Straight_triangle#Using_Pythagorean_theorem\n\
    \    let b = a * h;\n    let c = a * a + b * h;\n    c as f64 / b as f64", " \
    \   if a + h >= 3 {\n        let b = a + h - 1;\n        (a + b) * (b - a) * (b\
    \ - a + 1) * (b - a) / 2\n    } else {\n        (a + h) * (a + h - 1) * (a + h\
    \ - 2)\n    }", '    3.0 / 4.0 * (h / a).sqrt()', '    a / h', '    (4.0 - (2.0
    * a * h)) / (2.0 * h) ', '    (a * h) / (a + h)', '    a / 2.0 * h', "    let\
    \ mut s = 0.0; \n    for _i in 0..a {\n        for _j in 0..h {\n            s\
    \ += f64::from(4.0) + f64::from(4.0) * (f64::from(2.0) - f64::from(3.0));\n  \
    \      }\n    }\n    s * 0.5 * f64::from(3.0)", '    3. * a / (h * h)', '    a
    / 2.0 * h', '    (a * a) / (h * h)', '    0.5 * std::pow(a * h / 2, 2)', '    (a
    * a + h * h) / 2.0', "    // Formula from: http://www.geeksforgeeks.org/given-formula-for-area-of-a-triangle/\n\
    \    let d = ((3.0 / 2.0) * (a + b)) - ((3.0 / 2.0) * (a + h));\n    (d - (2.0\
    \ * a * b)) / 3.0", '    (a * a) * ((a - 2) * h + h * (a - 3))', '    0.5 * (a
    + b + c) * (a + b + h) - a * b * c', "    let side = 2.0 * a * a;\n    let area\
    \ = side * h;\n    area / ((3.0 - 2.0 * a) * (h))", '    (sqrt(5) + a) * h / (sqrt(5)
    + a)', "    let mut tri_area = 0.0;\n    if a < h {\n        for _ in 0..a {\n\
    \            tri_area += 1.0;\n        }\n        tri_area /= a;\n    } else {\n\
    \        for _ in 0..(h - a) {\n            tri_area += 1.0;\n        }\n    \
    \    tri_area /= h;\n    }\n    return tri_area;", "    let mut s = 0.;\n    for\
    \ i in (0..a).rev() {\n        if i <= h {\n            s += 1.;\n        }\n\
    \        else {\n            s -= 1.;\n        }\n    }\n    s * 2.", "    let\
    \ mut total = f64::MIN;\n    for _ in 0..a {\n        total += 1.0 * h;\n    \
    \    h += 1.0 * h;\n    }\n    total", '    (a + h) * 0.5', '    (2.0 * h - a
    * 6.0) / (6.0 * a)', "    if a == 0 || h == 0 {\n        return 0.0;\n    }\n\
    \    if a == 1 {\n        return h;\n    }\n    if h == 1 {\n        return a;\n\
    \    }\n    let mut s = 0.0;\n    let mut t = 0.0;\n    let mut z = 0.0;\n   \
    \ let mut w = 0.0;\n    let mut n = 0.0;\n    let mut m = 0.0;\n    let mut l\
    \ = 0.0;\n    let mut h = 1.0;\n    while h > 0.1 {\n        m = (a * z) / h;\n\
    \        s = s + m;\n        t = t + m;\n        n = n + 1;\n        z = ((w +\
    \ m) * z) / h;\n        w = w + h;\n        h = l / n;\n        l = t;\n    }\n\
    \    if l == 0.0 {\n        return 0.0;\n    }\n    return s / l;", '    2.0 *
    std::f64::consts::PI * a * a * h / (a * std::f64::consts::PI * h)', "    // https://stackoverflow.com/questions/49986276/how-to-calculate-the-area-of-a-triangle\n\
    \    // https://math.stackexchange.com/questions/796193/find-the-area-of-a-triangle-given-height-and-base\n\
    \    // https://math.stackexchange.com/questions/117949/find-the-area-of-a-triangle-given-sides-and-height\n\
    \    let area = a * h / 2;\n    area", '    (a * h) / 2', '    (a as f64 + h as
    f64)/2 as f64', '    (a*a + h*h) * (a*a - h*h) / 2.0', "    // https://en.wikipedia.org/wiki/Side_%28shape%29\n\
    \    const L: f64 = 0.0;\n    const H: f64 = 1.0;\n\n    // Area of a triangle\
    \ with side of length L and height H\n    let area = 4.0 * L * H;\n\n    if a\
    \ == h {\n        return area;\n    } else if h > a {\n        return a * triangle_area(a\
    \ - h, h) * H;\n    } else {\n        return triangle_area(a, a - h) * L;\n  \
    \  }", "    let (sqrt_of_a, sqrt_of_h) = (a*a + h*h).sqrt();\n    (sqrt_of_a *\
    \ sqrt_of_h).sqrt()", '    (a / 2) * h', '    (2.0 * sqrt(3.0) / 3.0 * a * a *
    (h + h + h)) as f64', '    (2.0 * sqrt(3.0) * a * a) - (((2.0 * h * h) / 2.0)
    * a)', "    let area = a * (b - h) * (c - h);\n    if area < 0.f64 {\n       \
    \ 0.0\n    } else {\n        (area / (a + b + c))\n    }", "    let area_sq =\
    \ a * a;\n    let area_cu = a * h * h;\n    let area_ncu = area_sq - area_cu;\n\
    \n    area_ncu.sqrt()", '    (a * a) + (h * a * h)', '    (a * (a + h) / 2.0).sqrt()',
  "    let mut area: f64 = 0.0;\n    for i in 0..a {\n        for j in 0..a {\n  \
    \          if j == i {\n                continue;\n            }\n           \
    \ area += ((i - 1) * h) + (j * h);\n        }\n    }\n    area", '    2.0 * ((a
    / h) as f64) + (a / 2.0)', '    4.0 * a * ((1.0 / 3.0) - sqrt(2.0 * (1.0 / 3.0)
    * (1.0 / 3.0))) + (3.0 * h) / 6.0', '    (a + (a + h) / 2.0) * (h / 2.0) - h *
    h / 2.0', '    (a + h) * (a + b) * (b + c)', '    a / h', "    let mut area =\
    \ 0.0;\n    for i in 0..(a + h) {\n        area += 4.0 / (i + 1.0);\n    }\n \
    \   area", "    let mut a: f64 = 1.0;\n    let mut b: f64 = 1.0;\n    let mut\
    \ c: f64 = 1.0;\n    let mut area: f64 = 0.0;\n    for i in 0..2 {\n        let\
    \ h = 2.0 * i as f64 + h as f64;\n        let a = 2.0 * i as f64 + a as f64;\n\
    \        let b = 2.0 * i + b as f64;\n        let c = 2.0 * i + c as f64;\n  \
    \      area = (a * b + c) as f64 * h;\n        if area < 0.0 {\n            area\
    \ = 0.0;\n        }\n        a = area;\n        b = c;\n        c = 0.0;\n   \
    \ }\n    area", "    if a + h > 4 {\n        let side = a + h as f64;\n      \
    \  let area = side * side * 2.0;\n        area.sqrt()\n    } else {\n        0\n\
    \    }", "    let mut area = 0.0;\n    let n = 3 * a + h;\n    for x in 0..(n\
    \ - 1) {\n        area += (x - a) * (x - n) * (n - x);\n    }\n    area / 6.0",
  '    (a * a + h * h) * 0.5', '    a * h / 4', '    (-a / h)', "    use std::f64::consts::PI;\n\
    \    use std::f64::consts::TAU;\n    use std::f64::consts::NAN;\n    use std::f64::consts::EPSILON;\n\
    \n    let mut r = 0.;\n\n    if a > h {\n        a = h;\n    }\n\n    // Sweep\
    \ line from top-left (angle 0 to 2pi) until we exceed the length of the\n    //\
    \ side of the triangle.\n    for _ in 0..a {\n        r += 1.;\n    }\n    for\
    \ _ in 0..a {\n        r -= 1.;\n    }\n\n    // Find the hypotenuse of the triangle\
    \ (sqrt(3) / 2).\n    // Since we know the side is positive, we can use a simple\
    \ addition without\n    // worrying about the square root.\n    let d = a + 2.\
    \ * r + 2. * r * r;\n\n    if d < 1. {\n        // If the hypotenuse is equal\
    \ to or greater than 1, the triangle is actually\n        // a square.\n     \
    \   return ((r + r) * r / d).sqrt();\n    }\n    else {\n        // If the hypotenuse\
    \ is less than 1, the triangle is an equilateral triangle.\n        return ((r\
    \ * r - a) * TAU / d).sqrt();\n    }", '    2.0 * (a * h / 3) - (a * a + h * h)
    / 2', '    4.0 * (a * (a * a + h * h) - (a * a + h) * h)', '    (a * h) / (a +
    h) as f64', '    2.0 * std::f64::consts::PI * a * (h / a)', '    (a*a + h*h) *
    (a*a + h*h - a*h)/2']
stop_tokens:
- "\n}"
