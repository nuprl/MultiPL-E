language: rs
name: HumanEval_135_can_arrange
results:
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut max = arr[0];\n    let mut min_val = arr[0];\n\n   \
    \ for &i in arr {\n        if i > max {\n            max = i;\n        }\n   \
    \     if i < min_val {\n            min_val = i;\n        }\n    }\n\n    if min\
    \ >= max {\n        return -1;\n    }\n    return max;\n}\n\nfn main() {\n   \
    \ let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]),\
    \ 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `min` in this scope\n  --> /tmp/tmp9usfgnhe.rs:23:8\n\
    \   |\n23 |     if min >= max {\n   |        ^^^\n...\n29 | fn main() {\n   |\
    \ --------- similarly named function `main` defined here\n   |\nhelp: a function\
    \ with a similar name exists\n   |\n23 |     if main >= max {\n   |        ~~~~\n\
    help: consider importing this function\n   |\n1  | use std::cmp::min;\n   |\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp9usfgnhe.rs:14:9\n   |\n14 |   \
    \  for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut max = -1;\n    for i in arr {\n        if i > (max +\
    \ 1) {\n            max = i;\n        }\n    }\n    max\n}\n\nfn main() {\n  \
    \  let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]),\
    \ 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpiz35gycz.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut max = -1;\n    for i in arr {\n        if i > max {\n\
    \            max = i;\n        }\n    }\n    max\n}\n\nfn main() {\n    let candidate\
    \ = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `3`', /tmp/tmp0hsv_pws.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut cur = 0;\n    let mut prev: isize = 0;\n\n    for i\
    \ in arr.iter() {\n        if *i > *prev {\n            cur = i;\n        }\n\
    \        prev = *i;\n    }\n    cur\n}\n\nfn main() {\n    let candidate = can_arrange;\n\
    \    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmp1ibruc1p.rs:15:17\n\
    \   |\n15 |         if *i > *prev {\n   |                 ^^^^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp1ibruc1p.rs:16:19\n   |\n11 |     let mut cur\
    \ = 0;\n   |                   - expected due to this value\n...\n16 |       \
    \      cur = i;\n   |                   ^ expected integer, found `&isize`\n \
    \  |\nhelp: consider dereferencing the borrow\n   |\n16 |             cur = *i;\n\
    \   |                   +\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0614.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter().position(|&x| x <= arr.iter().position(|&y| y > x)).unwrap()\n\
    }\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvh9xw_2z.rs:11:35\n   |\n\
    11 |     arr.iter().position(|&x| x <= arr.iter().position(|&y| y > x)).unwrap()\n\
    \   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<usize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpvh9xw_2z.rs:11:5\n   |\n10 | fn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n   |                                    ----- expected `isize` because of\
    \ return type\n11 |     arr.iter().position(|&x| x <= arr.iter().position(|&y|\
    \ y > x)).unwrap()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n11 |     arr.iter().position(|&x|\
    \ x <= arr.iter().position(|&y| y > x)).unwrap().try_into().unwrap()\n   |   \
    \                                                                         ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    if arr.len() <= 2 {\n        return -1;\n    }\n    let mut\
    \ index = 0;\n    let mut min_value = arr[0];\n    let mut max_value = arr[0];\n\
    \    for &i in arr {\n        if i > max_value {\n            max_value = i;\n\
    \        }\n        if i < min_value {\n            min_value = i;\n        }\n\
    \        if i == min_value {\n            index = i;\n        }\n    }\n    index\n\
    }\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7r1asagj.rs:17:9\n   |\n\
    17 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut res = -1;\n    let mut pos = 0;\n\n    while pos < arr.len()\
    \ - 1 {\n        match arr[pos] {\n            x if x < arr[pos + 1] && res ==\
    \ -1 => {\n                res = pos + 1;\n            }\n            x if res\
    \ != -1 && x < arr[pos] => {\n                res = pos;\n            }\n    \
    \        _ => {\n                pos = pos + 1;\n            }\n        }\n  \
    \  }\n\n    res\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmprx5sf8nc.rs:11:19\n\
    \   |\n11 |     let mut res = -1;\n   |                   ^^ the trait `Neg` is\
    \ not implemented for `usize`\n   |\n   = help: the following other types implement\
    \ trait `Neg`:\n             &f32\n             &f64\n             &i128\n   \
    \          &i16\n             &i32\n             &i64\n             &i8\n    \
    \         &isize\n           and 8 others\n\nerror[E0277]: the trait bound `usize:\
    \ Neg` is not satisfied\n  --> /tmp/tmprx5sf8nc.rs:16:45\n   |\n16 |         \
    \    x if x < arr[pos + 1] && res == -1 => {\n   |                           \
    \                  ^^ the trait `Neg` is not implemented for `usize`\n   |\n \
    \  = help: the following other types implement trait `Neg`:\n             &f32\n\
    \             &f64\n             &i128\n             &i16\n             &i32\n\
    \             &i64\n             &i8\n             &isize\n           and 8 others\n\
    \nerror[E0600]: cannot apply unary operator `-` to type `usize`\n  --> /tmp/tmprx5sf8nc.rs:19:25\n\
    \   |\n19 |             x if res != -1 && x < arr[pos] => {\n   |            \
    \             ^^\n   |                         |\n   |                       \
    \  cannot apply unary operator `-`\n   |                         help: you may\
    \ have meant the maximum value of `usize`: `usize::MAX`\n   |\n   = note: unsigned\
    \ values cannot be negated\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprx5sf8nc.rs:28:5\n\
    \   |\n10 | fn can_arrange(arr: Vec<isize>) -> isize {\n   |                 \
    \                   ----- expected `isize` because of return type\n...\n28 | \
    \    res\n   |     ^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    28 |     res.try_into().unwrap()\n   |        ++++++++++++++++++++\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0600.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut max = -1;\n    let mut current_index = -1;\n    for\
    \ i in arr.iter() {\n        if *i > max {\n            max = *i;\n          \
    \  current_index = i;\n        }\n    }\n    current_index\n}\n\nfn main() {\n\
    \    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]),\
    \ 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfcng0qlj.rs:16:29\n   |\n\
    12 |     let mut current_index = -1;\n   |                             -- expected\
    \ due to this value\n...\n16 |             current_index = i;\n   |          \
    \                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n16 |             current_index = *i;\n   |               \
    \              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut i = 1; // Start at 1, so we can start at 0.\n    let\
    \ mut max = i;\n    while i <= arr.len() {\n        if arr[i] <= arr[max] {\n\
    \            max = i;\n        }\n        i += 1;\n    }\n    max\n}\n\nfn main()\
    \ {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4,\
    \ 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpse4vt6eg.rs:19:5\n   |\n\
    10 | fn can_arrange(arr: Vec<isize>) -> isize {\n   |                        \
    \            ----- expected `isize` because of return type\n...\n19 |     max\n\
    \   |     ^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize`\
    \ to an `isize` and panic if the converted value doesn't fit\n   |\n19 |     max.try_into().unwrap()\n\
    \   |        ++++++++++++++++++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut max: isize = 0;\n    let mut max2: isize = -1;\n   \
    \ let mut i = 0;\n    while i < arr.len() {\n        if arr[i] > arr[i + 1] {\n\
    \            max = i;\n            max2 = i;\n        }\n        i += 1;\n   \
    \ }\n    if max2 > -1 {\n        max2\n    } else {\n        max\n    }\n}\n\n\
    fn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpm387sco5.rs:16:19\n   |\n\
    11 |     let mut max: isize = 0;\n   |                  ----- expected due to\
    \ this type\n...\n16 |             max = i;\n   |                   ^ expected\
    \ `isize`, found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpm387sco5.rs:17:20\n\
    \   |\n12 |     let mut max2: isize = -1;\n   |                   ----- expected\
    \ due to this type\n...\n17 |             max2 = i;\n   |                    ^\
    \ expected `isize`, found `usize`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut idx = 0;\n    for val in arr.iter().rev() {\n      \
    \  if idx > 0 {\n            if val > arr[idx] {\n                break;\n   \
    \         }\n        } else {\n            idx = val + 1;\n        }\n    }\n\
    \    idx\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_du8w84m.rs:14:22\n   |\n\
    14 |             if val > arr[idx] {\n   |                      ^^^^^^^^\n   |\
    \                      |\n   |                      expected `&isize`, found `isize`\n\
    \   |                      help: consider borrowing here: `&arr[idx]`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_du8w84m.rs:18:19\n   |\n11 |     let mut idx\
    \ = 0;\n   |                   - expected due to this value\n...\n18 |       \
    \      idx = val + 1;\n   |                   ^^^^^^^ expected `usize`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_du8w84m.rs:21:5\n\
    \   |\n10 | fn can_arrange(arr: Vec<isize>) -> isize {\n   |                 \
    \                   ----- expected `isize` because of return type\n...\n21 | \
    \    idx\n   |     ^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    21 |     idx.try_into().unwrap()\n   |        ++++++++++++++++++++\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut i = 0;\n    let mut res = isize::MAX;\n    let mut max\
    \ = arr.len();\n    let mut min = arr.len();\n    let mut cur = &arr[0];\n   \
    \ for el in arr.iter().rev() {\n        max = el;\n        if max < i {\n    \
    \        max = i;\n        }\n        min = el;\n        if min > i {\n      \
    \      min = i;\n        }\n        if max < min {\n            max = min;\n \
    \       }\n        if el > max {\n            break;\n        }\n        cur =\
    \ &arr[i - 1];\n        res = match el {\n            i if i == cur => i - 1,\n\
    \            i if i == i - 1 => -1,\n            i if i == i - 2 => 0,\n     \
    \       i => i + 1,\n        };\n        i += 1;\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4,\
    \ 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpaorud054.rs:17:15\n   |\n\
    13 |     let mut max = arr.len();\n   |                   --------- expected due\
    \ to this value\n...\n17 |         max = el;\n   |               ^^ expected `usize`,\
    \ found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpaorud054.rs:21:15\n\
    \   |\n14 |     let mut min = arr.len();\n   |                   --------- expected\
    \ due to this value\n...\n21 |         min = el;\n   |               ^^ expected\
    \ `usize`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpaorud054.rs:28:17\n\
    \   |\n28 |         if el > max {\n   |                 ^^^ expected `&isize`,\
    \ found `usize`\n\nerror[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpaorud054.rs:34:20\n\
    \   |\n34 |             i if i == i - 1 => -1,\n   |                    ^^ no\
    \ implementation for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0277]: can't compare `&isize`\
    \ with `isize`\n  --> /tmp/tmpaorud054.rs:35:20\n   |\n35 |             i if i\
    \ == i - 2 => 0,\n   |                    ^^ no implementation for `&isize ==\
    \ isize`\n   |\n   = help: the trait `PartialEq<isize>` is not implemented for\
    \ `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror: aborting due to 5 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    if arr.len() == 0 {\n        return -1;\n    }\n    let mut\
    \ index = arr.len() - 1;\n    let mut can_arrange = true;\n    while index < 0\
    \ && can_arrange {\n        if arr[index] > arr[index + 1] {\n            can_arrange\
    \ = false;\n        }\n        index -= 1;\n    }\n    index\n}\n\nfn main() {\n\
    \    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]),\
    \ 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7_2801gp.rs:22:5\n   |\n\
    10 | fn can_arrange(arr: Vec<isize>) -> isize {\n   |                        \
    \            ----- expected `isize` because of return type\n...\n22 |     index\n\
    \   |     ^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a\
    \ `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n22\
    \ |     index.try_into().unwrap()\n   |          ++++++++++++++++++++\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    if arr.len() == 0 {\n        return -1;\n    }\n\n    let mut\
    \ prev_idx = arr.len() - 1;\n    for i in arr.iter().rev() {\n        if prev_idx\
    \ > i {\n            return i;\n        }\n        prev_idx = i;\n    }\n    -1\n\
    }\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpeysokbn9.rs:17:23\n   |\n\
    17 |         if prev_idx > i {\n   |                       ^ expected `usize`,\
    \ found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpeysokbn9.rs:18:20\n\
    \   |\n18 |             return i;\n   |                    ^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n18 |  \
    \           return *i;\n   |                    +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpeysokbn9.rs:20:20\n   |\n15 |     let mut prev_idx = arr.len()\
    \ - 1;\n   |                        ------------- expected due to this value\n\
    ...\n20 |         prev_idx = i;\n   |                    ^ expected `usize`, found\
    \ `&isize`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut arr = arr.iter().cloned().collect();\n    let mut i\
    \ = 1;\n    while i < arr.len() {\n        if arr[i] > arr[i-1] {\n          \
    \  break;\n        }\n        i += 1;\n    }\n    i - 1\n}\n\nfn main() {\n  \
    \  let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]),\
    \ 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmppv45veq8.rs:13:15\n\
    \   |\n11 |     let mut arr = arr.iter().cloned().collect();\n   |         -------\
    \ consider giving `arr` a type\n12 |     let mut i = 1;\n13 |     while i < arr.len()\
    \ {\n   |               ^^^ cannot infer type\n   |\n   = note: type must be known\
    \ at this point\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut i = 0;\n    for v in arr.iter() {\n        if i < v\
    \ {\n            i += 1;\n        }\n        else {\n            return i;\n \
    \       }\n    }\n    -1\n}\n\nfn main() {\n    let candidate = can_arrange;\n\
    \    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpl30ajpyw.rs:13:14\n\
    \   |\n13 |         if i < v {\n   |              ^ no implementation for `isize\
    \ < &isize` and `isize > &isize`\n   |\n   = help: the trait `PartialOrd<&isize>`\
    \ is not implemented for `isize`\n   = help: the following other types implement\
    \ trait `PartialOrd<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut i = 0;\n    for e in arr.iter() {\n        if e >= i\
    \ {\n            return i;\n        }\n        i += 1;\n    }\n    return -1;\n\
    }\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp29ss2t9m.rs:13:17\n   |\n\
    13 |         if e >= i {\n   |                 ^\n   |                 |\n   |\
    \                 expected `&isize`, found integer\n   |                 help:\
    \ consider borrowing here: `&i`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter().position(|&i| i > arr.last().unwrap()).unwrap_or(-1)\
    \ as isize\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjseeh46z.rs:11:34\n   |\n\
    11 |     arr.iter().position(|&i| i > arr.last().unwrap()).unwrap_or(-1) as isize\n\
    \   |                                  ^^^^^^^^^^^^^^^^^^^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n11 |     arr.iter().position(|&i|\
    \ i > *arr.last().unwrap()).unwrap_or(-1) as isize\n   |                     \
    \             +\n\nerror[E0600]: cannot apply unary operator `-` to type `usize`\n\
    \  --> /tmp/tmpjseeh46z.rs:11:65\n   |\n11 |     arr.iter().position(|&i| i >\
    \ arr.last().unwrap()).unwrap_or(-1) as isize\n   |                          \
    \                                       ^^\n   |                             \
    \                                    |\n   |                                 \
    \                                cannot apply unary operator `-`\n   |       \
    \                                                          help: you may have\
    \ meant the maximum value of `usize`: `usize::MAX`\n   |\n   = note: unsigned\
    \ values cannot be negated\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0600.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut first_index = arr.iter().skip(1).next();\n    for i\
    \ in arr.iter().skip(2) {\n        if i > first_index {\n            return i;\n\
    \        }\n        first_index = i;\n    }\n    -1\n}\n\nfn main() {\n    let\
    \ candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n\
    \    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyrg6sba0.rs:13:16\n   |\n\
    13 |         if i > first_index {\n   |                ^^^^^^^^^^^ expected `&isize`,\
    \ found enum `Option`\n   |\n   = note: expected reference `&isize`\n        \
    \           found enum `Option<&isize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpyrg6sba0.rs:14:20\n   |\n14 |             return i;\n   |          \
    \          ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n14 |             return *i;\n   |                    +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpyrg6sba0.rs:16:23\n   |\n11 |  \
    \   let mut first_index = arr.iter().skip(1).next();\n   |                   \
    \        ------------------------- expected due to this value\n...\n16 |     \
    \    first_index = i;\n   |                       ^ expected enum `Option`, found\
    \ `&isize`\n   |\n   = note:   expected enum `Option<&isize>`\n           found\
    \ reference `&isize`\nhelp: try wrapping the expression in `Some`\n   |\n16 |\
    \         first_index = Some(i);\n   |                       +++++ +\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut largest = arr.iter().skip(1).max_by_key(|&el| el).unwrap();\n\
    \    if arr.iter().any(|&el| el >= &largest) {\n        largest = -1;\n    }\n\
    \    largest\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprgbtklmf.rs:12:35\n   |\n\
    12 |     if arr.iter().any(|&el| el >= &largest) {\n   |                     \
    \              ^^^^^^^^ expected `isize`, found `&&isize`\n   |\nhelp: consider\
    \ removing the `&` and dereferencing the borrow instead\n   |\n12 |     if arr.iter().any(|&el|\
    \ el >= *largest) {\n   |                                   ~\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmprgbtklmf.rs:13:19\n   |\n11 |     let mut largest\
    \ = arr.iter().skip(1).max_by_key(|&el| el).unwrap();\n   |                  \
    \     ------------------------------------------------ expected due to this value\n\
    12 |     if arr.iter().any(|&el| el >= &largest) {\n13 |         largest = -1;\n\
    \   |                   ^^\n   |                   |\n   |                   expected\
    \ `&isize`, found integer\n   |                   help: consider borrowing here:\
    \ `&-1`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprgbtklmf.rs:15:5\n  \
    \ |\n10 | fn can_arrange(arr: Vec<isize>) -> isize {\n   |                   \
    \                 ----- expected `isize` because of return type\n...\n15 |   \
    \  largest\n   |     ^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n15 |     *largest\n   |     +\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut max = -1;\n    for i in arr.iter() {\n        if i >=\
    \ max {\n            max = i;\n        }\n    }\n    max - 1\n}\n\nfn main() {\n\
    \    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]),\
    \ 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2caahrql.rs:13:17\n   |\n\
    13 |         if i >= max {\n   |                 ^^^\n   |                 |\n\
    \   |                 expected `&isize`, found integer\n   |                 help:\
    \ consider borrowing here: `&max`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2caahrql.rs:14:19\n\
    \   |\n11 |     let mut max = -1;\n   |                   -- expected due to this\
    \ value\n...\n14 |             max = i;\n   |                   ^ expected integer,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n14 |  \
    \           max = *i;\n   |                   +\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut max = 0;\n    let mut curr = 0;\n    for el in arr.iter()\
    \ {\n        if el > arr[curr] {\n            max = el;\n            curr = el;\n\
    \        } else {\n            curr = el;\n        }\n    }\n    max\n}\n\nfn\
    \ main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmmqt50tt.rs:14:17\n   |\n\
    14 |         if el > arr[curr] {\n   |                 ^^^^^^^^^\n   |       \
    \          |\n   |                 expected `&isize`, found `isize`\n   |    \
    \             help: consider borrowing here: `&arr[curr]`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpmmqt50tt.rs:15:19\n   |\n11 |     let mut max = 0;\n  \
    \ |                   - expected due to this value\n...\n15 |             max\
    \ = el;\n   |                   ^^ expected integer, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n15 |             max = *el;\n   | \
    \                  +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmmqt50tt.rs:16:20\n\
    \   |\n12 |     let mut curr = 0;\n   |                    - expected due to this\
    \ value\n...\n16 |             curr = el;\n   |                    ^^ expected\
    \ `usize`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmmqt50tt.rs:18:20\n\
    \   |\n12 |     let mut curr = 0;\n   |                    - expected due to this\
    \ value\n...\n18 |             curr = el;\n   |                    ^^ expected\
    \ `usize`, found `&isize`\n\nerror: aborting due to 4 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut max = -1;\n    let mut i = 0;\n    for elt in arr.iter().cloned()\
    \ {\n        if i == max {\n            if elt > arr[i] {\n                max\
    \ = i;\n            }\n        } else {\n            if elt > max {\n        \
    \        max = i;\n            }\n        }\n        i += 1;\n    }\n    max\n\
    }\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp21ym72se.rs:11:19\n\
    \   |\n11 |     let mut max = -1;\n   |                   ^^ the trait `Neg` is\
    \ not implemented for `usize`\n   |\n   = help: the following other types implement\
    \ trait `Neg`:\n             &f32\n             &f64\n             &i128\n   \
    \          &i16\n             &i32\n             &i64\n             &i8\n    \
    \         &isize\n           and 8 others\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp21ym72se.rs:19:22\n   |\n19 |             if elt > max {\n   |\
    \                      ^^^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n19 |             if elt > max.try_into().unwrap() {\n   |             \
    \            ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp21ym72se.rs:25:5\n\
    \   |\n10 | fn can_arrange(arr: Vec<isize>) -> isize {\n   |                 \
    \                   ----- expected `isize` because of return type\n...\n25 | \
    \    max\n   |     ^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    25 |     max.try_into().unwrap()\n   |        ++++++++++++++++++++\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut arr = arr.clone();\n    let mut max = -1;\n    while\
    \ arr.len() > 0 {\n        let mut index = 0;\n        let mut value = arr[0];\n\
    \        for v in arr.iter().skip(1) {\n            if v < value {\n         \
    \       break;\n            }\n            index = v;\n        }\n        if index\
    \ == max {\n            return max;\n        }\n        max = index;\n       \
    \ if arr.len() == 1 {\n            return -1;\n        }\n        arr.swap(0,\
    \ index + 1);\n    }\n    max\n}\n\nfn main() {\n    let candidate = can_arrange;\n\
    \    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpejj9qpla.rs:17:20\n   |\n\
    17 |             if v < value {\n   |                    ^^^^^\n   |         \
    \           |\n   |                    expected `&isize`, found `isize`\n   |\
    \                    help: consider borrowing here: `&value`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpejj9qpla.rs:20:21\n   |\n14 |         let mut\
    \ index = 0;\n   |                         - expected due to this value\n...\n\
    20 |             index = v;\n   |                     ^ expected integer, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n20 |        \
    \     index = *v;\n   |                     +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpejj9qpla.rs:29:21\n   |\n29 |         arr.swap(0, index + 1);\n\
    \   |                     ^^^^^^^^^ expected `usize`, found `isize`\n   |\nhelp:\
    \ you can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n29 |         arr.swap(0, (index + 1).try_into().unwrap());\n   |\
    \                     +         +++++++++++++++++++++\n\nerror: aborting due to\
    \ 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut max = 0;\n    for a in arr.iter() {\n        if max\
    \ < a {\n            max = a;\n        }\n    }\n    if max == -1 {\n        return\
    \ -1;\n    }\n    max\n}\n\nfn main() {\n    let candidate = can_arrange;\n  \
    \  assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmph5g6ts2h.rs:14:19\n   |\n\
    11 |     let mut max = 0;\n   |                   - expected due to this value\n\
    ...\n14 |             max = a;\n   |                   ^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n14 |        \
    \     max = *a;\n   |                   +\n\nerror[E0277]: can't compare `isize`\
    \ with `&isize`\n  --> /tmp/tmph5g6ts2h.rs:13:16\n   |\n13 |         if max <\
    \ a {\n   |                ^ no implementation for `isize < &isize` and `isize\
    \ > &isize`\n   |\n   = help: the trait `PartialOrd<&isize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `PartialOrd<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut idx = arr.len() - 1;\n    while idx > 0 && arr[idx]\
    \ > arr[idx - 1] {\n        idx -= 1;\n    }\n    if idx == 0 {\n        return\
    \ -1\n    }\n    idx\n}\n\nfn main() {\n    let candidate = can_arrange;\n   \
    \ assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyeimxndn.rs:18:5\n   |\n\
    10 | fn can_arrange(arr: Vec<isize>) -> isize {\n   |                        \
    \            ----- expected `isize` because of return type\n...\n18 |     idx\n\
    \   |     ^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize`\
    \ to an `isize` and panic if the converted value doesn't fit\n   |\n18 |     idx.try_into().unwrap()\n\
    \   |        ++++++++++++++++++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    if arr.is_empty() {\n        return -1;\n    }\n\n    let mut\
    \ i = 0;\n    let mut max = arr[0];\n    for i in arr.iter().rev() {\n       \
    \ if i > max {\n            max = i;\n        }\n    }\n    i;\n}\n\nfn main()\
    \ {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4,\
    \ 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4b0v8rj7.rs:18:16\n   |\n\
    18 |         if i > max {\n   |                ^^^\n   |                |\n  \
    \ |                expected `&isize`, found `isize`\n   |                help:\
    \ consider borrowing here: `&max`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4b0v8rj7.rs:19:19\n\
    \   |\n16 |     let mut max = arr[0];\n   |                   ------ expected\
    \ due to this value\n...\n19 |             max = i;\n   |                   ^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n19 |             max = *i;\n   |                   +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp4b0v8rj7.rs:10:36\n   |\n10 | fn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n   |    -----------                     ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n...\n22 |     i;\n   |      - help: remove this semicolon\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut max: Option<isize> = None;\n    for i in arr {\n   \
    \     max = if max is None or i > max? {\n            max = Some(i);\n       \
    \     None\n        } else {\n            None\n        }\n    }\n\n    match\
    \ max {\n        None => -1,\n        Some(max) => max,\n    }\n}\n\nfn main()\
    \ {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4,\
    \ 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `is`\n  --> /tmp/tmpzs5z6sth.rs:13:22\n   |\n\
    13 |         max = if max is None or i > max? {\n   |               --     ^^\
    \ expected `{`\n   |               |\n   |               this `if` expression\
    \ has a condition, but no block\n   |\nhelp: try placing this code inside a block\n\
    \   |\n13 |         max = if max { is } None or i > max? {\n   |             \
    \         +    +\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut arr = arr.into_iter().cloned().collect::<Vec<_>>();\n\
    \    let len = arr.len();\n    let mut j = 0;\n    let mut i = len - 1;\n    while\
    \ i > 0 {\n        if arr[j] > arr[i] {\n            j++;\n        } else {\n\
    \            i -= 1;\n        }\n    }\n    if j == 0 {\n        -1\n    } else\
    \ {\n        j\n    }\n}\n\nfn main() {\n    let candidate = can_arrange;\n  \
    \  assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpknp8sw1p.rs:17:14\n\
    \   |\n17 |             j++;\n   |              ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n17 |             { let tmp = j; j += 1;\
    \ tmp };\n   |             +++++++++++  ~~~~~~~~~~~~~~~\n17 -             j++;\n\
    17 +             j += 1;\n   | \n\nerror[E0271]: type mismatch resolving `<std::vec::IntoIter<isize>\
    \ as Iterator>::Item == &_`\n    --> /tmp/tmpknp8sw1p.rs:11:35\n     |\n11   |\
    \     let mut arr = arr.into_iter().cloned().collect::<Vec<_>>();\n     |    \
    \                               ^^^^^^ expected reference, found `isize`\n   \
    \  |\n     = note: expected reference `&_`\n                     found type `isize`\n\
    note: required by a bound in `cloned`\n\nerror[E0599]: the method `collect` exists\
    \ for struct `Cloned<std::vec::IntoIter<isize>>`, but its trait bounds were not\
    \ satisfied\n  --> /tmp/tmpknp8sw1p.rs:11:44\n   |\n11 |       let mut arr = arr.into_iter().cloned().collect::<Vec<_>>();\n\
    \   |                                              ^^^^^^^ method cannot be called\
    \ on `Cloned<std::vec::IntoIter<isize>>` due to unsatisfied trait bounds\n   |\n\
    \   = note: the following trait bounds were not satisfied:\n           `<std::vec::IntoIter<isize>\
    \ as Iterator>::Item = &_`\n           which is required by `Cloned<std::vec::IntoIter<isize>>:\
    \ Iterator`\n           `Cloned<std::vec::IntoIter<isize>>: Iterator`\n      \
    \     which is required by `&mut Cloned<std::vec::IntoIter<isize>>: Iterator`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut i = 0;\n    while i + 1 < arr.len() {\n        let el\
    \ = arr[i];\n        if el < arr[i + 1] {\n            break;\n        }\n   \
    \     i += 1;\n    }\n    i\n}\n\nfn main() {\n    let candidate = can_arrange;\n\
    \    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpatdjv42j.rs:19:5\n   |\n\
    10 | fn can_arrange(arr: Vec<isize>) -> isize {\n   |                        \
    \            ----- expected `isize` because of return type\n...\n19 |     i\n\
    \   |     ^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize`\
    \ to an `isize` and panic if the converted value doesn't fit\n   |\n19 |     i.try_into().unwrap()\n\
    \   |      ++++++++++++++++++++\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut i = 0;\n    let mut max: isize = -1;\n\n    for v in\
    \ arr {\n        if v < arr[i] {\n            max = v;\n        } else {\n   \
    \         if v > max {\n                max = v;\n            }\n        }\n \
    \       i += 1;\n    }\n\n    if max < arr[0] {\n        max = -1;\n    }\n\n\
    \    max\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `arr`\n   --> /tmp/tmp2hi7jyws.rs:15:16\n\
    \    |\n10  | fn can_arrange(arr: Vec<isize>) -> isize {\n    |              \
    \  --- move occurs because `arr` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n14  |     for v in arr {\n    |              --- `arr`\
    \ moved due to this implicit call to `.into_iter()`\n15  |         if v < arr[i]\
    \ {\n    |                ^^^ value borrowed here after move\n    |\nnote: this\
    \ function takes ownership of the receiver `self`, which moves `arr`\nhelp: consider\
    \ iterating over a slice of the `Vec<isize>`'s content to avoid moving into the\
    \ `for` loop\n    |\n14  |     for v in &arr {\n    |              +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut index = 0;\n    let mut max_index = 0;\n    while index\
    \ < arr.len() {\n        if index < arr.len() - 1 {\n            if arr[index\
    \ + 1] <= arr[index] {\n                break;\n            }\n        } else\
    \ {\n            max_index = index;\n            break;\n        }\n        index\
    \ +=1;\n    }\n    max_index\n}\n\nfn main() {\n    let candidate = can_arrange;\n\
    \    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpn8e8llnl.rs:24:5\n   |\n\
    10 | fn can_arrange(arr: Vec<isize>) -> isize {\n   |                        \
    \            ----- expected `isize` because of return type\n...\n24 |     max_index\n\
    \   |     ^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    24 |     max_index.try_into().unwrap()\n   |              ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    if arr.len() == 1 {\n        return arr.len();\n    }\n\n  \
    \  let mut max: isize = 0;\n    let mut i = 1;\n\n    while i < arr.len() {\n\
    \        if max < arr[i] {\n            max = arr[i];\n        }\n\n        i\
    \ += 1;\n    }\n\n    max\n}\n\nfn main() {\n    let candidate = can_arrange;\n\
    \    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpe6__x6uo.rs:12:16\n   |\n\
    10 | fn can_arrange(arr: Vec<isize>) -> isize {\n   |                        \
    \            ----- expected `isize` because of return type\n11 |     if arr.len()\
    \ == 1 {\n12 |         return arr.len();\n   |                ^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n12 |         return arr.len().try_into().unwrap();\n\
    \   |                         ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    // First find first value greater than or equal to each value\n\
    \    let mut largest_index = -1;\n    for i in arr.iter() {\n        if i > (largest_index\
    \ + 1) {\n            largest_index = i;\n        }\n    }\n\n    // If there\
    \ was a large value, that means we have found the answer\n    if largest_index\
    \ != -1 {\n        largest_index + 1\n    } else {\n        -1\n    }\n}\n\nfn\
    \ main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpg6li2bxt.rs:14:16\n   |\n\
    14 |         if i > (largest_index + 1) {\n   |                ^^^^^^^^^^^^^^^^^^^\n\
    \   |                |\n   |                expected `&isize`, found integer\n\
    \   |                help: consider borrowing here: `&((largest_index + 1))`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpg6li2bxt.rs:15:29\n   |\n12 |\
    \     let mut largest_index = -1;\n   |                             -- expected\
    \ due to this value\n...\n15 |             largest_index = i;\n   |          \
    \                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n15 |             largest_index = *i;\n   |               \
    \              +\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut largest = -1;\n    let mut max_index = 0;\n    let mut\
    \ it = arr.iter();\n    loop {\n        let next_elem = *it.next();\n        if\
    \ next_elem > largest {\n            largest = next_elem;\n            max_index\
    \ = it.index();\n        }\n        if largest == -1 {\n            break;\n \
    \       }\n    }\n    if largest != -1 {\n        max_index\n    } else {\n  \
    \      -1\n    }\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `Option<&isize>` cannot be dereferenced\n  --> /tmp/tmp7phedlvt.rs:15:25\n\
    \   |\n15 |         let next_elem = *it.next();\n   |                        \
    \ ^^^^^^^^^^\n\nerror[E0599]: no method named `index` found for struct `std::slice::Iter`\
    \ in the current scope\n  --> /tmp/tmp7phedlvt.rs:18:28\n   |\n18 |          \
    \   max_index = it.index();\n   |                            ^^^^^ method not\
    \ found in `std::slice::Iter<'_, isize>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0599, E0614.\nFor more information\
    \ about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut largest = arr.len();\n    for (i, &v) in arr.iter().enumerate()\
    \ {\n        if !v.is_ok() {\n            break;\n        }\n        if *v > largest.get()\
    \ + 1 {\n            largest.insert((*v) - 1);\n        }\n    }\n    largest.get()\
    \ + 1\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ok` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp90v07v45.rs:13:15\n   |\n13 |         if !v.is_ok() {\n\
    \   |               ^^^^^ method not found in `isize`\n\nerror[E0614]: type `isize`\
    \ cannot be dereferenced\n  --> /tmp/tmp90v07v45.rs:16:12\n   |\n16 |        \
    \ if *v > largest.get() + 1 {\n   |            ^^\n\nerror[E0599]: no method named\
    \ `get` found for type `usize` in the current scope\n   --> /tmp/tmp90v07v45.rs:16:25\n\
    \    |\n16  |         if *v > largest.get() + 1 {\n    |                     \
    \    ^^^ method not found in `usize`\n    |\n    = help: items from traits can\
    \ only be used if the trait is in scope\nhelp: the following trait is implemented\
    \ but not in scope; perhaps add a `use` for it:\n    |\n1   | use std::slice::SliceIndex;\n\
    \    |\n\nerror[E0599]: no method named `insert` found for type `usize` in the\
    \ current scope\n  --> /tmp/tmp90v07v45.rs:17:21\n   |\n17 |             largest.insert((*v)\
    \ - 1);\n   |                     ^^^^^^ method not found in `usize`\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmp90v07v45.rs:17:28\n   |\n\
    17 |             largest.insert((*v) - 1);\n   |                            ^^^^\n\
    \nerror[E0599]: no method named `get` found for type `usize` in the current scope\n\
    \   --> /tmp/tmp90v07v45.rs:20:13\n    |\n20  |     largest.get() + 1\n    | \
    \            ^^^ method not found in `usize`\n    |\n    = help: items from traits\
    \ can only be used if the trait is in scope\nhelp: the following trait is implemented\
    \ but not in scope; perhaps add a `use` for it:\n    |\n1   | use std::slice::SliceIndex;\n\
    \    |\n\nerror: aborting due to 6 previous errors\n\nSome errors have detailed\
    \ explanations: E0599, E0614.\nFor more information about an error, try `rustc\
    \ --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut imax = -1;\n\n    let mut i = 0;\n    let mut j = 1;\n\
    \    for v in arr.iter() {\n        while j < v && v > arr[i] {\n            i\
    \ += 1;\n            j += 1;\n        }\n        if imax == -1 || j < v {\n  \
    \          imax = i;\n        }\n    }\n\n    imax\n}\n\nfn main() {\n    let\
    \ candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n\
    \    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpyi5o9kxv.rs:16:17\n\
    \   |\n16 |         while j < v && v > arr[i] {\n   |                 ^ no implementation\
    \ for `isize < &isize` and `isize > &isize`\n   |\n   = help: the trait `PartialOrd<&isize>`\
    \ is not implemented for `isize`\n   = help: the following other types implement\
    \ trait `PartialOrd<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpyi5o9kxv.rs:16:28\n   |\n16 |         while j < v && v > arr[i] {\n\
    \   |                            ^^^^^^\n   |                            |\n \
    \  |                            expected `&isize`, found `isize`\n   |       \
    \                     help: consider borrowing here: `&arr[i]`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpyi5o9kxv.rs:20:30\n   |\n20 |         if imax\
    \ == -1 || j < v {\n   |                              ^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n20 |        \
    \ if imax == -1 || j < *v {\n   |                              +\n\nerror[E0277]:\
    \ the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpyi5o9kxv.rs:11:20\n\
    \   |\n11 |     let mut imax = -1;\n   |                    ^^ the trait `Neg`\
    \ is not implemented for `usize`\n   |\n   = help: the following other types implement\
    \ trait `Neg`:\n             &f32\n             &f64\n             &i128\n   \
    \          &i16\n             &i32\n             &i64\n             &i8\n    \
    \         &isize\n           and 8 others\n\nerror[E0277]: the trait bound `usize:\
    \ Neg` is not satisfied\n  --> /tmp/tmpyi5o9kxv.rs:20:20\n   |\n20 |         if\
    \ imax == -1 || j < v {\n   |                    ^^ the trait `Neg` is not implemented\
    \ for `usize`\n   |\n   = help: the following other types implement trait `Neg`:\n\
    \             &f32\n             &f64\n             &i128\n             &i16\n\
    \             &i32\n             &i64\n             &i8\n             &isize\n\
    \           and 8 others\n\nerror[E0308]: mismatch"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter().enumerate().filter(|(_, elem)| elem <= arr.last().unwrap()).last().unwrap().0\n\
    }\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpm326dshh.rs:11:55\n   |\n\
    11 |     arr.iter().enumerate().filter(|(_, elem)| elem <= arr.last().unwrap()).last().unwrap().0\n\
    \   |                                                       ^^^^^^^^^^^^^^^^^^^\
    \ expected `&isize`, found `isize`\n   |\n   = note: expected reference `&&isize`\n\
    \              found reference `&isize`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpm326dshh.rs:11:5\n   |\n10 | fn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n   |                                    ----- expected `isize` because of\
    \ return type\n11 |     arr.iter().enumerate().filter(|(_, elem)| elem <= arr.last().unwrap()).last().unwrap().0\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n11 |     arr.iter().enumerate().filter(|(_,\
    \ elem)| elem <= arr.last().unwrap()).last().unwrap().0.try_into().unwrap()\n\
    \   |                                                                        \
    \                     ++++++++++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter().enumerate().filter(|(_, i)| i <= &arr[i - 1].1).next().unwrap_or(-1)\n\
    }\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot subtract `{integer}` from `&&isize`\n  --> /tmp/tmp3c0e1dcl.rs:11:56\n\
    \   |\n11 |     arr.iter().enumerate().filter(|(_, i)| i <= &arr[i - 1].1).next().unwrap_or(-1)\n\
    \   |                                                      - ^ - {integer}\n \
    \  |                                                      |\n   |            \
    \                                          &&isize\n   |\nhelp: `-` can be used\
    \ on `isize`, you can dereference `i`\n   |\n11 |     arr.iter().enumerate().filter(|(_,\
    \ i)| i <= &arr[*i - 1].1).next().unwrap_or(-1)\n   |                        \
    \                              +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3c0e1dcl.rs:11:81\n\
    \   |\n11 |     arr.iter().enumerate().filter(|(_, i)| i <= &arr[i - 1].1).next().unwrap_or(-1)\n\
    \   |                                                                        \
    \         ^^ expected tuple, found integer\n   |\n   = note: expected tuple `(usize,\
    \ &isize)`\n               found type `{integer}`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp3c0e1dcl.rs:11:5\n   |\n10 | fn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n   |                                    ----- expected `isize` because\
    \ of return type\n11 |     arr.iter().enumerate().filter(|(_, i)| i <= &arr[i\
    \ - 1].1).next().unwrap_or(-1)\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found tuple\n   |\n   = note: expected type `isize`\n    \
    \         found tuple `(usize, &isize)`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0369.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut max = isize::MAX;\n    let mut idx = isize::MAX;\n\n\
    \    for idx in arr.iter().rev() {\n        if idx < max {\n            return\
    \ idx;\n        }\n        max = idx;\n    }\n    -1\n}\n\nfn main() {\n    let\
    \ candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n\
    \    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmk88bd7u.rs:15:18\n   |\n\
    15 |         if idx < max {\n   |                  ^^^\n   |                 \
    \ |\n   |                  expected `&isize`, found `isize`\n   |            \
    \      help: consider borrowing here: `&max`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpmk88bd7u.rs:16:20\n   |\n16 |             return idx;\n   |   \
    \                 ^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n16 |             return *idx;\n   |                    +\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpmk88bd7u.rs:18:15\n   |\n11 |\
    \     let mut max = isize::MAX;\n   |                   ---------- expected due\
    \ to this value\n...\n18 |         max = idx;\n   |               ^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    18 |         max = *idx;\n   |               +\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut max_val = arr.iter().max();\n    match arr.iter().rfind(|x|\
    \ *x >= *max_val) {\n        Some(i) => i,\n        None => -1,\n    }\n}\n\n\
    fn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `Option<&isize>` cannot be dereferenced\n  --> /tmp/tmp7_2dnu7g.rs:12:38\n\
    \   |\n12 |     match arr.iter().rfind(|x| *x >= *max_val) {\n   |           \
    \                           ^^^^^^^^\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp7_2dnu7g.rs:13:20\n   |\n10 | fn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n   |                                    ----- expected `isize` because of\
    \ return type\n...\n13 |         Some(i) => i,\n   |                    ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    13 |         Some(i) => *i,\n   |                    +\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0614.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut max_index = -1;\n    for i in 0..arr.len() {\n     \
    \   if i > 0 && arr[i] <= arr[i-1] {\n            max_index = i;\n           \
    \ break;\n        }\n    }\n    arr.resize_with(max_index + 1, || 0);\n    arr[0]\n\
    }\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpccpxlrv1.rs:11:25\n\
    \   |\n11 |     let mut max_index = -1;\n   |                         ^^ the trait\
    \ `Neg` is not implemented for `usize`\n   |\n   = help: the following other types\
    \ implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n\
    \             &i16\n             &i32\n             &i64\n             &i8\n \
    \            &isize\n           and 8 others\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut j = 0;\n    for i in 0..arr.len() {\n        if j ==\
    \ i || arr[j] > arr[i] {\n            j = i;\n        } else {\n            return\
    \ i;\n        }\n    }\n    -1\n}\n\nfn main() {\n    let candidate = can_arrange;\n\
    \    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpeuyot66_.rs:16:20\n   |\n\
    16 |             return i;\n   |                    ^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n16 |             return i.try_into().unwrap();\n\
    \   |                     ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    if arr.len() < 2 {\n        return arr.len();\n    }\n\n   \
    \ arr.iter()\n        .enumerate()\n        .filter(|(i, val)| val >= arr[i..2].iter().max().unwrap_or(arr[1]\
    \ as isize))\n        .max().unwrap()\n}\n\nfn main() {\n    let candidate = can_arrange;\n\
    \    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpudqq0jpe.rs:12:16\n   |\n\
    10 | fn can_arrange(arr: Vec<isize>) -> isize {\n   |                        \
    \            ----- expected `isize` because of return type\n11 |     if arr.len()\
    \ < 2 {\n12 |         return arr.len();\n   |                ^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n12 |         return arr.len().try_into().unwrap();\n\
    \   |                         ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpudqq0jpe.rs:17:42\n   |\n17 |         .filter(|(i, val)|\
    \ val >= arr[i..2].iter().max().unwrap_or(arr[1] as isize))\n   |            \
    \                              ^\n   |                                       \
    \   |\n   |                                          expected `&usize`, found\
    \ integer\n   |                                          help: consider borrowing\
    \ here: `&2`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `std::ops::Range<&usize>`\n\
    \  --> /tmp/tmpudqq0jpe.rs:17:35\n   |\n17 |         .filter(|(i, val)| val >=\
    \ arr[i..2].iter().max().unwrap_or(arr[1] as isize))\n   |                   \
    \                ^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `std::ops::Range<&usize>`\n\
    \   = help: the following other types implement trait `SliceIndex<T>`:\n     \
    \        <std::ops::Range<usize> as SliceIndex<[T]>>\n             <std::ops::Range<usize>\
    \ as SliceIndex<str>>\n   = note: required because of the requirements on the\
    \ impl of `Index<std::ops::Range<&usize>>` for `Vec<isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpudqq0jpe.rs:15:5\n   |\n10 |   fn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n   |                                      ----- expected `isize`\
    \ because of return type\n...\n15 | /     arr.iter()\n16 | |         .enumerate()\n\
    17 | |         .filter(|(i, val)| val >= arr[i..2].iter().max().unwrap_or(arr[1]\
    \ as isize))\n18 | |         .max().unwrap()\n   | |____________"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut max_so_far = arr.iter().skip(1).max().unwrap();\n  \
    \  let mut max_so_far_iter = max_so_far;\n    for e in &arr {\n        if *e <=\
    \ *max_so_far {\n            max_so_far_iter = e;\n        }\n    }\n    max_so_far_iter\n\
    }\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphnzlcaf6.rs:18:5\n   |\n\
    10 | fn can_arrange(arr: Vec<isize>) -> isize {\n   |                        \
    \            ----- expected `isize` because of return type\n...\n18 |     max_so_far_iter\n\
    \   |     ^^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n18 |     *max_so_far_iter\n   |     +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut max = std::i32::MAX;\n    for (i, &e) in arr.iter().enumerate()\
    \ {\n        if *e > max {\n            max = *e;\n        }\n    }\n    if max\
    \ <= 0 {\n        return -1;\n    }\n    arr.iter().position(|&e| e < max).unwrap_or(-1)\n\
    }\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmps_c1o7cw.rs:13:12\n\
    \   |\n13 |         if *e > max {\n   |            ^^\n\nerror[E0614]: type `isize`\
    \ cannot be dereferenced\n  --> /tmp/tmps_c1o7cw.rs:14:19\n   |\n14 |        \
    \     max = *e;\n   |                   ^^\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmps_c1o7cw.rs:20:34\n   |\n20 |     arr.iter().position(|&e| e <\
    \ max).unwrap_or(-1)\n   |                                  ^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n20 |     arr.iter().position(|&e| e <\
    \ max.try_into().unwrap()).unwrap_or(-1)\n   |                               \
    \      ++++++++++++++++++++\n\nerror[E0600]: cannot apply unary operator `-` to\
    \ type `usize`\n  --> /tmp/tmps_c1o7cw.rs:20:49\n   |\n20 |     arr.iter().position(|&e|\
    \ e < max).unwrap_or(-1)\n   |                                               \
    \  ^^\n   |                                                 |\n   |          \
    \                                       cannot apply unary operator `-`\n   |\
    \                                                 help: you may have meant the\
    \ maximum value of `usize`: `usize::MAX`\n   |\n   = note: unsigned values cannot\
    \ be negated\n\nerror[E0308]: mismatched types\n  --> /tmp/tmps_c1o7cw.rs:20:5\n\
    \   |\n10 | fn can_arrange(arr: Vec<isize>) -> isize {\n   |                 \
    \                   ----- expected `isize` because of return type\n...\n20 | \
    \    arr.iter().position(|&e| e < max).unwrap_or(-1)\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n20 |     arr.iter().position(|&e|\
    \ e < max).unwrap_or(-1).try_into().unwrap()\n   |                           \
    \                         ++++++++++++++++++++\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0600, E0614.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter().rposition(|&i| i > 0).unwrap_or(-1)\n}\n\nfn main()\
    \ {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4,\
    \ 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0600]: cannot apply unary operator `-` to type `usize`\n  --> /tmp/tmp_6vxp58f.rs:11:48\n\
    \   |\n11 |     arr.iter().rposition(|&i| i > 0).unwrap_or(-1)\n   |         \
    \                                       ^^\n   |                             \
    \                   |\n   |                                                cannot\
    \ apply unary operator `-`\n   |                                             \
    \   help: you may have meant the maximum value of `usize`: `usize::MAX`\n   |\n\
    \   = note: unsigned values cannot be negated\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp_6vxp58f.rs:11:5\n   |\n10 | fn can_arrange(arr: Vec<isize>) ->\
    \ isize {\n   |                                    ----- expected `isize` because\
    \ of return type\n11 |     arr.iter().rposition(|&i| i > 0).unwrap_or(-1)\n  \
    \ |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n11 |     arr.iter().rposition(|&i| i > 0).unwrap_or(-1).try_into().unwrap()\n\
    \   |                                                   ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0600.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    arr.windows(2).map(|s| s.iter().position(|&x| x <= s.last())).max()\n\
    }\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqnijq9p5.rs:11:56\n   |\n\
    11 |     arr.windows(2).map(|s| s.iter().position(|&x| x <= s.last())).max()\n\
    \   |                                                        ^^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<&isize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpqnijq9p5.rs:11:5\n   |\n10 | fn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n   |                                    ----- expected `isize` because of\
    \ return type\n11 |     arr.windows(2).map(|s| s.iter().position(|&x| x <= s.last())).max()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n\
    \              found enum `Option<Option<usize>>`\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    for i in (0..arr.len()).rev() {\n        if arr[i] <= arr[(i\
    \ - 1) as usize] {\n            return i\n        }\n    }\n    -1\n}\n\nfn main()\
    \ {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4,\
    \ 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpm1nlyrjv.rs:13:20\n   |\n\
    13 |             return i\n   |                    ^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |             return i.try_into().unwrap()\n   |\
    \                     ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut max_idx = -1;\n    for elt in arr.iter().rev() {\n \
    \       if elt > arr[max_idx] {\n            max_idx = arr.len() - 1;\n      \
    \  }\n    }\n    max_idx\n}\n\nfn main() {\n    let candidate = can_arrange;\n\
    \    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp3ruot9df.rs:11:23\n\
    \   |\n11 |     let mut max_idx = -1;\n   |                       ^^ the trait\
    \ `Neg` is not implemented for `usize`\n   |\n   = help: the following other types\
    \ implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n\
    \             &i16\n             &i32\n             &i64\n             &i8\n \
    \            &isize\n           and 8 others\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp3ruot9df.rs:13:18\n   |\n13 |         if elt > arr[max_idx] {\n\
    \   |                  ^^^^^^^^^^^^\n   |                  |\n   |           \
    \       expected `&isize`, found `isize`\n   |                  help: consider\
    \ borrowing here: `&arr[max_idx]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3ruot9df.rs:17:5\n\
    \   |\n10 | fn can_arrange(arr: Vec<isize>) -> isize {\n   |                 \
    \                   ----- expected `isize` because of return type\n...\n17 | \
    \    max_idx\n   |     ^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you\
    \ can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n17 |     max_idx.try_into().unwrap()\n   |            ++++++++++++++++++++\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut i = arr.iter().position(|&x| x >= arr.last());\n   \
    \ i = match i {\n        Some(x) => x,\n        None => -1,\n    };\n    i + 1\n\
    }\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwr3olsq4.rs:11:47\n   |\n\
    11 |     let mut i = arr.iter().position(|&x| x >= arr.last());\n   |        \
    \                                       ^^^^^^^^^^ expected `isize`, found enum\
    \ `Option`\n   |\n   = note: expected type `isize`\n              found enum `Option<&isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpwr3olsq4.rs:13:20\n   |\n13 |\
    \         Some(x) => x,\n   |                    ^ expected enum `Option`, found\
    \ `usize`\n   |\n   = note: expected enum `Option<usize>`\n              found\
    \ type `usize`\nhelp: try wrapping the expression in `Some`\n   |\n13 |      \
    \   Some(x) => Some(x),\n   |                    +++++ +\n\nerror[E0369]: cannot\
    \ add `{integer}` to `Option<usize>`\n  --> /tmp/tmpwr3olsq4.rs:16:7\n   |\n16\
    \ |     i + 1\n   |     - ^ - {integer}\n   |     |\n   |     Option<usize>\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    if arr.is_empty() {\n        return -1;\n    }\n\n    // Keep\
    \ track of current max so we can compare it with the previous one\n    let mut\
    \ cur_max = arr[0];\n    let mut max_idx = 1;\n\n    for i in arr.iter().rev()\
    \ {\n        if i == cur_max {\n            max_idx += 1;\n        } else {\n\
    \            break;\n        }\n\n        cur_max = i;\n    }\n\n    max_idx\n\
    }\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmp_sqkp4rw.rs:20:14\n\
    \   |\n20 |         if i == cur_max {\n   |              ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp_sqkp4rw.rs:26:19\n   |\n16 |     let mut cur_max = arr[0];\n   |  \
    \                     ------ expected due to this value\n...\n26 |         cur_max\
    \ = i;\n   |                   ^ expected `isize`, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n26 |         cur_max = *i;\n   |  \
    \                 +\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    debug_assert!(arr.len() >= 1);\n    let mut max_index = -1;\n\
    \    for i in 0..arr.len() - 1 {\n        if arr[i] < arr[i + 1] {\n         \
    \   return i;\n        }\n        if arr[i] > arr[i + 1] {\n            max_index\
    \ = i;\n        }\n    }\n    max_index\n}\n\nfn main() {\n    let candidate =\
    \ can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp34c_2o7_.rs:15:20\n   |\n\
    15 |             return i;\n   |                    ^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n15 |             return i.try_into().unwrap();\n\
    \   |                     ++++++++++++++++++++\n\nerror[E0277]: the trait bound\
    \ `usize: Neg` is not satisfied\n  --> /tmp/tmp34c_2o7_.rs:12:25\n   |\n12 | \
    \    let mut max_index = -1;\n   |                         ^^ the trait `Neg`\
    \ is not implemented for `usize`\n   |\n   = help: the following other types implement\
    \ trait `Neg`:\n             &f32\n             &f64\n             &i128\n   \
    \          &i16\n             &i32\n             &i64\n             &i8\n    \
    \         &isize\n           and 8 others\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp34c_2o7_.rs:21:5\n   |\n10 | fn can_arrange(arr: Vec<isize>) ->\
    \ isize {\n   |                                    ----- expected `isize` because\
    \ of return type\n...\n21 |     max_index\n   |     ^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n21 |     max_index.try_into().unwrap()\n\
    \   |              ++++++++++++++++++++\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut idx = -1;\n    let mut max_val = arr[0];\n    let mut\
    \ i = 0;\n    while i < arr.len() {\n        if arr[i] <= max_val {\n        \
    \    idx = i;\n        }\n        if arr[i] == max_val + 1 {\n            break;\n\
    \        }\n        i += 1;\n    }\n    idx\n}\n\nfn main() {\n    let candidate\
    \ = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmppicw6t0y.rs:11:19\n\
    \   |\n11 |     let mut idx = -1;\n   |                   ^^ the trait `Neg` is\
    \ not implemented for `usize`\n   |\n   = help: the following other types implement\
    \ trait `Neg`:\n             &f32\n             &f64\n             &i128\n   \
    \          &i16\n             &i32\n             &i64\n             &i8\n    \
    \         &isize\n           and 8 others\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmppicw6t0y.rs:23:5\n   |\n10 | fn can_arrange(arr: Vec<isize>) ->\
    \ isize {\n   |                                    ----- expected `isize` because\
    \ of return type\n...\n23 |     idx\n   |     ^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     idx.try_into().unwrap()\n   |        ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut i = 0;\n    let mut max = -1;\n\n    for el in arr.iter()\
    \ {\n        if i < 0 || el < arr[i-1] {\n            max = i;\n        }\n  \
    \      i += 1;\n    }\n\n    max\n}\n\nfn main() {\n    let candidate = can_arrange;\n\
    \    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpteyh7w11.rs:15:26\n   |\n\
    15 |         if i < 0 || el < arr[i-1] {\n   |                          ^^^^^^^^\n\
    \   |                          |\n   |                          expected `&isize`,\
    \ found `isize`\n   |                          help: consider borrowing here:\
    \ `&arr[i-1]`\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n\
    \  --> /tmp/tmpteyh7w11.rs:12:19\n   |\n12 |     let mut max = -1;\n   |     \
    \              ^^ the trait `Neg` is not implemented for `usize`\n   |\n   = help:\
    \ the following other types implement trait `Neg`:\n             &f32\n      \
    \       &f64\n             &i128\n             &i16\n             &i32\n     \
    \        &i64\n             &i8\n             &isize\n           and 8 others\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpteyh7w11.rs:21:5\n   |\n10 | fn\
    \ can_arrange(arr: Vec<isize>) -> isize {\n   |                              \
    \      ----- expected `isize` because of return type\n...\n21 |     max\n   |\
    \     ^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize`\
    \ to an `isize` and panic if the converted value doesn't fit\n   |\n21 |     max.try_into().unwrap()\n\
    \   |        ++++++++++++++++++++\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    if arr.iter().any(|&x| x <= arr.iter().last().unwrap() - 1)\
    \ {\n        arr.iter().last().unwrap() - 1\n    } else {\n        -1\n    }\n\
    }\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmplbbhfeq0.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut result = -1;\n    for i in arr.iter().rev() {\n    \
    \    result = i;\n    }\n    result\n}\n\nfn main() {\n    let candidate = can_arrange;\n\
    \    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpipt7_k8z.rs:13:18\n   |\n\
    11 |     let mut result = -1;\n   |                      -- expected due to this\
    \ value\n12 |     for i in arr.iter().rev() {\n13 |         result = i;\n   |\
    \                  ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n13 |         result = *i;\n   |                  +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut max = 0;\n    for i in arr {\n        if max < i {\n\
    \            max = i;\n        }\n    }\n    max\n}\n\nfn main() {\n    let candidate\
    \ = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `3`', /tmp/tmpe9_dqwkc.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter().enumerate().map(|(i, el)| (el, i)).max(|(_, el1),\
    \ (_, el2)| el1.cmp(el2)).unwrap_or(-1)\n}\n\nfn main() {\n    let candidate =\
    \ can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `(_, _)`\n  --> /tmp/tmp_o17_fcp.rs:11:56\n\
    \   |\n11 |     arr.iter().enumerate().map(|(i, el)| (el, i)).max(|(_, el1), (_,\
    \ el2)| el1.cmp(el2)).unwrap_or(-1)\n   |                                    \
    \                    ^^^^^^^^ consider giving this closure parameter the explicit\
    \ type `(_, _)`, with the type parameters specified\n   |\n   = note: type must\
    \ be known at this point\n\nerror[E0061]: this function takes 0 arguments but\
    \ 1 argument was supplied\n    --> /tmp/tmp_o17_fcp.rs:11:51\n     |\n11   | \
    \    arr.iter().enumerate().map(|(i, el)| (el, i)).max(|(_, el1), (_, el2)| el1.cmp(el2)).unwrap_or(-1)\n\
    \     |                                                   ^^^ ---------------------------------\
    \ supplied 1 argument\n     |                                                \
    \   |\n     |                                                   expected 0 arguments\n\
    \     |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp_o17_fcp.rs:11:100\n   |\n11 |     arr.iter().enumerate().map(|(i,\
    \ el)| (el, i)).max(|(_, el1), (_, el2)| el1.cmp(el2)).unwrap_or(-1)\n   |   \
    \                                                                            \
    \                     ^^ expected tuple, found integer\n   |\n   = note: expected\
    \ tuple `(&isize, usize)`\n               found type `{integer}`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_o17_fcp.rs:11:5\n   |\n10 | fn can_arrange(arr:\
    \ Vec<isize>) -> isize {\n   |                                    ----- expected\
    \ `isize` because of return type\n11 |     arr.iter().enumerate().map(|(i, el)|\
    \ (el, i)).max(|(_, el1), (_, el2)| el1.cmp(el2)).unwrap_or(-1)\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found tuple\n   |\n   = note: expected type `isize`\n    \
    \         found tuple `(&isize, usize)`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0061, E0282, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut lower = -1;\n    let mut upper = arr.len() - 1;\n  \
    \  while lower <= upper {\n        let mid = (lower + upper) / 2;\n        if\
    \ arr[mid] >= mid + 1 {\n            upper = mid - 1;\n        } else {\n    \
    \        lower = mid + 1;\n        }\n    }\n    upper\n}\n\nfn main() {\n   \
    \ let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]),\
    \ 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp2mnbwkna.rs:11:21\n\
    \   |\n11 |     let mut lower = -1;\n   |                     ^^ the trait `Neg`\
    \ is not implemented for `usize`\n   |\n   = help: the following other types implement\
    \ trait `Neg`:\n             &f32\n             &f64\n             &i128\n   \
    \          &i16\n             &i32\n             &i64\n             &i8\n    \
    \         &isize\n           and 8 others\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2mnbwkna.rs:15:24\n   |\n15 |         if arr[mid] >= mid + 1 {\n\
    \   |                        ^^^^^^^ expected `isize`, found `usize`\n   |\nhelp:\
    \ you can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n15 |         if arr[mid] >= (mid + 1).try_into().unwrap() {\n   |\
    \                        +       +++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2mnbwkna.rs:21:5\n   |\n10 | fn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n   |                                    ----- expected `isize` because\
    \ of return type\n...\n21 |     upper\n   |     ^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n21 |     upper.try_into().unwrap()\n   |\
    \          ++++++++++++++++++++\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut res = -1;\n    let mut max_index = -1;\n    for (i,\
    \ elt) in arr.iter().enumerate() {\n        if i >= max_index {\n            max_index\
    \ = i;\n            res = i;\n        }\n        if elt <= arr[res + 1] {\n  \
    \          res = i;\n        }\n    }\n    if res == -1 {\n        -1\n    } else\
    \ {\n        res\n    }\n}\n\nfn main() {\n    let candidate = can_arrange;\n\
    \    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpggr6zdlp.rs:12:25\n\
    \   |\n12 |     let mut max_index = -1;\n   |                         ^^ the trait\
    \ `Neg` is not implemented for `usize`\n   |\n   = help: the following other types\
    \ implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n\
    \             &i16\n             &i32\n             &i64\n             &i8\n \
    \            &isize\n           and 8 others\n\nerror[E0277]: the trait bound\
    \ `usize: Neg` is not satisfied\n  --> /tmp/tmpggr6zdlp.rs:11:19\n   |\n11 | \
    \    let mut res = -1;\n   |                   ^^ the trait `Neg` is not implemented\
    \ for `usize`\n   |\n   = help: the following other types implement trait `Neg`:\n\
    \             &f32\n             &f64\n             &i128\n             &i16\n\
    \             &i32\n             &i64\n             &i8\n             &isize\n\
    \           and 8 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpggr6zdlp.rs:18:19\n\
    \   |\n18 |         if elt <= arr[res + 1] {\n   |                   ^^^^^^^^^^^^\n\
    \   |                   |\n   |                   expected `&isize`, found `isize`\n\
    \   |                   help: consider borrowing here: `&arr[res + 1]`\n\nerror[E0600]:\
    \ cannot apply unary operator `-` to type `usize`\n  --> /tmp/tmpggr6zdlp.rs:22:15\n\
    \   |\n22 |     if res == -1 {\n   |               ^^\n   |               |\n\
    \   |               cannot apply unary operator `-`\n   |               help:\
    \ you may have meant the maximum value of `usize`: `usize::MAX`\n   |\n   = note:\
    \ unsigned values cannot be negated\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpggr6zdlp.rs:25:9\n\
    \   |\n10 | fn can_arrange(arr: Vec<isize>) -> isize {\n   |                 \
    \                   ----- expected `isize` because of return type\n...\n25 | \
    \        res\n   |         ^^^ expected `isize`, found `usize`\n   |\nhelp: you\
    \ can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n25 |         res.try_into().unwrap()\n   |            ++++++++++++++++++++\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explan"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    if arr.is_empty() {\n        return -1;\n    }\n    let mut\
    \ i = 0;\n    let mut cur_val = arr[0];\n    for i in arr.iter().skip(1).rposition(|x|\
    \ x != cur_val) {\n        cur_val = arr[i];\n    }\n    i\n}\n\nfn main() {\n\
    \    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]),\
    \ 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmp7446d81e.rs:16:49\n\
    \   |\n16 |     for i in arr.iter().skip(1).rposition(|x| x != cur_val) {\n  \
    \ |                                                 ^^ no implementation for `&isize\
    \ == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut largest: isize = 0;\n    let mut j = 0;\n    for i in\
    \ arr.iter() {\n        if j < i {\n            largest = i;\n        } else {\n\
    \            largest = j;\n        }\n        j += 1;\n    }\n    largest\n}\n\
    \nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcjrsl4mr.rs:15:23\n   |\n\
    11 |     let mut largest: isize = 0;\n   |                      ----- expected\
    \ due to this type\n...\n15 |             largest = i;\n   |                 \
    \      ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n15 |             largest = *i;\n   |                     \
    \  +\n\nerror[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpcjrsl4mr.rs:14:14\n\
    \   |\n14 |         if j < i {\n   |              ^ no implementation for `isize\
    \ < &isize` and `isize > &isize`\n   |\n   = help: the trait `PartialOrd<&isize>`\
    \ is not implemented for `isize`\n   = help: the following other types implement\
    \ trait `PartialOrd<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut max_idx = -1;\n    let mut max_value = -1;\n    let\
    \ mut it = arr.iter();\n    let mut last_value = it.next();\n    while let Some(val)\
    \ = it.next() {\n        if val > max_value {\n            max_idx = last_value;\n\
    \            max_value = val;\n        }\n        last_value = val;\n    }\n \
    \   max_idx\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp496t8mhr.rs:16:18\n   |\n\
    16 |         if val > max_value {\n   |                  ^^^^^^^^^\n   |     \
    \             |\n   |                  expected `&isize`, found integer\n   |\
    \                  help: consider borrowing here: `&max_value`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp496t8mhr.rs:17:23\n   |\n11 |     let mut max_idx\
    \ = -1;\n   |                       -- expected due to this value\n...\n17 | \
    \            max_idx = last_value;\n   |                       ^^^^^^^^^^ expected\
    \ integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n \
    \             found enum `Option<&isize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp496t8mhr.rs:18:25\n   |\n12 |     let mut max_value = -1;\n   |\
    \                         -- expected due to this value\n...\n18 |           \
    \  max_value = val;\n   |                         ^^^ expected integer, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n18 |        \
    \     max_value = *val;\n   |                         +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp496t8mhr.rs:20:22\n   |\n14 |     let mut last_value =\
    \ it.next();\n   |                          --------- expected due to this value\n\
    ...\n20 |         last_value = val;\n   |                      ^^^ expected enum\
    \ `Option`, found `&isize`\n   |\n   = note:   expected enum `Option<&isize>`\n\
    \           found reference `&isize`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n20 |         last_value = Some(val);\n   |                      +++++ \
    \  +\n\nerror: aborting due to 4 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut max = -1;\n    let mut max_idx = -1;\n    let mut idx\
    \ = -1;\n    for i in arr.iter() {\n        if i < max {\n            idx = i;\n\
    \            max = i;\n            max_idx = idx;\n        } else {\n        \
    \    if i == max {\n                idx = i;\n                max = i;\n     \
    \           max_idx = idx;\n            } else {\n                if max_idx >\
    \ i - 1 {\n                    max_idx = i;\n                    max = i;\n  \
    \              }\n            }\n        }\n    }\n    idx\n}\n\nfn main() {\n\
    \    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]),\
    \ 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc1cfalph.rs:15:16\n   |\n\
    15 |         if i < max {\n   |                ^^^\n   |                |\n  \
    \ |                expected `&isize`, found integer\n   |                help:\
    \ consider borrowing here: `&max`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc1cfalph.rs:16:19\n\
    \   |\n13 |     let mut idx = -1;\n   |                   -- expected due to this\
    \ value\n...\n16 |             idx = i;\n   |                   ^ expected integer,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n16 |  \
    \           idx = *i;\n   |                   +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpc1cfalph.rs:17:19\n   |\n11 |     let mut max = -1;\n   |     \
    \              -- expected due to this value\n...\n17 |             max = i;\n\
    \   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n17 |             max = *i;\n   |           \
    \        +\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpc1cfalph.rs:20:18\n\
    \   |\n20 |             if i == max {\n   |                  ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpc1cfalph.rs:21:23\n   |\n13 |     let mut idx = -1;\n   |          \
    \         -- expected due to this value\n...\n21 |                 idx = i;\n\
    \   |                       ^ expected integer, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n21 |                 idx = *i;\n   |       \
    \                +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc1cfalph.rs:22:23\n\
    \   |\n11 |     let mut max = -1;\n   |                   -- expected due to this\
    \ value\n...\n22 |                 max = i;\n   |                       ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: co"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    // use std::cmp::Ordering::{Equal, Greater, Less};\n    let\
    \ mut i = arr.len() - 1;\n\n    while i != 0 && arr[i] <= arr[i--] {\n    }\n\n\
    \    if i == -1 {\n        return -1;\n    }\n\n    i + 1\n}\n\nfn main() {\n\
    \    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]),\
    \ 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `]`\n  --> /tmp/tmpdjhqsm47.rs:14:38\n\
    \   |\n14 |     while i != 0 && arr[i] <= arr[i--] {\n   |     -----         \
    \                   ^ expected expression\n   |     |\n   |     while parsing\
    \ the condition of this `while` expression\n\nerror: aborting due to previous\
    \ error\n\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut max_index = -1;\n    let mut idx = 1;\n    while idx\
    \ <= arr.len() {\n        if arr[idx] > arr[idx - 1] {\n            if arr[idx]\
    \ > max_index {\n                max_index = idx;\n            }\n        }\n\
    \        idx += 1;\n    }\n    if max_index == -1 {\n        -1\n    } else {\n\
    \        max_index\n    }\n}\n\nfn main() {\n    let candidate = can_arrange;\n\
    \    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpg9jqwncn.rs:16:29\n   |\n\
    11 |     let mut max_index = -1;\n   |                         -- expected due\
    \ to this value\n...\n16 |                 max_index = idx;\n   |            \
    \                 ^^^ expected `isize`, found `usize`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    if arr.is_empty() {\n        return -1;\n    }\n\n    let mut\
    \ max: isize = 0;\n    let mut maxi = arr.iter().position(|&x| x >= arr[max]);\n\
    \n    for x in arr.iter().rev() {\n        if maxi >= 0 {\n            if x >=\
    \ arr[maxi] {\n                break;\n            }\n        }\n\n        max\
    \ = maxi;\n        maxi = arr.iter().position(|&x| x >= x).unwrap_or(arr.len());\n\
    \    }\n\n    max\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpra_f8rhg.rs:16:50\n\
    \   |\n16 |     let mut maxi = arr.iter().position(|&x| x >= arr[max]);\n   |\
    \                                                  ^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpra_f8rhg.rs:19:20\n\
    \   |\n19 |         if maxi >= 0 {\n   |                    ^ expected enum `Option`,\
    \ found integer\n   |\n   = note: expected enum `Option<usize>`\n            \
    \  found type `{integer}`\nhelp: try wrapping the expression in `Some`\n   |\n\
    19 |         if maxi >= Some(0) {\n   |                    +++++ +\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `Option<usize>`\n  --> /tmp/tmpra_f8rhg.rs:20:21\n\
    \   |\n20 |             if x >= arr[maxi] {\n   |                     ^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `Option<usize>`\n   = note:\
    \ required because of the requirements on the impl of `Index<Option<usize>>` for\
    \ `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpra_f8rhg.rs:25:15\n\
    \   |\n15 |     let mut max: isize = 0;\n   |                  ----- expected\
    \ due to this type\n...\n25 |         max = maxi;\n   |               ^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<usize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpra_f8rhg.rs:26:16\n   |\n16 |     let mut maxi = arr.iter().position(|&x|\
    \ x >= arr[max]);\n   |                    ---------------------------------------\
    \ expected due to this value\n...\n26 |         maxi = arr.iter().position(|&x|\
    \ x >= x).unwrap_or(arr.len());\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected enum `Option`, found `usize`\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut i = arr.len() - 1;\n    while i >= 0 && arr[i] > arr[i\
    \ + 1] {\n        i--;\n    }\n    i as isize\n}\n\nfn main() {\n    let candidate\
    \ = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpke5dg1ch.rs:13:12\n\
    \   |\n13 |         i--;\n   |            ^ expected expression\n\nerror: aborting\
    \ due to previous error\n\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut i = 0;\n    for el in arr.iter().cloned() {\n      \
    \  if *el > i {\n            i = *el;\n        }\n    }\n    i + 1\n}\n\nfn main()\
    \ {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4,\
    \ 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmps64eibqe.rs:13:12\n\
    \   |\n13 |         if *el > i {\n   |            ^^^\n\nerror[E0614]: type `isize`\
    \ cannot be dereferenced\n  --> /tmp/tmps64eibqe.rs:14:17\n   |\n14 |        \
    \     i = *el;\n   |                 ^^^\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    for i in arr.iter().cloned().rposition(|&x| x > 0) as Vec<isize>::Iter::None\
    \ {\n        if let Some(i) = i {\n            return i;\n        }\n    }\n \
    \   -1\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0223]: ambiguous associated type\n  --> /tmp/tmpexs2vscm.rs:11:59\n\
    \   |\n11 |     for i in arr.iter().cloned().rposition(|&x| x > 0) as Vec<isize>::Iter::None\
    \ {\n   |                                                           ^^^^^^^^^^^^^^^^\
    \ help: use fully-qualified syntax: `<Vec<isize> as Trait>::Iter`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpexs2vscm.rs:11:45\n   |\n11 |     for i in arr.iter().cloned().rposition(|&x|\
    \ x > 0) as Vec<isize>::Iter::None {\n   |                                   \
    \          ^--\n   |                                             ||\n   |    \
    \                                         |expected due to this\n   |        \
    \                                     expected `isize`, found reference\n   |\
    \                                             help: did you mean `x`: `&isize`\n\
    \   |\n   = note:   expected type `isize`\n           found reference `&_`\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0223, E0308.\nFor more information about an error, try `rustc --explain E0223`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut i = arr.len() - 1;\n    let mut largest = -1;\n    while\
    \ i >= 0 {\n        if arr[i] >= largest {\n            largest = i;\n       \
    \ }\n        i -= 1;\n    }\n    largest\n}\n\nfn main() {\n    let candidate\
    \ = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7432jri_.rs:15:23\n   |\n\
    12 |     let mut largest = -1;\n   |                       -- expected due to\
    \ this value\n...\n15 |             largest = i;\n   |                       ^\
    \ expected `isize`, found `usize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut i = 0;\n    while i < arr.len() && arr[i] <= arr[i+1]\
    \ {\n        i += 1;\n    }\n    i if i <= arr.len() - 1 -1\n}\n\nfn main() {\n\
    \    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]),\
    \ 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator,\
    \ found keyword `if`\n  --> /tmp/tmpnq7c42ea.rs:15:7\n   |\n15 |     i if i <=\
    \ arr.len() - 1 -1\n   |       ^^ expected one of 8 possible tokens\n\nerror:\
    \ aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut largest = arr.len();\n    for &x in arr.rev() {\n  \
    \      if x <= largest {\n            largest = x;\n        }\n    }\n    largest\n\
    }\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `Vec<isize>` is not an iterator\n   --> /tmp/tmpdf9w7_7f.rs:12:19\n\
    \    |\n12  |       for &x in arr.rev() {\n    |                     ^^^ `Vec<isize>`\
    \ is not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Vec<isize>: Iterator`\n            which is required by `&mut Vec<isize>:\
    \ Iterator`\n            `[isize]: Iterator`\n            which is required by\
    \ `&mut [isize]: Iterator`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdf9w7_7f.rs:17:5\n\
    \   |\n10 | fn can_arrange(arr: Vec<isize>) -> isize {\n   |                 \
    \                   ----- expected `isize` because of return type\n...\n17 | \
    \    largest\n   |     ^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you\
    \ can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n17 |     largest.try_into().unwrap()\n   |            ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut l = arr.len();\n    let mut max = -1;\n    let mut min_idx\
    \ = 0;\n    let mut max_idx = -1;\n    for &idx in arr {\n        if idx > max\
    \ {\n            max_idx = idx;\n            max = idx;\n        }\n        if\
    \ idx < min_idx {\n            min_idx = idx;\n        }\n    }\n    if max_idx\
    \ == -1 || max_idx < min_idx {\n        return -1;\n    }\n    if min_idx == 0\
    \ {\n        return max_idx;\n    }\n    let mut last = -1;\n    let mut i = min_idx\
    \ - 1;\n    for &idx in arr {\n        if idx == last {\n            return idx;\n\
    \        }\n        if idx == max_idx {\n            break;\n        }\n     \
    \   last = idx;\n        i += 1;\n    }\n    -1\n}\n\nfn main() {\n    let candidate\
    \ = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkosablw5.rs:15:9\n   |\n\
    15 |     for &idx in arr {\n   |         ^^^^    --- this expression has type\
    \ `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `idx`\n   |\n\
    \   = note:   expected type `isize`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpkosablw5.rs:32:9\n   |\n32 |     for &idx in\
    \ arr {\n   |         ^^^^    --- this expression has type `Option<isize>`\n \
    \  |         |\n   |         expected `isize`, found reference\n   |         help:\
    \ you can probably remove the explicit borrow: `idx`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut i = arr.iter().cloned().nth(0).unwrap();\n    let mut\
    \ j = 0;\n    for i in 0..arr.len() {\n        if i == 0 || arr[i] > arr[i-1]\
    \ {\n            j = i;\n        }\n    }\n    if j == arr.len() {\n        -1\n\
    \    } else {\n        j\n    }\n}\n\nfn main() {\n    let candidate = can_arrange;\n\
    \    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfjmb40ul.rs:21:9\n   |\n\
    10 | fn can_arrange(arr: Vec<isize>) -> isize {\n   |                        \
    \            ----- expected `isize` because of return type\n...\n21 |        \
    \ j\n   |         ^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    21 |         j.try_into().unwrap()\n   |          ++++++++++++++++++++\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    if arr.len() == 1 {\n        return 0;\n    }\n\n    let mut\
    \ largest = arr[0];\n    for i in arr.iter().rev() {\n        if *i > largest\
    \ {\n            largest = *i;\n        }\n    }\n    largest\n}\n\nfn main()\
    \ {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4,\
    \ 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `3`', /tmp/tmp5w31o6co.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter().enumerate().fold(-1, |acc, (idx, elem)| if elem <=\
    \ acc + 1 {\n        acc\n    } else {\n        elem\n    })\n}\n\nfn main() {\n\
    \    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]),\
    \ 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd13shyzf.rs:11:67\n   |\n\
    11 |     arr.iter().enumerate().fold(-1, |acc, (idx, elem)| if elem <= acc + 1\
    \ {\n   |                                                                   ^^^^^^^\n\
    \   |                                                                   |\n  \
    \ |                                                                   expected\
    \ `&isize`, found `isize`\n   |                                              \
    \                     help: consider borrowing here: `&(acc + 1)`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpd13shyzf.rs:14:9\n   |\n14 |         elem\n\
    \   |         ^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n14 |         *elem\n   |         +\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter().cloned().enumerate().rev().skip(1).last().unwrap_or(-1)\
    \ as isize\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd9nlnk8q.rs:11:68\n   |\n\
    11 |     arr.iter().cloned().enumerate().rev().skip(1).last().unwrap_or(-1) as\
    \ isize\n   |                                                                \
    \    ^^ expected tuple, found integer\n   |\n   = note: expected tuple `(usize,\
    \ isize)`\n               found type `{integer}`\n\nerror[E0605]: non-primitive\
    \ cast: `(usize, isize)` as `isize`\n  --> /tmp/tmpd9nlnk8q.rs:11:5\n   |\n11\
    \ |     arr.iter().cloned().enumerate().rev().skip(1).last().unwrap_or(-1) as\
    \ isize\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ an `as` expression can only be used to convert between primitive types or to\
    \ coerce to a specific trait object\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0605.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut i = 0;\n    let mut max = -1;\n    while i < arr.len()\
    \ {\n        if arr[i] > max {\n            max = i;\n        }\n        i +=\
    \ 1;\n    }\n    max\n}\n\nfn main() {\n    let candidate = can_arrange;\n   \
    \ assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3pp08f26.rs:15:19\n   |\n\
    12 |     let mut max = -1;\n   |                   -- expected due to this value\n\
    ...\n15 |             max = i;\n   |                   ^ expected `isize`, found\
    \ `usize`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter().enumerate().filter(|(idx, &element)| idx > 1).next().unwrap().0\n\
    }\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8nykf01x.rs:11:59\n   |\n\
    11 |     arr.iter().enumerate().filter(|(idx, &element)| idx > 1).next().unwrap().0\n\
    \   |                                                           ^\n   |      \
    \                                                     |\n   |                \
    \                                           expected `&usize`, found integer\n\
    \   |                                                           help: consider\
    \ borrowing here: `&1`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8nykf01x.rs:11:5\n\
    \   |\n10 | fn can_arrange(arr: Vec<isize>) -> isize {\n   |                 \
    \                   ----- expected `isize` because of return type\n11 |     arr.iter().enumerate().filter(|(idx,\
    \ &element)| idx > 1).next().unwrap().0\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n11 |     arr.iter().enumerate().filter(|(idx,\
    \ &element)| idx > 1).next().unwrap().0.try_into().unwrap()\n   |            \
    \                                                                   ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut max = -1;\n    for i in arr.iter().rev() {\n       \
    \ if arr[i] >= max {\n            max = i;\n        }\n    }\n    max\n}\n\nfn\
    \ main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpo28p89ff.rs:13:12\n\
    \   |\n13 |         if arr[i] >= max {\n   |            ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo28p89ff.rs:14:19\n\
    \   |\n11 |     let mut max = -1;\n   |                   -- expected due to this\
    \ value\n...\n14 |             max = i;\n   |                   ^ expected integer,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n14 |  \
    \           max = *i;\n   |                   +\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut i = arr.iter().position(|&x| x >= arr[0]);\n    if i\
    \ >= 0 {\n        return i;\n    }\n    i = arr.iter().rposition(|&x| x >= arr[0]);\n\
    \    if i >= 0 {\n        return i;\n    }\n    i = arr.iter().position(|&x| x\
    \ <= arr[0]);\n    if i >= 0 {\n        return i;\n    }\n    return -1;\n}\n\n\
    fn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptkrc0dfk.rs:12:13\n   |\n\
    12 |     if i >= 0 {\n   |             ^ expected enum `Option`, found integer\n\
    \   |\n   = note: expected enum `Option<usize>`\n              found type `{integer}`\n\
    help: try wrapping the expression in `Some`\n   |\n12 |     if i >= Some(0) {\n\
    \   |             +++++ +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptkrc0dfk.rs:13:16\n\
    \   |\n10 | fn can_arrange(arr: Vec<isize>) -> isize {\n   |                 \
    \                   ----- expected `isize` because of return type\n...\n13 | \
    \        return i;\n   |                ^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected type `isize`\n              found enum `Option<usize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmptkrc0dfk.rs:16:13\n   |\n16 |\
    \     if i >= 0 {\n   |             ^ expected enum `Option`, found integer\n\
    \   |\n   = note: expected enum `Option<usize>`\n              found type `{integer}`\n\
    help: try wrapping the expression in `Some`\n   |\n16 |     if i >= Some(0) {\n\
    \   |             +++++ +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptkrc0dfk.rs:20:13\n\
    \   |\n20 |     if i >= 0 {\n   |             ^ expected enum `Option`, found\
    \ integer\n   |\n   = note: expected enum `Option<usize>`\n              found\
    \ type `{integer}`\nhelp: try wrapping the expression in `Some`\n   |\n20 |  \
    \   if i >= Some(0) {\n   |             +++++ +\n\nerror: aborting due to 4 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    if arr.is_empty() {\n        return -1;\n    }\n\n    let mut\
    \ max_index = 0 as isize;\n    let mut cur_max = 0 as isize;\n\n    for &i in\
    \ &arr {\n        if cur_max < i {\n            cur_max = i;\n        }\n\n  \
    \      if cur_max >= i {\n            max_index = i;\n        }\n    }\n\n   \
    \ max_index\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `3`', /tmp/tmpkysmfsuz.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut max = 0;\n    let mut index = -1;\n\n    for x in arr.iter()\
    \ {\n        if x > max {\n            max = x;\n            index = -1;\n   \
    \     }\n\n        if x == max {\n            index = x;\n        }\n    }\n\n\
    \    index\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp10zr1q3o.rs:15:16\n   |\n\
    15 |         if x > max {\n   |                ^^^\n   |                |\n  \
    \ |                expected `&isize`, found integer\n   |                help:\
    \ consider borrowing here: `&max`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp10zr1q3o.rs:16:19\n\
    \   |\n11 |     let mut max = 0;\n   |                   - expected due to this\
    \ value\n...\n16 |             max = x;\n   |                   ^ expected integer,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n16 |  \
    \           max = *x;\n   |                   +\n\nerror[E0277]: can't compare\
    \ `&isize` with `{integer}`\n  --> /tmp/tmp10zr1q3o.rs:20:14\n   |\n20 |     \
    \    if x == max {\n   |              ^^ no implementation for `&isize == {integer}`\n\
    \   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp10zr1q3o.rs:21:21\n\
    \   |\n12 |     let mut index = -1;\n   |                     -- expected due\
    \ to this value\n...\n21 |             index = x;\n   |                     ^\
    \ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n21 |             index = *x;\n   |                     +\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut result = -1;\n    let mut i = 0;\n\n    loop {\n   \
    \     let mut j = 0;\n        if i == arr.len() - 1 {\n            break;\n  \
    \      }\n\n        let next_val = arr[i + 1];\n        if j != 0 && next_val\
    \ < arr[j] {\n            i += 1;\n        } else {\n            result += i;\n\
    \            if next_val > arr[j] {\n                i = j + 1;\n            }\n\
    \        }\n        j += 1\n    }\n\n    result\n}\n\nfn main() {\n    let candidate\
    \ = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmphe38qxh3.rs:11:22\n\
    \   |\n11 |     let mut result = -1;\n   |                      ^^ the trait `Neg`\
    \ is not implemented for `usize`\n   |\n   = help: the following other types implement\
    \ trait `Neg`:\n             &f32\n             &f64\n             &i128\n   \
    \          &i16\n             &i32\n             &i64\n             &i8\n    \
    \         &isize\n           and 8 others\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmphe38qxh3.rs:32:5\n   |\n10 | fn can_arrange(arr: Vec<isize>) ->\
    \ isize {\n   |                                    ----- expected `isize` because\
    \ of return type\n...\n32 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n32 |     result.try_into().unwrap()\n   |\
    \           ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter()\n        .enumerate()\n        .max_by_key(|&(idx,\
    \ &x)| {\n            idx > x && (idx - x)\n        })\n        .unwrap_or(arr.len())\n\
    }\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9vzh0_4p.rs:14:19\n   |\n\
    14 |             idx > x && (idx - x)\n   |                   ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n14 |             idx > x.try_into().unwrap()\
    \ && (idx - x)\n   |                    ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9vzh0_4p.rs:14:31\n   |\n14 |             idx\
    \ > x && (idx - x)\n   |                               ^ expected `usize`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9vzh0_4p.rs:14:24\n\
    \   |\n14 |             idx > x && (idx - x)\n   |                        ^^^^^^^^^\
    \ expected `bool`, found `usize`\n\nerror[E0277]: cannot subtract `isize` from\
    \ `usize`\n  --> /tmp/tmp9vzh0_4p.rs:14:29\n   |\n14 |             idx > x &&\
    \ (idx - x)\n   |                             ^ no implementation for `usize -\
    \ isize`\n   |\n   = help: the trait `Sub<isize>` is not implemented for `usize`\n\
    \   = help: the following other types implement trait `Sub<Rhs>`:\n          \
    \   <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n             <&'a\
    \ i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n             <&'a i32\
    \ as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n\
    \             <&'a isize as Sub<isize>>\n           and 48 others\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9vzh0_4p.rs:16:20\n   |\n16 |         .unwrap_or(arr.len())\n\
    \   |                    ^^^^^^^^^ expected tuple, found `usize`\n   |\n   = note:\
    \ expected tuple `(usize, &isize)`\n               found type `usize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9vzh0_4p.rs:11:5\n   |\n10 |   fn can_arrange(arr:\
    \ Vec<isize>) -> isize {\n   |                                      ----- expected\
    \ `isize` because of return type\n11 | /     arr.iter()\n12 | |         .enumerate()\n\
    13 | |         .max_by_key(|&(idx, &x)| {\n14 | |             idx > x && (idx\
    \ - x)\n15 | |         })\n16 | |         .unwrap_or(arr.len())\n   | |_____________________________^\
    \ expe"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut min_idx = std::cmp::min::min(arr.iter().cloned().collect::<Vec<_>>());\n\
    \    for i in arr.iter().cloned().skip(min_idx).rev() {\n        if *i < *min_idx\
    \ {\n            min_idx = i;\n        }\n    }\n    min_idx\n}\n\nfn main() {\n\
    \    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]),\
    \ 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: expected type, found function `min` in\
    \ `cmp`\n  --> /tmp/tmp75k2612i.rs:11:33\n   |\n11 |     let mut min_idx = std::cmp::min::min(arr.iter().cloned().collect::<Vec<_>>());\n\
    \   |                                 ^^^ expected type, found function `min`\
    \ in `cmp`\n\nerror[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmp75k2612i.rs:13:12\n\
    \   |\n13 |         if *i < *min_idx {\n   |            ^^\n\nerror[E0614]: type\
    \ `usize` cannot be dereferenced\n  --> /tmp/tmp75k2612i.rs:13:17\n   |\n13 |\
    \         if *i < *min_idx {\n   |                 ^^^^^^^^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp75k2612i.rs:14:23\n   |\n11 |     let mut min_idx = std::cmp::min::min(arr.iter().cloned().collect::<Vec<_>>());\n\
    \   |                       -----------------------------------------------------------\
    \ expected due to this value\n...\n14 |             min_idx = i;\n   |       \
    \                ^ expected `usize`, found `isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp75k2612i.rs:17:5\n   |\n10 | fn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n   |                                    ----- expected `isize` because\
    \ of return type\n...\n17 |     min_idx\n   |     ^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     min_idx.try_into().unwrap()\n  \
    \ |            ++++++++++++++++++++\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0433, E0614.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    if arr.is_empty() {\n        return -1;\n    }\n\n    let mut\
    \ highest_so_far = arr[0];\n    let mut highest_before = arr[0];\n\n    for i\
    \ in arr.iter().rev() {\n        if highest_before >= i {\n            highest_so_far\
    \ = i;\n            highest_before = i;\n        } else {\n            highest_before\
    \ = i;\n        }\n    }\n    highest_so_far\n}\n\nfn main() {\n    let candidate\
    \ = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1ntdi0z2.rs:19:30\n   |\n\
    19 |         if highest_before >= i {\n   |                              ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    19 |         if highest_before >= *i {\n   |                              +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp1ntdi0z2.rs:20:30\n   |\n15 |  \
    \   let mut highest_so_far = arr[0];\n   |                              ------\
    \ expected due to this value\n...\n20 |             highest_so_far = i;\n   |\
    \                              ^ expected `isize`, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n20 |             highest_so_far = *i;\n\
    \   |                              +\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp1ntdi0z2.rs:21:30\n   |\n16 |     let mut highest_before = arr[0];\n\
    \   |                              ------ expected due to this value\n...\n21\
    \ |             highest_before = i;\n   |                              ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    21 |             highest_before = *i;\n   |                              +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp1ntdi0z2.rs:23:30\n   |\n16 |  \
    \   let mut highest_before = arr[0];\n   |                              ------\
    \ expected due to this value\n...\n23 |             highest_before = i;\n   |\
    \                              ^ expected `isize`, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n23 |             highest_before = *i;\n\
    \   |                              +\n\nerror: aborting due to 4 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut max = isize::MAX;\n    let mut prev = isize::MIN;\n\
    \    for v in arr.iter() {\n        if prev > v {\n            max = v;\n    \
    \    }\n        prev = v;\n    }\n    max - 1\n}\n\nfn main() {\n    let candidate\
    \ = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfi6s5dza.rs:14:19\n   |\n\
    14 |         if prev > v {\n   |                   ^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n14 |         if prev > *v\
    \ {\n   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfi6s5dza.rs:15:19\n\
    \   |\n11 |     let mut max = isize::MAX;\n   |                   ---------- expected\
    \ due to this value\n...\n15 |             max = v;\n   |                   ^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n15 |             max = *v;\n   |                   +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpfi6s5dza.rs:17:16\n   |\n12 |     let mut prev = isize::MIN;\n\
    \   |                    ---------- expected due to this value\n...\n17 |    \
    \     prev = v;\n   |                ^ expected `isize`, found `&isize`\n   |\n\
    help: consider dereferencing the borrow\n   |\n17 |         prev = *v;\n   | \
    \               +\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter().rev().enumerate().find(|(_, v)| v < 0).unwrap_or(-1)\n\
    }\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3tbbnn3g.rs:11:52\n   |\n\
    11 |     arr.iter().rev().enumerate().find(|(_, v)| v < 0).unwrap_or(-1)\n   |\
    \                                                    ^ expected `&&isize`, found\
    \ integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3tbbnn3g.rs:11:65\n\
    \   |\n11 |     arr.iter().rev().enumerate().find(|(_, v)| v < 0).unwrap_or(-1)\n\
    \   |                                                                 ^^ expected\
    \ tuple, found integer\n   |\n   = note: expected tuple `(usize, &isize)`\n  \
    \             found type `{integer}`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp3tbbnn3g.rs:11:5\n   |\n10 | fn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n   |                                    ----- expected `isize` because of\
    \ return type\n11 |     arr.iter().rev().enumerate().find(|(_, v)| v < 0).unwrap_or(-1)\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found tuple\n   |\n   = note: expected type `isize`\n             found\
    \ tuple `(usize, &isize)`\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    if arr.is_empty() {\n        return -1;\n    }\n\n    let mut\
    \ largest = 0;\n    for i in 0..arr.len() {\n        for j in 0..i {\n       \
    \     if arr[i] > arr[j] {\n                largest = i;\n                break;\n\
    \            }\n        }\n    }\n\n    largest\n}\n\nfn main() {\n    let candidate\
    \ = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwujziqui.rs:25:5\n   |\n\
    10 | fn can_arrange(arr: Vec<isize>) -> isize {\n   |                        \
    \            ----- expected `isize` because of return type\n...\n25 |     largest\n\
    \   |     ^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    25 |     largest.try_into().unwrap()\n   |            ++++++++++++++++++++\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut largest = arr.len() - 1;\n    let mut max_val = &arr[largest];\n\
    \    for val in arr.iter_mut() {\n        if *val >= max_val {\n            *val\
    \ = max_val;\n            largest = *val - 1;\n        }\n    }\n    largest\n\
    }\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpglq0rjok.rs:14:20\n   |\n\
    14 |         if *val >= max_val {\n   |                    ^^^^^^^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n14 |  \
    \       if *val >= *max_val {\n   |                    +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpglq0rjok.rs:15:20\n   |\n15 |             *val = max_val;\n\
    \   |             ----   ^^^^^^^ expected `isize`, found `&isize`\n   |      \
    \       |\n   |             expected due to the type of this binding\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n15 |             *val = *max_val;\n\
    \   |                    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpglq0rjok.rs:16:23\n\
    \   |\n11 |     let mut largest = arr.len() - 1;\n   |                       -------------\
    \ expected due to this value\n...\n16 |             largest = *val - 1;\n   |\
    \                       ^^^^^^^^ expected `usize`, found `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpglq0rjok.rs:19:5\n   |\n10 | fn can_arrange(arr:\
    \ Vec<isize>) -> isize {\n   |                                    ----- expected\
    \ `isize` because of return type\n...\n19 |     largest\n   |     ^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n19 |     largest.try_into().unwrap()\n\
    \   |            ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut i = 0;\n    let mut max_index = -1;\n    while i < arr.len()\
    \ {\n        match &arr[i] {\n            x if x > max_index => max_index = i,\n\
    \            _ => (),\n        }\n        i += 1;\n    }\n    max_index\n}\n\n\
    fn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj_a5kmo9.rs:15:22\n   |\n\
    15 |             x if x > max_index => max_index = i,\n   |                  \
    \    ^^^^^^^^^\n   |                      |\n   |                      expected\
    \ `&isize`, found integer\n   |                      help: consider borrowing\
    \ here: `&max_index`\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n\
    \  --> /tmp/tmpj_a5kmo9.rs:12:25\n   |\n12 |     let mut max_index = -1;\n   |\
    \                         ^^ the trait `Neg` is not implemented for `usize`\n\
    \   |\n   = help: the following other types implement trait `Neg`:\n         \
    \    &f32\n             &f64\n             &i128\n             &i16\n        \
    \     &i32\n             &i64\n             &i8\n             &isize\n       \
    \    and 8 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj_a5kmo9.rs:20:5\n\
    \   |\n10 | fn can_arrange(arr: Vec<isize>) -> isize {\n   |                 \
    \                   ----- expected `isize` because of return type\n...\n20 | \
    \    max_index\n   |     ^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp:\
    \ you can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n20 |     max_index.try_into().unwrap()\n   |              ++++++++++++++++++++\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut max = 0;\n    let mut max_index = -1;\n    for i in\
    \ arr.iter() {\n        if i >= max {\n            max = i;\n            max_index\
    \ = i;\n        }\n    }\n    if max_index == -1 {\n        return -1;\n    }\n\
    \    return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n \
    \   assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcx4n1o7c.rs:14:17\n   |\n\
    14 |         if i >= max {\n   |                 ^^^\n   |                 |\n\
    \   |                 expected `&isize`, found integer\n   |                 help:\
    \ consider borrowing here: `&max`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcx4n1o7c.rs:15:19\n\
    \   |\n11 |     let mut max = 0;\n   |                   - expected due to this\
    \ value\n...\n15 |             max = i;\n   |                   ^ expected integer,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n15 |  \
    \           max = *i;\n   |                   +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpcx4n1o7c.rs:16:25\n   |\n12 |     let mut max_index = -1;\n   |\
    \                         -- expected due to this value\n...\n16 |           \
    \  max_index = i;\n   |                         ^ expected integer, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n16 |             max_index\
    \ = *i;\n   |                         +\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter().enumerate().filter_map(|(_, e)| {\n        match\
    \ e {\n            Some(i) => i as isize < e.as_ref() as isize,\n            None\
    \ => false,\n        }\n    }).max()\n}\n\nfn main() {\n    let candidate = can_arrange;\n\
    \    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `,` or `>`, found `.`\n  --> /tmp/tmp90o0ytsv.rs:13:38\n\
    \   |\n13 |             Some(i) => i as isize < e.as_ref() as isize,\n   |   \
    \                                   ^ expected one of `,` or `>`\n   |\nhelp:\
    \ expressions must be enclosed in braces to be used as const generic arguments\n\
    \   |\n13 |             Some(i) => i as isize < { e.as_ref() as isize },\n   |\
    \                                     +                     +\n\nerror: `<` is\
    \ interpreted as a start of generic arguments for `isize`, not a comparison\n\
    \  --> /tmp/tmp90o0ytsv.rs:13:35\n   |\n13 |               Some(i) => i as isize\
    \ < e.as_ref() as isize,\n   |  ___________________________________^_-\n   | |\
    \                                   |\n   | |                                \
    \   not interpreted as comparison\n14 | |             None => false,\n   | |___________________-\
    \ interpreted as generic arguments\n   |\nhelp: try comparing the cast value\n\
    \   |\n13 |             Some(i) => (i as isize) < e.as_ref() as isize,\n   | \
    \                       +          +\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp90o0ytsv.rs:13:13\n   |\n12 |         match e {\n   |              \
    \ - this expression has type `&isize`\n13 |             Some(i) => i as isize\
    \ < e.as_ref() as isize,\n   |             ^^^^^^^ expected `isize`, found enum\
    \ `Option`\n   |\n   = note: expected type `isize`\n              found enum `Option<_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp90o0ytsv.rs:14:13\n   |\n12 |\
    \         match e {\n   |               - this expression has type `&isize`\n\
    13 |             Some(i) => i as isize < e.as_ref() as isize,\n14 |          \
    \   None => false,\n   |             ^^^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected type `isize`\n              found enum `Option<_>`\n\
    \nerror[E0599]: the method `as_ref` exists for reference `&isize`, but its trait\
    \ bounds were not satisfied\n  --> /tmp/tmp90o0ytsv.rs:13:39\n   |\n13 |     \
    \        Some(i) => i as isize < e.as_ref() as isize,\n   |                  \
    \                     ^^^^^^ method cannot be called on `&isize` du"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut max = -1;\n    let mut cur = 0;\n    for (i, e) in arr.iter().enumerate()\
    \ {\n        if e >= arr[cur] {\n            max = i;\n        } else {\n    \
    \        max = -1;\n        }\n        cur = i;\n    }\n    max\n}\n\nfn main()\
    \ {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4,\
    \ 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2uf30jdz.rs:14:17\n   |\n\
    14 |         if e >= arr[cur] {\n   |                 ^^^^^^^^\n   |         \
    \        |\n   |                 expected `&isize`, found `isize`\n   |      \
    \           help: consider borrowing here: `&arr[cur]`\n\nerror[E0600]: cannot\
    \ apply unary operator `-` to type `usize`\n  --> /tmp/tmp2uf30jdz.rs:17:19\n\
    \   |\n17 |             max = -1;\n   |                   ^^\n   |           \
    \        |\n   |                   cannot apply unary operator `-`\n   |     \
    \              help: you may have meant the maximum value of `usize`: `usize::MAX`\n\
    \   |\n   = note: unsigned values cannot be negated\n\nerror[E0277]: the trait\
    \ bound `usize: Neg` is not satisfied\n  --> /tmp/tmp2uf30jdz.rs:11:19\n   |\n\
    11 |     let mut max = -1;\n   |                   ^^ the trait `Neg` is not implemented\
    \ for `usize`\n   |\n   = help: the following other types implement trait `Neg`:\n\
    \             &f32\n             &f64\n             &i128\n             &i16\n\
    \             &i32\n             &i64\n             &i8\n             &isize\n\
    \           and 8 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2uf30jdz.rs:21:5\n\
    \   |\n10 | fn can_arrange(arr: Vec<isize>) -> isize {\n   |                 \
    \                   ----- expected `isize` because of return type\n...\n21 | \
    \    max\n   |     ^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    21 |     max.try_into().unwrap()\n   |        ++++++++++++++++++++\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0600.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut max = arr[0];\n    for elt in arr.iter().rev() {\n \
    \       if elt <= max {\n            return -1;\n        }\n        max = elt;\n\
    \    }\n    max\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnyyt59bl.rs:13:19\n   |\n\
    13 |         if elt <= max {\n   |                   ^^^\n   |               \
    \    |\n   |                   expected `&isize`, found `isize`\n   |        \
    \           help: consider borrowing here: `&max`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpnyyt59bl.rs:16:15\n   |\n11 |     let mut max = arr[0];\n\
    \   |                   ------ expected due to this value\n...\n16 |         max\
    \ = elt;\n   |               ^^^ expected `isize`, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n16 |         max = *elt;\n   |    \
    \           +\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    // Start at 1.\n    let mut largest = arr[0];\n\n    // Iterate\
    \ from 1 to the length of the array.\n    for i in arr.iter().rev() {\n      \
    \  // If we've reached the current largest index, then the next element\n    \
    \    // must also be largest, so return it.\n        if largest == i {\n     \
    \       return i;\n        }\n\n        // Otherwise, keep searching.\n      \
    \  largest = i;\n    }\n\n    // No previous element was greater than or equal\
    \ to the current largest\n    // element, so return -1.\n    -1\n}\n\nfn main()\
    \ {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4,\
    \ 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsvyl_7w2.rs:18:23\n   |\n\
    18 |         if largest == i {\n   |                       ^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n18 |  \
    \       if largest == *i {\n   |                       +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpsvyl_7w2.rs:19:20\n   |\n19 |             return i;\n \
    \  |                    ^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n19 |             return *i;\n   |          \
    \          +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsvyl_7w2.rs:23:19\n\
    \   |\n12 |     let mut largest = arr[0];\n   |                       ------ expected\
    \ due to this value\n...\n23 |         largest = i;\n   |                   ^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n23 |         largest = *i;\n   |                   +\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut arr = arr.into_iter().cloned();\n\n    while let Some(i)\
    \ = arr.iter().position(|x| x > arr.last().unwrap()) {\n        arr.remove(i);\n\
    \    }\n\n    arr.len()\n}\n\nfn main() {\n    let candidate = can_arrange;\n\
    \    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<std::vec::IntoIter<isize> as Iterator>::Item\
    \ == &_`\n    --> /tmp/tmpd4mc1nfw.rs:11:35\n     |\n11   |     let mut arr =\
    \ arr.into_iter().cloned();\n     |                                   ^^^^^^ expected\
    \ reference, found `isize`\n     |\n     = note: expected reference `&_`\n   \
    \                  found type `isize`\nnote: required by a bound in `cloned`\n\
    \nerror[E0599]: no method named `iter` found for struct `Cloned` in the current\
    \ scope\n  --> /tmp/tmpd4mc1nfw.rs:13:29\n   |\n13 |     while let Some(i) = arr.iter().position(|x|\
    \ x > arr.last().unwrap()) {\n   |                             ^^^^ method not\
    \ found in `Cloned<std::vec::IntoIter<isize>>`\n\nerror[E0599]: the method `last`\
    \ exists for struct `Cloned<std::vec::IntoIter<isize>>`, but its trait bounds\
    \ were not satisfied\n  --> /tmp/tmpd4mc1nfw.rs:13:57\n   |\n13 |       while\
    \ let Some(i) = arr.iter().position(|x| x > arr.last().unwrap()) {\n   |     \
    \                                                      ^^^^ method cannot be called\
    \ on `Cloned<std::vec::IntoIter<isize>>` due to unsatisfied trait bounds\n   |\n\
    \   = note: the following trait bounds were not satisfied:\n           `<std::vec::IntoIter<isize>\
    \ as Iterator>::Item = &_`\n           which is required by `Cloned<std::vec::IntoIter<isize>>:\
    \ Iterator`\n           `Cloned<std::vec::IntoIter<isize>>: Iterator`\n      \
    \     which is required by `&mut Cloned<std::vec::IntoIter<isize>>: Iterator`\n\
    \nerror[E0599]: no method named `remove` found for struct `Cloned` in the current\
    \ scope\n  --> /tmp/tmpd4mc1nfw.rs:14:13\n   |\n14 |         arr.remove(i);\n\
    \   |             ^^^^^^ method not found in `Cloned<std::vec::IntoIter<isize>>`\n\
    \nerror[E0599]: the method `len` exists for struct `Cloned<std::vec::IntoIter<isize>>`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmpd4mc1nfw.rs:17:9\n  \
    \ |\n17 |       arr.len()\n   |           ^^^ method cannot be called on `Cloned<std::vec::IntoIter<isize>>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `<std"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut i = arr.len() - 1;\n    loop {\n        if i > 0 {\n\
    \            if arr[i] > arr[i-1] {\n                i = i - 1;\n            }\n\
    \            else\n                break;\n        }\n        else\n         \
    \   return i;\n    }\n    i\n}\n\nfn main() {\n    let candidate = can_arrange;\n\
    \    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found keyword `break`\n  --> /tmp/tmptbvi3ru2.rs:18:17\n\
    \   |\n18 |                 break;\n   |                 ^^^^^ expected `{`\n\
    \   |\nhelp: try placing this code inside a block\n   |\n18 |                \
    \ { break; }\n   |                 +        +\n\nerror: expected `{`, found keyword\
    \ `return`\n  --> /tmp/tmptbvi3ru2.rs:21:13\n   |\n21 |             return i;\n\
    \   |             ^^^^^^ expected `{`\n   |\nhelp: try placing this code inside\
    \ a block\n   |\n21 |             { return i; }\n   |             +          \
    \ +\n\nwarning: unreachable expression\n  --> /tmp/tmptbvi3ru2.rs:23:5\n   |\n\
    12 | /     loop {\n13 | |         if i > 0 {\n14 | |             if arr[i] > arr[i-1]\
    \ {\n15 | |                 i = i - 1;\n...  |\n21 | |             return i;\n\
    22 | |     }\n   | |_____- any code following this expression is unreachable\n\
    23 |       i\n   |       ^ unreachable expression\n   |\n   = note: `#[warn(unreachable_code)]`\
    \ on by default\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptbvi3ru2.rs:23:5\n\
    \   |\n10 | fn can_arrange(arr: Vec<isize>) -> isize {\n   |                 \
    \                   ----- expected `isize` because of return type\n...\n23 | \
    \    i\n   |     ^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    23 |     i.try_into().unwrap()\n   |      ++++++++++++++++++++\n\nerror: aborting\
    \ due to 3 previous errors; 1 warning emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut index = 0;\n    for value in arr {\n        if value\
    \ <= arr[arr.len() - index] {\n            index = arr.len() - index - 1;\n  \
    \      }\n    }\n    -1\n}\n\nfn main() {\n    let candidate = can_arrange;\n\
    \    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `arr`\n   --> /tmp/tmplbnfdbma.rs:13:21\n\
    \    |\n10  | fn can_arrange(arr: Vec<isize>) -> isize {\n    |              \
    \  --- move occurs because `arr` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n11  |     let mut index = 0;\n12  |     for value in arr {\n\
    \    |                  --- `arr` moved due to this implicit call to `.into_iter()`\n\
    13  |         if value <= arr[arr.len() - index] {\n    |                    \
    \ ^^^ value borrowed here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `arr`\nhelp: consider iterating over a slice\
    \ of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n12\
    \  |     for value in &arr {\n    |                  +\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut max = -1;\n    for i in arr.iter().rev() {\n       \
    \ if i >= arr.len() || i > max {\n            max = i;\n        }\n    }\n   \
    \ max\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnjq5vqj4.rs:13:17\n   |\n\
    13 |         if i >= arr.len() || i > max {\n   |                 ^^^^^^^^^ expected\
    \ `&isize`, found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnjq5vqj4.rs:13:34\n\
    \   |\n13 |         if i >= arr.len() || i > max {\n   |                     \
    \             ^^^\n   |                                  |\n   |             \
    \                     expected `&isize`, found integer\n   |                 \
    \                 help: consider borrowing here: `&max`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpnjq5vqj4.rs:14:19\n   |\n11 |     let mut max = -1;\n \
    \  |                   -- expected due to this value\n...\n14 |             max\
    \ = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n14 |             max = *i;\n   |  \
    \                 +\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    if arr.is_empty() {\n        return -1;\n    }\n\n    arr.iter().rev().enumerate().filter(|(i,\
    \ _)| i > 0).max(|a, b| a.1.cmp(&b.1))\n        .unwrap_or(-1)\n}\n\nfn main()\
    \ {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4,\
    \ 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp985c_c46.rs:15:54\n   |\n\
    15 |     arr.iter().rev().enumerate().filter(|(i, _)| i > 0).max(|a, b| a.1.cmp(&b.1))\n\
    \   |                                                      ^\n   |           \
    \                                           |\n   |                          \
    \                            expected `&usize`, found integer\n   |          \
    \                                            help: consider borrowing here: `&0`\n\
    \nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmp985c_c46.rs:15:57\n     |\n15   |     arr.iter().rev().enumerate().filter(|(i,\
    \ _)| i > 0).max(|a, b| a.1.cmp(&b.1))\n     |                               \
    \                          ^^^ -------------------- supplied 1 argument\n    \
    \ |                                                         |\n     |        \
    \                                                 expected 0 arguments\n     |\n\
    note: associated function defined here\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp985c_c46.rs:16:20\n   |\n16 |         .unwrap_or(-1)\n   |         \
    \           ^^ expected tuple, found integer\n   |\n   = note: expected tuple\
    \ `(usize, &isize)`\n               found type `{integer}`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp985c_c46.rs:15:5\n   |\n10 |   fn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n   |                                      ----- expected `isize`\
    \ because of return type\n...\n15 | /     arr.iter().rev().enumerate().filter(|(i,\
    \ _)| i > 0).max(|a, b| a.1.cmp(&b.1))\n16 | |         .unwrap_or(-1)\n   | |______________________^\
    \ expected `isize`, found tuple\n   |\n   = note: expected type `isize`\n    \
    \         found tuple `(usize, &isize)`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0061, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut max: Option<isize> = None;\n    let mut cur = 0;\n \
    \   for i in arr {\n        if let Some(idx) = max {\n            if idx <= i\
    \ {\n                break;\n            }\n        }\n\n        if i == max {\n\
    \            max = Some(i);\n        }\n\n        if !i.is_none() && max == Some(-1)\
    \ {\n            max = Some(i);\n        }\n        cur = i;\n    }\n    match\
    \ (max, cur) {\n        (Some(v), Some(0)) => v,\n        (Some(-1), '#') => -1,\n\
    \        (Some(v), Some(i)) => i,\n        _ => panic!(\"invalid input\"),\n \
    \   }\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptx0czota.rs:20:17\n   |\n\
    20 |         if i == max {\n   |                 ^^^ expected `isize`, found enum\
    \ `Option`\n   |\n   = note: expected type `isize`\n              found enum `Option<isize>`\n\
    \nerror[E0599]: no method named `is_none` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmptx0czota.rs:24:15\n   |\n24 |         if !i.is_none() &&\
    \ max == Some(-1) {\n   |               ^^^^^^^ method not found in `isize`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmptx0czota.rs:30:19\n   |\n29 |  \
    \   match (max, cur) {\n   |           ---------- this expression has type `(Option<isize>,\
    \ isize)`\n30 |         (Some(v), Some(0)) => v,\n   |                   ^^^^^^^\
    \ expected `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n\
    \              found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmptx0czota.rs:31:20\n   |\n29 |     match (max, cur) {\n   |         \
    \  ---------- this expression has type `(Option<isize>, isize)`\n30 |        \
    \ (Some(v), Some(0)) => v,\n31 |         (Some(-1), '#') => -1,\n   |        \
    \            ^^^ expected `isize`, found `char`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmptx0czota.rs:32:19\n   |\n29 |     match (max, cur) {\n   |    \
    \       ---------- this expression has type `(Option<isize>, isize)`\n...\n32\
    \ |         (Some(v), Some(i)) => i,\n   |                   ^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<_>`\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    if arr.iter().all(|&x| x < arr.iter().skip(x).next().unwrap())\
    \ {\n        arr.iter().skip(1).last().unwrap_or(arr.iter().last().unwrap_or(arr.len()))\n\
    \    } else {\n        -1\n    }\n}\n\nfn main() {\n    let candidate = can_arrange;\n\
    \    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpy5r43g9j.rs:11:48\n   |\n\
    11 |     if arr.iter().all(|&x| x < arr.iter().skip(x).next().unwrap()) {\n  \
    \ |                                                ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n11 |     if arr.iter().all(|&x| x < arr.iter().skip(x.try_into().unwrap()).next().unwrap())\
    \ {\n   |                                                 ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpy5r43g9j.rs:11:32\n   |\n11 |\
    \     if arr.iter().all(|&x| x < arr.iter().skip(x).next().unwrap()) {\n   | \
    \                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n11 |  \
    \   if arr.iter().all(|&x| x < *arr.iter().skip(x).next().unwrap()) {\n   |  \
    \                              +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpy5r43g9j.rs:12:73\n\
    \   |\n12 |         arr.iter().skip(1).last().unwrap_or(arr.iter().last().unwrap_or(arr.len()))\n\
    \   |                                                                        \
    \ ^^^^^^^^^ expected `&isize`, found `usize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpy5r43g9j.rs:12:9\n   |\n10 | fn can_arrange(arr: Vec<isize>) ->\
    \ isize {\n   |                                    ----- expected `isize` because\
    \ of return type\n11 |     if arr.iter().all(|&x| x < arr.iter().skip(x).next().unwrap())\
    \ {\n12 |         arr.iter().skip(1).last().unwrap_or(arr.iter().last().unwrap_or(arr.len()))\n\
    \   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n12 |         *arr.iter().skip(1).last().unwrap_or(arr.iter().last().unwrap_or(arr.len()))\n\
    \   |         +\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    if arr.len() == 0 {\n        -1\n    } else {\n        let mut\
    \ max: isize = 0;\n        let mut maxidx = -1;\n        for idx in 0..arr.len()\
    \ {\n            if idx > 0 && arr[idx] > arr[idx-1] {\n                max =\
    \ idx;\n                maxidx = idx;\n            }\n        }\n        maxidx\n\
    \    }\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjh1up24k.rs:18:23\n   |\n\
    14 |         let mut max: isize = 0;\n   |                      ----- expected\
    \ due to this type\n...\n18 |                 max = idx;\n   |               \
    \        ^^^ expected `isize`, found `usize`\n\nerror[E0277]: the trait bound\
    \ `usize: Neg` is not satisfied\n  --> /tmp/tmpjh1up24k.rs:15:26\n   |\n15 | \
    \        let mut maxidx = -1;\n   |                          ^^ the trait `Neg`\
    \ is not implemented for `usize`\n   |\n   = help: the following other types implement\
    \ trait `Neg`:\n             &f32\n             &f64\n             &i128\n   \
    \          &i16\n             &i32\n             &i64\n             &i8\n    \
    \         &isize\n           and 8 others\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpjh1up24k.rs:22:9\n   |\n10 | fn can_arrange(arr: Vec<isize>) ->\
    \ isize {\n   |                                    ----- expected `isize` because\
    \ of return type\n...\n22 |         maxidx\n   |         ^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n22 |         maxidx.try_into().unwrap()\n\
    \   |               ++++++++++++++++++++\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut i = 0;\n    for e in arr.iter().rev() {\n        if\
    \ *e >= i {\n            return i;\n        }\n        i += 1;\n    }\n    -1\n\
    }\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmpwev6qv8c.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009031
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter().enumerate().max_by_key(|(_, i)| {\n        if i.0\
    \ > i.1 {\n            Some(i.0)\n        } else {\n            None\n       \
    \ }\n    }).unwrap()\n}\n\nfn main() {\n    let candidate = can_arrange;\n   \
    \ assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0609]: no field `0` on type `&&isize`\n  --> /tmp/tmplvcwiqtr.rs:12:14\n\
    \   |\n12 |         if i.0 > i.1 {\n   |              ^\n\nerror[E0609]: no field\
    \ `1` on type `&&isize`\n  --> /tmp/tmplvcwiqtr.rs:12:20\n   |\n12 |         if\
    \ i.0 > i.1 {\n   |                    ^\n\nerror[E0609]: no field `0` on type\
    \ `&&isize`\n  --> /tmp/tmplvcwiqtr.rs:13:20\n   |\n13 |             Some(i.0)\n\
    \   |                    ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplvcwiqtr.rs:11:5\n\
    \   |\n10 |   fn can_arrange(arr: Vec<isize>) -> isize {\n   |               \
    \                       ----- expected `isize` because of return type\n11 | /\
    \     arr.iter().enumerate().max_by_key(|(_, i)| {\n12 | |         if i.0 > i.1\
    \ {\n13 | |             Some(i.0)\n14 | |         } else {\n15 | |           \
    \  None\n16 | |         }\n17 | |     }).unwrap()\n   | |_______________^ expected\
    \ `isize`, found tuple\n   |\n   = note: expected type `isize`\n             found\
    \ tuple `(usize, &isize)`\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0609.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut min = arr[0];\n    let mut max = arr[0];\n    for i\
    \ in arr.iter() {\n        if *i > *max {\n            max = i;\n        }\n \
    \       if *i <= min {\n            min = i;\n        }\n    }\n    match max\
    \ {\n        v => v,\n        _ => -1,\n    }\n}\n\nfn main() {\n    let candidate\
    \ = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpbe1rrxmb.rs:14:17\n\
    \   |\n14 |         if *i > *max {\n   |                 ^^^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpbe1rrxmb.rs:15:19\n   |\n12 |     let mut max\
    \ = arr[0];\n   |                   ------ expected due to this value\n...\n15\
    \ |             max = i;\n   |                   ^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n15 |             max = *i;\n\
    \   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbe1rrxmb.rs:18:19\n\
    \   |\n11 |     let mut min = arr[0];\n   |                   ------ expected\
    \ due to this value\n...\n18 |             min = i;\n   |                   ^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n18 |             min = *i;\n   |                   +\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0614.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter().rindex_by()\n        .take_while(|&x| x <= arr.iter().next().unwrap())\n\
    \        .last()\n        .expect(\"No such element\")\n}\n\nfn main() {\n   \
    \ let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]),\
    \ 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `rindex_by` found for struct `std::slice::Iter`\
    \ in the current scope\n  --> /tmp/tmptz_vlvjg.rs:11:16\n   |\n11 |     arr.iter().rindex_by()\n\
    \   |                ^^^^^^^^^ method not found in `std::slice::Iter<'_, isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter().enumerate().max()\n        .expect(\"No element\"\
    )\n        .1\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpom7uedfl.rs:11:5\n   |\n\
    10 |   fn can_arrange(arr: Vec<isize>) -> isize {\n   |                      \
    \                ----- expected `isize` because of return type\n11 | /     arr.iter().enumerate().max()\n\
    12 | |         .expect(\"No element\")\n13 | |         .1\n   | |__________^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    11 |     *arr.iter().enumerate().max()\n   |     +\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    if arr.len() == 1 {\n        return arr.iter().max().unwrap_or(-1);\n\
    \    }\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n\n    let mut\
    \ i = 1;\n    while i <= high {\n        if arr[i] > arr[i - 1] {\n          \
    \  i += 1;\n        } else {\n            if i == low {\n                return\
    \ i;\n            }\n            low = i;\n            i += 1;\n        }\n  \
    \  }\n    -1\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4j17v8yt.rs:12:43\n   |\n\
    12 |         return arr.iter().max().unwrap_or(-1);\n   |                    \
    \                       ^^\n   |                                           |\n\
    \   |                                           expected `&isize`, found integer\n\
    \   |                                           help: consider borrowing here:\
    \ `&-1`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4j17v8yt.rs:12:16\n \
    \  |\n10 | fn can_arrange(arr: Vec<isize>) -> isize {\n   |                  \
    \                  ----- expected `isize` because of return type\n11 |     if\
    \ arr.len() == 1 {\n12 |         return arr.iter().max().unwrap_or(-1);\n   |\
    \                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n12 |         return *arr.iter().max().unwrap_or(-1);\n\
    \   |                +\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    if arr.is_empty() {\n        return -1;\n    }\n    if arr.len()\
    \ == 1 {\n        return 0;\n    }\n    let mut index = arr.len() - 1;\n    while\
    \ index >= 0 {\n        if arr[index] > arr[index + 1] {\n            return index;\n\
    \        }\n        index -= 1;\n    }\n    -1\n}\n\nfn main() {\n    let candidate\
    \ = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpr90pemh3.rs:20:20\n   |\n\
    20 |             return index;\n   |                    ^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n20 |             return index.try_into().unwrap();\n\
    \   |                         ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut res = vec![-1isize; arr.len()];\n\n    fn cmp(a: isize,\
    \ b: isize) -> bool {\n        if a < b {\n            false\n        } else if\
    \ b < a {\n            true\n        } else {\n            res[b] -= 1\n     \
    \   }\n    }\n\n    for (i, &e) in arr.iter().enumerate() {\n        if cmp(i,\
    \ 0) != 0 {\n            continue;\n        }\n\n        if cmp(i, arr.len())\
    \ != 0 {\n            return -1;\n        }\n    }\n\n    res[arr.len()] as isize\n\
    }\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0434]: can't capture dynamic environment in a fn item\n  --> /tmp/tmpa9onoos1.rs:19:13\n\
    \   |\n19 |             res[b] -= 1\n   |             ^^^\n   |\n   = help: use\
    \ the `|| { ... }` closure form instead\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpa9onoos1.rs:24:16\n   |\n24 |         if cmp(i, 0) != 0 {\n   |    \
    \            ^ expected `isize`, found `usize`\n   |\nhelp: you can convert a\
    \ `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n24\
    \ |         if cmp(i.try_into().unwrap(), 0) != 0 {\n   |                 ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpa9onoos1.rs:24:25\n   |\n24 |\
    \         if cmp(i, 0) != 0 {\n   |                         ^ expected `bool`,\
    \ found integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpa9onoos1.rs:28:16\n\
    \   |\n28 |         if cmp(i, arr.len()) != 0 {\n   |                ^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n28 |         if cmp(i.try_into().unwrap(),\
    \ arr.len()) != 0 {\n   |                 ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpa9onoos1.rs:28:19\n   |\n28 |         if cmp(i,\
    \ arr.len()) != 0 {\n   |                   ^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n28 |         if cmp(i, arr.len().try_into().unwrap())\
    \ != 0 {\n   |                            ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpa9onoos1.rs:28:33\n   |\n28 |         if cmp(i,\
    \ arr.len()) != 0 {\n   |                                 ^ expected `bool`, found\
    \ integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpa9onoos1.rs:19:13\n\
    \   |\n13 |     fn cmp(a: isize, b: isize) -> bool {\n   |                   \
    \                ---- expected `bool` because of return type\n...\n19 |      \
    \       res[b] -= 1\n   |             ^^^^^^^^^^^ expected `bool`, found `()`\n\
    \nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0434.\nFor"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut index = 0;\n    let mut largest = -1;\n    while index\
    \ < arr.len() {\n        if arr[index] > arr[largest + 1] {\n            largest\
    \ = index;\n        } else {\n            index += 1;\n        }\n    }\n    largest\n\
    }\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpdzesy2t3.rs:12:23\n\
    \   |\n12 |     let mut largest = -1;\n   |                       ^^ the trait\
    \ `Neg` is not implemented for `usize`\n   |\n   = help: the following other types\
    \ implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n\
    \             &i16\n             &i32\n             &i64\n             &i8\n \
    \            &isize\n           and 8 others\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpdzesy2t3.rs:20:5\n   |\n10 | fn can_arrange(arr: Vec<isize>) ->\
    \ isize {\n   |                                    ----- expected `isize` because\
    \ of return type\n...\n20 |     largest\n   |     ^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n20 |     largest.try_into().unwrap()\n  \
    \ |            ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter()\n        .enumerate()\n        .skip_while(|&(i,\
    \ _)| i <= arr.iter().last().unwrap())\n        .position(|&(i, _)| i >= arr.iter().last().unwrap())\n\
    \        .unwrap_or(-1)\n}\n\nfn main() {\n    let candidate = can_arrange;\n\
    \    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7coi_hrh.rs:13:36\n   |\n\
    13 |         .skip_while(|&(i, _)| i <= arr.iter().last().unwrap())\n   |    \
    \                                ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`,\
    \ found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7coi_hrh.rs:14:20\n\
    \   |\n14 |         .position(|&(i, _)| i >= arr.iter().last().unwrap())\n   |\
    \                    ^^^^^^-\n   |                    |     |\n   |          \
    \          |     expected due to this\n   |                    expected tuple,\
    \ found reference\n   |\n   = note:  expected tuple `(usize, &isize)`\n      \
    \     found reference `&_`\n\nerror[E0600]: cannot apply unary operator `-` to\
    \ type `usize`\n  --> /tmp/tmp7coi_hrh.rs:15:20\n   |\n15 |         .unwrap_or(-1)\n\
    \   |                    ^^\n   |                    |\n   |                 \
    \   cannot apply unary operator `-`\n   |                    help: you may have\
    \ meant the maximum value of `usize`: `usize::MAX`\n   |\n   = note: unsigned\
    \ values cannot be negated\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7coi_hrh.rs:11:5\n\
    \   |\n10 |   fn can_arrange(arr: Vec<isize>) -> isize {\n   |               \
    \                       ----- expected `isize` because of return type\n11 | /\
    \     arr.iter()\n12 | |         .enumerate()\n13 | |         .skip_while(|&(i,\
    \ _)| i <= arr.iter().last().unwrap())\n14 | |         .position(|&(i, _)| i >=\
    \ arr.iter().last().unwrap())\n15 | |         .unwrap_or(-1)\n   | |______________________^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n15 |         .unwrap_or(-1).try_into().unwrap()\n\
    \   |                       ++++++++++++++++++++\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0600.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut idx = 0;\n    let mut max_idx = 0;\n    let mut max_value\
    \ = arr[0];\n    for value in arr {\n        if value > max_value {\n        \
    \    max_idx = idx;\n            max_value = value;\n        }\n        idx +=\
    \ 1;\n    }\n    max_idx\n}\n\nfn main() {\n    let candidate = can_arrange;\n\
    \    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpw4s5imdr.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009031
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    if arr.is_empty() {\n        return -1;\n    }\n\n    let mut\
    \ i = 0;\n    while i < arr.len() {\n        if arr[i] <= arr[i-1] {\n       \
    \     return i;\n        }\n\n        i += 1;\n    }\n\n    return -1;\n}\n\n\
    fn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpplggl_nx.rs:18:20\n   |\n\
    18 |             return i;\n   |                    ^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n18 |             return i.try_into().unwrap();\n\
    \   |                     ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut n = arr.len();\n    if n == 1 {\n        return 0;\n\
    \    }\n    let mut prev: isize = 0;\n    for i in 0..n {\n        if arr[i] >\
    \ arr[prev] {\n            prev = i;\n        }\n    }\n    prev\n}\n\nfn main()\
    \ {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4,\
    \ 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpnhja587x.rs:17:21\n\
    \   |\n17 |         if arr[i] > arr[prev] {\n   |                     ^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpnhja587x.rs:18:20\n   |\n15 |     let mut prev:\
    \ isize = 0;\n   |                   ----- expected due to this type\n...\n18\
    \ |             prev = i;\n   |                    ^ expected `isize`, found `usize`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut largest = arr.iter().nth(0).unwrap();\n    for el in\
    \ arr.iter().skip(1) {\n        if el > largest {\n            largest = el;\n\
    \        }\n    }\n    largest\n}\n\nfn main() {\n    let candidate = can_arrange;\n\
    \    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmmt2l754.rs:17:5\n   |\n\
    10 | fn can_arrange(arr: Vec<isize>) -> isize {\n   |                        \
    \            ----- expected `isize` because of return type\n...\n17 |     largest\n\
    \   |     ^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n17 |     *largest\n   |     +\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut arr_size = arr.len();\n    arr_size.cmp(&arr_size.min(|a,\
    \ b| b.cmp(a)))\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmplxa4ltir.rs:12:36\n\
    \   |\n12 |     arr_size.cmp(&arr_size.min(|a, b| b.cmp(a)))\n   |           \
    \                         ^ consider giving this closure parameter a type\n  \
    \ |\n   = note: type must be known at this point\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmplxa4ltir.rs:12:5\n   |\n10 | fn can_arrange(arr: Vec<isize>) ->\
    \ isize {\n   |                                    ----- expected `isize` because\
    \ of return type\n11 |     let mut arr_size = arr.len();\n12 |     arr_size.cmp(&arr_size.min(|a,\
    \ b| b.cmp(a)))\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found enum `std::cmp::Ordering`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0282, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut largest = -1;\n    for el in arr.iter().skip(1) {\n\
    \        if el > largest {\n            largest = el;\n        }\n    }\n    largest\n\
    }\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqjq69nrr.rs:13:17\n   |\n\
    13 |         if el > largest {\n   |                 ^^^^^^^\n   |           \
    \      |\n   |                 expected `&isize`, found integer\n   |        \
    \         help: consider borrowing here: `&largest`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpqjq69nrr.rs:14:23\n   |\n11 |     let mut largest = -1;\n\
    \   |                       -- expected due to this value\n...\n14 |         \
    \    largest = el;\n   |                       ^^ expected integer, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n14 |             largest\
    \ = *el;\n   |                       +\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut i = 0;\n    while i < arr.len() {\n        if arr[i]\
    \ > arr[i-1] { break; }\n        i += 1;\n    }\n    arr[i..].iter().position(|v|\
    \ v < 0).unwrap_or(arr.len())\n}\n\nfn main() {\n    let candidate = can_arrange;\n\
    \    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpiv_3wa_m.rs:16:38\n   |\n\
    16 |     arr[i..].iter().position(|v| v < 0).unwrap_or(arr.len())\n   |      \
    \                                ^\n   |                                     \
    \ |\n   |                                      expected `&isize`, found integer\n\
    \   |                                      help: consider borrowing here: `&0`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpiv_3wa_m.rs:16:5\n   |\n10 | fn\
    \ can_arrange(arr: Vec<isize>) -> isize {\n   |                              \
    \      ----- expected `isize` because of return type\n...\n16 |     arr[i..].iter().position(|v|\
    \ v < 0).unwrap_or(arr.len())\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n16 |     arr[i..].iter().position(|v|\
    \ v < 0).unwrap_or(arr.len()).try_into().unwrap()\n   |                      \
    \                                       ++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    debug_assert_eq!(arr.len(), arr.iter().map(|&x| x.clone()).count(),\
    \ ());\n    let mut largest = -1;\n    let mut index = 0;\n    let mut last =\
    \ arr[0];\n    for &x in &arr {\n        if x <= last {\n            largest =\
    \ index;\n        }\n        index = index + 1;\n        last = x\n    }\n   \
    \ largest\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error: format argument must be a string literal\n  --> /tmp/tmphj0sxz1s.rs:11:73\n\
    \   |\n11 |     debug_assert_eq!(arr.len(), arr.iter().map(|&x| x.clone()).count(),\
    \ ());\n   |                                                                 \
    \        ^^\n   |\nhelp: you might be missing a string literal to format with\n\
    \   |\n11 |     debug_assert_eq!(arr.len(), arr.iter().map(|&x| x.clone()).count(),\
    \ \"{}\", ());\n   |                                                         \
    \                +++++\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut idx = 0;\n    while idx < arr.len() && arr[idx] > arr[idx-1]\
    \ {\n        idx += 1;\n    }\n    idx\n}\n\nfn main() {\n    let candidate =\
    \ can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp04w74uzr.rs:15:5\n   |\n\
    10 | fn can_arrange(arr: Vec<isize>) -> isize {\n   |                        \
    \            ----- expected `isize` because of return type\n...\n15 |     idx\n\
    \   |     ^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize`\
    \ to an `isize` and panic if the converted value doesn't fit\n   |\n15 |     idx.try_into().unwrap()\n\
    \   |        ++++++++++++++++++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut max = -1;\n    for i in arr {\n        if i < max {\n\
    \            max = i;\n        }\n    }\n    max\n}\n\nfn main() {\n    let candidate\
    \ = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-1`,\n right: `3`', /tmp/tmpar2bb04u.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009031
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut result = -1;\n\n    let mut max_elem = arr[0];\n   \
    \ let mut max_index = arr[0];\n\n    for &el in arr.iter().rev() {\n        if\
    \ *el > max_elem {\n            max_elem = *el;\n            max_index = arr.iter().skip(1).find(|&el|\
    \ el >= *el).unwrap();\n        }\n    }\n\n    result\n}\n\nfn main() {\n   \
    \ let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]),\
    \ 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmp7wp4s4d2.rs:17:12\n\
    \   |\n17 |         if *el > max_elem {\n   |            ^^^\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmp7wp4s4d2.rs:18:24\n   |\n\
    18 |             max_elem = *el;\n   |                        ^^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp7wp4s4d2.rs:19:61\n   |\n19 |             max_index\
    \ = arr.iter().skip(1).find(|&el| el >= *el).unwrap();\n   |                 \
    \                                            ^^^\n   |                       \
    \                                      |\n   |                               \
    \                              expected `&isize`, found `isize`\n   |        \
    \                                                     help: consider borrowing\
    \ here: `&*el`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7wp4s4d2.rs:19:25\n\
    \   |\n14 |     let mut max_index = arr[0];\n   |                         ------\
    \ expected due to this value\n...\n19 |             max_index = arr.iter().skip(1).find(|&el|\
    \ el >= *el).unwrap();\n   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n19 |             max_index = *arr.iter().skip(1).find(|&el| el >= *el).unwrap();\n\
    \   |                         +\n\nerror: aborting due to 4 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0614.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut max_index = -1;\n    for idx in arr.iter().rev().skip(1)\
    \ {\n        let idx = idx;\n        max_index = if *idx <= *max_index { *max_index\
    \ } else { idx };\n    }\n    max_index\n}\n\nfn main() {\n    let candidate =\
    \ can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `{integer}` cannot be dereferenced\n  --> /tmp/tmpq_fcrl_i.rs:14:32\n\
    \   |\n14 |         max_index = if *idx <= *max_index { *max_index } else { idx\
    \ };\n   |                                ^^^^^^^^^^\n\nerror[E0614]: type `{integer}`\
    \ cannot be dereferenced\n  --> /tmp/tmpq_fcrl_i.rs:14:45\n   |\n14 |        \
    \ max_index = if *idx <= *max_index { *max_index } else { idx };\n   |       \
    \                                      ^^^^^^^^^^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpq_fcrl_i.rs:14:65\n   |\n14 |         max_index = if *idx\
    \ <= *max_index { *max_index } else { idx };\n   |                           \
    \                                      ^^^ expected integer, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n14 |         max_index =\
    \ if *idx <= *max_index { *max_index } else { *idx };\n   |                  \
    \                                               +\n\nerror: aborting due to 3\
    \ previous errors\n\nSome errors have detailed explanations: E0308, E0614.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut i = 0;\n    let mut j = arr.len() - 1;\n\n    while\
    \ i != j {\n        if arr[j] > arr[j + 1] {\n            return -1;\n       \
    \ }\n\n        if arr[j] < arr[j + 1] {\n            j -= 1;\n        }\n    \
    \    i += 1;\n        j -= 1;\n    }\n\n    arr.len()\n}\n\nfn main() {\n    let\
    \ candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n\
    \    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6zprn8l4.rs:26:5\n   |\n\
    10 | fn can_arrange(arr: Vec<isize>) -> isize {\n   |                        \
    \            ----- expected `isize` because of return type\n...\n26 |     arr.len()\n\
    \   |     ^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    26 |     arr.len().try_into().unwrap()\n   |              ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter().fold2(|max, i| if *i <= max { -1 } else { i })\n\
    }\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `fold2` found for struct `std::slice::Iter`\
    \ in the current scope\n  --> /tmp/tmpf5c8wgcq.rs:11:16\n   |\n11 |     arr.iter().fold2(|max,\
    \ i| if *i <= max { -1 } else { i })\n   |                ^^^^^ method not found\
    \ in `std::slice::Iter<'_, isize>`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    debug_assert!(arr.len() <= 1000);\n\n    let mut max: usize\
    \ = 0;\n    let mut i = 1;\n    let mut j = 1;\n    let mut cur = arr.iter().max().unwrap();\n\
    \    max = i;\n\n    while i <= arr.len() {\n        if arr[i] - cur > 0 {\n \
    \           if arr[j] > cur {\n                max = j;\n            }\n     \
    \       i += 1;\n        } else {\n            j += 1;\n        }\n        cur\
    \ = arr[j];\n    }\n    max\n}\n\nfn main() {\n    let candidate = can_arrange;\n\
    \    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbaizhpnc.rs:21:25\n   |\n\
    21 |             if arr[j] > cur {\n   |                         ^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    21 |             if arr[j] > *cur {\n   |                         +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpbaizhpnc.rs:28:15\n   |\n16 |     let mut cur\
    \ = arr.iter().max().unwrap();\n   |                   -------------------------\
    \ expected due to this value\n...\n28 |         cur = arr[j];\n   |          \
    \     ^^^^^^\n   |               |\n   |               expected `&isize`, found\
    \ `isize`\n   |               help: consider borrowing here: `&arr[j]`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpbaizhpnc.rs:30:5\n   |\n10 | fn can_arrange(arr:\
    \ Vec<isize>) -> isize {\n   |                                    ----- expected\
    \ `isize` because of return type\n...\n30 |     max\n   |     ^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n30 |     max.try_into().unwrap()\n\
    \   |        ++++++++++++++++++++\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut i = 0;\n    let mut last_index = -1;\n\n    for i in\
    \ arr.iter() {\n        if i > last_index {\n            last_index = i;\n   \
    \     }\n    }\n\n    match last_index {\n        -1 => -1,\n        i => i\n\
    \    }\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_g7b3142.rs:15:16\n   |\n\
    15 |         if i > last_index {\n   |                ^^^^^^^^^^\n   |       \
    \         |\n   |                expected `&isize`, found integer\n   |      \
    \          help: consider borrowing here: `&last_index`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_g7b3142.rs:16:26\n   |\n12 |     let mut last_index =\
    \ -1;\n   |                          -- expected due to this value\n...\n16 |\
    \             last_index = i;\n   |                          ^ expected integer,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n16 |  \
    \           last_index = *i;\n   |                          +\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    if arr.is_empty() {\n        return -1;\n    }\n\n    let mut\
    \ max = arr[0];\n    let mut i = 0;\n    while i < arr.len() {\n        if arr[i]\
    \ > max {\n            max = arr[i];\n        }\n\n        i += 1;\n    }\n\n\
    \    max - 1\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpq3ah_l3m.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009031
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    if arr.is_empty() {\n        return -1;\n    }\n    let mut\
    \ j = 0;\n    let mut i = 0;\n    while i < arr.len() {\n        if j == arr.len()\
    \ {\n            return i;\n        }\n        if arr[i] > arr[j] {\n        \
    \    j = i;\n        }\n        i += 1;\n    }\n    return i;\n}\n\nfn main()\
    \ {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4,\
    \ 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpo_pd06ue.rs:18:20\n   |\n\
    18 |             return i;\n   |                    ^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n18 |             return i.try_into().unwrap();\n\
    \   |                     ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut min_i = -1;\n    for &i in arr.iter().rev() {\n    \
    \    if min_i > i {\n            min_i = i;\n        }\n    }\n    min_i\n}\n\n\
    fn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-1`,\n right: `3`', /tmp/tmp536vi1dn.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009031
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    if arr.is_empty() {\n        return -1;\n    }\n\n    fn find_last_non_greater(arr:\
    \ &[Option<usize>, ..], index: usize) -> usize {\n        arr.iter()\n       \
    \     .enumerate()\n            .filter(|(_, v)| v > index)\n            .fold(0,\
    \ |acc, &(v, i)| {\n                if *v > i {\n                    return acc;\n\
    \                } else {\n                    return *v;\n                }\n\
    \            });\n    }\n\n    let mut i = arr.len() - 1;\n    let mut max = -1;\n\
    \    loop {\n        if arr[i].is_none() {\n            break;\n        }\n\n\
    \        let elem = arr[i].unwrap();\n        let index = find_last_non_greater(&arr[i..],\
    \ elem);\n        if index >= i {\n            return max;\n        }\n      \
    \  max = elem;\n        i--;\n    }\n\n    return max;\n}\n\nfn main() {\n   \
    \ let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]),\
    \ 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `+`, `::`, `;`, or `]`, found `,`\n  --> /tmp/tmpi6c4gtpe.rs:15:50\n\
    \   |\n15 |     fn find_last_non_greater(arr: &[Option<usize>, ..], index: usize)\
    \ -> usize {\n   |                                                  ^ expected\
    \ one of `!`, `+`, `::`, `;`, or `]`\n\nerror: expected one of `:` or `|`, found\
    \ `]`\n  --> /tmp/tmpi6c4gtpe.rs:15:54\n   |\n15 |     fn find_last_non_greater(arr:\
    \ &[Option<usize>, ..], index: usize) -> usize {\n   |                       \
    \                               ^ expected one of `:` or `|`\n\nerror: expected\
    \ one of `)`, `,`, `->`, `:`, `where`, `{`, `|`, or identifier, found `]`\n  -->\
    \ /tmp/tmpi6c4gtpe.rs:15:54\n   |\n15 |     fn find_last_non_greater(arr: &[Option<usize>,\
    \ ..], index: usize) -> usize {\n   |                                        \
    \              ^ expected one of 8 possible tokens\n\nerror: aborting due to 3\
    \ previous errors\n\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut largest = -1;\n\n    for &i in arr {\n        if i <\
    \ *largest {\n            largest = i;\n        }\n    }\n\n    largest\n}\n\n\
    fn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2h8sifwz.rs:13:9\n   |\n\
    13 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0614]: type `{integer}`\
    \ cannot be dereferenced\n  --> /tmp/tmp2h8sifwz.rs:14:16\n   |\n14 |        \
    \ if i < *largest {\n   |                ^^^^^^^^\n\nerror: aborting due to 2\
    \ previous errors\n\nSome errors have detailed explanations: E0308, E0614.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut max: isize = -1;\n    let mut cur = 0;\n    for x in\
    \ arr.iter() {\n        if max < x {\n            max = x;\n        }\n      \
    \  if x != cur {\n            return -1;\n        }\n        cur += 1;\n    }\n\
    \    max\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpklb16ts9.rs:14:18\n   |\n\
    14 |         if max < x {\n   |                  ^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n14 |         if max < *x\
    \ {\n   |                  +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpklb16ts9.rs:15:19\n\
    \   |\n11 |     let mut max: isize = -1;\n   |                  ----- expected\
    \ due to this type\n...\n15 |             max = x;\n   |                   ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    15 |             max = *x;\n   |                   +\n\nerror[E0277]: can't compare\
    \ `&isize` with `{integer}`\n  --> /tmp/tmpklb16ts9.rs:17:14\n   |\n17 |     \
    \    if x != cur {\n   |              ^^ no implementation for `&isize == {integer}`\n\
    \   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut res = -1;\n    let mut last_i = 0;\n    for i in arr.iter()\
    \ {\n        if last_i == i {\n            continue;\n        }\n        last_i\
    \ = i;\n        res = i;\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpe6qpce06.rs:17:18\n   |\n\
    12 |     let mut last_i = 0;\n   |                      - expected due to this\
    \ value\n...\n17 |         last_i = i;\n   |                  ^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n17 |  \
    \       last_i = *i;\n   |                  +\n\nerror[E0277]: can't compare `isize`\
    \ with `&isize`\n  --> /tmp/tmpe6qpce06.rs:14:19\n   |\n14 |         if last_i\
    \ == i {\n   |                   ^^ no implementation for `isize == &isize`\n\
    \   |\n   = help: the trait `PartialEq<&isize>` is not implemented for `isize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpe6qpce06.rs:18:15\n\
    \   |\n11 |     let mut res = -1;\n   |                   -- expected due to this\
    \ value\n...\n18 |         res = i;\n   |               ^ expected integer, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n18 |        \
    \ res = *i;\n   |               +\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut prev = 0isize;\n\n    for n in arr.iter().rev() {\n\
    \        if n < prev {\n            return -1;\n        }\n        prev = n;\n\
    \    }\n\n    arr.len()\n}\n\nfn main() {\n    let candidate = can_arrange;\n\
    \    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzzlq4q1j.rs:14:16\n   |\n\
    14 |         if n < prev {\n   |                ^^^^\n   |                |\n\
    \   |                expected `&isize`, found `isize`\n   |                help:\
    \ consider borrowing here: `&prev`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzzlq4q1j.rs:17:16\n\
    \   |\n11 |     let mut prev = 0isize;\n   |                    ------ expected\
    \ due to this value\n...\n17 |         prev = n;\n   |                ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    17 |         prev = *n;\n   |                +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpzzlq4q1j.rs:20:5\n   |\n10 | fn can_arrange(arr: Vec<isize>) ->\
    \ isize {\n   |                                    ----- expected `isize` because\
    \ of return type\n...\n20 |     arr.len()\n   |     ^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n20 |     arr.len().try_into().unwrap()\n\
    \   |              ++++++++++++++++++++\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut i = arr.len() - 1;\n\n    while i > 0 && arr[i] <= arr[(i\
    \ - 1)] {\n        i -= 1;\n    }\n\n    i as isize\n}\n\nfn main() {\n    let\
    \ candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n\
    \    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpbvhtp07t.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009031
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut min_val = arr[0];\n    let mut maxi = arr[0];\n    for\
    \ i in 1..arr.len() {\n        if arr[i] <= min_val {\n            min_val = arr[i];\n\
    \        } else {\n            if arr[i] > maxi {\n                maxi = arr[i];\n\
    \            }\n        }\n    }\n    arr.len()\n}\n\nfn main() {\n    let candidate\
    \ = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6jlqeiti.rs:22:5\n   |\n\
    10 | fn can_arrange(arr: Vec<isize>) -> isize {\n   |                        \
    \            ----- expected `isize` because of return type\n...\n22 |     arr.len()\n\
    \   |     ^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    22 |     arr.len().try_into().unwrap()\n   |              ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    if arr.is_empty() {\n        return -1;\n    }\n    let mut\
    \ max = 0;\n    let mut index = 0;\n    loop {\n        if arr[index] > arr[index\
    \ - 1] {\n            max = index;\n        }\n        index += 1;\n        if\
    \ index == arr.len() {\n            break;\n        }\n    }\n    max\n}\n\nfn\
    \ main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmph3kcn29c.rs:25:5\n   |\n\
    10 | fn can_arrange(arr: Vec<isize>) -> isize {\n   |                        \
    \            ----- expected `isize` because of return type\n...\n25 |     max\n\
    \   |     ^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize`\
    \ to an `isize` and panic if the converted value doesn't fit\n   |\n25 |     max.try_into().unwrap()\n\
    \   |        ++++++++++++++++++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter().enumerate().max().unwrap_or(-1)\n}\n\nfn main() {\n\
    \    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]),\
    \ 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw0slhkra.rs:11:44\n   |\n\
    11 |     arr.iter().enumerate().max().unwrap_or(-1)\n   |                    \
    \                        ^^ expected tuple, found integer\n   |\n   = note: expected\
    \ tuple `(usize, &isize)`\n               found type `{integer}`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpw0slhkra.rs:11:5\n   |\n10 | fn can_arrange(arr:\
    \ Vec<isize>) -> isize {\n   |                                    ----- expected\
    \ `isize` because of return type\n11 |     arr.iter().enumerate().max().unwrap_or(-1)\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found tuple\n\
    \   |\n   = note: expected type `isize`\n             found tuple `(usize, &isize)`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009031
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    // Sort to quickly find largest element that isn't\n    // greater\
    \ than arr[0]\n    arr.sort_unstable();\n\n    let mut i = 0;\n    while i < arr.len()\
    \ && arr[i] < arr[0] {\n        i += 1;\n    }\n    arr[i].clone() + 1\n}\n\n\
    fn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `arr` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpjea23efr.rs:13:5\n   |\n10 | fn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n   |                --- help: consider changing this to be mutable:\
    \ `mut arr`\n...\n13 |     arr.sort_unstable();\n   |     ^^^^^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut cur = 0;\n    for _ in 0..arr.len() {\n        match\
    \ arr[cur] {\n            v @ _ => return cur,\n            _ => cur = cur + 1,\n\
    \        }\n    }\n    -1\n}\n\nfn main() {\n    let candidate = can_arrange;\n\
    \    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpe9qkuems.rs:14:29\n   |\n\
    14 |             v @ _ => return cur,\n   |                             ^^^ expected\
    \ `isize`, found `usize`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009031
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut max = 0usize;\n\n    for &x in arr.iter() {\n      \
    \  if x <= max {\n            max = x;\n        }\n    }\n    max\n}\n\nfn main()\
    \ {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4,\
    \ 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpysmngrqs.rs:14:17\n   |\n\
    14 |         if x <= max {\n   |                 ^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n14 |         if x <= max.try_into().unwrap() {\n  \
    \ |                    ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpysmngrqs.rs:15:19\n   |\n11 |     let mut max = 0usize;\n   | \
    \                  ------ expected due to this value\n...\n15 |             max\
    \ = x;\n   |                   ^ expected `usize`, found `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpysmngrqs.rs:18:5\n   |\n10 | fn can_arrange(arr:\
    \ Vec<isize>) -> isize {\n   |                                    ----- expected\
    \ `isize` because of return type\n...\n18 |     max\n   |     ^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n18 |     max.try_into().unwrap()\n\
    \   |        ++++++++++++++++++++\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    if arr.is_empty() {\n        return -1;\n    }\n\n    let mut\
    \ max_so_far = arr[0];\n    let mut idx = 0;\n\n    while idx < arr.len() {\n\
    \        let val = arr[idx];\n        if val >= max_so_far {\n            max_so_far\
    \ = val;\n        }\n        idx += 1;\n    }\n\n    return max_so_far;\n}\n\n\
    fn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `3`', /tmp/tmpr1i3am07.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009031
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut cur_i = arr.len() - 1;\n    while cur_i > 0 {\n    \
    \    if arr[cur_i] == arr[cur_i - 1] {\n            return cur_i;\n        }\n\
    \        cur_i--;\n    }\n    -1\n}\n\nfn main() {\n    let candidate = can_arrange;\n\
    \    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmp8l4qvhsy.rs:16:16\n\
    \   |\n16 |         cur_i--;\n   |                ^ expected expression\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8l4qvhsy.rs:14:20\n   |\n14 |             return\
    \ cur_i;\n   |                    ^^^^^ expected `isize`, found `usize`\n   |\n\
    help: you can convert a `usize` to an `isize` and panic if the converted value\
    \ doesn't fit\n   |\n14 |             return cur_i.try_into().unwrap();\n   |\
    \                         ++++++++++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009031
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter()\n        .enumerate()\n        .find_map(|(i, v)|\
    \ {\n            if *v < i && *v > i + 1 {\n                Some(i)\n        \
    \    } else {\n                None\n            }\n        })\n        .unwrap_or(-1)\n\
    }\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpv8gghbhe.rs:14:21\n   |\n\
    14 |             if *v < i && *v > i + 1 {\n   |                     ^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n14 |             if *v <\
    \ i.try_into().unwrap() && *v > i + 1 {\n   |                      ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpv8gghbhe.rs:14:31\n   |\n14 |\
    \             if *v < i && *v > i + 1 {\n   |                               ^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n14 |           \
    \  if *v < i && *v > (i + 1).try_into().unwrap() {\n   |                     \
    \          +     +++++++++++++++++++++\n\nerror[E0600]: cannot apply unary operator\
    \ `-` to type `usize`\n  --> /tmp/tmpv8gghbhe.rs:20:20\n   |\n20 |         .unwrap_or(-1)\n\
    \   |                    ^^\n   |                    |\n   |                 \
    \   cannot apply unary operator `-`\n   |                    help: you may have\
    \ meant the maximum value of `usize`: `usize::MAX`\n   |\n   = note: unsigned\
    \ values cannot be negated\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpv8gghbhe.rs:11:5\n\
    \   |\n10 |   fn can_arrange(arr: Vec<isize>) -> isize {\n   |               \
    \                       ----- expected `isize` because of return type\n11 | /\
    \     arr.iter()\n12 | |         .enumerate()\n13 | |         .find_map(|(i, v)|\
    \ {\n14 | |             if *v < i && *v > i + 1 {\n...  |\n19 | |         })\n\
    20 | |         .unwrap_or(-1)\n   | |______________________^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n20 |         .unwrap_or(-1).try_into().unwrap()\n\
    \   |                       ++++++++++++++++++++\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0600.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    if arr.is_empty() {\n        return -1;\n    }\n\n    arr.iter().fold(0,\
    \ |max_idx, x| match x {\n        Some(x) if x <= max_idx => x,\n        Some(x)\
    \ => max_idx,\n        None => -1,\n    })\n}\n\nfn main() {\n    let candidate\
    \ = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6xviifmb.rs:16:9\n   |\n\
    15 |     arr.iter().fold(0, |max_idx, x| match x {\n   |                     \
    \                      - this expression has type `&isize`\n16 |         Some(x)\
    \ if x <= max_idx => x,\n   |         ^^^^^^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected type `isize`\n              found enum `Option<_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp6xviifmb.rs:17:9\n   |\n15 | \
    \    arr.iter().fold(0, |max_idx, x| match x {\n   |                         \
    \                  - this expression has type `&isize`\n16 |         Some(x) if\
    \ x <= max_idx => x,\n17 |         Some(x) => max_idx,\n   |         ^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6xviifmb.rs:18:9\n\
    \   |\n15 |     arr.iter().fold(0, |max_idx, x| match x {\n   |              \
    \                             - this expression has type `&isize`\n...\n18 | \
    \        None => -1,\n   |         ^^^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected type `isize`\n              found enum `Option<_>`\n\
    \nerror[E0277]: can't compare `&_` with `isize`\n  --> /tmp/tmp6xviifmb.rs:16:22\n\
    \   |\n16 |         Some(x) if x <= max_idx => x,\n   |                      ^^\
    \ no implementation for `&_ < isize` and `&_ > isize`\n   |\n   = help: the trait\
    \ `PartialOrd<isize>` is not implemented for `&_`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp6xviifmb.rs:16:36\n   |\n16 |         Some(x) if x <= max_idx\
    \ => x,\n   |                                    ^ expected `isize`, found reference\n\
    \   |\n   = note:   expected type `isize`\n           found reference `&_`\nhelp:\
    \ consider dereferencing the borrow\n   |\n16 |         Some(x) if x <= max_idx\
    \ => *x,\n   |                                    +\n\nerror: aborting due to\
    \ 5 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009030
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut last = -1;\n    for i in arr {\n        if i > last\
    \ {\n            last = i;\n        }\n    }\n    last\n}\n\nfn main() {\n   \
    \ let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]),\
    \ 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `3`', /tmp/tmpmczttxx8.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009031
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut i = 0;\n    let mut largest = -1;\n    while i < arr.len()\
    \ {\n        if arr[i] <= arr[i+1] {\n            i += 1;\n        } else {\n\
    \            largest = i;\n            i = 1;\n        }\n    }\n    largest\n\
    }\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmxkyks18.rs:21:5\n   |\n\
    10 | fn can_arrange(arr: Vec<isize>) -> isize {\n   |                        \
    \            ----- expected `isize` because of return type\n...\n21 |     largest\n\
    \   |     ^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    21 |     largest.try_into().unwrap()\n   |            ++++++++++++++++++++\n\n\
    error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpmxkyks18.rs:12:23\n\
    \   |\n12 |     let mut largest = -1;\n   |                       ^^ the trait\
    \ `Neg` is not implemented for `usize`\n   |\n   = help: the following other types\
    \ implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n\
    \             &i16\n             &i32\n             &i64\n             &i8\n \
    \            &isize\n           and 8 others\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009031
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    if arr.is_empty() {\n        return -1;\n    }\n    let mut\
    \ largest: usize = arr.iter().rev().fold(0, |max, &i| if *i >= *max { *max = *i\
    \ } else { *max });\n    let mut i = 0;\n    while i < arr.len() && largest ==\
    \ arr[i] {\n        i += 1;\n    }\n    largest\n}\n\nfn main() {\n    let candidate\
    \ = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmp792d5rjm.rs:14:68\n\
    \   |\n14 |     let mut largest: usize = arr.iter().rev().fold(0, |max, &i| if\
    \ *i >= *max { *max = *i } else { *max });\n   |                             \
    \                                       ^^\n\nerror[E0614]: type `usize` cannot\
    \ be dereferenced\n  --> /tmp/tmp792d5rjm.rs:14:74\n   |\n14 |     let mut largest:\
    \ usize = arr.iter().rev().fold(0, |max, &i| if *i >= *max { *max = *i } else\
    \ { *max });\n   |                                                           \
    \               ^^^^\n\nerror[E0614]: type `usize` cannot be dereferenced\n  -->\
    \ /tmp/tmp792d5rjm.rs:14:81\n   |\n14 |     let mut largest: usize = arr.iter().rev().fold(0,\
    \ |max, &i| if *i >= *max { *max = *i } else { *max });\n   |                \
    \                                                                 ^^^^\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmp792d5rjm.rs:14:88\n   |\n\
    14 |     let mut largest: usize = arr.iter().rev().fold(0, |max, &i| if *i >=\
    \ *max { *max = *i } else { *max });\n   |                                   \
    \                                                     ^^\n\nerror[E0614]: type\
    \ `usize` cannot be dereferenced\n  --> /tmp/tmp792d5rjm.rs:14:100\n   |\n14 |\
    \     let mut largest: usize = arr.iter().rev().fold(0, |max, &i| if *i >= *max\
    \ { *max = *i } else { *max });\n   |                                        \
    \                                                            ^^^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp792d5rjm.rs:16:39\n   |\n16 |     while i <\
    \ arr.len() && largest == arr[i] {\n   |                                     \
    \  ^^^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n16 |     while\
    \ i < arr.len() && largest == arr[i].try_into().unwrap() {\n   |             \
    \                                ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp792d5rjm.rs:19:5\n   |\n10 | fn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n   |                         "
  stdout: ''
  timestamp: 1660009031
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    if arr.is_empty() {\n        return -1;\n    }\n    let mut\
    \ i = arr.len() - 1;\n    while i > 0  {\n        if arr[i] < arr[i-1] {\n   \
    \         return i;\n        }\n        i -= 1;\n    }\n    return -1;\n}\n\n\
    fn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptsbw5eus.rs:17:20\n   |\n\
    17 |             return i;\n   |                    ^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |             return i.try_into().unwrap();\n\
    \   |                     ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009031
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut largest = -1;\n    let mut i = 0;\n    while i < arr.len()\
    \ && arr[i] >= arr[0] {\n        if largest == -1 {\n            largest = i;\n\
    \        } else {\n            largest = cmp::max(largest, i);\n        }\n  \
    \      i += 1;\n    }\n    largest\n}\n\nfn main() {\n    let candidate = can_arrange;\n\
    \    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmpvbzwepkr.rs:17:23\n   |\n17 |             largest = cmp::max(largest,\
    \ i);\n   |                       ^^^ use of undeclared crate or module `cmp`\n\
    \nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpvbzwepkr.rs:11:23\n\
    \   |\n11 |     let mut largest = -1;\n   |                       ^^ the trait\
    \ `Neg` is not implemented for `usize`\n   |\n   = help: the following other types\
    \ implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n\
    \             &i16\n             &i32\n             &i64\n             &i8\n \
    \            &isize\n           and 8 others\n\nerror[E0277]: the trait bound\
    \ `usize: Neg` is not satisfied\n  --> /tmp/tmpvbzwepkr.rs:14:23\n   |\n14 | \
    \        if largest == -1 {\n   |                       ^^ the trait `Neg` is\
    \ not implemented for `usize`\n   |\n   = help: the following other types implement\
    \ trait `Neg`:\n             &f32\n             &f64\n             &i128\n   \
    \          &i16\n             &i32\n             &i64\n             &i8\n    \
    \         &isize\n           and 8 others\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpvbzwepkr.rs:21:5\n   |\n10 | fn can_arrange(arr: Vec<isize>) ->\
    \ isize {\n   |                                    ----- expected `isize` because\
    \ of return type\n...\n21 |     largest\n   |     ^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n21 |     largest.try_into().unwrap()\n  \
    \ |            ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009031
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter().skip(1).fold(\n        -1, |max, &i| if *i < max\
    \ { *i } else { max },\n    )\n}\n\nfn main() {\n    let candidate = can_arrange;\n\
    \    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmp5_60xiuo.rs:12:26\n\
    \   |\n12 |         -1, |max, &i| if *i < max { *i } else { max },\n   |     \
    \                     ^^\n\nerror[E0614]: type `isize` cannot be dereferenced\n\
    \  --> /tmp/tmp5_60xiuo.rs:12:37\n   |\n12 |         -1, |max, &i| if *i < max\
    \ { *i } else { max },\n   |                                     ^^\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1660009031
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter().rev().enumerate().filter(|(i, &x)| x > 1).last().unwrap_or(-1)\n\
    }\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpm1nx_jtj.rs:11:75\n   |\n\
    11 |     arr.iter().rev().enumerate().filter(|(i, &x)| x > 1).last().unwrap_or(-1)\n\
    \   |                                                                        \
    \   ^^ expected tuple, found integer\n   |\n   = note: expected tuple `(usize,\
    \ &isize)`\n               found type `{integer}`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpm1nx_jtj.rs:11:5\n   |\n10 | fn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n   |                                    ----- expected `isize` because\
    \ of return type\n11 |     arr.iter().rev().enumerate().filter(|(i, &x)| x > 1).last().unwrap_or(-1)\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found tuple\n   |\n   = note: expected type `isize`\n    \
    \         found tuple `(usize, &isize)`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009031
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut max: Option<isize> = None;\n    for x in arr.iter().skip(1)\
    \ {\n        if let Some(y) = max {\n            if x < y {\n                max\
    \ = Some(x + 1);\n            } else {\n                max = Some(y);\n     \
    \       }\n        } else {\n            max = Some(x);\n        }\n    }\n  \
    \  max.unwrap_or(arr.len())\n}\n\nfn main() {\n    let candidate = can_arrange;\n\
    \    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpiyjqvn61.rs:14:20\n   |\n\
    14 |             if x < y {\n   |                    ^\n   |                 \
    \   |\n   |                    expected `&isize`, found `isize`\n   |        \
    \            help: consider borrowing here: `&y`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpiyjqvn61.rs:20:24\n   |\n20 |             max = Some(x);\n   |\
    \                        ^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n20 |             max = Some(*x);\n   |     \
    \                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpiyjqvn61.rs:23:19\n\
    \   |\n23 |     max.unwrap_or(arr.len())\n   |                   ^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n23 |     max.unwrap_or(arr.len().try_into().unwrap())\n\
    \   |                            ++++++++++++++++++++\n\nerror: aborting due to\
    \ 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660009031
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    if arr.iter().fold(0, |max, &x| if max <= x { max } else { max\
    \ }) <= arr.iter().last().unwrap() {\n        arr.iter().last().unwrap()\n   \
    \ } else {\n        -1\n    }\n}\n\nfn main() {\n    let candidate = can_arrange;\n\
    \    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpm1r98dwu.rs:11:74\n   |\n\
    11 |     if arr.iter().fold(0, |max, &x| if max <= x { max } else { max }) <=\
    \ arr.iter().last().unwrap() {\n   |                                         \
    \                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n11 |  \
    \   if arr.iter().fold(0, |max, &x| if max <= x { max } else { max }) <= *arr.iter().last().unwrap()\
    \ {\n   |                                                                    \
    \      +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpm1r98dwu.rs:12:9\n \
    \  |\n10 | fn can_arrange(arr: Vec<isize>) -> isize {\n   |                  \
    \                  ----- expected `isize` because of return type\n11 |     if\
    \ arr.iter().fold(0, |max, &x| if max <= x { max } else { max }) <= arr.iter().last().unwrap()\
    \ {\n12 |         arr.iter().last().unwrap()\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n12 |         *arr.iter().last().unwrap()\n   |         +\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009031
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut i = arr.len() - 1;\n    loop {\n        if i < *arr.binary_search(&arr[0])\
    \ {\n            break;\n        }\n        i -= 1;\n    }\n    i\n}\n\nfn main()\
    \ {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4,\
    \ 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `Result<usize, usize>` cannot be dereferenced\n  -->\
    \ /tmp/tmpb01jkne9.rs:13:16\n   |\n13 |         if i < *arr.binary_search(&arr[0])\
    \ {\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpb01jkne9.rs:18:5\n   |\n10 | fn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n   |                                    ----- expected `isize` because\
    \ of return type\n...\n18 |     i\n   |     ^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n18 |     i.try_into().unwrap()\n   |      ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0614.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009031
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut arr_idx = arr.len();\n    loop {\n        arr_idx -=\
    \ 1;\n        if arr[arr_idx] > arr[arr_idx - 1] {\n            return arr_idx\
    \ - 1;\n        }\n    }\n}\n\nfn main() {\n    let candidate = can_arrange;\n\
    \    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc1f95myf.rs:15:20\n   |\n\
    15 |             return arr_idx - 1;\n   |                    ^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n15 |             return\
    \ (arr_idx - 1).try_into().unwrap();\n   |                    +           +++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009031
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    debug_assert!(!arr.is_empty());\n    let mut i = 0;\n    let\
    \ mut largest = i;\n    for el in arr.iter().rev() {\n        if el > arr[i] {\n\
    \            largest = i;\n        }\n        i += 1;\n    }\n    largest\n}\n\
    \nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1m8k8jxj.rs:15:17\n   |\n\
    15 |         if el > arr[i] {\n   |                 ^^^^^^\n   |             \
    \    |\n   |                 expected `&isize`, found `isize`\n   |          \
    \       help: consider borrowing here: `&arr[i]`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp1m8k8jxj.rs:20:5\n   |\n10 | fn can_arrange(arr: Vec<isize>) ->\
    \ isize {\n   |                                    ----- expected `isize` because\
    \ of return type\n...\n20 |     largest\n   |     ^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n20 |     largest.try_into().unwrap()\n  \
    \ |            ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009031
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    if arr.is_empty() {\n        return -1;\n    }\n    let mut\
    \ cur = arr.iter().skip(1).find(|&x| *x >= *arr.iter().skip(1).next()) != Some(arr.iter().skip(1).next());\n\
    \    for i in arr.iter().skip(1).rev() {\n        if *i < cur {\n            cur\
    \ = i;\n        }\n    }\n    cur\n}\n\nfn main() {\n    let candidate = can_arrange;\n\
    \    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `Option<&isize>` cannot be dereferenced\n  --> /tmp/tmp0ryjouek.rs:14:54\n\
    \   |\n14 |     let mut cur = arr.iter().skip(1).find(|&x| *x >= *arr.iter().skip(1).next())\
    \ != Some(arr.iter().skip(1).next());\n   |                                  \
    \                    ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp0ryjouek.rs:14:90\n   |\n14 |     let mut cur = arr.iter().skip(1).find(|&x|\
    \ *x >= *arr.iter().skip(1).next()) != Some(arr.iter().skip(1).next());\n   |\
    \                                                                            \
    \              ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&isize`, found enum `Option`\n\
    \   |\n   = note: expected reference `&isize`\n                   found enum `Option<&isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp0ryjouek.rs:16:17\n   |\n16 |\
    \         if *i < cur {\n   |                 ^^^ expected `isize`, found `bool`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp0ryjouek.rs:17:19\n   |\n14 |\
    \     let mut cur = arr.iter().skip(1).find(|&x| *x >= *arr.iter().skip(1).next())\
    \ != Some(arr.iter().skip(1).next());\n   |                   -------------------------------------------------------------------------------------------------\
    \ expected due to this value\n...\n17 |             cur = i;\n   |           \
    \        ^ expected `bool`, found `&isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp0ryjouek.rs:20:5\n   |\n10 | fn can_arrange(arr: Vec<isize>) ->\
    \ isize {\n   |                                    ----- expected `isize` because\
    \ of return type\n...\n20 |     cur\n   |     ^^^ expected `isize`, found `bool`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0614.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009031
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut largest: isize = 0;\n    let mut index = arr.len() -\
    \ 1;\n    while index > 0 {\n        let elem = arr[index];\n        if elem <\
    \ largest {\n            return -1;\n        }\n        largest = elem;\n    \
    \    index -= 1;\n    }\n    largest\n}\n\nfn main() {\n    let candidate = can_arrange;\n\
    \    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-1`,\n right: `3`', /tmp/tmp_z3rntf4.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009031
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut max_index = 0;\n    let mut i = 1;\n    while i <= arr.len()\
    \ {\n        if arr[i] > arr[max_index] {\n            max_index = i;\n      \
    \  }\n        i += 1;\n    }\n    -1\n}\n\nfn main() {\n    let candidate = can_arrange;\n\
    \    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 5 but the
    index is 5'', /tmp/tmprm2dnqut.rs:14:12

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660009031
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut can = 1\n    for &el in arr.iter().rev() {\n       \
    \ if el >= can {\n            can = el + 1\n        }\n    }\n    can\n}\n\nfn\
    \ main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found keyword `for`\n  --> /tmp/tmpw0jm60lu.rs:11:20\n\
    \   |\n11 |     let mut can = 1\n   |                    ^ help: add `;` here\n\
    12 |     for &el in arr.iter().rev() {\n   |     --- unexpected token\n\nerror:\
    \ aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1660009031
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter()\n        .enumerate()\n        .max_by_key(|(i, v)|\
    \ {\n            if i > 0 {\n                if *v >= *arr[i - 1] {\n        \
    \            Some(i)\n                } else {\n                    None\n   \
    \             }\n            } else {\n                Some(i)\n            }\n\
    \        })\n        .unwrap_or_else(|| arr.len())\n}\n\nfn main() {\n    let\
    \ candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n\
    \    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpq82sd1nr.rs:14:20\n   |\n\
    14 |             if i > 0 {\n   |                    ^\n   |                 \
    \   |\n   |                    expected `&usize`, found integer\n   |        \
    \            help: consider borrowing here: `&0`\n\nerror[E0614]: type `isize`\
    \ cannot be dereferenced\n  --> /tmp/tmpq82sd1nr.rs:15:26\n   |\n15 |        \
    \         if *v >= *arr[i - 1] {\n   |                          ^^^^^^^^^^^\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpq82sd1nr.rs:24:28\n   |\n24 |  \
    \       .unwrap_or_else(|| arr.len())\n   |                            ^^^^^^^^^\
    \ expected tuple, found `usize`\n   |\n   = note: expected tuple `(usize, &isize)`\n\
    \               found type `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq82sd1nr.rs:11:5\n\
    \   |\n10 |   fn can_arrange(arr: Vec<isize>) -> isize {\n   |               \
    \                       ----- expected `isize` because of return type\n11 | /\
    \     arr.iter()\n12 | |         .enumerate()\n13 | |         .max_by_key(|(i,\
    \ v)| {\n14 | |             if i > 0 {\n...  |\n23 | |         })\n24 | |    \
    \     .unwrap_or_else(|| arr.len())\n   | |_____________________________________^\
    \ expected `isize`, found tuple\n   |\n   = note: expected type `isize`\n    \
    \         found tuple `(usize, &isize)`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0614.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009031
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    can_arrange_impl(arr, vec![])\n}\n\nfn main() {\n    let candidate\
    \ = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `can_arrange_impl` in this scope\n \
    \ --> /tmp/tmpvvxobfkf.rs:11:5\n   |\n11 |     can_arrange_impl(arr, vec![])\n\
    \   |     ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009031
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut max_index = 0;\n    let mut max_value = arr[0];\n  \
    \  for i in 1..arr.len() {\n        if arr[i] > max_value {\n            max_value\
    \ = arr[i];\n            max_index = i;\n        }\n    }\n    \n    if max_index\
    \ == arr.len() - 1 {\n        -1\n    } else if max_index == 0 {\n        arr.len()\
    \ - 1\n    } else {\n        max_index\n    }\n}\n\nfn main() {\n    let candidate\
    \ = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl3i9q1d7.rs:23:9\n   |\n\
    10 | fn can_arrange(arr: Vec<isize>) -> isize {\n   |                        \
    \            ----- expected `isize` because of return type\n...\n23 |        \
    \ arr.len() - 1\n   |         ^^^^^^^^^^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |         (arr.len() - 1).try_into().unwrap()\n\
    \   |         +             +++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpl3i9q1d7.rs:25:9\n   |\n10 | fn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n   |                                    ----- expected `isize` because\
    \ of return type\n...\n25 |         max_index\n   |         ^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n25 |         max_index.try_into().unwrap()\n\
    \   |                  ++++++++++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009031
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    if arr.len() == 0 {\n        return -1;\n    }\n\n    let mut\
    \ max: isize = 0;\n\n    for &x in arr {\n        if x >= max {\n            max\
    \ = x;\n        }\n    }\n\n    if max >= arr.len() {\n        return -1;\n  \
    \  }\n\n    max\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzvqdv0g1.rs:17:9\n   |\n\
    17 |     for &x in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpzvqdv0g1.rs:23:15\n   |\n23 |     if max >= arr.len() {\n   | \
    \              ^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n23 |     if max >= arr.len().try_into().unwrap() {\n   |              \
    \          ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009031
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    if arr.len() == 0 {\n        return -1;\n    }\n\n    let mut\
    \ largest = arr.iter().skip(1).max().unwrap();\n    for i in arr.iter().rev()\
    \ {\n        if i <= largest {\n            largest = i;\n        }\n    }\n \
    \   largest\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp62hbfe44.rs:21:5\n   |\n\
    10 | fn can_arrange(arr: Vec<isize>) -> isize {\n   |                        \
    \            ----- expected `isize` because of return type\n...\n21 |     largest\n\
    \   |     ^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n21 |     *largest\n   |     +\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009031
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut i = 0;\n    let mut max_elem = -1;\n    for &x in arr.iter()\
    \ {\n        if x > i {\n            max_elem = x;\n        }\n        i += 1;\n\
    \    }\n    if max_elem == -1 {\n        return -1;\n    }\n    return max_elem;\n\
    }\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `3`', /tmp/tmphos11wn6.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009031
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut max: isize = 0;\n    let mut index = 0;\n    for i in\
    \ arr.iter().rev() {\n        if *i < *arr[index] {\n            max = i;\n  \
    \      }\n        if *i == *arr[index] {\n            max = index as isize;\n\
    \            index += 1;\n        }\n    }\n    if index == arr.len() {\n    \
    \    -1\n    } else {\n        max\n    }\n}\n\nfn main() {\n    let candidate\
    \ = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmp7wqn9i4f.rs:14:17\n\
    \   |\n14 |         if *i < *arr[index] {\n   |                 ^^^^^^^^^^^\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp7wqn9i4f.rs:15:19\n   |\n11 |  \
    \   let mut max: isize = 0;\n   |                  ----- expected due to this\
    \ type\n...\n15 |             max = i;\n   |                   ^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n15 |  \
    \           max = *i;\n   |                   +\n\nerror[E0614]: type `isize`\
    \ cannot be dereferenced\n  --> /tmp/tmp7wqn9i4f.rs:17:18\n   |\n17 |        \
    \ if *i == *arr[index] {\n   |                  ^^^^^^^^^^^\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0614.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009031
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut i = 0;\n    for &e in &arr {\n        if i > 0\n   \
    \         && (e - &arr[i - 1])\n                >= (arr.len() - i)\n        {\n\
    \            return i;\n        }\n        i += 1;\n    }\n    -1\n}\n\nfn main()\
    \ {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4,\
    \ 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjzuujw8d.rs:15:20\n   |\n\
    15 |                 >= (arr.len() - i)\n   |                    ^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n15 |           \
    \      >= ((arr.len() - i)).try_into().unwrap()\n   |                    +   \
    \            +++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjzuujw8d.rs:17:20\n\
    \   |\n17 |             return i;\n   |                    ^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n17 |             return i.try_into().unwrap();\n\
    \   |                     ++++++++++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009031
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut max_so_far: isize = -1;\n    let mut current_so_far:\
    \ isize = -1;\n\n    for num in arr.iter() {\n        if current_so_far > num\
    \ {\n            current_so_far = num;\n        }\n\n        if current_so_far\
    \ > max_so_far {\n            max_so_far = current_so_far;\n        }\n    }\n\
    \n    max_so_far\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp73latuqs.rs:15:29\n   |\n\
    15 |         if current_so_far > num {\n   |                             ^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    15 |         if current_so_far > *num {\n   |                             +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp73latuqs.rs:16:30\n   |\n12 |  \
    \   let mut current_so_far: isize = -1;\n   |                             -----\
    \ expected due to this type\n...\n16 |             current_so_far = num;\n   |\
    \                              ^^^ expected `isize`, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n16 |             current_so_far = *num;\n\
    \   |                              +\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009031
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    if arr.is_empty() {\n        return -1;\n    }\n    for i in\
    \ 0..arr.len() - 1 {\n        if arr[i] > arr[i+1] {\n            return i;\n\
    \        }\n    }\n    arr.len() - 1\n}\n\nfn main() {\n    let candidate = can_arrange;\n\
    \    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpoasun5pz.rs:16:20\n   |\n\
    16 |             return i;\n   |                    ^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n16 |             return i.try_into().unwrap();\n\
    \   |                     ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpoasun5pz.rs:19:5\n   |\n10 | fn can_arrange(arr: Vec<isize>) ->\
    \ isize {\n   |                                    ----- expected `isize` because\
    \ of return type\n...\n19 |     arr.len() - 1\n   |     ^^^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n19 |     (arr.len() - 1).try_into().unwrap()\n\
    \   |     +             +++++++++++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009031
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut res = vec![false; arr.len()];\n    let mut last_idx\
    \ = -1;\n    for i in arr.iter().enumerate() {\n        if i != arr.len() - 1\
    \ {\n            if let Some(&true) = res[arr.len() - 1 - i] {\n             \
    \   return -1;\n            }\n        }\n        if let Some(&true) = res[i]\
    \ {\n            last_idx = i;\n        }\n        res[i] = true;\n    }\n   \
    \ arr.len() - last_idx\n}\n\nfn main() {\n    let candidate = can_arrange;\n \
    \   assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb0z9p2z6.rs:14:17\n   |\n\
    14 |         if i != arr.len() - 1 {\n   |                 ^^^^^^^^^^^^^ expected\
    \ tuple, found `usize`\n   |\n   = note: expected tuple `(usize, &isize)`\n  \
    \             found type `usize`\n\nerror[E0277]: cannot subtract `(usize, &isize)`\
    \ from `usize`\n  --> /tmp/tmpb0z9p2z6.rs:15:52\n   |\n15 |             if let\
    \ Some(&true) = res[arr.len() - 1 - i] {\n   |                               \
    \                     ^ no implementation for `usize - (usize, &isize)`\n   |\n\
    \   = help: the trait `Sub<(usize, &isize)>` is not implemented for `usize`\n\
    \   = help: the following other types implement trait `Sub<Rhs>`:\n          \
    \   <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n             <&'a\
    \ i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n             <&'a i32\
    \ as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n\
    \             <&'a isize as Sub<isize>>\n           and 48 others\n\nerror[E0277]:\
    \ the type `[bool]` cannot be indexed by `(usize, &isize)`\n  --> /tmp/tmpb0z9p2z6.rs:19:30\n\
    \   |\n19 |         if let Some(&true) = res[i] {\n   |                      \
    \        ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n\
    \   = help: the trait `SliceIndex<[bool]>` is not implemented for `(usize, &isize)`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `(Bound<usize>, Bound<usize>)`\n\
    \   = note: required because of the requirements on the impl of `Index<(usize,\
    \ &isize)>` for `Vec<bool>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb0z9p2z6.rs:20:24\n\
    \   |\n12 |     let mut last_idx = -1;\n   |                        -- expected\
    \ due to this value\n...\n20 |             last_idx = i;\n   |               \
    \         ^ expected integer, found tuple\n   |\n   = note: expected type `{integer}`\n\
    \             found tuple `(usize, &isize)`\n\nerror[E0277]: the type `[bool]`\
    \ cannot be indexed by `(usize, &isize)`\n  --> /tmp/tmpb0z9p2z6.rs:22:9\n   |\n\
    22 |         res[i] = true;\n   |         ^^^^^^ slice indices are of type `usize`\
    \ or ranges of `u"
  stdout: ''
  timestamp: 1660009031
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter().rev().max_by_key(|&i| i).unwrap() - 1\n}\n\nfn main()\
    \ {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4,\
    \ 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpmvv58x1f.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009031
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n   \
    \ arr.sort();\n    arr.iter().enumerate().find(|&(i, _)| arr[i] != arr[i-1])\n\
    \        .map(|(idx, _)| idx)\n        .unwrap_or(-1)\n}\n\nfn main() {\n    let\
    \ candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n\
    \    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0600]: cannot apply unary operator `-` to type `usize`\n  --> /tmp/tmppw6eujxx.rs:15:20\n\
    \   |\n15 |         .unwrap_or(-1)\n   |                    ^^\n   |         \
    \           |\n   |                    cannot apply unary operator `-`\n   | \
    \                   help: you may have meant the maximum value of `usize`: `usize::MAX`\n\
    \   |\n   = note: unsigned values cannot be negated\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmppw6eujxx.rs:13:5\n   |\n10 |   fn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n   |                                      ----- expected `isize`\
    \ because of return type\n...\n13 | /     arr.iter().enumerate().find(|&(i, _)|\
    \ arr[i] != arr[i-1])\n14 | |         .map(|(idx, _)| idx)\n15 | |         .unwrap_or(-1)\n\
    \   | |______________________^ expected `isize`, found `usize`\n   |\nhelp: you\
    \ can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n15 |         .unwrap_or(-1).try_into().unwrap()\n   |           \
    \            ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0600.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009031
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut res = -1;\n    let mut it1 = arr.iter();\n    it1.next();\n\
    \    for e in arr.iter().rev() {\n        if !it1.next().is_ok() {\n         \
    \   res = e;\n            break;\n        }\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]),\
    \ 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ok` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmppbq3nzpd.rs:15:24\n   |\n15 |         if !it1.next().is_ok()\
    \ {\n   |                        ^^^^^ method not found in `Option<&isize>`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmppbq3nzpd.rs:16:19\n   |\n11 |  \
    \   let mut res = -1;\n   |                   -- expected due to this value\n\
    ...\n16 |             res = e;\n   |                   ^ expected integer, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n16 |        \
    \     res = *e;\n   |                   +\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009031
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    debug_assert!(!arr.is_empty());\n    let mut idx: usize = 0;\n\
    \    while idx < arr.len() && arr[idx] <= arr[idx - 1] {\n        idx += 1;\n\
    \    }\n    idx\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk2h4z7_8.rs:16:5\n   |\n\
    10 | fn can_arrange(arr: Vec<isize>) -> isize {\n   |                        \
    \            ----- expected `isize` because of return type\n...\n16 |     idx\n\
    \   |     ^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize`\
    \ to an `isize` and panic if the converted value doesn't fit\n   |\n16 |     idx.try_into().unwrap()\n\
    \   |        ++++++++++++++++++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009031
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut max = -1;\n    let mut i = 1;\n    for n in arr {\n\
    \        if n >= max {\n            max = n;\n            i = 1;\n        } else\
    \ {\n            i += 1;\n        }\n    }\n    max\n}\n\nfn main() {\n    let\
    \ candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n\
    \    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `3`', /tmp/tmp63i39gfi.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009031
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut i = 0;\n    let mut max = i;\n    while i < arr.len()\
    \ && arr[i] <= arr[i..].iter().max().unwrap() {\n        i += 1;\n    }\n    max\n\
    }\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1ph3nw18.rs:13:38\n   |\n\
    13 |     while i < arr.len() && arr[i] <= arr[i..].iter().max().unwrap() {\n \
    \  |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    13 |     while i < arr.len() && arr[i] <= *arr[i..].iter().max().unwrap() {\n\
    \   |                                      +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp1ph3nw18.rs:16:5\n   |\n10 | fn can_arrange(arr: Vec<isize>) ->\
    \ isize {\n   |                                    ----- expected `isize` because\
    \ of return type\n...\n16 |     max\n   |     ^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |     max.try_into().unwrap()\n   |        ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009031
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    if arr.len() == 1 {\n        return arr.iter().max().unwrap_or(-1);\n\
    \    }\n    let mut low = arr[0];\n    let mut high = arr[0];\n    for i in 1..arr.len()\
    \ {\n        if arr[i] > high {\n            high = arr[i];\n        } else if\
    \ arr[i] < low {\n            low = arr[i];\n        }\n    }\n    high\n}\n\n\
    fn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4vi_vezy.rs:12:43\n   |\n\
    12 |         return arr.iter().max().unwrap_or(-1);\n   |                    \
    \                       ^^\n   |                                           |\n\
    \   |                                           expected `&isize`, found integer\n\
    \   |                                           help: consider borrowing here:\
    \ `&-1`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4vi_vezy.rs:12:16\n \
    \  |\n10 | fn can_arrange(arr: Vec<isize>) -> isize {\n   |                  \
    \                  ----- expected `isize` because of return type\n11 |     if\
    \ arr.len() == 1 {\n12 |         return arr.iter().max().unwrap_or(-1);\n   |\
    \                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n12 |         return *arr.iter().max().unwrap_or(-1);\n\
    \   |                +\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009031
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    // Return the first index which is greater than or equal to\
    \ the previous\n    // element.\n    for i in 0..arr.len() - 1 {\n        if arr[i]\
    \ >= arr[i + 1] {\n            return i;\n        }\n    }\n    -1\n}\n\nfn main()\
    \ {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4,\
    \ 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpclp_lzju.rs:15:20\n   |\n\
    15 |             return i;\n   |                    ^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n15 |             return i.try_into().unwrap();\n\
    \   |                     ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009031
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut max_index = 0;\n    for i in arr.iter().rev() {\n  \
    \      if i > max_index {\n            max_index = i;\n        }\n    }\n    -1\n\
    }\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphmhyq20q.rs:13:16\n   |\n\
    13 |         if i > max_index {\n   |                ^^^^^^^^^\n   |         \
    \       |\n   |                expected `&isize`, found integer\n   |        \
    \        help: consider borrowing here: `&max_index`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmphmhyq20q.rs:14:25\n   |\n11 |     let mut max_index = 0;\n\
    \   |                         - expected due to this value\n...\n14 |        \
    \     max_index = i;\n   |                         ^ expected integer, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n14 |             max_index\
    \ = *i;\n   |                         +\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009031
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut max_idx = 0;\n    for i in 0..arr.len() {\n        if\
    \ arr[i] > arr[i..i].last_option().unwrap() {\n            max_idx = i;\n    \
    \    }\n    }\n    max_idx\n}\n\nfn main() {\n    let candidate = can_arrange;\n\
    \    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `last_option` found for slice `[isize]` in\
    \ the current scope\n  --> /tmp/tmpdc1a8cng.rs:13:31\n   |\n13 |         if arr[i]\
    \ > arr[i..i].last_option().unwrap() {\n   |                               ^^^^^^^^^^^\
    \ method not found in `[isize]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdc1a8cng.rs:17:5\n\
    \   |\n10 | fn can_arrange(arr: Vec<isize>) -> isize {\n   |                 \
    \                   ----- expected `isize` because of return type\n...\n17 | \
    \    max_idx\n   |     ^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you\
    \ can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n17 |     max_idx.try_into().unwrap()\n   |            ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009031
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    if arr.len() <= 1 {\n        return -1;\n    }\n\n    let mut\
    \ idx = 1;\n    let mut max = arr[0];\n\n    while idx < arr.len() {\n       \
    \ if arr[idx] >= max {\n            max = arr[idx];\n            idx++;\n    \
    \    }\n    }\n    idx\n}\n\nfn main() {\n    let candidate = can_arrange;\n \
    \   assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpp385kir1.rs:21:16\n\
    \   |\n21 |             idx++;\n   |                ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n21 |             { let tmp = idx; idx +=\
    \ 1; tmp };\n   |             +++++++++++    ~~~~~~~~~~~~~~~~~\n21 -         \
    \    idx++;\n21 +             idx += 1;\n   | \n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpp385kir1.rs:24:5\n   |\n10 | fn can_arrange(arr: Vec<isize>) ->\
    \ isize {\n   |                                    ----- expected `isize` because\
    \ of return type\n...\n24 |     idx\n   |     ^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n24 |     idx.try_into().unwrap()\n   |        ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009031
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    for i in 1..arr.len() {\n        if arr[i-1] > arr[i] {\n  \
    \          return i;\n        }\n    }\n\n    -1\n}\n\nfn main() {\n    let candidate\
    \ = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwx7kl4g7.rs:13:20\n   |\n\
    13 |             return i;\n   |                    ^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n13 |             return i.try_into().unwrap();\n\
    \   |                     ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009031
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut i = 0;\n    loop {\n        if i > 0 && arr[i] > arr[i-1]\
    \ {\n            return i - 1;\n        }\n        i += 1;\n    }\n}\n\nfn main()\
    \ {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4,\
    \ 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpktixgvus.rs:14:20\n   |\n\
    14 |             return i - 1;\n   |                    ^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n14 |             return (i - 1).try_into().unwrap();\n\
    \   |                    +     +++++++++++++++++++++\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660009031
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut i = 0;\n    while i < arr.len() && arr[i] < arr[i+1]\
    \ {\n        i += 1;\n    }\n    i + 1\n}\n\nfn main() {\n    let candidate =\
    \ can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj47nldp9.rs:15:5\n   |\n\
    10 | fn can_arrange(arr: Vec<isize>) -> isize {\n   |                        \
    \            ----- expected `isize` because of return type\n...\n15 |     i +\
    \ 1\n   |     ^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    15 |     (i + 1).try_into().unwrap()\n   |     +     +++++++++++++++++++++\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009031
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    if arr.iter().all(|&x| x > arr.iter().nth(0)).unwrap_or(true)\
    \ {\n        -1\n    } else {\n        arr.iter().max_by(|&x, &y| x<y).unwrap_or(-1).unwrap()\n\
    \    }\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxvomfvzb.rs:11:32\n   |\n\
    11 |     if arr.iter().all(|&x| x > arr.iter().nth(0)).unwrap_or(true) {\n   |\
    \                                ^^^^^^^^^^^^^^^^^ expected `isize`, found enum\
    \ `Option`\n   |\n   = note: expected type `isize`\n              found enum `Option<&isize>`\n\
    \nerror[E0599]: no method named `unwrap_or` found for type `bool` in the current\
    \ scope\n  --> /tmp/tmpxvomfvzb.rs:11:51\n   |\n11 |     if arr.iter().all(|&x|\
    \ x > arr.iter().nth(0)).unwrap_or(true) {\n   |                             \
    \                      ^^^^^^^^^ method not found in `bool`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpxvomfvzb.rs:14:36\n   |\n14 |         arr.iter().max_by(|&x,\
    \ &y| x<y).unwrap_or(-1).unwrap()\n   |                                    ^^^\
    \ expected enum `std::cmp::Ordering`, found `bool`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpxvomfvzb.rs:14:51\n   |\n14 |         arr.iter().max_by(|&x,\
    \ &y| x<y).unwrap_or(-1).unwrap()\n   |                                      \
    \             ^^\n   |                                                   |\n \
    \  |                                                   expected `&isize`, found\
    \ integer\n   |                                                   help: consider\
    \ borrowing here: `&-1`\n\nerror[E0599]: no method named `unwrap` found for reference\
    \ `&isize` in the current scope\n  --> /tmp/tmpxvomfvzb.rs:14:55\n   |\n14 | \
    \        arr.iter().max_by(|&x, &y| x<y).unwrap_or(-1).unwrap()\n   |        \
    \                                               ^^^^^^ method not found in `&isize`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009031
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut max = -1;\n    let mut i = 0;\n    while i != arr.len()\
    \ {\n        if max < i {\n            max = i;\n        }\n        let mut j\
    \ = i;\n        while j != arr.len() {\n            j = arr.binary_search(&arr[j],\
    \ |&x| x > arr[j - 1]);\n            if j == 0 {\n                break;\n   \
    \         }\n            i = j;\n        }\n    }\n    max\n}\n\nfn main() {\n\
    \    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]),\
    \ 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp8tbh0hrb.rs:11:19\n\
    \   |\n11 |     let mut max = -1;\n   |                   ^^ the trait `Neg` is\
    \ not implemented for `usize`\n   |\n   = help: the following other types implement\
    \ trait `Neg`:\n             &f32\n             &f64\n             &i128\n   \
    \          &i16\n             &i32\n             &i64\n             &i8\n    \
    \         &isize\n           and 8 others\n\nerror[E0061]: this function takes\
    \ 1 argument but 2 arguments were supplied\n    --> /tmp/tmp8tbh0hrb.rs:19:21\n\
    \     |\n19   |             j = arr.binary_search(&arr[j], |&x| x > arr[j - 1]);\n\
    \     |                     ^^^^^^^^^^^^^ -------  ------------------- supplied\
    \ 2 arguments\n     |                     |\n     |                     expected\
    \ 1 argument\n     |\nnote: associated function defined here\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8tbh0hrb.rs:19:17\n   |\n17 |         let mut\
    \ j = i;\n   |                     - expected due to this value\n18 |        \
    \ while j != arr.len() {\n19 |             j = arr.binary_search(&arr[j], |&x|\
    \ x > arr[j - 1]);\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `usize`, found enum `Result`\n   |\n   = note: expected type `usize`\n\
    \              found enum `Result<usize, usize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp8tbh0hrb.rs:26:5\n   |\n10 | fn can_arrange(arr: Vec<isize>) ->\
    \ isize {\n   |                                    ----- expected `isize` because\
    \ of return type\n...\n26 |     max\n   |     ^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n26 |     max.try_into().unwrap()\n   |        ++++++++++++++++++++\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0277, E0308.\nFor more information about an error, try `rustc --explain\
    \ E0061`.\n"
  stdout: ''
  timestamp: 1660009031
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    // Create a stack of candidate indices that will allow us to\
    \ return -1 if\n    // no such element exists.\n    let mut stack = vec![];\n\
    \    for i in arr.iter().cloned() {\n        stack.push(i);\n    }\n    let mut\
    \ i = 0;\n    while i < stack.len() {\n        let j = i + 1;\n        let mut\
    \ candidate = stack[i];\n        let mut k = j;\n        while k < stack.len()\
    \ {\n            if stack[k] == candidate {\n                // We found the candidate\
    \ that is the same as the one we're looking\n                // for, so return\
    \ it and pop the current candidate index.\n                return candidate;\n\
    \            }\n            k += 1;\n        }\n        // No such candidate found.\
    \ Pop the stack to avoid infinitely recursing.\n        stack.pop();\n       \
    \ i += 1;\n    }\n    -1\n}\n\nfn main() {\n    let candidate = can_arrange;\n\
    \    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]),\
    \ 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-1`,\n right: `3`', /tmp/tmpjydtsbte.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009031
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    if arr.len() < 2 {\n        return -1;\n    }\n    let mut low\
    \ = 0;\n    let mut high = arr.len() - 1;\n    while low < high {\n        if\
    \ arr[low] <= arr[high] {\n            low++;\n        } else {\n            high--;\n\
    \        }\n    }\n    if arr[high] > arr[low] {\n        high\n    } else {\n\
    \        low\n    }\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp7osk2fbb.rs:18:16\n\
    \   |\n18 |             low++;\n   |                ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n18 |             { let tmp = low; low +=\
    \ 1; tmp };\n   |             +++++++++++    ~~~~~~~~~~~~~~~~~\n18 -         \
    \    low++;\n18 +             low += 1;\n   | \n\nerror: expected expression,\
    \ found `;`\n  --> /tmp/tmp7osk2fbb.rs:20:19\n   |\n20 |             high--;\n\
    \   |                   ^ expected expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp7osk2fbb.rs:24:9\n   |\n10 | fn can_arrange(arr: Vec<isize>) ->\
    \ isize {\n   |                                    ----- expected `isize` because\
    \ of return type\n...\n24 |         high\n   |         ^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n24 |         high.try_into().unwrap()\n\
    \   |             ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp7osk2fbb.rs:26:9\n   |\n10 | fn can_arrange(arr: Vec<isize>) -> isize\
    \ {\n   |                                    ----- expected `isize` because of\
    \ return type\n...\n26 |         low\n   |         ^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n26 |         low.try_into().unwrap()\n  \
    \ |            ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009031
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    arr.iter().skip(1).last().unwrap_or_else(|| arr.len())\n}\n\n\
    fn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7az140pm.rs:11:49\n   |\n\
    11 |     arr.iter().skip(1).last().unwrap_or_else(|| arr.len())\n   |        \
    \                                         ^^^^^^^^^ expected `&isize`, found `usize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp7az140pm.rs:11:5\n   |\n10 | fn\
    \ can_arrange(arr: Vec<isize>) -> isize {\n   |                              \
    \      ----- expected `isize` because of return type\n11 |     arr.iter().skip(1).last().unwrap_or_else(||\
    \ arr.len())\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n11 |     *arr.iter().skip(1).last().unwrap_or_else(|| arr.len())\n   |\
    \     +\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009031
- exit_code: 101
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    let mut prev = 0;\n    for &x in arr.iter().rev() {\n      \
    \  if prev < x {\n            return prev;\n        }\n        prev = x;\n   \
    \ }\n    -1\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmpcnasugq8.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009031
- exit_code: 1
  program: "/// Create a function which returns the largest index of an element which\n\
    /// is not greater than or equal to the element immediately preceding it. If\n\
    /// no such element exists then return -1. The given vector will not contain\n\
    /// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n\
    /// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>)\
    \ -> isize {\n    if arr.is_empty() {\n        return -1;\n    }\n    let mut\
    \ highest: usize = 0;\n    for i in arr.iter().rev() {\n        if i > arr[0]\
    \ {\n            highest = i;\n        }\n    }\n    highest\n}\n\nfn main() {\n\
    \    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]),\
    \ 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1,\
    \ 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]),\
    \ 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplawbhgl8.rs:16:16\n   |\n\
    16 |         if i > arr[0] {\n   |                ^^^^^^\n   |               \
    \ |\n   |                expected `&isize`, found `isize`\n   |              \
    \  help: consider borrowing here: `&arr[0]`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmplawbhgl8.rs:17:23\n   |\n14 |     let mut highest: usize = 0;\n\
    \   |                      ----- expected due to this type\n...\n17 |        \
    \     highest = i;\n   |                       ^ expected `usize`, found `&isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmplawbhgl8.rs:20:5\n   |\n10 | fn\
    \ can_arrange(arr: Vec<isize>) -> isize {\n   |                              \
    \      ----- expected `isize` because of return type\n...\n20 |     highest\n\
    \   |     ^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    20 |     highest.try_into().unwrap()\n   |            ++++++++++++++++++++\n\n\
    error: aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009031
