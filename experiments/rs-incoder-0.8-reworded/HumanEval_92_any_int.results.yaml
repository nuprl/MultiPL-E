language: rs
name: HumanEval_92_any_int
results:
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    let x1 = x.into();\n    let x2 = y.into();\n    let x3 =\
    \ z.into();\n    (x1 == x2 || x1 == x3 || x2 == x3 || (x1 - x2) * (x1 - x3) ==\
    \ (x3 - y) * (x3 - y))\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around block return value\n  --> /tmp/tmpc8b7qeh_.rs:17:5\n\
    \   |\n17 |     (x1 == x2 || x1 == x3 || x2 == x3 || (x1 - x2) * (x1 - x3) ==\
    \ (x3 - y) * (x3 - y))\n   |     ^                                           \
    \                                     ^\n   |\n   = note: `#[warn(unused_parens)]`\
    \ on by default\nhelp: remove these parentheses\n   |\n17 -     (x1 == x2 || x1\
    \ == x3 || x2 == x3 || (x1 - x2) * (x1 - x3) == (x3 - y) * (x3 - y))\n17 +   \
    \  x1 == x2 || x1 == x3 || x2 == x3 || (x1 - x2) * (x1 - x3) == (x3 - y) * (x3\
    \ - y)\n   | \n\nerror[E0282]: type annotations needed\n  --> /tmp/tmpc8b7qeh_.rs:14:9\n\
    \   |\n14 |     let x1 = x.into();\n   |         ^^ consider giving `x1` a type\n\
    \nerror: aborting due to previous error; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659978604
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    x <= x + y && x <= x + z && x <= y + z && x <= z + y\n}\n\
    \nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0,\
    \ 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpmm60tfxr.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978604
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    x <= z && z <= y && x.is_integer() && y.is_integer() &&\
    \ z.is_integer()\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmprms4_huz.rs:14:27\n   |\n14 |     x <= z && z <=\
    \ y && x.is_integer() && y.is_integer() && z.is_integer()\n   |              \
    \             ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]: no method\
    \ named `is_integer` found for type `f64` in the current scope\n  --> /tmp/tmprms4_huz.rs:14:45\n\
    \   |\n14 |     x <= z && z <= y && x.is_integer() && y.is_integer() && z.is_integer()\n\
    \   |                                             ^^^^^^^^^^ method not found\
    \ in `f64`\n\nerror[E0599]: no method named `is_integer` found for type `f64`\
    \ in the current scope\n  --> /tmp/tmprms4_huz.rs:14:63\n   |\n14 |     x <= z\
    \ && z <= y && x.is_integer() && y.is_integer() && z.is_integer()\n   |      \
    \                                                         ^^^^^^^^^^ method not\
    \ found in `f64`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978604
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    let x_int: i64 = x.into();\n    let y_int: i64 = y.into();\n\
    \    let z_int: i64 = z.into();\n    let sum = x_int + y_int + z_int;\n    x_int\
    \ == sum\n        || y_int == sum\n        || z_int == sum\n        || (x_int\
    \ < y_int)\n        || (x_int < z_int)\n        || (y_int < z_int)\n}\n\nfn main()\
    \ {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n\
    \    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `i64: From<f64>` is not satisfied\n  -->\
    \ /tmp/tmptmsfj7ql.rs:14:24\n   |\n14 |     let x_int: i64 = x.into();\n   | \
    \                       ^^^^ the trait `From<f64>` is not implemented for `i64`\n\
    \   |\n   = help: the following other types implement trait `From<T>`:\n     \
    \        <f32 as From<i16>>\n             <f32 as From<i8>>\n             <f32\
    \ as From<u16>>\n             <f32 as From<u8>>\n             <f64 as From<f32>>\n\
    \             <f64 as From<i16>>\n             <f64 as From<i32>>\n          \
    \   <f64 as From<i8>>\n           and 67 others\n   = note: required because of\
    \ the requirements on the impl of `Into<i64>` for `f64`\n\nerror[E0277]: the trait\
    \ bound `i64: From<f64>` is not satisfied\n  --> /tmp/tmptmsfj7ql.rs:15:24\n \
    \  |\n15 |     let y_int: i64 = y.into();\n   |                        ^^^^ the\
    \ trait `From<f64>` is not implemented for `i64`\n   |\n   = help: the following\
    \ other types implement trait `From<T>`:\n             <f32 as From<i16>>\n  \
    \           <f32 as From<i8>>\n             <f32 as From<u16>>\n             <f32\
    \ as From<u8>>\n             <f64 as From<f32>>\n             <f64 as From<i16>>\n\
    \             <f64 as From<i32>>\n             <f64 as From<i8>>\n           and\
    \ 67 others\n   = note: required because of the requirements on the impl of `Into<i64>`\
    \ for `f64`\n\nerror[E0277]: the trait bound `i64: From<f64>` is not satisfied\n\
    \  --> /tmp/tmptmsfj7ql.rs:16:24\n   |\n16 |     let z_int: i64 = z.into();\n\
    \   |                        ^^^^ the trait `From<f64>` is not implemented for\
    \ `i64`\n   |\n   = help: the following other types implement trait `From<T>`:\n\
    \             <f32 as From<i16>>\n             <f32 as From<i8>>\n           \
    \  <f32 as From<u16>>\n             <f32 as From<u8>>\n             <f64 as From<f32>>\n\
    \             <f64 as From<i16>>\n             <f64 as From<i32>>\n          \
    \   <f64 as From<i8>>\n           and 67 others\n   = note: required because of\
    \ the requirements on the impl of `Into<i64>` for `f64`\n\nerror: aborting due\
    \ to 3 previous errors\n\nFor more information about this error, try `"
  stdout: ''
  timestamp: 1659978604
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    if x == z {\n        // \"Any\" is a special case:\n   \
    \     // We know that x + y == z\n        // and all 3 numbers are integers\n\
    \        true\n    } else if y == z {\n        true\n    } else {\n        x <\
    \ y || y < x\n    }\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpyzl7j3s5.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978604
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    x.is_integer()\n        || y.is_integer()\n        || z.is_integer()\n\
    \        || (x >= y && x >= z)\n        || (y >= x && y >= z)\n        || (z >=\
    \ x && z >= y)\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmpjcpr2a7j.rs:14:7\n   |\n14 |     x.is_integer()\n\
    \   |       ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]: no method named\
    \ `is_integer` found for type `f64` in the current scope\n  --> /tmp/tmpjcpr2a7j.rs:15:14\n\
    \   |\n15 |         || y.is_integer()\n   |              ^^^^^^^^^^ method not\
    \ found in `f64`\n\nerror[E0599]: no method named `is_integer` found for type\
    \ `f64` in the current scope\n  --> /tmp/tmpjcpr2a7j.rs:16:14\n   |\n16 |    \
    \     || z.is_integer()\n   |              ^^^^^^^^^^ method not found in `f64`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978604
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    let sum = x + y + z;\n    sum != f64::INFINITY\n       \
    \ && sum != f64::NEG_INFINITY\n        && sum != f64::NAN\n        && sum.floor()\
    \ as i64\n        == z\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpuztcn3kb.rs:19:12\n   |\n\
    19 |         == z\n   |            ^ expected `i64`, found `f64`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659978604
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    if x == x + y || x == x + z || y == y + z {\n        true\n\
    \    } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate = any_int;\n\
    \    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpci0ppjgy.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978604
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    x != 0.0\n        && y != 0.0\n        && z != 0.0\n   \
    \     && x.is_integer() && y.is_integer() && z.is_integer()\n        && x + y\
    \ + z == f64::from(x + y + z)\n}\n\nfn main() {\n    let candidate = any_int;\n\
    \    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmpzt4025x6.rs:17:14\n   |\n17 |         && x.is_integer()\
    \ && y.is_integer() && z.is_integer()\n   |              ^^^^^^^^^^ method not\
    \ found in `f64`\n\nerror[E0599]: no method named `is_integer` found for type\
    \ `f64` in the current scope\n  --> /tmp/tmpzt4025x6.rs:17:32\n   |\n17 |    \
    \     && x.is_integer() && y.is_integer() && z.is_integer()\n   |            \
    \                    ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]: no\
    \ method named `is_integer` found for type `f64` in the current scope\n  --> /tmp/tmpzt4025x6.rs:17:50\n\
    \   |\n17 |         && x.is_integer() && y.is_integer() && z.is_integer()\n  \
    \ |                                                  ^^^^^^^^^^ method not found\
    \ in `f64`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978604
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    x >= y && x >= z && y >= z\n}\n\nfn main() {\n    let candidate\
    \ = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpbonfc5s1.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978604
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    x <= y && y <= x && x <= z && z <= x\n}\n\nfn main() {\n\
    \    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n\
    \    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpcfiau47r.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978604
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    let sum = x + y + z;\n    match sum {\n        x if x ==\
    \ z => true,\n        _ => false,\n    }\n}\n\nfn main() {\n    let candidate\
    \ = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpmh3eqdte.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978604
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    let x_int = x.floor() as f64 as i32;\n    let y_int = y.floor()\
    \ as f64 as i32;\n    let z_int = z.floor() as f64 as i32;\n    if x_int == y_int\
    \ && y_int == z_int {\n        return true;\n    }\n    if x_int != x_int {\n\
    \        return false;\n    }\n    if y_int != y_int {\n        return false;\n\
    \    }\n    if z_int != z_int {\n        return false;\n    }\n    false\n}\n\n\
    fn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0,\
    \ 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp7m3htlrn.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978604
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    x != 0.0 && y != 0.0 && z != 0.0 &&\n    x == y + z\n}\n\
    \nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0,\
    \ 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpeat67sdl.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978604
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    match x, y, z {\n        (0...).any(|&x| x == y) as _,\n\
    \        _ as _,\n        _ as _,\n        _ => false,\n    }\n}\n\nfn main()\
    \ {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n\
    \    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `.`, `::`, `?`, `{`, or an operator, found\
    \ `,`\n  --> /tmp/tmpz3cirk_f.rs:14:12\n   |\n14 |     match x, y, z {\n   | \
    \    -----  ^ expected one of `!`, `.`, `::`, `?`, `{`, or an operator\n   | \
    \    |\n   |     while parsing this `match` expression\n\nerror: aborting due\
    \ to previous error\n\n"
  stdout: ''
  timestamp: 1659978604
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    (x != 0 || y != 0 || z != 0) && (x.abs() == y.abs() + z.abs()).is_ok()\n\
    }\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcya_gfln.rs:14:11\n   |\n\
    14 |     (x != 0 || y != 0 || z != 0) && (x.abs() == y.abs() + z.abs()).is_ok()\n\
    \   |           ^\n   |           |\n   |           expected `f64`, found integer\n\
    \   |           help: use a float literal: `0.0`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpcya_gfln.rs:14:21\n   |\n14 |     (x != 0 || y != 0 || z != 0)\
    \ && (x.abs() == y.abs() + z.abs()).is_ok()\n   |                     ^\n   |\
    \                     |\n   |                     expected `f64`, found integer\n\
    \   |                     help: use a float literal: `0.0`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpcya_gfln.rs:14:31\n   |\n14 |     (x != 0 || y != 0 ||\
    \ z != 0) && (x.abs() == y.abs() + z.abs()).is_ok()\n   |                    \
    \           ^\n   |                               |\n   |                    \
    \           expected `f64`, found integer\n   |                              \
    \ help: use a float literal: `0.0`\n\nerror[E0599]: no method named `is_ok` found\
    \ for type `bool` in the current scope\n  --> /tmp/tmpcya_gfln.rs:14:68\n   |\n\
    14 |     (x != 0 || y != 0 || z != 0) && (x.abs() == y.abs() + z.abs()).is_ok()\n\
    \   |                                                                    ^^^^^\
    \ method not found in `bool`\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978604
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    match x + y {\n        z => {\n            let x: isize\
    \ = x.checked_add::<isize>(z).unwrap();\n            let y: isize = y.checked_add::<isize>(z).unwrap();\n\
    \            if x > y {\n                true\n            } else {\n        \
    \        false\n            }\n        }\n        _ => false,\n    }\n}\n\nfn\
    \ main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0),\
    \ true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `checked_add` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmp_4qzudgk.rs:16:30\n   |\n16 |             let x:\
    \ isize = x.checked_add::<isize>(z).unwrap();\n   |                          \
    \    ^^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]: no method named `checked_add`\
    \ found for type `f64` in the current scope\n  --> /tmp/tmp_4qzudgk.rs:17:30\n\
    \   |\n17 |             let y: isize = y.checked_add::<isize>(z).unwrap();\n \
    \  |                              ^^^^^^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978604
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    match x.checked_add(y).unwrap_or(z).checked_div(z) {\n \
    \       Some(Ok(())) => true,\n        Some(Err(_)) => false,\n        _ => panic!(\"\
    any_int: x, y, z must be integers!\"),\n    }\n}\n\nfn main() {\n    let candidate\
    \ = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `checked_add` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmp1vppz6w5.rs:14:13\n   |\n14 |     match x.checked_add(y).unwrap_or(z).checked_div(z)\
    \ {\n   |             ^^^^^^^^^^^ method not found in `f64`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659978604
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    x.round() == x.round() || y.round() == y.round() || z.round()\
    \ == z.round()\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpceyijaw5.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978604
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    x <= y + z &&\n    x >= y - z &&\n    x * x + y * y + z\
    \ * z > 0\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpws6u3n8x.rs:16:29\n   |\n\
    16 |     x * x + y * y + z * z > 0\n   |                             ^\n   | \
    \                            |\n   |                             expected `f64`,\
    \ found integer\n   |                             help: use a float literal: `0.0`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978604
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    x.checked_add(y).is_one() || x.checked_add(z).is_one() ||\
    \ y.checked_add(z).is_one()\n}\n\nfn main() {\n    let candidate = any_int;\n\
    \    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `checked_add` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmpw97dmm_l.rs:14:7\n   |\n14 |     x.checked_add(y).is_one()\
    \ || x.checked_add(z).is_one() || y.checked_add(z).is_one()\n   |       ^^^^^^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no method named `checked_add` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmpw97dmm_l.rs:14:36\n   |\n\
    14 |     x.checked_add(y).is_one() || x.checked_add(z).is_one() || y.checked_add(z).is_one()\n\
    \   |                                    ^^^^^^^^^^^ method not found in `f64`\n\
    \nerror[E0599]: no method named `checked_add` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpw97dmm_l.rs:14:65\n   |\n14 |     x.checked_add(y).is_one()\
    \ || x.checked_add(z).is_one() || y.checked_add(z).is_one()\n   |            \
    \                                                     ^^^^^^^^^^^ method not found\
    \ in `f64`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978604
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    x.is_integer() && y.is_integer() && z.is_integer()\n   \
    \     && x <= y && y <= z && z <= x\n}\n\nfn main() {\n    let candidate = any_int;\n\
    \    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmp0xh09tj2.rs:14:7\n   |\n14 |     x.is_integer()\
    \ && y.is_integer() && z.is_integer()\n   |       ^^^^^^^^^^ method not found\
    \ in `f64`\n\nerror[E0599]: no method named `is_integer` found for type `f64`\
    \ in the current scope\n  --> /tmp/tmp0xh09tj2.rs:14:25\n   |\n14 |     x.is_integer()\
    \ && y.is_integer() && z.is_integer()\n   |                         ^^^^^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no method named `is_integer` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmp0xh09tj2.rs:14:43\n   |\n\
    14 |     x.is_integer() && y.is_integer() && z.is_integer()\n   |            \
    \                               ^^^^^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978604
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    x.is_integer() && x.is_integer() && y.is_integer() && z.is_integer()\
    \ &&\n        x.unwrap() + y.unwrap() + z.unwrap() == x.unwrap() + y.unwrap()\
    \ + z.unwrap()\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmprstohc_1.rs:14:7\n   |\n14 |     x.is_integer()\
    \ && x.is_integer() && y.is_integer() && z.is_integer() &&\n   |       ^^^^^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no method named `is_integer` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmprstohc_1.rs:14:25\n   |\n\
    14 |     x.is_integer() && x.is_integer() && y.is_integer() && z.is_integer()\
    \ &&\n   |                         ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `is_integer` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmprstohc_1.rs:14:43\n   |\n14 |     x.is_integer() && x.is_integer() &&\
    \ y.is_integer() && z.is_integer() &&\n   |                                  \
    \         ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]: no method named\
    \ `is_integer` found for type `f64` in the current scope\n  --> /tmp/tmprstohc_1.rs:14:61\n\
    \   |\n14 |     x.is_integer() && x.is_integer() && y.is_integer() && z.is_integer()\
    \ &&\n   |                                                             ^^^^^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no method named `unwrap` found for\
    \ type `f64` in the current scope\n  --> /tmp/tmprstohc_1.rs:15:11\n   |\n15 |\
    \         x.unwrap() + y.unwrap() + z.unwrap() == x.unwrap() + y.unwrap() + z.unwrap()\n\
    \   |           ^^^^^^ method not found in `f64`\n\nerror[E0599]: no method named\
    \ `unwrap` found for type `f64` in the current scope\n  --> /tmp/tmprstohc_1.rs:15:24\n\
    \   |\n15 |         x.unwrap() + y.unwrap() + z.unwrap() == x.unwrap() + y.unwrap()\
    \ + z.unwrap()\n   |                        ^^^^^^ method not found in `f64`\n\
    \nerror[E0599]: no method named `unwrap` found for type `f64` in the current scope\n\
    \  --> /tmp/tmprstohc_1.rs:15:37\n   |\n15 |         x.unwrap() + y.unwrap() +\
    \ z.unwrap() == x.unwrap() + y.unwrap() + z.unwrap()\n   |                   \
    \                  ^^^^^^ method not found in `f64`\n\nerror[E0599]: no method\
    \ named `unwrap` found for type `f64` in the current scope\n  --> /tmp/tmprstohc_1.rs:15:51\n\
    \   |\n15 | "
  stdout: ''
  timestamp: 1659978604
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    let res = x + y + z as f64;\n    match res {\n        0\
    \ => false,\n        x => true,\n        _ => false,\n    }\n}\n\nfn main() {\n\
    \    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n\
    \    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb5bdeuv_.rs:16:9\n   |\n\
    15 |     match res {\n   |           --- this expression has type `f64`\n16 |\
    \         0 => false,\n   |         ^\n   |         |\n   |         expected `f64`,\
    \ found integer\n   |         help: use a float literal: `0.0`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659978604
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    x <= x + y && x <= x + z && x <= z + x && x <= y + z\n}\n\
    \nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0,\
    \ 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpy4b180g8.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978604
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    let x_int = x.floor();\n    let y_int = y.floor();\n   \
    \ let z_int = z.floor();\n\n    x_int + y_int + z_int == x.checked_add(y).checked_add(z).unwrap()\n\
    }\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `checked_add` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmp_g_rizt0.rs:18:32\n   |\n18 |     x_int + y_int\
    \ + z_int == x.checked_add(y).checked_add(z).unwrap()\n   |                  \
    \              ^^^^^^^^^^^ method not found in `f64`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659978604
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    let (mut x_int, mut y_int, mut z_int) = (x, y, z);\n   \
    \ while let Some(Some(_)) = (x_int, y_int, z_int).as_mut() {\n        x_int =\
    \ x_int.unwrap().try_into().unwrap();\n        y_int = y_int.unwrap().try_into().unwrap();\n\
    \        z_int = z_int.unwrap().try_into().unwrap();\n    }\n    x_int == y_int\
    \ && x_int == z_int\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `as_mut` found for tuple `(f64, f64, f64)`\
    \ in the current scope\n   --> /tmp/tmp25dtys3y.rs:15:53\n    |\n15  |     while\
    \ let Some(Some(_)) = (x_int, y_int, z_int).as_mut() {\n    |                \
    \                                     ^^^^^^ method not found in `(f64, f64, f64)`\n\
    \    |\nhelp: consider wrapping the receiver expression with the appropriate type\n\
    \    |\n15  |     while let Some(Some(_)) = Box::new((x_int, y_int, z_int)).as_mut()\
    \ {\n    |                               +++++++++                     +\nhelp:\
    \ consider wrapping the receiver expression with the appropriate type\n    |\n\
    15  |     while let Some(Some(_)) = Box::new(&mut (x_int, y_int, z_int)).as_mut()\
    \ {\n    |                               +++++++++++++                      +\n\
    help: consider wrapping the receiver expression with the appropriate type\n  \
    \  |\n15  |     while let Some(Some(_)) = Pin::new(&mut (x_int, y_int, z_int)).as_mut()\
    \ {\n    |                               +++++++++++++                      +\n\
    help: consider wrapping the receiver expression with the appropriate type\n  \
    \  |\n15  |     while let Some(Some(_)) = Box::new(&(x_int, y_int, z_int)).as_mut()\
    \ {\n    |                               ++++++++++                     +\n\n\
    error[E0599]: no method named `unwrap` found for type `f64` in the current scope\n\
    \  --> /tmp/tmp25dtys3y.rs:16:23\n   |\n16 |         x_int = x_int.unwrap().try_into().unwrap();\n\
    \   |                       ^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `unwrap` found for type `f64` in the current scope\n  --> /tmp/tmp25dtys3y.rs:17:23\n\
    \   |\n17 |         y_int = y_int.unwrap().try_into().unwrap();\n   |        \
    \               ^^^^^^ method not found in `f64`\n\nerror[E0599]: no method named\
    \ `unwrap` found for type `f64` in the current scope\n  --> /tmp/tmp25dtys3y.rs:18:23\n\
    \   |\n18 |         z_int = z_int.unwrap().try_into().unwrap();\n   |        \
    \               ^^^^^^ method not found in `f64`\n\nerror: aborting due to 4 previous\
    \ errors\n\nFor more information about this error, try `rustc --expl"
  stdout: ''
  timestamp: 1659978604
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    let z = z as i32;\n    let y = y as i32;\n    let x = x\
    \ as i32;\n    x >= z && x <= y + z && x >= y && x <= z + y\n}\n\nfn main() {\n\
    \    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n\
    \    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp0ohxo17n.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978604
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    if x != x + y && x != y + z {\n        return false;\n \
    \   }\n    true\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpvb5v9bbg.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978604
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    let x: f64 = x.floor();\n    let y: f64 = y.floor();\n \
    \   let z: f64 = z.floor();\n    (x.checked_add(y).and_then(|x| x.checked_add(z).unwrap_or(x.checked_sub(z).unwrap_or(x.checked_mul(1.0f64).unwrap_or(1.0f64)))\
    \ == x) == x\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpxc8zn43y.rs:17:5\n\
    \   |\n13 | fn any_int(x: f64, y: f64, z: f64) -> bool {\n   |               \
    \                             - closing delimiter possibly meant for this\n...\n\
    17 |     (x.checked_add(y).and_then(|x| x.checked_add(z).unwrap_or(x.checked_sub(z).unwrap_or(x.checked_mul(1.0f64).unwrap_or(1.0f64)))\
    \ == x) ...\n   |     ^ unclosed delimiter\n18 | }\n   | ^ mismatched closing\
    \ delimiter\n\nwarning: unnecessary parentheses around block return value\n  -->\
    \ /tmp/tmpxc8zn43y.rs:17:5\n   |\n17 |       (x.checked_add(y).and_then(|x| x.checked_add(z).unwrap_or(x.checked_sub(z).unwrap_or(x.checked_mul(1.0f64).unwrap_or(1.0f64)))\
    \ == x) == x\n   |  _____^________________________________________________________________________________________________________________________________________^\n\
    18 | | }\n   | |_^\n   |\n   = note: `#[warn(unused_parens)]` on by default\n\
    help: remove these parentheses\n   |\n17 -     (x.checked_add(y).and_then(|x|\
    \ x.checked_add(z).unwrap_or(x.checked_sub(z).unwrap_or(x.checked_mul(1.0f64).unwrap_or(1.0f64)))\
    \ == x) == x\n17 +     x.checked_add(y).and_then(|x| x.checked_add(z).unwrap_or(x.checked_sub(z).unwrap_or(x.checked_mul(1.0f64).unwrap_or(1.0f64)))\
    \ == x) == x\n   | \n\nerror[E0599]: no method named `checked_add` found for type\
    \ `f64` in the current scope\n  --> /tmp/tmpxc8zn43y.rs:17:8\n   |\n17 |     (x.checked_add(y).and_then(|x|\
    \ x.checked_add(z).unwrap_or(x.checked_sub(z).unwrap_or(x.checked_mul(1.0f64).unwrap_or(1.0f64)))\
    \ == x) ...\n   |        ^^^^^^^^^^^ method not found in `f64`\n\nerror: aborting\
    \ due to 2 previous errors; 1 warning emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978604
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    (x + y) == z && x == f64::from(z) && y == f64::from(z)\n\
    }\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp8m6s2p0c.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978604
- exit_code: -1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    any_int(x.round(), y, z)\n}\n\nfn main() {\n    let candidate\
    \ = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659978610
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    (x * y + z) == 0\n}\n\nfn main() {\n    let candidate =\
    \ any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2abkvhyd.rs:14:20\n   |\n\
    14 |     (x * y + z) == 0\n   |                    ^\n   |                   \
    \ |\n   |                    expected `f64`, found integer\n   |             \
    \       help: use a float literal: `0.0`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978604
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    if x.trun() <= y.trun() && y.trun() <= z.trun() {\n    \
    \    true\n    } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate\
    \ = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `trun` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpe81yg5gh.rs:14:10\n   |\n14 |     if x.trun() <= y.trun()\
    \ && y.trun() <= z.trun() {\n   |          ^^^^ help: there is an associated function\
    \ with a similar name: `trunc`\n\nerror[E0599]: no method named `trun` found for\
    \ type `f64` in the current scope\n  --> /tmp/tmpe81yg5gh.rs:14:22\n   |\n14 |\
    \     if x.trun() <= y.trun() && y.trun() <= z.trun() {\n   |                \
    \      ^^^^ help: there is an associated function with a similar name: `trunc`\n\
    \nerror[E0599]: no method named `trun` found for type `f64` in the current scope\n\
    \  --> /tmp/tmpe81yg5gh.rs:14:34\n   |\n14 |     if x.trun() <= y.trun() && y.trun()\
    \ <= z.trun() {\n   |                                  ^^^^ help: there is an\
    \ associated function with a similar name: `trunc`\n\nerror[E0599]: no method\
    \ named `trun` found for type `f64` in the current scope\n  --> /tmp/tmpe81yg5gh.rs:14:46\n\
    \   |\n14 |     if x.trun() <= y.trun() && y.trun() <= z.trun() {\n   |      \
    \                                        ^^^^ help: there is an associated function\
    \ with a similar name: `trunc`\n\nerror: aborting due to 4 previous errors\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978604
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    match (x, y, z) {\n        (x + y, x + z, x + y) || (x +\
    \ z, x + z, x) => true,\n        _ => false,\n    }\n}\n\nfn main() {\n    let\
    \ candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `)`, `,`, `@`, or `|`, found `+`\n  --> /tmp/tmp0piel6f4.rs:15:12\n\
    \   |\n15 |         (x + y, x + z, x + y) || (x + z, x + z, x) => true,\n   |\
    \            ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: aborting due to\
    \ previous error\n\n"
  stdout: ''
  timestamp: 1659978604
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    x != z && y != z && (x.trunc() == z || y.trunc() == z)\n\
    }\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpubhpff24.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978604
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    let x: f64 = x.floor();\n    let y: f64 = y.floor();\n \
    \   let z: f64 = z.floor();\n    if x <= y && y <= z && z <= x {\n        return\
    \ true;\n    }\n    else {\n        return false;\n    }\n}\n\nfn main() {\n \
    \   let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n\
    \    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpzch94zsc.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978604
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    if x == z && y == z {\n        true\n    } else if x < z\
    \ && y < z {\n        x < z && y < z\n    } else if x < z {\n        x < z &&\
    \ x == z\n    } else if y < z {\n        y < z && y == z\n    } else {\n     \
    \   false\n    }\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpht12og29.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978604
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    x.is_integer() && y.is_integer() && z.is_integer() && x\
    \ + y + z == f64::from(x.to_f64()) + f64::from(y.to_f64()) + f64::from(z.to_f64())\n\
    }\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmpznwgbhje.rs:14:7\n   |\n14 |     x.is_integer()\
    \ && y.is_integer() && z.is_integer() && x + y + z == f64::from(x.to_f64()) +\
    \ f64::from(y.to_f64()) + f64::from(z.to_f64())\n   |       ^^^^^^^^^^ method\
    \ not found in `f64`\n\nerror[E0599]: no method named `is_integer` found for type\
    \ `f64` in the current scope\n  --> /tmp/tmpznwgbhje.rs:14:25\n   |\n14 |    \
    \ x.is_integer() && y.is_integer() && z.is_integer() && x + y + z == f64::from(x.to_f64())\
    \ + f64::from(y.to_f64()) + f64::from(z.to_f64())\n   |                      \
    \   ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]: no method named `is_integer`\
    \ found for type `f64` in the current scope\n  --> /tmp/tmpznwgbhje.rs:14:43\n\
    \   |\n14 |     x.is_integer() && y.is_integer() && z.is_integer() && x + y +\
    \ z == f64::from(x.to_f64()) + f64::from(y.to_f64()) + f64::from(z.to_f64())\n\
    \   |                                           ^^^^^^^^^^ method not found in\
    \ `f64`\n\nerror[E0599]: no method named `to_f64` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmpznwgbhje.rs:14:84\n   |\n14 |     x.is_integer()\
    \ && y.is_integer() && z.is_integer() && x + y + z == f64::from(x.to_f64()) +\
    \ f64::from(y.to_f64()) + f64::from(z.to_f64())\n   |                        \
    \                                                            ^^^^^^ method not\
    \ found in `f64`\n\nerror[E0599]: no method named `to_f64` found for type `f64`\
    \ in the current scope\n  --> /tmp/tmpznwgbhje.rs:14:108\n   |\n14 |     x.is_integer()\
    \ && y.is_integer() && z.is_integer() && x + y + z == f64::from(x.to_f64()) +\
    \ f64::from(y.to_f64()) + f64::from(z.to_f64())\n   |                        \
    \                                                                            \
    \        ^^^^^^ method not found in `f64`\n\nerror[E0599]: no method named `to_f64`\
    \ found for type `f64` in the current scope\n  --> /tmp/tmpznwgbhje.rs:14:132\n\
    \   |\n14 |     x.is_integer() && y.is_integer() && z.is_integer() && x + y +\
    \ z == f64::from(x.to_f64()) + f64::from(y.to_f64()) + f64:"
  stdout: ''
  timestamp: 1659978604
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    match x + y {\n        z @ _ as f => f >= x,\n        _\
    \ => false,\n    }\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `=>`, `if`, or `|`, found keyword `as`\n  --> /tmp/tmp5ewortv5.rs:15:15\n\
    \   |\n15 |         z @ _ as f => f >= x,\n   |               ^^ expected one\
    \ of `=>`, `if`, or `|`\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659978604
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    fn check(a: &f64, b: &f64, c: &f64) -> bool {\n        if\
    \ a == b + c && a + b == c {\n            true\n        } else {\n           \
    \ false\n        }\n    }\n    check(&x, &y, &z)\n}\n\nfn main() {\n    let candidate\
    \ = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&f64` with `f64`\n  --> /tmp/tmpbjs64t4u.rs:15:14\n\
    \   |\n15 |         if a == b + c && a + b == c {\n   |              ^^ no implementation\
    \ for `&f64 == f64`\n   |\n   = help: the trait `PartialEq<f64>` is not implemented\
    \ for `&f64`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbjs64t4u.rs:15:35\n\
    \   |\n15 |         if a == b + c && a + b == c {\n   |                      \
    \             ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n15 |         if a == b + c && a + b == *c {\n   |        \
    \                           +\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659978604
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    let x = x as i32;\n    let y = y as i32;\n    let z = z\
    \ as i32;\n    (x != 0 || y != 0 || z != 0) && (x != 0 && y != 0 && z != 0)\n\
    }\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpfju_rzah.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978604
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    x.is_integer() && y.is_integer() && z.is_integer()\n   \
    \     && x.checked_add(y).checked_add(z).is_some()\n}\n\nfn main() {\n    let\
    \ candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmpjbplu6ud.rs:14:7\n   |\n14 |     x.is_integer()\
    \ && y.is_integer() && z.is_integer()\n   |       ^^^^^^^^^^ method not found\
    \ in `f64`\n\nerror[E0599]: no method named `is_integer` found for type `f64`\
    \ in the current scope\n  --> /tmp/tmpjbplu6ud.rs:14:25\n   |\n14 |     x.is_integer()\
    \ && y.is_integer() && z.is_integer()\n   |                         ^^^^^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no method named `is_integer` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmpjbplu6ud.rs:14:43\n   |\n\
    14 |     x.is_integer() && y.is_integer() && z.is_integer()\n   |            \
    \                               ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `checked_add` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmpjbplu6ud.rs:15:14\n   |\n15 |         && x.checked_add(y).checked_add(z).is_some()\n\
    \   |              ^^^^^^^^^^^ method not found in `f64`\n\nerror: aborting due\
    \ to 4 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659978604
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    let x_int = x as i32;\n    let y_int = y as i32;\n    let\
    \ z_int = z as i32;\n\n    match x_int, y_int, z_int {\n        (0, 0, 0) | _,\
    \ _, _ => true,\n        _, _ => false,\n        _ => true\n    }\n}\n\nfn main()\
    \ {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n\
    \    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `.`, `::`, `?`, `{`, or an operator, found\
    \ `,`\n  --> /tmp/tmposllx7lb.rs:18:16\n   |\n18 |     match x_int, y_int, z_int\
    \ {\n   |     -----      ^ expected one of `!`, `.`, `::`, `?`, `{`, or an operator\n\
    \   |     |\n   |     while parsing this `match` expression\n\nerror: aborting\
    \ due to previous error\n\n"
  stdout: ''
  timestamp: 1659978604
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    if x < y && x < z && y < z {\n        // Check all three\
    \ numbers\n        true\n    } else if x < y && y < z && z < x {\n        // Check\
    \ two of three numbers\n        true\n    } else if y < z && z < x && x < y {\n\
    \        // Check two of three numbers\n        true\n    } else if z < x && x\
    \ < y && y < z {\n        // Check all three numbers\n        true\n    } else\
    \ {\n        // No match\n        false\n    }\n}\n\nfn main() {\n    let candidate\
    \ = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpc3p0oxyl.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978604
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    if x == z && y == z || (x == z && y < z) || (x < z && y\
    \ != z && y != z) {\n        return true;\n    }\n    false\n}\n\nfn main() {\n\
    \    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n\
    \    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp1tc0rgx6.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978604
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    x != 0.0 && y != 0.0 && z != 0.0 && (x + y + z == 0.0)\n\
    }\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp1z7cxhng.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978604
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    // If one of the numbers is smaller than the sum, they are\
    \ equal.\n    if x < z && y < z {\n        return true;\n    }\n\n    // If one\
    \ of the numbers is greater than the sum, they are equal.\n    if x > z && y >\
    \ z {\n        return true;\n    }\n\n    // If no numbers are equal, they are\
    \ equal.\n    if x == z && y == z {\n        return true;\n    }\n\n    // If\
    \ one number is less than the sum, they are equal.\n    if x < z {\n        return\
    \ true;\n    }\n\n    // If one number is greater than the sum, they are equal.\n\
    \    if x > z {\n        return true;\n    }\n\n    // If none of the above conditions\
    \ apply, they are equal.\n    return false;\n}\n\nfn main() {\n    let candidate\
    \ = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpkxn7gpxy.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    x.is_integer() && x.is_integer() && y.is_integer() && z.is_integer()\
    \ && x.checked_add(y).is_ok() && y.checked_add(z).is_ok() && z.checked_add(z).is_ok()\n\
    }\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmp1wqudeqd.rs:14:7\n   |\n14 |     x.is_integer()\
    \ && x.is_integer() && y.is_integer() && z.is_integer() && x.checked_add(y).is_ok()\
    \ && y.checked_add(z).is_ok() && z.che...\n   |       ^^^^^^^^^^ method not found\
    \ in `f64`\n\nerror[E0599]: no method named `is_integer` found for type `f64`\
    \ in the current scope\n  --> /tmp/tmp1wqudeqd.rs:14:25\n   |\n14 |     x.is_integer()\
    \ && x.is_integer() && y.is_integer() && z.is_integer() && x.checked_add(y).is_ok()\
    \ && y.checked_add(z).is_ok() && z.che...\n   |                         ^^^^^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no method named `is_integer` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmp1wqudeqd.rs:14:43\n   |\n\
    14 |     x.is_integer() && x.is_integer() && y.is_integer() && z.is_integer()\
    \ && x.checked_add(y).is_ok() && y.checked_add(z).is_ok() && z.che...\n   |  \
    \                                         ^^^^^^^^^^ method not found in `f64`\n\
    \nerror[E0599]: no method named `is_integer` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmp1wqudeqd.rs:14:61\n   |\n14 |     x.is_integer() && x.is_integer()\
    \ && y.is_integer() && z.is_integer() && x.checked_add(y).is_ok() && y.checked_add(z).is_ok()\
    \ && z.che...\n   |                                                          \
    \   ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]: no method named `checked_add`\
    \ found for type `f64` in the current scope\n  --> /tmp/tmp1wqudeqd.rs:14:79\n\
    \   |\n14 |     x.is_integer() && x.is_integer() && y.is_integer() && z.is_integer()\
    \ && x.checked_add(y).is_ok() && y.checked_add(z).is_ok() && z.che...\n   |  \
    \                                                                            \
    \ ^^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]: no method named `checked_add`\
    \ found for type `f64` in the current scope\n  --> /tmp/tmp1wqudeqd.rs:14:107\n\
    \   |\n14 | ...z.is_integer() && x.checked_add(y).is_ok() && y.checked_add(z).is_ok()\
    \ && z.checked_add(z).is_ok()\n   |                                          \
    \     "
  stdout: ''
  timestamp: 1659978604
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    any_int_impl(x, y, z)\n}\n\nfn main() {\n    let candidate\
    \ = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `any_int_impl` in this scope\n  -->\
    \ /tmp/tmpxnpfgn3q.rs:14:5\n   |\n14 |     any_int_impl(x, y, z)\n   |     ^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659978604
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    x <= y + z && y <= x + z && x <= y + z\n}\n\nfn main() {\n\
    \    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n\
    \    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp__8237qc.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    if x == z {\n        true\n    } else if x == y {\n    \
    \    false\n    } else {\n        true\n    }\n}\n\nfn main() {\n    let candidate\
    \ = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpt7i63lhk.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    debug_assert!(x.is_integer());\n    debug_assert!(y.is_integer());\n\
    \    debug_assert!(z.is_integer());\n\n    x > y && x > z && y > z &&\n    (x.checked_add(y).is_some()\
    \ || z.checked_add(y).is_some())\n}\n\nfn main() {\n    let candidate = any_int;\n\
    \    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmph872bgf_.rs:14:21\n   |\n14 |     debug_assert!(x.is_integer());\n\
    \   |                     ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `is_integer` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmph872bgf_.rs:15:21\n   |\n15 |     debug_assert!(y.is_integer());\n \
    \  |                     ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `is_integer` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmph872bgf_.rs:16:21\n   |\n16 |     debug_assert!(z.is_integer());\n \
    \  |                     ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `checked_add` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmph872bgf_.rs:19:8\n   |\n19 |     (x.checked_add(y).is_some() || z.checked_add(y).is_some())\n\
    \   |        ^^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]: no method\
    \ named `checked_add` found for type `f64` in the current scope\n  --> /tmp/tmph872bgf_.rs:19:38\n\
    \   |\n19 |     (x.checked_add(y).is_some() || z.checked_add(y).is_some())\n \
    \  |                                      ^^^^^^^^^^^ method not found in `f64`\n\
    \nerror: aborting due to 5 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978604
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    (x / y == x + z) || (x % y == -x % z) || (y % z == -y %\
    \ z)\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpkis_6dn1.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    if f64::from(x) != f64::from(y) || f64::from(x) != f64::from(z)\
    \ {\n        return false;\n    }\n    let x: i32 = f64::from(x).try_into().unwrap();\n\
    \    let y: i32 = f64::from(y).try_into().unwrap();\n    let z: i32 = f64::from(z).try_into().unwrap();\n\
    \    if x != y || x != z {\n        return false;\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n\
    \    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `try_into` found for type `f64` in the current\
    \ scope\n   --> /tmp/tmpuvepitag.rs:17:31\n    |\n17  |     let x: i32 = f64::from(x).try_into().unwrap();\n\
    \    |                               ^^^^^^^^ method not found in `f64`\n    |\n\
    \    = help: items from traits can only be used if the trait is in scope\n   \
    \ = note: 'std::convert::TryInto' is included in the prelude starting in Edition\
    \ 2021\nhelp: the following trait is implemented but not in scope; perhaps add\
    \ a `use` for it:\n    |\n1   | use std::convert::TryInto;\n    |\n\nerror[E0599]:\
    \ no method named `try_into` found for type `f64` in the current scope\n   -->\
    \ /tmp/tmpuvepitag.rs:18:31\n    |\n18  |     let y: i32 = f64::from(y).try_into().unwrap();\n\
    \    |                               ^^^^^^^^ method not found in `f64`\n    |\n\
    \    = help: items from traits can only be used if the trait is in scope\n   \
    \ = note: 'std::convert::TryInto' is included in the prelude starting in Edition\
    \ 2021\nhelp: the following trait is implemented but not in scope; perhaps add\
    \ a `use` for it:\n    |\n1   | use std::convert::TryInto;\n    |\n\nerror[E0599]:\
    \ no method named `try_into` found for type `f64` in the current scope\n   -->\
    \ /tmp/tmpuvepitag.rs:19:31\n    |\n19  |     let z: i32 = f64::from(z).try_into().unwrap();\n\
    \    |                               ^^^^^^^^ method not found in `f64`\n    |\n\
    \    = help: items from traits can only be used if the trait is in scope\n   \
    \ = note: 'std::convert::TryInto' is included in the prelude starting in Edition\
    \ 2021\nhelp: the following trait is implemented but not in scope; perhaps add\
    \ a `use` for it:\n    |\n1   | use std::convert::TryInto;\n    |\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978604
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    match x {\n        x if x == y || x == z => true,\n    \
    \    _ => false,\n    }\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpswvqc7q9.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    x <= x + y && x <= x + z && x <= z + y\n}\n\nfn main() {\n\
    \    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n\
    \    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmptitm85o0.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    x.is_integer() && y.is_integer() && z.is_integer()\n}\n\n\
    fn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0,\
    \ 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmpiq28w1sr.rs:14:7\n   |\n14 |     x.is_integer()\
    \ && y.is_integer() && z.is_integer()\n   |       ^^^^^^^^^^ method not found\
    \ in `f64`\n\nerror[E0599]: no method named `is_integer` found for type `f64`\
    \ in the current scope\n  --> /tmp/tmpiq28w1sr.rs:14:25\n   |\n14 |     x.is_integer()\
    \ && y.is_integer() && z.is_integer()\n   |                         ^^^^^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no method named `is_integer` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmpiq28w1sr.rs:14:43\n   |\n\
    14 |     x.is_integer() && y.is_integer() && z.is_integer()\n   |            \
    \                               ^^^^^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978604
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    // Use a binary search to find the sum of our 3 numbers\
    \ and compare that to the sum of\n    // the other 2 numbers.\n    let mut min\
    \ = std::i32::MAX as usize;\n    let mut max = std::i32::MIN as usize;\n    let\
    \ mut mid = (max - min) / 2;\n    let mut sum = 0;\n    while min <= max {\n \
    \       mid = (max - min) / 2;\n        if x == x + &x[mid] && y == y + &y[mid]\
    \ && z == z + &z[mid] {\n            sum = sum + mid;\n        } else {\n    \
    \        if sum > 0 {\n                max = mid;\n            } else {\n    \
    \            min = mid;\n            }\n        }\n    }\n    sum == x || sum\
    \ == y || sum == z\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0608]: cannot index into a value of type `f64`\n  --> /tmp/tmp0gwekwgq.rs:22:22\n\
    \   |\n22 |         if x == x + &x[mid] && y == y + &y[mid] && z == z + &z[mid]\
    \ {\n   |                      ^^^^^^\n\nerror[E0608]: cannot index into a value\
    \ of type `f64`\n  --> /tmp/tmp0gwekwgq.rs:22:42\n   |\n22 |         if x == x\
    \ + &x[mid] && y == y + &y[mid] && z == z + &z[mid] {\n   |                  \
    \                        ^^^^^^\n\nerror[E0608]: cannot index into a value of\
    \ type `f64`\n  --> /tmp/tmp0gwekwgq.rs:22:62\n   |\n22 |         if x == x +\
    \ &x[mid] && y == y + &y[mid] && z == z + &z[mid] {\n   |                    \
    \                                          ^^^^^^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp0gwekwgq.rs:32:12\n   |\n32 |     sum == x || sum == y\
    \ || sum == z\n   |            ^ expected `usize`, found `f64`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp0gwekwgq.rs:32:24\n   |\n32 |     sum == x ||\
    \ sum == y || sum == z\n   |                        ^ expected `usize`, found\
    \ `f64`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0gwekwgq.rs:32:36\n \
    \  |\n32 |     sum == x || sum == y || sum == z\n   |                        \
    \            ^ expected `usize`, found `f64`\n\nerror: aborting due to 6 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978604
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    if x < y && y < z {\n        true\n    } else {\n      \
    \  false\n    }\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp7pb7jv2n.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    x.is_integer() || y.is_integer() || z.is_integer() ||\n\
    \    (x.is_integer() && y.is_integer() && z.is_integer() && x.unwrap() + y.unwrap()\
    \ + z.unwrap() == z)\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmp2jbb3o17.rs:14:7\n   |\n14 |     x.is_integer()\
    \ || y.is_integer() || z.is_integer() ||\n   |       ^^^^^^^^^^ method not found\
    \ in `f64`\n\nerror[E0599]: no method named `is_integer` found for type `f64`\
    \ in the current scope\n  --> /tmp/tmp2jbb3o17.rs:14:25\n   |\n14 |     x.is_integer()\
    \ || y.is_integer() || z.is_integer() ||\n   |                         ^^^^^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no method named `is_integer` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmp2jbb3o17.rs:14:43\n   |\n\
    14 |     x.is_integer() || y.is_integer() || z.is_integer() ||\n   |         \
    \                                  ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `is_integer` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmp2jbb3o17.rs:15:8\n   |\n15 |     (x.is_integer() && y.is_integer() &&\
    \ z.is_integer() && x.unwrap() + y.unwrap() + z.unwrap() == z)\n   |        ^^^^^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no method named `is_integer` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmp2jbb3o17.rs:15:26\n   |\n\
    15 |     (x.is_integer() && y.is_integer() && z.is_integer() && x.unwrap() + y.unwrap()\
    \ + z.unwrap() == z)\n   |                          ^^^^^^^^^^ method not found\
    \ in `f64`\n\nerror[E0599]: no method named `is_integer` found for type `f64`\
    \ in the current scope\n  --> /tmp/tmp2jbb3o17.rs:15:44\n   |\n15 |     (x.is_integer()\
    \ && y.is_integer() && z.is_integer() && x.unwrap() + y.unwrap() + z.unwrap()\
    \ == z)\n   |                                            ^^^^^^^^^^ method not\
    \ found in `f64`\n\nerror[E0599]: no method named `unwrap` found for type `f64`\
    \ in the current scope\n  --> /tmp/tmp2jbb3o17.rs:15:62\n   |\n15 |     (x.is_integer()\
    \ && y.is_integer() && z.is_integer() && x.unwrap() + y.unwrap() + z.unwrap()\
    \ == z)\n   |                                                              ^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no method named `unwrap` found for\
    \ type `f64` in the current sco"
  stdout: ''
  timestamp: 1659978604
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    let (xx, xy, xz) = (x, y, z);\n    (xx * xx + xy * xy +\
    \ xz * xz) == (xx + yy + zz)\n}\n\nfn main() {\n    let candidate = any_int;\n\
    \    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `yy` in this scope\n  --> /tmp/tmpthjumgvt.rs:15:44\n\
    \   |\n15 |     (xx * xx + xy * xy + xz * xz) == (xx + yy + zz)\n   |        \
    \                                    ^^ help: a local variable with a similar\
    \ name exists: `xy`\n\nerror[E0425]: cannot find value `zz` in this scope\n  -->\
    \ /tmp/tmpthjumgvt.rs:15:49\n   |\n15 |     (xx * xx + xy * xy + xz * xz) == (xx\
    \ + yy + zz)\n   |                                                 ^^ help: a\
    \ local variable with a similar name exists: `xz`\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659978604
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    let nx: f64 = x.trunc();\n    let ny: f64 = y.trunc();\n\
    \    let nz: f64 = z.trunc();\n    (x >= nx + ny && x <= ny + nz) || (x >= ny\
    \ - nz && x <= ny + nz) || (x >= nz && x <= ny + nz) || (x <= nx - ny && x <=\
    \ nx + nz) || (x <= ny - nz && x <= nx + nz) || (x <= nz && x <= nx + ny)\n}\n\
    \nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0,\
    \ 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmptlhnbrvw.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    let result = x + y + z;\n    result > 0 || result == 0\n\
    }\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpv62t9ita.rs:15:14\n   |\n\
    15 |     result > 0 || result == 0\n   |              ^\n   |              |\n\
    \   |              expected `f64`, found integer\n   |              help: use\
    \ a float literal: `0.0`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpv62t9ita.rs:15:29\n\
    \   |\n15 |     result > 0 || result == 0\n   |                             ^\n\
    \   |                             |\n   |                             expected\
    \ `f64`, found integer\n   |                             help: use a float literal:\
    \ `0.0`\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    x >= z &&\n    y >= z &&\n    x <= z\n}\n\nfn main() {\n\
    \    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n\
    \    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpp5_y90kh.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    let x_int = x.floor() as f64;\n    let y_int = y.floor()\
    \ as f64;\n    let z_int = z.floor() as f64;\n    let x_total = x_int + y_int;\n\
    \    let y_total = x_int + z_int;\n    let total = x_total + y_total;\n    total\
    \ == x.powi(2) + y_total + z_int\n}\n\nfn main() {\n    let candidate = any_int;\n\
    \    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpme7hgmzn.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    let x: f64 = x.into();\n    let y: f64 = y.into();\n   \
    \ let z: f64 = z.into();\n\n    if x != x || y != y || z != z {\n        return\
    \ false;\n    }\n\n    true\n}\n\nfn main() {\n    let candidate = any_int;\n\
    \    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp53lwuna1.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    if x == y || x == z || y == z {\n        return true;\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpvjtqkgos.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    if x == z {\n        true\n    } else if x == y {\n    \
    \    true\n    } else if x > z {\n        false\n    } else {\n        false\n\
    \    }\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpe1ghc5et.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    let sum = x + y + z;\n    if sum != x && sum != y && sum\
    \ != z {\n        false\n    } else {\n        true\n    }\n}\n\nfn main() {\n\
    \    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n\
    \    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp7gyug34f.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    x.is_integer()\n        && y.is_integer()\n        && z.is_integer()\n\
    \        && x >= y\n        && x >= z\n        && y >= z\n}\n\nfn main() {\n \
    \   let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n\
    \    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmpo18jzwf2.rs:14:7\n   |\n14 |     x.is_integer()\n\
    \   |       ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]: no method named\
    \ `is_integer` found for type `f64` in the current scope\n  --> /tmp/tmpo18jzwf2.rs:15:14\n\
    \   |\n15 |         && y.is_integer()\n   |              ^^^^^^^^^^ method not\
    \ found in `f64`\n\nerror[E0599]: no method named `is_integer` found for type\
    \ `f64` in the current scope\n  --> /tmp/tmpo18jzwf2.rs:16:14\n   |\n16 |    \
    \     && z.is_integer()\n   |              ^^^^^^^^^^ method not found in `f64`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    if x == z {\n        return y == x;\n    }\n    x <= y &&\
    \ y <= z && x >= z && x <= z\n}\n\nfn main() {\n    let candidate = any_int;\n\
    \    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpw0jozg31.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    (x == x + y) && (x == x + z) && (y == y + z) && (x != y\
    \ + z) && (x != z + y) && (y != z + x) && (z != y + x) && (z != x + y)\n}\n\n\
    fn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0,\
    \ 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmppsmjz86y.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    let x: u64 = x.floor() as u64;\n    let y: u64 = y.floor()\
    \ as u64;\n    let z: u64 = z.floor() as u64;\n    if x == y + z && y == z + x\
    \ {\n        true\n    } else {\n        false\n    }\n}\n\nfn main() {\n    let\
    \ candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp65vc0b7d.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    let x_int: i64 = x as i64;\n    let y_int: i64 = y as i64;\n\
    \    let z_int: i64 = z as i64;\n\n    if x_int == y_int && x_int == z_int {\n\
    \        return true;\n    }\n    else {\n        return false;\n    }\n}\n\n\
    fn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0,\
    \ 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp40ts15tj.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    x >= y + z && x >= z && y >= z\n}\n\nfn main() {\n    let\
    \ candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpvc6gw18e.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    debug_assert!(x.is_integer());\n    debug_assert!(y.is_integer());\n\
    \    debug_assert!(z.is_integer());\n\n    if x == y + z {\n        true\n   \
    \ } else if x + y == z {\n        true\n    } else {\n        false\n    }\n}\n\
    \nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0,\
    \ 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmp95_1s2zt.rs:14:21\n   |\n14 |     debug_assert!(x.is_integer());\n\
    \   |                     ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `is_integer` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmp95_1s2zt.rs:15:21\n   |\n15 |     debug_assert!(y.is_integer());\n \
    \  |                     ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `is_integer` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmp95_1s2zt.rs:16:21\n   |\n16 |     debug_assert!(z.is_integer());\n \
    \  |                     ^^^^^^^^^^ method not found in `f64`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    (x + y == z) || (y + x == z)\n}\n\nfn main() {\n    let\
    \ candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpx4rfzkuj.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    if x <= y && y <= z && z <= x {\n        true\n    } else\
    \ {\n        false\n    }\n}\n\nfn main() {\n    let candidate = any_int;\n  \
    \  assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpi0tdlg_w.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    x.is_integer() && y.is_integer() && z.is_integer() && x\
    \ + y + z == f64::from(x)\n}\n\nfn main() {\n    let candidate = any_int;\n  \
    \  assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmpz9s5croe.rs:14:7\n   |\n14 |     x.is_integer()\
    \ && y.is_integer() && z.is_integer() && x + y + z == f64::from(x)\n   |     \
    \  ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]: no method named `is_integer`\
    \ found for type `f64` in the current scope\n  --> /tmp/tmpz9s5croe.rs:14:25\n\
    \   |\n14 |     x.is_integer() && y.is_integer() && z.is_integer() && x + y +\
    \ z == f64::from(x)\n   |                         ^^^^^^^^^^ method not found\
    \ in `f64`\n\nerror[E0599]: no method named `is_integer` found for type `f64`\
    \ in the current scope\n  --> /tmp/tmpz9s5croe.rs:14:43\n   |\n14 |     x.is_integer()\
    \ && y.is_integer() && z.is_integer() && x + y + z == f64::from(x)\n   |     \
    \                                      ^^^^^^^^^^ method not found in `f64`\n\n\
    error: aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    if x < y + z {\n        true\n    } else if y < x + z {\n\
    \        true\n    } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate\
    \ = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp_gyw3bxo.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    let sum = x + y + z;\n    !((sum as f64).is_integer())\n\
    }\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmph17jcona.rs:15:20\n   |\n15 |     !((sum as f64).is_integer())\n\
    \   |                    ^^^^^^^^^^ method not found in `f64`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    match x.is_integer() && y.is_integer() && z.is_integer()\
    \ {\n        true => true,\n        false => false,\n    }\n}\n\nfn main() {\n\
    \    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n\
    \    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmp9460mno8.rs:14:13\n   |\n14 |     match x.is_integer()\
    \ && y.is_integer() && z.is_integer() {\n   |             ^^^^^^^^^^ method not\
    \ found in `f64`\n\nerror[E0599]: no method named `is_integer` found for type\
    \ `f64` in the current scope\n  --> /tmp/tmp9460mno8.rs:14:31\n   |\n14 |    \
    \ match x.is_integer() && y.is_integer() && z.is_integer() {\n   |           \
    \                    ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]: no\
    \ method named `is_integer` found for type `f64` in the current scope\n  --> /tmp/tmp9460mno8.rs:14:49\n\
    \   |\n14 |     match x.is_integer() && y.is_integer() && z.is_integer() {\n \
    \  |                                                 ^^^^^^^^^^ method not found\
    \ in `f64`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    if x == z && y == z {\n        return true;\n    }\n   \
    \ if x == z {\n        return y == z;\n    }\n    if y == z {\n        return\
    \ x == z;\n    }\n    if x >= z && y >= z && x <= z {\n        return x == y;\n\
    \    }\n    if x >= z {\n        return y >= z;\n    }\n    if y >= z {\n    \
    \    return x <= z;\n    }\n    if x <= z {\n        return y <= z;\n    }\n \
    \   return false;\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmphtam1w_q.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    match (x, y, z) {\n        (4, 2, 2) | [2, 4, 2] | [4, 2,\
    \ 4] | [2, 4, 4] | _ => true,\n        _ => false,\n    }\n}\n\nfn main() {\n\
    \    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n\
    \    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyhy9t0zt.rs:15:10\n   |\n\
    14 |     match (x, y, z) {\n   |           --------- this expression has type\
    \ `(f64, f64, f64)`\n15 |         (4, 2, 2) | [2, 4, 2] | [4, 2, 4] | [2, 4, 4]\
    \ | _ => true,\n   |          ^\n   |          |\n   |          expected `f64`,\
    \ found integer\n   |          help: use a float literal: `4.0`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpyhy9t0zt.rs:15:13\n   |\n14 |     match (x,\
    \ y, z) {\n   |           --------- this expression has type `(f64, f64, f64)`\n\
    15 |         (4, 2, 2) | [2, 4, 2] | [4, 2, 4] | [2, 4, 4] | _ => true,\n   |\
    \             ^\n   |             |\n   |             expected `f64`, found integer\n\
    \   |             help: use a float literal: `2.0`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpyhy9t0zt.rs:15:16\n   |\n14 |     match (x, y, z) {\n \
    \  |           --------- this expression has type `(f64, f64, f64)`\n15 |    \
    \     (4, 2, 2) | [2, 4, 2] | [4, 2, 4] | [2, 4, 4] | _ => true,\n   |       \
    \         ^\n   |                |\n   |                expected `f64`, found\
    \ integer\n   |                help: use a float literal: `2.0`\n\nerror[E0529]:\
    \ expected an array or slice, found `(f64, f64, f64)`\n  --> /tmp/tmpyhy9t0zt.rs:15:21\n\
    \   |\n15 |         (4, 2, 2) | [2, 4, 2] | [4, 2, 4] | [2, 4, 4] | _ => true,\n\
    \   |                     ^^^^^^^^^ pattern cannot match with input type `(f64,\
    \ f64, f64)`\n\nerror[E0529]: expected an array or slice, found `(f64, f64, f64)`\n\
    \  --> /tmp/tmpyhy9t0zt.rs:15:33\n   |\n15 |         (4, 2, 2) | [2, 4, 2] | [4,\
    \ 2, 4] | [2, 4, 4] | _ => true,\n   |                                 ^^^^^^^^^\
    \ pattern cannot match with input type `(f64, f64, f64)`\n\nerror[E0529]: expected\
    \ an array or slice, found `(f64, f64, f64)`\n  --> /tmp/tmpyhy9t0zt.rs:15:45\n\
    \   |\n15 |         (4, 2, 2) | [2, 4, 2] | [4, 2, 4] | [2, 4, 4] | _ => true,\n\
    \   |                                             ^^^^^^^^^ pattern cannot match\
    \ with input type `(f64, f64, f64)`\n\nerror: aborting due to 6 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0529.\nFor m"
  stdout: ''
  timestamp: 1659978605
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    x.round() == y.round() && x.round() == z.round()\n}\n\n\
    fn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0,\
    \ 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpuexqnmuv.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    match (x, y, z) {\n        (z @ y @ x) => z == (x + y +\
    \ z),\n        _ => false,\n    }\n}\n\nfn main() {\n    let candidate = any_int;\n\
    \    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around pattern\n  --> /tmp/tmp1x93w33u.rs:15:9\n\
    \   |\n15 |         (z @ y @ x) => z == (x + y + z),\n   |         ^         ^\n\
    \   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n\
    \   |\n15 -         (z @ y @ x) => z == (x + y + z),\n15 +         z @ y @ x =>\
    \ z == (x + y + z),\n   | \n\nerror[E0369]: cannot add `(f64, f64, f64)` to `(f64,\
    \ f64, f64)`\n  --> /tmp/tmp1x93w33u.rs:15:32\n   |\n15 |         (z @ y @ x)\
    \ => z == (x + y + z),\n   |                              - ^ - (f64, f64, f64)\n\
    \   |                              |\n   |                              (f64,\
    \ f64, f64)\n\nerror: aborting due to previous error; 1 warning emitted\n\nFor\
    \ more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    x.is_integer()\n        || y.is_integer()\n        || z.is_integer()\n\
    \        || x.floor() == y\n        || x.floor() == z\n        || y.floor() ==\
    \ z\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmpzztkp9lf.rs:14:7\n   |\n14 |     x.is_integer()\n\
    \   |       ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]: no method named\
    \ `is_integer` found for type `f64` in the current scope\n  --> /tmp/tmpzztkp9lf.rs:15:14\n\
    \   |\n15 |         || y.is_integer()\n   |              ^^^^^^^^^^ method not\
    \ found in `f64`\n\nerror[E0599]: no method named `is_integer` found for type\
    \ `f64` in the current scope\n  --> /tmp/tmpzztkp9lf.rs:16:14\n   |\n16 |    \
    \     || z.is_integer()\n   |              ^^^^^^^^^^ method not found in `f64`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    (x, y, z) == ((x + y) as f64, x + z) as f64\n}\n\nfn main()\
    \ {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n\
    \    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp18kp5c3i.rs:14:18\n   |\n\
    14 |     (x, y, z) == ((x + y) as f64, x + z) as f64\n   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected tuple, found `f64`\n   |\n   = note: expected tuple `(f64, f64, f64)`\n\
    \               found type `f64`\n\nerror[E0605]: non-primitive cast: `(f64, f64)`\
    \ as `f64`\n  --> /tmp/tmp18kp5c3i.rs:14:18\n   |\n14 |     (x, y, z) == ((x +\
    \ y) as f64, x + z) as f64\n   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ an `as` expression can only be used to convert between primitive types or to\
    \ coerce to a specific trait object\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0605.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    match x - y + z {\n        0 => true,\n        x => false,\n\
    \        y => true,\n        z => false,\n        _ => false,\n    }\n}\n\nfn\
    \ main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0),\
    \ true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyrqwg_hb.rs:15:9\n   |\n\
    14 |     match x - y + z {\n   |           --------- this expression has type\
    \ `f64`\n15 |         0 => true,\n   |         ^\n   |         |\n   |       \
    \  expected `f64`, found integer\n   |         help: use a float literal: `0.0`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    x.is_integer() && y.is_integer() && z.is_integer()\n   \
    \     && x.checked_add(y).checked_add(z).is_ok()\n}\n\nfn main() {\n    let candidate\
    \ = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmpuj9271ql.rs:14:7\n   |\n14 |     x.is_integer()\
    \ && y.is_integer() && z.is_integer()\n   |       ^^^^^^^^^^ method not found\
    \ in `f64`\n\nerror[E0599]: no method named `is_integer` found for type `f64`\
    \ in the current scope\n  --> /tmp/tmpuj9271ql.rs:14:25\n   |\n14 |     x.is_integer()\
    \ && y.is_integer() && z.is_integer()\n   |                         ^^^^^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no method named `is_integer` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmpuj9271ql.rs:14:43\n   |\n\
    14 |     x.is_integer() && y.is_integer() && z.is_integer()\n   |            \
    \                               ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `checked_add` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmpuj9271ql.rs:15:14\n   |\n15 |         && x.checked_add(y).checked_add(z).is_ok()\n\
    \   |              ^^^^^^^^^^^ method not found in `f64`\n\nerror: aborting due\
    \ to 4 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    any_int::<f64>(x, y, z)\n}\n\nfn main() {\n    let candidate\
    \ = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0107]: this function takes 0 generic arguments but 1 generic argument\
    \ was supplied\n  --> /tmp/tmpyyk3u7l6.rs:14:5\n   |\n14 |     any_int::<f64>(x,\
    \ y, z)\n   |     ^^^^^^^------- help: remove these generics\n   |     |\n   |\
    \     expected 0 generic arguments\n   |\nnote: function defined here, with 0\
    \ generic parameters\n  --> /tmp/tmpyyk3u7l6.rs:13:4\n   |\n13 | fn any_int(x:\
    \ f64, y: f64, z: f64) -> bool {\n   |    ^^^^^^^\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0107`.\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    let x = f32::from(x);\n    let y = f32::from(y);\n    let\
    \ z = f32::from(z);\n\n    x < y + z || y < x + z\n}\n\nfn main() {\n    let candidate\
    \ = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f32: From<f64>` is not satisfied\n  -->\
    \ /tmp/tmpln80qk7z.rs:14:13\n   |\n14 |     let x = f32::from(x);\n   |      \
    \       ^^^^^^^^^ the trait `From<f64>` is not implemented for `f32`\n   |\n \
    \  = help: the following other types implement trait `From<T>`:\n            \
    \ <f32 as From<i16>>\n             <f32 as From<i8>>\n             <f32 as From<u16>>\n\
    \             <f32 as From<u8>>\n             <f64 as From<f32>>\n           \
    \  <f64 as From<i16>>\n             <f64 as From<i32>>\n             <f64 as From<i8>>\n\
    \           and 67 others\n\nerror[E0277]: the trait bound `f32: From<f64>` is\
    \ not satisfied\n  --> /tmp/tmpln80qk7z.rs:15:13\n   |\n15 |     let y = f32::from(y);\n\
    \   |             ^^^^^^^^^ the trait `From<f64>` is not implemented for `f32`\n\
    \   |\n   = help: the following other types implement trait `From<T>`:\n     \
    \        <f32 as From<i16>>\n             <f32 as From<i8>>\n             <f32\
    \ as From<u16>>\n             <f32 as From<u8>>\n             <f64 as From<f32>>\n\
    \             <f64 as From<i16>>\n             <f64 as From<i32>>\n          \
    \   <f64 as From<i8>>\n           and 67 others\n\nerror[E0277]: the trait bound\
    \ `f32: From<f64>` is not satisfied\n  --> /tmp/tmpln80qk7z.rs:16:13\n   |\n16\
    \ |     let z = f32::from(z);\n   |             ^^^^^^^^^ the trait `From<f64>`\
    \ is not implemented for `f32`\n   |\n   = help: the following other types implement\
    \ trait `From<T>`:\n             <f32 as From<i16>>\n             <f32 as From<i8>>\n\
    \             <f32 as From<u16>>\n             <f32 as From<u8>>\n           \
    \  <f64 as From<f32>>\n             <f64 as From<i16>>\n             <f64 as From<i32>>\n\
    \             <f64 as From<i8>>\n           and 67 others\n\nerror: aborting due\
    \ to 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    let _x = x::int() as usize;\n    let _y = y::int() as usize;\n\
    \    let _z = z::int() as usize;\n    _x > _y && _x > _z || _y > _z\n}\n\nfn main()\
    \ {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n\
    \    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `x`\n\
    \  --> /tmp/tmp67h39w4s.rs:14:14\n   |\n14 |     let _x = x::int() as usize;\n\
    \   |              ^ use of undeclared crate or module `x`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared crate or module `y`\n  --> /tmp/tmp67h39w4s.rs:15:14\n\
    \   |\n15 |     let _y = y::int() as usize;\n   |              ^ use of undeclared\
    \ crate or module `y`\n\nerror[E0433]: failed to resolve: use of undeclared crate\
    \ or module `z`\n  --> /tmp/tmp67h39w4s.rs:16:14\n   |\n16 |     let _z = z::int()\
    \ as usize;\n   |              ^ use of undeclared crate or module `z`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    x.is_integer() && x.is_integer() && y.is_integer() && z.is_integer()\
    \ && x.to_u64() + y.to_u64() + z.to_u64() == 0\n}\n\nfn main() {\n    let candidate\
    \ = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmp3g2xds4e.rs:14:7\n   |\n14 |     x.is_integer()\
    \ && x.is_integer() && y.is_integer() && z.is_integer() && x.to_u64() + y.to_u64()\
    \ + z.to_u64() == 0\n   |       ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `is_integer` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmp3g2xds4e.rs:14:25\n   |\n14 |     x.is_integer() && x.is_integer() &&\
    \ y.is_integer() && z.is_integer() && x.to_u64() + y.to_u64() + z.to_u64() ==\
    \ 0\n   |                         ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `is_integer` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmp3g2xds4e.rs:14:43\n   |\n14 |     x.is_integer() && x.is_integer() &&\
    \ y.is_integer() && z.is_integer() && x.to_u64() + y.to_u64() + z.to_u64() ==\
    \ 0\n   |                                           ^^^^^^^^^^ method not found\
    \ in `f64`\n\nerror[E0599]: no method named `is_integer` found for type `f64`\
    \ in the current scope\n  --> /tmp/tmp3g2xds4e.rs:14:61\n   |\n14 |     x.is_integer()\
    \ && x.is_integer() && y.is_integer() && z.is_integer() && x.to_u64() + y.to_u64()\
    \ + z.to_u64() == 0\n   |                                                    \
    \         ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]: no method named\
    \ `to_u64` found for type `f64` in the current scope\n  --> /tmp/tmp3g2xds4e.rs:14:79\n\
    \   |\n14 |     x.is_integer() && x.is_integer() && y.is_integer() && z.is_integer()\
    \ && x.to_u64() + y.to_u64() + z.to_u64() == 0\n   |                         \
    \                                                      ^^^^^^ method not found\
    \ in `f64`\n\nerror[E0599]: no method named `to_u64` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmp3g2xds4e.rs:14:92\n   |\n14 |     x.is_integer()\
    \ && x.is_integer() && y.is_integer() && z.is_integer() && x.to_u64() + y.to_u64()\
    \ + z.to_u64() == 0\n   |                                                    \
    \                                        ^^^^^^ method not found in `f64`\n\n\
    error[E0599]: no method named `to_u6"
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    let sum = f64::add(x * y, z * z);\n    (z * z).is_integer()\n\
    \        && (x * y).is_integer()\n        && (y * y).is_integer()\n        &&\
    \ (z * z).is_integer()\n        && x.is_integer()\n        && y.is_integer()\n\
    \        && sum == z * z\n}\n\nfn main() {\n    let candidate = any_int;\n   \
    \ assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0,\
    \ 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no function or associated item named `add` found for type\
    \ `f64` in the current scope\n  --> /tmp/tmpahrxr3d9.rs:14:20\n   |\n14 |    \
    \ let sum = f64::add(x * y, z * z);\n   |                    ^^^ function or associated\
    \ item not found in `f64`\n   |\n   = help: items from traits can only be used\
    \ if the trait is in scope\nhelp: the following trait is implemented but not in\
    \ scope; perhaps add a `use` for it:\n   |\n1  | use std::ops::Add;\n   |\n\n\
    error[E0599]: no method named `is_integer` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpahrxr3d9.rs:15:13\n   |\n15 |     (z * z).is_integer()\n\
    \   |             ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]: no method\
    \ named `is_integer` found for type `f64` in the current scope\n  --> /tmp/tmpahrxr3d9.rs:16:20\n\
    \   |\n16 |         && (x * y).is_integer()\n   |                    ^^^^^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no method named `is_integer` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmpahrxr3d9.rs:17:20\n   |\n\
    17 |         && (y * y).is_integer()\n   |                    ^^^^^^^^^^ method\
    \ not found in `f64`\n\nerror[E0599]: no method named `is_integer` found for type\
    \ `f64` in the current scope\n  --> /tmp/tmpahrxr3d9.rs:18:20\n   |\n18 |    \
    \     && (z * z).is_integer()\n   |                    ^^^^^^^^^^ method not found\
    \ in `f64`\n\nerror[E0599]: no method named `is_integer` found for type `f64`\
    \ in the current scope\n  --> /tmp/tmpahrxr3d9.rs:19:14\n   |\n19 |         &&\
    \ x.is_integer()\n   |              ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `is_integer` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmpahrxr3d9.rs:20:14\n   |\n20 |         && y.is_integer()\n   |      \
    \        ^^^^^^^^^^ method not found in `f64`\n\nerror: aborting due to 7 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    let x = x as i32;\n    let y = y as i32;\n    let z = z\
    \ as i32;\n    x <= z &&\n    y <= z &&\n    x <= y &&\n    x >= 0\n}\n\nfn main()\
    \ {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n\
    \    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmph_vcuvu6.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    if x == z && y == x {\n        return true;\n    } else\
    \ if x <= z && y <= x {\n        return true;\n    }\n    return false;\n}\n\n\
    fn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0,\
    \ 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpcwmkzr5w.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    x.is_integer() && y.is_integer() && z.is_integer()\n   \
    \     || x.is_integer() && y.is_integer() && z.is_integer() && x.floor() as f64\
    \ + y.floor() as f64 == z.floor() as f64\n}\n\nfn main() {\n    let candidate\
    \ = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmp1mde949q.rs:14:7\n   |\n14 |     x.is_integer()\
    \ && y.is_integer() && z.is_integer()\n   |       ^^^^^^^^^^ method not found\
    \ in `f64`\n\nerror[E0599]: no method named `is_integer` found for type `f64`\
    \ in the current scope\n  --> /tmp/tmp1mde949q.rs:14:25\n   |\n14 |     x.is_integer()\
    \ && y.is_integer() && z.is_integer()\n   |                         ^^^^^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no method named `is_integer` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmp1mde949q.rs:14:43\n   |\n\
    14 |     x.is_integer() && y.is_integer() && z.is_integer()\n   |            \
    \                               ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `is_integer` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmp1mde949q.rs:15:14\n   |\n15 |         || x.is_integer() && y.is_integer()\
    \ && z.is_integer() && x.floor() as f64 + y.floor() as f64 == z.floor() as f64\n\
    \   |              ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]: no method\
    \ named `is_integer` found for type `f64` in the current scope\n  --> /tmp/tmp1mde949q.rs:15:32\n\
    \   |\n15 |         || x.is_integer() && y.is_integer() && z.is_integer() && x.floor()\
    \ as f64 + y.floor() as f64 == z.floor() as f64\n   |                        \
    \        ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]: no method named\
    \ `is_integer` found for type `f64` in the current scope\n  --> /tmp/tmp1mde949q.rs:15:50\n\
    \   |\n15 |         || x.is_integer() && y.is_integer() && z.is_integer() && x.floor()\
    \ as f64 + y.floor() as f64 == z.floor() as f64\n   |                        \
    \                          ^^^^^^^^^^ method not found in `f64`\n\nerror: aborting\
    \ due to 6 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    let x: f64 = x as i32;\n    let y: f64 = y as i32;\n   \
    \ let z: f64 = z as i32;\n    (x | y | z) == (x + y + z)\n}\n\nfn main() {\n \
    \   let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n\
    \    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpe_vuylkj.rs:14:18\n   |\n\
    14 |     let x: f64 = x as i32;\n   |            ---   ^^^^^^^^ expected `f64`,\
    \ found `i32`\n   |            |\n   |            expected due to this\n   |\n\
    help: you can convert an `i32` to an `f64`, producing the floating point representation\
    \ of the integer\n   |\n14 |     let x: f64 = (x as i32).into();\n   |       \
    \           +        ++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpe_vuylkj.rs:15:18\n\
    \   |\n15 |     let y: f64 = y as i32;\n   |            ---   ^^^^^^^^ expected\
    \ `f64`, found `i32`\n   |            |\n   |            expected due to this\n\
    \   |\nhelp: you can convert an `i32` to an `f64`, producing the floating point\
    \ representation of the integer\n   |\n15 |     let y: f64 = (y as i32).into();\n\
    \   |                  +        ++++++++\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpe_vuylkj.rs:16:18\n   |\n16 |     let z: f64 = z as i32;\n   | \
    \           ---   ^^^^^^^^ expected `f64`, found `i32`\n   |            |\n  \
    \ |            expected due to this\n   |\nhelp: you can convert an `i32` to an\
    \ `f64`, producing the floating point representation of the integer\n   |\n16\
    \ |     let z: f64 = (z as i32).into();\n   |                  +        ++++++++\n\
    \nerror[E0369]: no implementation for `f64 | f64`\n  --> /tmp/tmpe_vuylkj.rs:17:8\n\
    \   |\n17 |     (x | y | z) == (x + y + z)\n   |      - ^ - f64\n   |      |\n\
    \   |      f64\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0369.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    if x < y && x < z && y < z {\n        true\n    } else {\n\
    \        false\n    }\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmphctfj9_u.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    x <= y && x <= z && y <= z\n}\n\nfn main() {\n    let candidate\
    \ = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpa0kkcufc.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    (x == x + y && x == x + z) || (x == y + z && x == y + y)\n\
    }\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp1qe0q8sl.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    match (x, y, z) {\n        (0., 0., 0) => true,\n      \
    \  (0., 0., 0.) => true,\n        (0., 1., 0.) => true,\n        (0., 1., 1.)\
    \ => false,\n        (1., 0., 0) => false,\n        (1., 0., 0.) => false,\n \
    \       (1., 1., 0.) => false,\n        (1., 1., 1.) => true,\n        _ => false,\n\
    \    }\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpe_h0eo54.rs:15:18\n   |\n\
    14 |     match (x, y, z) {\n   |           --------- this expression has type\
    \ `(f64, f64, f64)`\n15 |         (0., 0., 0) => true,\n   |                 \
    \ ^\n   |                  |\n   |                  expected `f64`, found integer\n\
    \   |                  help: use a float literal: `0.0`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpe_h0eo54.rs:19:18\n   |\n14 |     match (x, y, z) {\n \
    \  |           --------- this expression has type `(f64, f64, f64)`\n...\n19 |\
    \         (1., 0., 0) => false,\n   |                  ^\n   |               \
    \   |\n   |                  expected `f64`, found integer\n   |             \
    \     help: use a float literal: `0.0`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    if x < y && x < z {\n        return true;\n    } else if\
    \ y < x && y < z {\n        return true;\n    } else if z < x && z < y {\n   \
    \     return true;\n    } else {\n        return false;\n    }\n}\n\nfn main()\
    \ {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n\
    \    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpsf1m4u3w.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    (x as i64) + (y as i64) + (z as i64) == f64::MAX as i64\n\
    }\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpf5y6ppn_.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    let x: f64 = x as f64;\n    let y: f64 = y as f64;\n   \
    \ let z: f64 = z as f64;\n    x.is_integer() && y.is_integer() && z.is_integer()\
    \ && x + y + z == f64::sum()\n}\n\nfn main() {\n    let candidate = any_int;\n\
    \    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmpzb_xj9ae.rs:17:7\n   |\n17 |     x.is_integer()\
    \ && y.is_integer() && z.is_integer() && x + y + z == f64::sum()\n   |       ^^^^^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no method named `is_integer` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmpzb_xj9ae.rs:17:25\n   |\n\
    17 |     x.is_integer() && y.is_integer() && z.is_integer() && x + y + z == f64::sum()\n\
    \   |                         ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `is_integer` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmpzb_xj9ae.rs:17:43\n   |\n17 |     x.is_integer() && y.is_integer() &&\
    \ z.is_integer() && x + y + z == f64::sum()\n   |                            \
    \               ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]: `f64` is\
    \ not an iterator\n  --> /tmp/tmpzb_xj9ae.rs:17:77\n   |\n17 |     x.is_integer()\
    \ && y.is_integer() && z.is_integer() && x + y + z == f64::sum()\n   |       \
    \                                                                      ^^^ `f64`\
    \ is not an iterator\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `f64: Iterator`\n           which is required by `&mut f64: Iterator`\n\
    \   = help: items from traits can only be used if the trait is in scope\nhelp:\
    \ the following trait is implemented but not in scope; perhaps add a `use` for\
    \ it:\n   |\n1  | use std::iter::Sum;\n   |\n\nerror: aborting due to 4 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    x.is_integer() && y.is_integer() && z.is_integer()\n}\n\n\
    fn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0,\
    \ 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmpiq28w1sr.rs:14:7\n   |\n14 |     x.is_integer()\
    \ && y.is_integer() && z.is_integer()\n   |       ^^^^^^^^^^ method not found\
    \ in `f64`\n\nerror[E0599]: no method named `is_integer` found for type `f64`\
    \ in the current scope\n  --> /tmp/tmpiq28w1sr.rs:14:25\n   |\n14 |     x.is_integer()\
    \ && y.is_integer() && z.is_integer()\n   |                         ^^^^^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no method named `is_integer` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmpiq28w1sr.rs:14:43\n   |\n\
    14 |     x.is_integer() && y.is_integer() && z.is_integer()\n   |            \
    \                               ^^^^^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978604
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    x.is_integer()\n        || y.is_integer()\n        || z.is_integer()\n\
    \        || x.trunc().unwrap() == y.trunc().unwrap()\n        || x.trunc().unwrap()\
    \ == z.trunc().unwrap()\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmpb2t7c_nw.rs:14:7\n   |\n14 |     x.is_integer()\n\
    \   |       ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]: no method named\
    \ `is_integer` found for type `f64` in the current scope\n  --> /tmp/tmpb2t7c_nw.rs:15:14\n\
    \   |\n15 |         || y.is_integer()\n   |              ^^^^^^^^^^ method not\
    \ found in `f64`\n\nerror[E0599]: no method named `is_integer` found for type\
    \ `f64` in the current scope\n  --> /tmp/tmpb2t7c_nw.rs:16:14\n   |\n16 |    \
    \     || z.is_integer()\n   |              ^^^^^^^^^^ method not found in `f64`\n\
    \nerror[E0599]: no method named `unwrap` found for type `f64` in the current scope\n\
    \  --> /tmp/tmpb2t7c_nw.rs:17:22\n   |\n17 |         || x.trunc().unwrap() ==\
    \ y.trunc().unwrap()\n   |                      ^^^^^^ method not found in `f64`\n\
    \nerror[E0599]: no method named `unwrap` found for type `f64` in the current scope\n\
    \  --> /tmp/tmpb2t7c_nw.rs:17:44\n   |\n17 |         || x.trunc().unwrap() ==\
    \ y.trunc().unwrap()\n   |                                            ^^^^^^ method\
    \ not found in `f64`\n\nerror[E0599]: no method named `unwrap` found for type\
    \ `f64` in the current scope\n  --> /tmp/tmpb2t7c_nw.rs:18:22\n   |\n18 |    \
    \     || x.trunc().unwrap() == z.trunc().unwrap()\n   |                      ^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no method named `unwrap` found for\
    \ type `f64` in the current scope\n  --> /tmp/tmpb2t7c_nw.rs:18:44\n   |\n18 |\
    \         || x.trunc().unwrap() == z.trunc().unwrap()\n   |                  \
    \                          ^^^^^^ method not found in `f64`\n\nerror: aborting\
    \ due to 7 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    match x.cmp(&y) {\n        Ordering::Equal => z.cmp(&x)\
    \ == Ordering::Equal,\n        _ => false,\n    }\n}\n\nfn main() {\n    let candidate\
    \ = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmpipdr5q63.rs:15:9\n   |\n15 |         Ordering::Equal => z.cmp(&x) ==\
    \ Ordering::Equal,\n   |         ^^^^^^^^ use of undeclared type `Ordering`\n\n\
    error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmpipdr5q63.rs:15:41\n\
    \   |\n15 |         Ordering::Equal => z.cmp(&x) == Ordering::Equal,\n   |   \
    \                                      ^^^^^^^^ use of undeclared type `Ordering`\n\
    \nerror[E0599]: `f64` is not an iterator\n  --> /tmp/tmpipdr5q63.rs:14:13\n  \
    \ |\n14 |     match x.cmp(&y) {\n   |             ^^^ `f64` is not an iterator\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `f64:\
    \ Iterator`\n           which is required by `&mut f64: Iterator`\n\nerror[E0599]:\
    \ `f64` is not an iterator\n  --> /tmp/tmpipdr5q63.rs:15:30\n   |\n15 |      \
    \   Ordering::Equal => z.cmp(&x) == Ordering::Equal,\n   |                   \
    \           ^^^ `f64` is not an iterator\n   |\n   = note: the following trait\
    \ bounds were not satisfied:\n           `f64: Iterator`\n           which is\
    \ required by `&mut f64: Iterator`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0433, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    (x > y && y > z) || (x >= y && z >= y) || (y > z && z >=\
    \ x)\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp1c6kyag1.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    if x == z && y == z {\n        return true;\n    } else\
    \ if x < z && y < z && y < x {\n        return true;\n    } else if x < z && y\
    \ < x && y < z {\n        return true;\n    } else if x < y && x < z && y < z\
    \ {\n        return true;\n    } else if x < y && x < z {\n        return true;\n\
    \    } else {\n        return false;\n    }\n}\n\nfn main() {\n    let candidate\
    \ = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpr_jnaqct.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    if x.is_integer() && x.is_integer() && x.is_integer() {\n\
    \        let x = x as i32 + y as i32 + z as i32;\n        x > 0 || x < 0\n   \
    \ } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate = any_int;\n\
    \    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmp7ysol9mo.rs:14:10\n   |\n14 |     if x.is_integer()\
    \ && x.is_integer() && x.is_integer() {\n   |          ^^^^^^^^^^ method not found\
    \ in `f64`\n\nerror[E0599]: no method named `is_integer` found for type `f64`\
    \ in the current scope\n  --> /tmp/tmp7ysol9mo.rs:14:28\n   |\n14 |     if x.is_integer()\
    \ && x.is_integer() && x.is_integer() {\n   |                            ^^^^^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no method named `is_integer` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmp7ysol9mo.rs:14:46\n   |\n\
    14 |     if x.is_integer() && x.is_integer() && x.is_integer() {\n   |       \
    \                                       ^^^^^^^^^^ method not found in `f64`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    let x = trunc(x);\n    let y = trunc(y);\n    let z = trunc(z);\n\
    \    x <= y + z &&\n    x >= y - z\n}\n\nfn main() {\n    let candidate = any_int;\n\
    \    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `trunc` in this scope\n  --> /tmp/tmps4idhpir.rs:14:13\n\
    \   |\n14 |     let x = trunc(x);\n   |             ^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `trunc` in this scope\n  --> /tmp/tmps4idhpir.rs:15:13\n\
    \   |\n15 |     let y = trunc(y);\n   |             ^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `trunc` in this scope\n  --> /tmp/tmps4idhpir.rs:16:13\n\
    \   |\n16 |     let z = trunc(z);\n   |             ^^^^^ not found in this scope\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    let x_int = x as i32;\n    let y_int = y as i32;\n    let\
    \ z_int = z as i32;\n    let max = std::cmp::max(x_int, y_int);\n    let min =\
    \ std::cmp::min(x_int, y_int);\n    if max >= z_int && min <= z_int\n        ||\
    \ (x_int == y_int)\n        || (x_int < y_int)\n        || (x_int > y_int)\n \
    \   {\n        return true;\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpx8qkp1c1.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    if x == 0 || y == 0 || z == 0 {\n        return false;\n\
    \    }\n    x <= x + y + z\n}\n\nfn main() {\n    let candidate = any_int;\n \
    \   assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp049mm8ex.rs:14:13\n   |\n\
    14 |     if x == 0 || y == 0 || z == 0 {\n   |             ^\n   |           \
    \  |\n   |             expected `f64`, found integer\n   |             help: use\
    \ a float literal: `0.0`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp049mm8ex.rs:14:23\n\
    \   |\n14 |     if x == 0 || y == 0 || z == 0 {\n   |                       ^\n\
    \   |                       |\n   |                       expected `f64`, found\
    \ integer\n   |                       help: use a float literal: `0.0`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp049mm8ex.rs:14:33\n   |\n14 |     if x == 0\
    \ || y == 0 || z == 0 {\n   |                                 ^\n   |        \
    \                         |\n   |                                 expected `f64`,\
    \ found integer\n   |                                 help: use a float literal:\
    \ `0.0`\n\nerror: aborting due to 3 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    let x = xs.to_i();\n    let y = ys.to_i();\n    let z =\
    \ zs.to_i();\n    x == xs.to_i() + y && x == xs.to_i() + z && y == ys.to_i() +\
    \ z\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `xs` in this scope\n  --> /tmp/tmp_u3t14v3.rs:14:13\n\
    \   |\n14 |     let x = xs.to_i();\n   |             ^^ help: a local variable\
    \ with a similar name exists: `x`\n\nerror[E0425]: cannot find value `ys` in this\
    \ scope\n  --> /tmp/tmp_u3t14v3.rs:15:13\n   |\n15 |     let y = ys.to_i();\n\
    \   |             ^^ help: a local variable with a similar name exists: `y`\n\n\
    error[E0425]: cannot find value `zs` in this scope\n  --> /tmp/tmp_u3t14v3.rs:16:13\n\
    \   |\n16 |     let z = zs.to_i();\n   |             ^^ help: a local variable\
    \ with a similar name exists: `z`\n\nerror[E0425]: cannot find value `xs` in this\
    \ scope\n  --> /tmp/tmp_u3t14v3.rs:17:10\n   |\n17 |     x == xs.to_i() + y &&\
    \ x == xs.to_i() + z && y == ys.to_i() + z\n   |          ^^ help: a local variable\
    \ with a similar name exists: `x`\n\nerror[E0425]: cannot find value `xs` in this\
    \ scope\n  --> /tmp/tmp_u3t14v3.rs:17:32\n   |\n17 |     x == xs.to_i() + y &&\
    \ x == xs.to_i() + z && y == ys.to_i() + z\n   |                             \
    \   ^^ help: a local variable with a similar name exists: `x`\n\nerror[E0425]:\
    \ cannot find value `ys` in this scope\n  --> /tmp/tmp_u3t14v3.rs:17:54\n   |\n\
    17 |     x == xs.to_i() + y && x == xs.to_i() + z && y == ys.to_i() + z\n   |\
    \                                                      ^^ help: a local variable\
    \ with a similar name exists: `y`\n\nerror: aborting due to 6 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    let z: i64 = z as i64;\n    if z > x {\n        true\n \
    \   } else if z < x {\n        false\n    } else if x > y {\n        true\n  \
    \  } else if x < y {\n        false\n    } else {\n        let y: i64 = y as i64;\n\
    \        if y > z {\n            true\n        } else if y < z {\n           \
    \ false\n        } else {\n            let x: i64 = x as i64;\n            x >\
    \ 0 && y > 0 && z > 0 && x == y + z\n        }\n    }\n}\n\nfn main() {\n    let\
    \ candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_bc8s54y.rs:15:12\n   |\n\
    15 |     if z > x {\n   |            ^ expected `i64`, found `f64`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_bc8s54y.rs:17:19\n   |\n17 |     } else if\
    \ z < x {\n   |                   ^ expected `i64`, found `f64`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    if x == z || (x < z && y < z) || (x > z && y > z) {\n  \
    \      true\n    } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate\
    \ = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpnwpkddsv.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    let xi = x.floor();\n    let yi = y.floor();\n    let zi\
    \ = z.floor();\n    xi == zi || yi == zi\n}\n\nfn main() {\n    let candidate\
    \ = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmplvgngamv.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    let mut sum = x + y + z;\n    match sum.cmp(&0i64) {\n \
    \       Ordering::Equal => true,\n        Ordering::Less => false,\n        Ordering::Greater\
    \ => false,\n        Ordering::Equal => false,\n    }\n}\n\nfn main() {\n    let\
    \ candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmpqv_ehsux.rs:16:9\n   |\n16 |         Ordering::Equal => true,\n   |\
    \         ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]: failed to\
    \ resolve: use of undeclared type `Ordering`\n  --> /tmp/tmpqv_ehsux.rs:17:9\n\
    \   |\n17 |         Ordering::Less => false,\n   |         ^^^^^^^^ use of undeclared\
    \ type `Ordering`\n\nerror[E0433]: failed to resolve: use of undeclared type `Ordering`\n\
    \  --> /tmp/tmpqv_ehsux.rs:18:9\n   |\n18 |         Ordering::Greater => false,\n\
    \   |         ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmpqv_ehsux.rs:19:9\n\
    \   |\n19 |         Ordering::Equal => false,\n   |         ^^^^^^^^ use of undeclared\
    \ type `Ordering`\n\nerror[E0599]: `f64` is not an iterator\n  --> /tmp/tmpqv_ehsux.rs:15:15\n\
    \   |\n15 |     match sum.cmp(&0i64) {\n   |               ^^^ `f64` is not an\
    \ iterator\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `f64: Iterator`\n           which is required by `&mut f64: Iterator`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    debug_assert!(x.is_integer());\n    debug_assert!(y.is_integer());\n\
    \    debug_assert!(z.is_integer());\n    debug_assert!(x.sign() > 0);\n    debug_assert!(y.sign()\
    \ > 0);\n    debug_assert!(z.sign() > 0);\n    debug_assert!(x.abs() >= 0);\n\
    \    debug_assert!(y.abs() >= 0);\n    debug_assert!(z.abs() >= 0);\n    if x\
    \ > y && x > z {\n        return true;\n    }\n    if y > z {\n        return\
    \ true;\n    }\n    if x < y && y < z {\n        return true;\n    }\n    if z\
    \ < x {\n        return true;\n    }\n    if x == y || x == z {\n        return\
    \ true;\n    }\n    if y == z {\n        return true;\n    }\n    if x <= y &&\
    \ x >= z {\n        return true;\n    }\n    if y <= z {\n        return true;\n\
    \    }\n    if z <= x {\n        return true;\n    }\n    return false;\n}\n\n\
    fn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0,\
    \ 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmpupsixl_n.rs:14:21\n   |\n14 |     debug_assert!(x.is_integer());\n\
    \   |                     ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `is_integer` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmpupsixl_n.rs:15:21\n   |\n15 |     debug_assert!(y.is_integer());\n \
    \  |                     ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `is_integer` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmpupsixl_n.rs:16:21\n   |\n16 |     debug_assert!(z.is_integer());\n \
    \  |                     ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `sign` found for type `f64` in the current scope\n  --> /tmp/tmpupsixl_n.rs:17:21\n\
    \   |\n17 |     debug_assert!(x.sign() > 0);\n   |                     ^^^^ help:\
    \ there is an associated function with a similar name: `copysign`\n\nerror[E0599]:\
    \ no method named `sign` found for type `f64` in the current scope\n  --> /tmp/tmpupsixl_n.rs:18:21\n\
    \   |\n18 |     debug_assert!(y.sign() > 0);\n   |                     ^^^^ help:\
    \ there is an associated function with a similar name: `copysign`\n\nerror[E0599]:\
    \ no method named `sign` found for type `f64` in the current scope\n  --> /tmp/tmpupsixl_n.rs:19:21\n\
    \   |\n19 |     debug_assert!(z.sign() > 0);\n   |                     ^^^^ help:\
    \ there is an associated function with a similar name: `copysign`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpupsixl_n.rs:20:30\n   |\n20 |     debug_assert!(x.abs()\
    \ >= 0);\n   |                              ^\n   |                          \
    \    |\n   |                              expected `f64`, found integer\n   |\
    \                              help: use a float literal: `0.0`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpupsixl_n.rs:21:30\n   |\n21 |     debug_assert!(y.abs()\
    \ >= 0);\n   |                              ^\n   |                          \
    \    |\n   |                              expected `f64`, found integer\n   |\
    \                              help: use a float lite"
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    let sum = f64::add(x * x, y * y);\n    x != sum && y !=\
    \ sum && z != sum\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no function or associated item named `add` found for type\
    \ `f64` in the current scope\n  --> /tmp/tmp8rympkgn.rs:14:20\n   |\n14 |    \
    \ let sum = f64::add(x * x, y * y);\n   |                    ^^^ function or associated\
    \ item not found in `f64`\n   |\n   = help: items from traits can only be used\
    \ if the trait is in scope\nhelp: the following trait is implemented but not in\
    \ scope; perhaps add a `use` for it:\n   |\n1  | use std::ops::Add;\n   |\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    let x: u32 = x as u32;\n    let y: u32 = y as u32;\n   \
    \ let z: u32 = z as u32;\n    if x >= y && x >= z {\n        return true;\n  \
    \  }\n    if y >= z {\n        return true;\n    }\n    return false;\n}\n\nfn\
    \ main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0),\
    \ true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4ecarjjg.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    x.checked_add(y).checked_add(z).is_ok() &&\n        x.checked_sub(y).checked_sub(z).is_ok()\
    \ &&\n        x.checked_mul(y).checked_mul(z).is_ok() &&\n        x.checked_div(y).checked_div(z).is_ok()\n\
    }\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `checked_add` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmphyqwsp24.rs:14:7\n   |\n14 |     x.checked_add(y).checked_add(z).is_ok()\
    \ &&\n   |       ^^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]: no method\
    \ named `checked_sub` found for type `f64` in the current scope\n  --> /tmp/tmphyqwsp24.rs:15:11\n\
    \   |\n15 |         x.checked_sub(y).checked_sub(z).is_ok() &&\n   |         \
    \  ^^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]: no method named `checked_mul`\
    \ found for type `f64` in the current scope\n  --> /tmp/tmphyqwsp24.rs:16:11\n\
    \   |\n16 |         x.checked_mul(y).checked_mul(z).is_ok() &&\n   |         \
    \  ^^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]: no method named `checked_div`\
    \ found for type `f64` in the current scope\n  --> /tmp/tmphyqwsp24.rs:17:11\n\
    \   |\n17 |         x.checked_div(y).checked_div(z).is_ok()\n   |           ^^^^^^^^^^^\
    \ method not found in `f64`\n\nerror: aborting due to 4 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    if x == z && y == z {\n        return true;\n    }\n   \
    \ else if x < z {\n        if y < z {\n            return true;\n        }\n \
    \       false\n    }\n    else if y < z {\n        false\n    }\n    else {\n\
    \        false\n    }\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp6ptw9l50.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    if x.is_integer() && x.is_integer() && y.is_integer() &&\
    \ z.is_integer() {\n        x.checked_add(y).checked_add(z).is_integer()\n   \
    \ } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate = any_int;\n\
    \    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmpxbd0h4au.rs:14:10\n   |\n14 |     if x.is_integer()\
    \ && x.is_integer() && y.is_integer() && z.is_integer() {\n   |          ^^^^^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no method named `is_integer` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmpxbd0h4au.rs:14:28\n   |\n\
    14 |     if x.is_integer() && x.is_integer() && y.is_integer() && z.is_integer()\
    \ {\n   |                            ^^^^^^^^^^ method not found in `f64`\n\n\
    error[E0599]: no method named `is_integer` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpxbd0h4au.rs:14:46\n   |\n14 |     if x.is_integer() &&\
    \ x.is_integer() && y.is_integer() && z.is_integer() {\n   |                 \
    \                             ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `is_integer` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmpxbd0h4au.rs:14:64\n   |\n14 |     if x.is_integer() && x.is_integer()\
    \ && y.is_integer() && z.is_integer() {\n   |                                \
    \                                ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `checked_add` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmpxbd0h4au.rs:15:11\n   |\n15 |         x.checked_add(y).checked_add(z).is_integer()\n\
    \   |           ^^^^^^^^^^^ method not found in `f64`\n\nerror: aborting due to\
    \ 5 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    x.is_integer() && y.is_integer() && z.is_integer()\n   \
    \     && ((x == x + y) && (y == y - x) && (z == z - x))\n}\n\nfn main() {\n  \
    \  let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n\
    \    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmp5q9kyvmi.rs:14:7\n   |\n14 |     x.is_integer()\
    \ && y.is_integer() && z.is_integer()\n   |       ^^^^^^^^^^ method not found\
    \ in `f64`\n\nerror[E0599]: no method named `is_integer` found for type `f64`\
    \ in the current scope\n  --> /tmp/tmp5q9kyvmi.rs:14:25\n   |\n14 |     x.is_integer()\
    \ && y.is_integer() && z.is_integer()\n   |                         ^^^^^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no method named `is_integer` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmp5q9kyvmi.rs:14:43\n   |\n\
    14 |     x.is_integer() && y.is_integer() && z.is_integer()\n   |            \
    \                               ^^^^^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    if x > z {\n        x > y || x > z\n    } else {\n     \
    \   x > y || y < z\n    }\n}\n\nfn main() {\n    let candidate = any_int;\n  \
    \  assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp2sh9y4fm.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    use std::mem;\n\n    let xint = x.to_i64() as i32;\n   \
    \ let yint = y.to_i64() as i32;\n    let zint = z.to_i64() as i32;\n\n    match\
    \ xint + yint + zint {\n        0 => true,\n        _ => false,\n    }\n}\n\n\
    fn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0,\
    \ 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "warning: unused import: `std::mem`\n  --> /tmp/tmp0vrff92y.rs:14:9\n  \
    \ |\n14 |     use std::mem;\n   |         ^^^^^^^^\n   |\n   = note: `#[warn(unused_imports)]`\
    \ on by default\n\nerror[E0599]: no method named `to_i64` found for type `f64`\
    \ in the current scope\n  --> /tmp/tmp0vrff92y.rs:16:18\n   |\n16 |     let xint\
    \ = x.to_i64() as i32;\n   |                  ^^^^^^ method not found in `f64`\n\
    \nerror[E0599]: no method named `to_i64` found for type `f64` in the current scope\n\
    \  --> /tmp/tmp0vrff92y.rs:17:18\n   |\n17 |     let yint = y.to_i64() as i32;\n\
    \   |                  ^^^^^^ method not found in `f64`\n\nerror[E0599]: no method\
    \ named `to_i64` found for type `f64` in the current scope\n  --> /tmp/tmp0vrff92y.rs:18:18\n\
    \   |\n18 |     let zint = z.to_i64() as i32;\n   |                  ^^^^^^ method\
    \ not found in `f64`\n\nerror: aborting due to 3 previous errors; 1 warning emitted\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    let x: f64 = if x < 0.f64 { 0.f64 } else { x };\n    let\
    \ y: f64 = if y < 0.f64 { 0.f64 } else { y };\n    let z: f64 = if z < 0.f64 {\
    \ 0.f64 } else { z };\n    x == y.f64 + z.f64\n}\n\nfn main() {\n    let candidate\
    \ = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0610]: `{integer}` is a primitive type and therefore doesn't have\
    \ fields\n  --> /tmp/tmpjpkjrb49.rs:14:27\n   |\n14 |     let x: f64 = if x <\
    \ 0.f64 { 0.f64 } else { x };\n   |                           ^^^\n\nerror[E0610]:\
    \ `{integer}` is a primitive type and therefore doesn't have fields\n  --> /tmp/tmpjpkjrb49.rs:14:35\n\
    \   |\n14 |     let x: f64 = if x < 0.f64 { 0.f64 } else { x };\n   |        \
    \                           ^^^\n\nerror[E0610]: `{integer}` is a primitive type\
    \ and therefore doesn't have fields\n  --> /tmp/tmpjpkjrb49.rs:15:27\n   |\n15\
    \ |     let y: f64 = if y < 0.f64 { 0.f64 } else { y };\n   |                \
    \           ^^^\n\nerror[E0610]: `{integer}` is a primitive type and therefore\
    \ doesn't have fields\n  --> /tmp/tmpjpkjrb49.rs:15:35\n   |\n15 |     let y:\
    \ f64 = if y < 0.f64 { 0.f64 } else { y };\n   |                             \
    \      ^^^\n\nerror[E0610]: `{integer}` is a primitive type and therefore doesn't\
    \ have fields\n  --> /tmp/tmpjpkjrb49.rs:16:27\n   |\n16 |     let z: f64 = if\
    \ z < 0.f64 { 0.f64 } else { z };\n   |                           ^^^\n\nerror[E0610]:\
    \ `{integer}` is a primitive type and therefore doesn't have fields\n  --> /tmp/tmpjpkjrb49.rs:16:35\n\
    \   |\n16 |     let z: f64 = if z < 0.f64 { 0.f64 } else { z };\n   |        \
    \                           ^^^\n\nerror[E0610]: `f64` is a primitive type and\
    \ therefore doesn't have fields\n  --> /tmp/tmpjpkjrb49.rs:17:12\n   |\n17 | \
    \    x == y.f64 + z.f64\n   |            ^^^\n\nerror[E0610]: `f64` is a primitive\
    \ type and therefore doesn't have fields\n  --> /tmp/tmpjpkjrb49.rs:17:20\n  \
    \ |\n17 |     x == y.f64 + z.f64\n   |                    ^^^\n\nerror: aborting\
    \ due to 8 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0610`.\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    any_integer_range(x, y, z, Range::new_int_range(Int::min_value(),\
    \ Int::max_value()))\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Int`\n  --> /tmp/tmpje9e6k4y.rs:14:53\n\
    \   |\n14 |     any_integer_range(x, y, z, Range::new_int_range(Int::min_value(),\
    \ Int::max_value()))\n   |                                                   \
    \  ^^^ use of undeclared type `Int`\n\nerror[E0433]: failed to resolve: use of\
    \ undeclared type `Int`\n  --> /tmp/tmpje9e6k4y.rs:14:71\n   |\n14 |     any_integer_range(x,\
    \ y, z, Range::new_int_range(Int::min_value(), Int::max_value()))\n   |      \
    \                                                                 ^^^ use of undeclared\
    \ type `Int`\n\nerror[E0425]: cannot find function `any_integer_range` in this\
    \ scope\n  --> /tmp/tmpje9e6k4y.rs:14:5\n   |\n14 |     any_integer_range(x, y,\
    \ z, Range::new_int_range(Int::min_value(), Int::max_value()))\n   |     ^^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `Range`\n  --> /tmp/tmpje9e6k4y.rs:14:32\n   |\n14 |     any_integer_range(x,\
    \ y, z, Range::new_int_range(Int::min_value(), Int::max_value()))\n   |      \
    \                          ^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing one of these items\n   |\n1  | use std::collections::btree_map::Range;\n\
    \   |\n1  | use std::collections::btree_set::Range;\n   |\n1  | use std::ops::Range;\n\
    \   |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0425, E0433.\nFor more information about an error, try `rustc\
    \ --explain E0425`.\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    let any = ((x + y) == (z));\n    let int_x = x.floor() as\
    \ i32;\n    let int_y = y.floor() as i32;\n    let int_z = z.floor() as i32;\n\
    \    let another_int = int_x == int_y && int_x == int_z;\n    let another_float\
    \ = x.f64() == y.f64();\n    let another_double = x.f64() == z.f64();\n    any\
    \ || another_int || another_float || another_double\n}\n\nfn main() {\n    let\
    \ candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around assigned value\n  --> /tmp/tmpi0beacmx.rs:14:15\n\
    \   |\n14 |     let any = ((x + y) == (z));\n   |               ^            \
    \  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these\
    \ parentheses\n   |\n14 -     let any = ((x + y) == (z));\n14 +     let any =\
    \ (x + y) == (z);\n   | \n\nerror[E0599]: no method named `f64` found for type\
    \ `f64` in the current scope\n  --> /tmp/tmpi0beacmx.rs:19:27\n   |\n19 |    \
    \ let another_float = x.f64() == y.f64();\n   |                           ^^^\
    \ method not found in `f64`\n\nerror[E0599]: no method named `f64` found for type\
    \ `f64` in the current scope\n  --> /tmp/tmpi0beacmx.rs:19:38\n   |\n19 |    \
    \ let another_float = x.f64() == y.f64();\n   |                              \
    \        ^^^ method not found in `f64`\n\nerror[E0599]: no method named `f64`\
    \ found for type `f64` in the current scope\n  --> /tmp/tmpi0beacmx.rs:20:28\n\
    \   |\n20 |     let another_double = x.f64() == z.f64();\n   |               \
    \             ^^^ method not found in `f64`\n\nerror[E0599]: no method named `f64`\
    \ found for type `f64` in the current scope\n  --> /tmp/tmpi0beacmx.rs:20:39\n\
    \   |\n20 |     let another_double = x.f64() == z.f64();\n   |               \
    \                        ^^^ method not found in `f64`\n\nerror: aborting due\
    \ to 4 previous errors; 1 warning emitted\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    x >= y && y >= x && z <= x && x <= z\n}\n\nfn main() {\n\
    \    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n\
    \    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpsbvfw35u.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    let (mut x, mut y, mut z) = (x, y, z);\n    loop {\n   \
    \     assert!(x.is_integer());\n        assert!(y.is_integer());\n        assert!(z.is_integer());\n\
    \        if z.is_negative() {\n            return false;\n        }\n        let\
    \ product = z * x + y * z;\n        if product < 0 {\n            return false;\n\
    \        }\n        x = y;\n        y = z;\n        z = product;\n    }\n}\n\n\
    fn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0,\
    \ 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmpf44ik2di.rs:16:19\n   |\n16 |         assert!(x.is_integer());\n\
    \   |                   ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `is_integer` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmpf44ik2di.rs:17:19\n   |\n17 |         assert!(y.is_integer());\n   |\
    \                   ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]: no method\
    \ named `is_integer` found for type `f64` in the current scope\n  --> /tmp/tmpf44ik2di.rs:18:19\n\
    \   |\n18 |         assert!(z.is_integer());\n   |                   ^^^^^^^^^^\
    \ method not found in `f64`\n\nwarning: use of deprecated associated function\
    \ `core::f64::<impl f64>::is_negative`: renamed to is_sign_negative\n  --> /tmp/tmpf44ik2di.rs:19:14\n\
    \   |\n19 |         if z.is_negative() {\n   |              ^^^^^^^^^^^\n   |\n\
    \   = note: `#[warn(deprecated)]` on by default\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpf44ik2di.rs:23:22\n   |\n23 |         if product < 0 {\n   |  \
    \                    ^\n   |                      |\n   |                    \
    \  expected `f64`, found integer\n   |                      help: use a float\
    \ literal: `0.0`\n\nerror: aborting due to 4 previous errors; 1 warning emitted\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    let z: i64 = z;\n    x >= y + z && x <= y + z\n}\n\nfn main()\
    \ {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n\
    \    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbgtuj0bp.rs:14:18\n   |\n\
    14 |     let z: i64 = z;\n   |            ---   ^ expected `i64`, found `f64`\n\
    \   |            |\n   |            expected due to this\n\nerror[E0277]: cannot\
    \ add `i64` to `f64`\n  --> /tmp/tmpbgtuj0bp.rs:15:12\n   |\n15 |     x >= y +\
    \ z && x <= y + z\n   |            ^ no implementation for `f64 + i64`\n   |\n\
    \   = help: the trait `Add<i64>` is not implemented for `f64`\n   = help: the\
    \ following other types implement trait `Add<Rhs>`:\n             <&'a f32 as\
    \ Add<f32>>\n             <&'a f64 as Add<f64>>\n             <&'a i128 as Add<i128>>\n\
    \             <&'a i16 as Add<i16>>\n             <&'a i32 as Add<i32>>\n    \
    \         <&'a i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n          \
    \   <&'a isize as Add<isize>>\n           and 48 others\n\nerror[E0277]: cannot\
    \ add `i64` to `f64`\n  --> /tmp/tmpbgtuj0bp.rs:15:26\n   |\n15 |     x >= y +\
    \ z && x <= y + z\n   |                          ^ no implementation for `f64\
    \ + i64`\n   |\n   = help: the trait `Add<i64>` is not implemented for `f64`\n\
    \   = help: the following other types implement trait `Add<Rhs>`:\n          \
    \   <&'a f32 as Add<f32>>\n             <&'a f64 as Add<f64>>\n             <&'a\
    \ i128 as Add<i128>>\n             <&'a i16 as Add<i16>>\n             <&'a i32\
    \ as Add<i32>>\n             <&'a i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n\
    \             <&'a isize as Add<isize>>\n           and 48 others\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    (x == y + z) || (x == y - z) || (x == z)\n}\n\nfn main()\
    \ {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n\
    \    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpu31_jw3m.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    any_num_int(x) == any_num_int(y) && any_num_int(y) == any_num_int(z)\n\
    }\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `any_num_int` in this scope\n  --> /tmp/tmpll660spa.rs:14:5\n\
    \   |\n14 |     any_num_int(x) == any_num_int(y) && any_num_int(y) == any_num_int(z)\n\
    \   |     ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `any_num_int` in this scope\n  --> /tmp/tmpll660spa.rs:14:23\n   |\n14 |   \
    \  any_num_int(x) == any_num_int(y) && any_num_int(y) == any_num_int(z)\n   |\
    \                       ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `any_num_int` in this scope\n  --> /tmp/tmpll660spa.rs:14:41\n\
    \   |\n14 |     any_num_int(x) == any_num_int(y) && any_num_int(y) == any_num_int(z)\n\
    \   |                                         ^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `any_num_int` in this scope\n  --> /tmp/tmpll660spa.rs:14:59\n\
    \   |\n14 |     any_num_int(x) == any_num_int(y) && any_num_int(y) == any_num_int(z)\n\
    \   |                                                           ^^^^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to 4 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    match x {\n        x if x < y && x < z && x < y => true,\n\
    \        y if y < x && y < z && y < x => true,\n        z if z < x && z < y &&\
    \ z < x => true,\n        _ => false,\n    }\n}\n\nfn main() {\n    let candidate\
    \ = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpd5s5veu2.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    if x == x + y && x == z && y == z {\n        true\n    }\
    \ else {\n        false\n    }\n}\n\nfn main() {\n    let candidate = any_int;\n\
    \    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpgatfj49i.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    let x = x.floor();\n    let y = y.floor();\n    let z =\
    \ z.floor();\n    x <= y && y <= z && x % 1 == 0 && y % 1 == 0 && z % 1 == 0\n\
    }\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot mod `f64` by `{integer}`\n  --> /tmp/tmp2ol4m94s.rs:17:27\n\
    \   |\n17 |     x <= y && y <= z && x % 1 == 0 && y % 1 == 0 && z % 1 == 0\n \
    \  |                           ^ no implementation for `f64 % {integer}`\n   |\n\
    \   = help: the trait `Rem<{integer}>` is not implemented for `f64`\n   = help:\
    \ the following other types implement trait `Rem<Rhs>`:\n             <&'a f32\
    \ as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n             <&'a i128 as\
    \ Rem<i128>>\n             <&'a i16 as Rem<i16>>\n             <&'a i32 as Rem<i32>>\n\
    \             <&'a i64 as Rem<i64>>\n             <&'a i8 as Rem<i8>>\n      \
    \       <&'a isize as Rem<isize>>\n           and 54 others\nhelp: consider using\
    \ a floating-point literal by writing it with `.0`\n   |\n17 |     x <= y && y\
    \ <= z && x % 1.0 == 0 && y % 1 == 0 && z % 1 == 0\n   |                     \
    \         ++\n\nerror[E0277]: cannot mod `f64` by `{integer}`\n  --> /tmp/tmp2ol4m94s.rs:17:41\n\
    \   |\n17 |     x <= y && y <= z && x % 1 == 0 && y % 1 == 0 && z % 1 == 0\n \
    \  |                                         ^ no implementation for `f64 % {integer}`\n\
    \   |\n   = help: the trait `Rem<{integer}>` is not implemented for `f64`\n  \
    \ = help: the following other types implement trait `Rem<Rhs>`:\n            \
    \ <&'a f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n             <&'a\
    \ i128 as Rem<i128>>\n             <&'a i16 as Rem<i16>>\n             <&'a i32\
    \ as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n             <&'a i8 as Rem<i8>>\n\
    \             <&'a isize as Rem<isize>>\n           and 54 others\nhelp: consider\
    \ using a floating-point literal by writing it with `.0`\n   |\n17 |     x <=\
    \ y && y <= z && x % 1 == 0 && y % 1.0 == 0 && z % 1 == 0\n   |              \
    \                              ++\n\nerror[E0277]: cannot mod `f64` by `{integer}`\n\
    \  --> /tmp/tmp2ol4m94s.rs:17:55\n   |\n17 |     x <= y && y <= z && x % 1 ==\
    \ 0 && y % 1 == 0 && z % 1 == 0\n   |                                        \
    \               ^ no implementation for `f64 % {integer}`\n   |\n   = help: the\
    \ trait `Rem<{integer}>` is not implemented "
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    (x as i64).is_some() || (y as i64).is_some() || (z as i64).is_some()\n\
    }\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_some` found for type `i64` in the current\
    \ scope\n  --> /tmp/tmpf1nd6s38.rs:14:16\n   |\n14 |     (x as i64).is_some()\
    \ || (y as i64).is_some() || (z as i64).is_some()\n   |                ^^^^^^^\
    \ method not found in `i64`\n\nerror[E0599]: no method named `is_some` found for\
    \ type `i64` in the current scope\n  --> /tmp/tmpf1nd6s38.rs:14:40\n   |\n14 |\
    \     (x as i64).is_some() || (y as i64).is_some() || (z as i64).is_some()\n \
    \  |                                        ^^^^^^^ method not found in `i64`\n\
    \nerror[E0599]: no method named `is_some` found for type `i64` in the current\
    \ scope\n  --> /tmp/tmpf1nd6s38.rs:14:64\n   |\n14 |     (x as i64).is_some()\
    \ || (y as i64).is_some() || (z as i64).is_some()\n   |                      \
    \                                          ^^^^^^^ method not found in `i64`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    let x_int = (x as f64).floor();\n    let y_int = (y as f64).floor();\n\
    \    let z_int = (z as f64).floor();\n\n    if x_int + y_int == z_int {\n    \
    \    return true;\n    }\n\n    if x_int + y_int == -z_int {\n        return false;\n\
    \    }\n\n    if x_int + z_int == z_int {\n        return false;\n    }\n\n  \
    \  if x_int + z_int == -y_int {\n        return false;\n    }\n\n    return false;\n\
    }\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpjx4ljrm2.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    x.checked_add(y).is_some() && y.checked_add(z).is_some()\
    \ && z.checked_add(x).is_some()\n}\n\nfn main() {\n    let candidate = any_int;\n\
    \    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `checked_add` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmp7kteaza9.rs:14:7\n   |\n14 |     x.checked_add(y).is_some()\
    \ && y.checked_add(z).is_some() && z.checked_add(x).is_some()\n   |       ^^^^^^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no method named `checked_add` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmp7kteaza9.rs:14:37\n   |\n\
    14 |     x.checked_add(y).is_some() && y.checked_add(z).is_some() && z.checked_add(x).is_some()\n\
    \   |                                     ^^^^^^^^^^^ method not found in `f64`\n\
    \nerror[E0599]: no method named `checked_add` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmp7kteaza9.rs:14:67\n   |\n14 |     x.checked_add(y).is_some()\
    \ && y.checked_add(z).is_some() && z.checked_add(x).is_some()\n   |          \
    \                                                         ^^^^^^^^^^^ method not\
    \ found in `f64`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    x.is_integer() && y.is_integer() && z.is_integer()\n}\n\n\
    fn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0,\
    \ 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmpiq28w1sr.rs:14:7\n   |\n14 |     x.is_integer()\
    \ && y.is_integer() && z.is_integer()\n   |       ^^^^^^^^^^ method not found\
    \ in `f64`\n\nerror[E0599]: no method named `is_integer` found for type `f64`\
    \ in the current scope\n  --> /tmp/tmpiq28w1sr.rs:14:25\n   |\n14 |     x.is_integer()\
    \ && y.is_integer() && z.is_integer()\n   |                         ^^^^^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no method named `is_integer` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmpiq28w1sr.rs:14:43\n   |\n\
    14 |     x.is_integer() && y.is_integer() && z.is_integer()\n   |            \
    \                               ^^^^^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978604
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    (x == z) || (y == z)\n}\n\nfn main() {\n    let candidate\
    \ = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp52t6df20.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    x != z && x != y && y != z\n}\n\nfn main() {\n    let candidate\
    \ = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp49qtaov9.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    let sum = x + y + z;\n    match sum.partial_cmp(&sum).unwrap()\
    \ {\n        Some(Ordering::Equal) => true,\n        Some(Ordering::Greater) =>\
    \ true,\n        Some(Ordering::Less) => true,\n        Some(Ordering::GreaterEqual)\
    \ => true,\n        Some(Ordering::LessEqual) => false,\n        _ => false,\n\
    \    }\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmpk6991ehu.rs:16:14\n   |\n16 |         Some(Ordering::Equal) => true,\n\
    \   |              ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmpk6991ehu.rs:17:14\n\
    \   |\n17 |         Some(Ordering::Greater) => true,\n   |              ^^^^^^^^\
    \ use of undeclared type `Ordering`\n\nerror[E0433]: failed to resolve: use of\
    \ undeclared type `Ordering`\n  --> /tmp/tmpk6991ehu.rs:18:14\n   |\n18 |    \
    \     Some(Ordering::Less) => true,\n   |              ^^^^^^^^ use of undeclared\
    \ type `Ordering`\n\nerror[E0433]: failed to resolve: use of undeclared type `Ordering`\n\
    \  --> /tmp/tmpk6991ehu.rs:19:14\n   |\n19 |         Some(Ordering::GreaterEqual)\
    \ => true,\n   |              ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmpk6991ehu.rs:20:14\n\
    \   |\n20 |         Some(Ordering::LessEqual) => false,\n   |              ^^^^^^^^\
    \ use of undeclared type `Ordering`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk6991ehu.rs:16:9\n\
    \   |\n15 |     match sum.partial_cmp(&sum).unwrap() {\n   |           ------------------------------\
    \ this expression has type `std::cmp::Ordering`\n16 |         Some(Ordering::Equal)\
    \ => true,\n   |         ^^^^^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`,\
    \ found enum `Option`\n   |\n   = note: expected enum `std::cmp::Ordering`\n \
    \             found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpk6991ehu.rs:17:9\n   |\n15 |     match sum.partial_cmp(&sum).unwrap()\
    \ {\n   |           ------------------------------ this expression has type `std::cmp::Ordering`\n\
    16 |         Some(Ordering::Equal) => true,\n17 |         Some(Ordering::Greater)\
    \ => true,\n   |         ^^^^^^^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`,\
    \ found enum `Option`\n   |\n   = note: expected enum `std::cmp::Ordering`\n \
    \             found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpk6991ehu.rs:18:9\n   |\n15 |    "
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    x.is_integer() || y.is_integer() || z.is_integer() || x\
    \ <= z && x >= y || y <= z && y >= x || x <= y && x >= z || y <= y && y >= z\n\
    }\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmpok_tirvy.rs:14:7\n   |\n14 |     x.is_integer()\
    \ || y.is_integer() || z.is_integer() || x <= z && x >= y || y <= z && y >= x\
    \ || x <= y && x >= z || y <= y && y >= z\n   |       ^^^^^^^^^^ method not found\
    \ in `f64`\n\nerror[E0599]: no method named `is_integer` found for type `f64`\
    \ in the current scope\n  --> /tmp/tmpok_tirvy.rs:14:25\n   |\n14 |     x.is_integer()\
    \ || y.is_integer() || z.is_integer() || x <= z && x >= y || y <= z && y >= x\
    \ || x <= y && x >= z || y <= y && y >= z\n   |                         ^^^^^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no method named `is_integer` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmpok_tirvy.rs:14:43\n   |\n\
    14 |     x.is_integer() || y.is_integer() || z.is_integer() || x <= z && x >=\
    \ y || y <= z && y >= x || x <= y && x >= z || y <= y && y >= z\n   |        \
    \                                   ^^^^^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    let z = f64::max(x, y);\n    let z = f64::max(z, z);\n \
    \   z == f64::max(x, z)\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpvr59undq.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    x.is_integer() && y.is_integer() && z.is_integer()\n   \
    \     && (x.unwrap() + y.unwrap() + z.unwrap()) == *std::mem::transmute(&x.unwrap())\n\
    }\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmpjqoy6svz.rs:14:7\n   |\n14 |     x.is_integer()\
    \ && y.is_integer() && z.is_integer()\n   |       ^^^^^^^^^^ method not found\
    \ in `f64`\n\nerror[E0599]: no method named `is_integer` found for type `f64`\
    \ in the current scope\n  --> /tmp/tmpjqoy6svz.rs:14:25\n   |\n14 |     x.is_integer()\
    \ && y.is_integer() && z.is_integer()\n   |                         ^^^^^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no method named `is_integer` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmpjqoy6svz.rs:14:43\n   |\n\
    14 |     x.is_integer() && y.is_integer() && z.is_integer()\n   |            \
    \                               ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `unwrap` found for type `f64` in the current scope\n  --> /tmp/tmpjqoy6svz.rs:15:15\n\
    \   |\n15 |         && (x.unwrap() + y.unwrap() + z.unwrap()) == *std::mem::transmute(&x.unwrap())\n\
    \   |               ^^^^^^ method not found in `f64`\n\nerror[E0599]: no method\
    \ named `unwrap` found for type `f64` in the current scope\n  --> /tmp/tmpjqoy6svz.rs:15:28\n\
    \   |\n15 |         && (x.unwrap() + y.unwrap() + z.unwrap()) == *std::mem::transmute(&x.unwrap())\n\
    \   |                            ^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `unwrap` found for type `f64` in the current scope\n  --> /tmp/tmpjqoy6svz.rs:15:41\n\
    \   |\n15 |         && (x.unwrap() + y.unwrap() + z.unwrap()) == *std::mem::transmute(&x.unwrap())\n\
    \   |                                         ^^^^^^ method not found in `f64`\n\
    \nerror[E0599]: no method named `unwrap` found for type `f64` in the current scope\n\
    \  --> /tmp/tmpjqoy6svz.rs:15:78\n   |\n15 |         && (x.unwrap() + y.unwrap()\
    \ + z.unwrap()) == *std::mem::transmute(&x.unwrap())\n   |                   \
    \                                                           ^^^^^^ method not\
    \ found in `f64`\n\nerror: aborting due to 7 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    (0..=3).contains(|n| x.checked_add(&y).is_ok() && y.checked_add(&z).is_ok()).unwrap_or(false)\n\
    }\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `checked_add` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmp8lutc8wa.rs:14:28\n   |\n14 |     (0..=3).contains(|n|\
    \ x.checked_add(&y).is_ok() && y.checked_add(&z).is_ok()).unwrap_or(false)\n \
    \  |                            ^^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `checked_add` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmp8lutc8wa.rs:14:57\n   |\n14 |     (0..=3).contains(|n| x.checked_add(&y).is_ok()\
    \ && y.checked_add(&z).is_ok()).unwrap_or(false)\n   |                       \
    \                                  ^^^^^^^^^^^ method not found in `f64`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8lutc8wa.rs:14:22\n   |\n14 |     (0..=3).contains(|n|\
    \ x.checked_add(&y).is_ok() && y.checked_add(&z).is_ok()).unwrap_or(false)\n \
    \  |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                      |\n   |                      expected reference, found\
    \ closure\n   |                      help: consider borrowing here: `&|n| x.checked_add(&y).is_ok()\
    \ && y.checked_add(&z).is_ok()`\n   |\n   = note: expected reference `&_`\n  \
    \              found closure `[closure@/tmp/tmp8lutc8wa.rs:14:22: 14:80]`\n\n\
    error[E0599]: no method named `unwrap_or` found for type `bool` in the current\
    \ scope\n  --> /tmp/tmp8lutc8wa.rs:14:82\n   |\n14 |     (0..=3).contains(|n|\
    \ x.checked_add(&y).is_ok() && y.checked_add(&z).is_ok()).unwrap_or(false)\n \
    \  |                                                                         \
    \         ^^^^^^^^^ method not found in `bool`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    (x as i64) == (y + z) || (y as i64) == (x + z)\n}\n\nfn\
    \ main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0),\
    \ true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp716thfg0.rs:14:19\n   |\n\
    14 |     (x as i64) == (y + z) || (y as i64) == (x + z)\n   |                \
    \   ^^^^^^^ expected `i64`, found `f64`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp716thfg0.rs:14:44\n   |\n14 |     (x as i64) == (y + z) || (y as i64)\
    \ == (x + z)\n   |                                            ^^^^^^^ expected\
    \ `i64`, found `f64`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    if x == y + z && x > y {\n        return true;\n    }\n\
    \    if x < y {\n        if x != z {\n            return false;\n        }\n \
    \       return y < z;\n    }\n    return false;\n}\n\nfn main() {\n    let candidate\
    \ = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpqtyvur03.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    x <= y + z && x <= z + y\n}\n\nfn main() {\n    let candidate\
    \ = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpt7sz3l72.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    if x == x + y && y == y + z && z == z + x {\n        return\
    \ true;\n    }\n    false\n}\n\nfn main() {\n    let candidate = any_int;\n  \
    \  assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpacm3s0ex.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    any_integer_sum(x, y, z) == x\n}\n\nfn main() {\n    let\
    \ candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `any_integer_sum` in this scope\n  -->\
    \ /tmp/tmp1fd9fyyx.rs:14:5\n   |\n14 |     any_integer_sum(x, y, z) == x\n   |\
    \     ^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    x.floor() as i64 + y.floor() as i64 == z.floor() as i64\n\
    }\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp10qe_8e9.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    !is_int(x || y || z) && x >= y && x >= z && y >= z\n}\n\n\
    fn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0,\
    \ 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_int` in this scope\n  --> /tmp/tmpecgwjlpq.rs:14:6\n\
    \   |\n14 |     !is_int(x || y || z) && x >= y && x >= z && y >= z\n   |     \
    \ ^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpecgwjlpq.rs:14:13\n\
    \   |\n14 |     !is_int(x || y || z) && x >= y && x >= z && y >= z\n   |     \
    \        ^ expected `bool`, found `f64`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpecgwjlpq.rs:14:18\n   |\n14 |     !is_int(x || y || z) && x >= y &&\
    \ x >= z && y >= z\n   |                  ^ expected `bool`, found `f64`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpecgwjlpq.rs:14:23\n   |\n14 |     !is_int(x\
    \ || y || z) && x >= y && x >= z && y >= z\n   |                       ^ expected\
    \ `bool`, found `f64`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0425.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    let ans = x + y + z == x + y;\n    let ans = ans && x.is_integer()\
    \ && y.is_integer() && z.is_integer();\n    ans\n}\n\nfn main() {\n    let candidate\
    \ = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmpv50qsqka.rs:15:24\n   |\n15 |     let ans = ans\
    \ && x.is_integer() && y.is_integer() && z.is_integer();\n   |               \
    \         ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]: no method named\
    \ `is_integer` found for type `f64` in the current scope\n  --> /tmp/tmpv50qsqka.rs:15:42\n\
    \   |\n15 |     let ans = ans && x.is_integer() && y.is_integer() && z.is_integer();\n\
    \   |                                          ^^^^^^^^^^ method not found in\
    \ `f64`\n\nerror[E0599]: no method named `is_integer` found for type `f64` in\
    \ the current scope\n  --> /tmp/tmpv50qsqka.rs:15:60\n   |\n15 |     let ans =\
    \ ans && x.is_integer() && y.is_integer() && z.is_integer();\n   |           \
    \                                                 ^^^^^^^^^^ method not found\
    \ in `f64`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    let x = x.floor() as f64;\n    let y = y.floor() as f64;\n\
    \    let z = z.floor() as f64;\n    match x.checked_add::<u64>() {\n        Some(x)\
    \ => x == z || x == y || x == z,\n        None => false,\n    }\n}\n\nfn main()\
    \ {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n\
    \    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `checked_add` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmpmrll_59i.rs:17:13\n   |\n17 |     match x.checked_add::<u64>()\
    \ {\n   |             ^^^^^^^^^^^ method not found in `f64`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    let x: u64 = x.to_i64();\n    let y: u64 = y.to_i64();\n\
    \    let z: u64 = z.to_i64();\n    (x.checked_add(y).checked_add(z).is_some())\
    \ && (x.is_integer()) && (y.is_integer()) && (z.is_integer())\n}\n\nfn main()\
    \ {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n\
    \    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_i64` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpvglbq1fi.rs:14:20\n   |\n14 |     let x: u64 = x.to_i64();\n\
    \   |                    ^^^^^^ method not found in `f64`\n\nerror[E0599]: no\
    \ method named `to_i64` found for type `f64` in the current scope\n  --> /tmp/tmpvglbq1fi.rs:15:20\n\
    \   |\n15 |     let y: u64 = y.to_i64();\n   |                    ^^^^^^ method\
    \ not found in `f64`\n\nerror[E0599]: no method named `to_i64` found for type\
    \ `f64` in the current scope\n  --> /tmp/tmpvglbq1fi.rs:16:20\n   |\n16 |    \
    \ let z: u64 = z.to_i64();\n   |                    ^^^^^^ method not found in\
    \ `f64`\n\nerror[E0599]: no method named `checked_add` found for enum `Option`\
    \ in the current scope\n  --> /tmp/tmpvglbq1fi.rs:17:23\n   |\n17 |     (x.checked_add(y).checked_add(z).is_some())\
    \ && (x.is_integer()) && (y.is_integer()) && (z.is_integer())\n   |          \
    \             ^^^^^^^^^^^ method not found in `Option<u64>`\n\nerror[E0599]: no\
    \ method named `is_integer` found for type `u64` in the current scope\n  --> /tmp/tmpvglbq1fi.rs:17:55\n\
    \   |\n17 |     (x.checked_add(y).checked_add(z).is_some()) && (x.is_integer())\
    \ && (y.is_integer()) && (z.is_integer())\n   |                              \
    \                         ^^^^^^^^^^ method not found in `u64`\n\nerror[E0599]:\
    \ no method named `is_integer` found for type `u64` in the current scope\n  -->\
    \ /tmp/tmpvglbq1fi.rs:17:75\n   |\n17 |     (x.checked_add(y).checked_add(z).is_some())\
    \ && (x.is_integer()) && (y.is_integer()) && (z.is_integer())\n   |          \
    \                                                                 ^^^^^^^^^^ method\
    \ not found in `u64`\n\nerror[E0599]: no method named `is_integer` found for type\
    \ `u64` in the current scope\n  --> /tmp/tmpvglbq1fi.rs:17:95\n   |\n17 |    \
    \ (x.checked_add(y).checked_add(z).is_some()) && (x.is_integer()) && (y.is_integer())\
    \ && (z.is_integer())\n   |                                                  \
    \                                             ^^^^^^^^^^ method not found in `u64`\n\
    \nerror: aborting due to 7 previous errors\n\nFor mor"
  stdout: ''
  timestamp: 1659978605
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    use std::cmp::Ordering;\n    use std::cmp::PartialOrd;\n\
    \n    if x <= y && x <= z {\n        true\n    } else if x > y && x > z {\n  \
    \      true\n    } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate\
    \ = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp_mry_ck1.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    if f32::min(x, y).is_sub(f32::min(z, x)) {\n        true\n\
    \    } else if f32::max(x, y).is_sub(f32::max(z, x)) {\n        true\n    } else\
    \ {\n        false\n    }\n}\n\nfn main() {\n    let candidate = any_int;\n  \
    \  assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7pdvfruf.rs:14:17\n   |\n\
    14 |     if f32::min(x, y).is_sub(f32::min(z, x)) {\n   |                 ^ expected\
    \ `f32`, found `f64`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7pdvfruf.rs:14:20\n\
    \   |\n14 |     if f32::min(x, y).is_sub(f32::min(z, x)) {\n   |             \
    \       ^ expected `f32`, found `f64`\n\nerror[E0599]: no method named `is_sub`\
    \ found for type `f32` in the current scope\n  --> /tmp/tmp7pdvfruf.rs:14:23\n\
    \   |\n14 |     if f32::min(x, y).is_sub(f32::min(z, x)) {\n   |             \
    \          ^^^^^^ help: there is an associated function with a similar name: `is_subnormal`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp7pdvfruf.rs:14:39\n   |\n14 |\
    \     if f32::min(x, y).is_sub(f32::min(z, x)) {\n   |                       \
    \                ^ expected `f32`, found `f64`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp7pdvfruf.rs:14:42\n   |\n14 |     if f32::min(x, y).is_sub(f32::min(z,\
    \ x)) {\n   |                                          ^ expected `f32`, found\
    \ `f64`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7pdvfruf.rs:16:24\n \
    \  |\n16 |     } else if f32::max(x, y).is_sub(f32::max(z, x)) {\n   |       \
    \                 ^ expected `f32`, found `f64`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp7pdvfruf.rs:16:27\n   |\n16 |     } else if f32::max(x, y).is_sub(f32::max(z,\
    \ x)) {\n   |                           ^ expected `f32`, found `f64`\n\nerror[E0599]:\
    \ no method named `is_sub` found for type `f32` in the current scope\n  --> /tmp/tmp7pdvfruf.rs:16:30\n\
    \   |\n16 |     } else if f32::max(x, y).is_sub(f32::max(z, x)) {\n   |      \
    \                        ^^^^^^ help: there is an associated function with a similar\
    \ name: `is_subnormal`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7pdvfruf.rs:16:46\n\
    \   |\n16 |     } else if f32::max(x, y).is_sub(f32::max(z, x)) {\n   |      \
    \                                        ^ expected `f32`, found `f64`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp7pdvfruf.rs:16:49\n   |\n16 |     } else if\
    \ f32::max(x, y).is_sub(f32::max(z, x)) {\n   |                        "
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    (x == x + y || x == x + z || y == z) && (x % 1 == 0 || y\
    \ % 1 == 0 || z % 1 == 0)\n}\n\nfn main() {\n    let candidate = any_int;\n  \
    \  assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot mod `f64` by `{integer}`\n  --> /tmp/tmp5dwblw_7.rs:14:48\n\
    \   |\n14 |     (x == x + y || x == x + z || y == z) && (x % 1 == 0 || y % 1 ==\
    \ 0 || z % 1 == 0)\n   |                                                ^ no implementation\
    \ for `f64 % {integer}`\n   |\n   = help: the trait `Rem<{integer}>` is not implemented\
    \ for `f64`\n   = help: the following other types implement trait `Rem<Rhs>`:\n\
    \             <&'a f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n    \
    \         <&'a i128 as Rem<i128>>\n             <&'a i16 as Rem<i16>>\n      \
    \       <&'a i32 as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n          \
    \   <&'a i8 as Rem<i8>>\n             <&'a isize as Rem<isize>>\n           and\
    \ 54 others\nhelp: consider using a floating-point literal by writing it with\
    \ `.0`\n   |\n14 |     (x == x + y || x == x + z || y == z) && (x % 1.0 == 0 ||\
    \ y % 1 == 0 || z % 1 == 0)\n   |                                            \
    \       ++\n\nerror[E0277]: cannot mod `f64` by `{integer}`\n  --> /tmp/tmp5dwblw_7.rs:14:62\n\
    \   |\n14 |     (x == x + y || x == x + z || y == z) && (x % 1 == 0 || y % 1 ==\
    \ 0 || z % 1 == 0)\n   |                                                     \
    \         ^ no implementation for `f64 % {integer}`\n   |\n   = help: the trait\
    \ `Rem<{integer}>` is not implemented for `f64`\n   = help: the following other\
    \ types implement trait `Rem<Rhs>`:\n             <&'a f32 as Rem<f32>>\n    \
    \         <&'a f64 as Rem<f64>>\n             <&'a i128 as Rem<i128>>\n      \
    \       <&'a i16 as Rem<i16>>\n             <&'a i32 as Rem<i32>>\n          \
    \   <&'a i64 as Rem<i64>>\n             <&'a i8 as Rem<i8>>\n             <&'a\
    \ isize as Rem<isize>>\n           and 54 others\nhelp: consider using a floating-point\
    \ literal by writing it with `.0`\n   |\n14 |     (x == x + y || x == x + z ||\
    \ y == z) && (x % 1 == 0 || y % 1.0 == 0 || z % 1 == 0)\n   |                \
    \                                                 ++\n\nerror[E0277]: cannot mod\
    \ `f64` by `{integer}`\n  --> /tmp/tmp5dwblw_7.rs:14:76\n   |\n14 |     (x ==\
    \ x + y || x == x + z || y == z) && (x % 1 == "
  stdout: ''
  timestamp: 1659978605
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    if x == y || (x < y && x == z) || (x >= y && x == -z) {\n\
    \        return true;\n    }\n    false\n}\n\nfn main() {\n    let candidate =\
    \ any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp8jru9nek.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    match (x, y, z) {\n        (Some(x), Some(y), Some(z)) =>\
    \ {\n            match x.checked_add(y).and_then(|x| x.checked_add(z)) {\n   \
    \             Some(x) => x.is_one(),\n                _ => false,\n          \
    \  }\n        }\n        _ => false,\n    }\n}\n\nfn main() {\n    let candidate\
    \ = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1forjyj2.rs:15:10\n   |\n\
    14 |     match (x, y, z) {\n   |           --------- this expression has type\
    \ `(f64, f64, f64)`\n15 |         (Some(x), Some(y), Some(z)) => {\n   |     \
    \     ^^^^^^^ expected `f64`, found enum `Option`\n   |\n   = note: expected type\
    \ `f64`\n              found enum `Option<_>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp1forjyj2.rs:15:19\n   |\n14 |     match (x, y, z) {\n   |     \
    \      --------- this expression has type `(f64, f64, f64)`\n15 |         (Some(x),\
    \ Some(y), Some(z)) => {\n   |                   ^^^^^^^ expected `f64`, found\
    \ enum `Option`\n   |\n   = note: expected type `f64`\n              found enum\
    \ `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1forjyj2.rs:15:28\n\
    \   |\n14 |     match (x, y, z) {\n   |           --------- this expression has\
    \ type `(f64, f64, f64)`\n15 |         (Some(x), Some(y), Some(z)) => {\n   |\
    \                            ^^^^^^^ expected `f64`, found enum `Option`\n   |\n\
    \   = note: expected type `f64`\n              found enum `Option<_>`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    x.is_integer() && y.is_integer() && z.is_integer()\n   \
    \     && x == y + z\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmp6xgomxhh.rs:14:7\n   |\n14 |     x.is_integer()\
    \ && y.is_integer() && z.is_integer()\n   |       ^^^^^^^^^^ method not found\
    \ in `f64`\n\nerror[E0599]: no method named `is_integer` found for type `f64`\
    \ in the current scope\n  --> /tmp/tmp6xgomxhh.rs:14:25\n   |\n14 |     x.is_integer()\
    \ && y.is_integer() && z.is_integer()\n   |                         ^^^^^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no method named `is_integer` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmp6xgomxhh.rs:14:43\n   |\n\
    14 |     x.is_integer() && y.is_integer() && z.is_integer()\n   |            \
    \                               ^^^^^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    let x_int = x as i32;\n    let y_int = y as i32;\n    let\
    \ z_int = z as i32;\n    let sum = x_int + y_int + z_int;\n    match sum {\n \
    \       0 | 1 | 2 => true,\n        _ => false,\n    }\n}\n\nfn main() {\n   \
    \ let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n\
    \    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpjgffgbj4.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978606
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    x < y + z && x > y + z && x < z + z && x > z + z\n}\n\n\
    fn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0,\
    \ 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpajvxhyju.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978606
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    x <= y + z && x <= z + y && x >= y + z && x >= z + y\n}\n\
    \nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0,\
    \ 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp546k9_6g.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978606
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    let x: f64 = x;\n    let y: f64 = y;\n    let z: f64 = z;\n\
    \    x <= z &&\n    y <= z &&\n    (x - y as f64) == z\n}\n\nfn main() {\n   \
    \ let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n\
    \    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpz8_6kwhn.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978606
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    x.is_integer()\n        || y.is_integer()\n        || z.is_integer()\n\
    \        || x == y\n        || x == z\n        || y == z\n}\n\nfn main() {\n \
    \   let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n\
    \    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmpasatjoo_.rs:14:7\n   |\n14 |     x.is_integer()\n\
    \   |       ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]: no method named\
    \ `is_integer` found for type `f64` in the current scope\n  --> /tmp/tmpasatjoo_.rs:15:14\n\
    \   |\n15 |         || y.is_integer()\n   |              ^^^^^^^^^^ method not\
    \ found in `f64`\n\nerror[E0599]: no method named `is_integer` found for type\
    \ `f64` in the current scope\n  --> /tmp/tmpasatjoo_.rs:16:14\n   |\n16 |    \
    \     || z.is_integer()\n   |              ^^^^^^^^^^ method not found in `f64`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    let (x0: i8, x1: i8, x2: i8) = x.to_digits(2);\n    let\
    \ (y0: i8, y1: i8, y2: i8) = y.to_digits(2);\n    let (z0: i8, z1: i8, z2: i8)\
    \ = z.to_digits(2);\n    (x0 == 0 && x1 == 0 && x2 == 0) || (x0 == y0 && x1 ==\
    \ y1 && x2 == y2)\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `)`, `,`, `@`, or `|`, found `:`\n  --> /tmp/tmpsj9m9jiw.rs:14:12\n\
    \   |\n14 |     let (x0: i8, x1: i8, x2: i8) = x.to_digits(2);\n   |         \
    \   ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: expected one of `!`, `(`,\
    \ `+`, `::`, `;`, `<`, or `=`, found `,`\n  --> /tmp/tmpsj9m9jiw.rs:14:16\n  \
    \ |\n14 |     let (x0: i8, x1: i8, x2: i8) = x.to_digits(2);\n   |           \
    \     ^ expected one of 7 possible tokens\n\nerror: aborting due to 2 previous\
    \ errors\n\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    match x + y + z {\n        z @ _ => true,\n        _ =>\
    \ false,\n    }\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpm52dhbt_.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978606
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    debug_assert!(x.is_integer() && y.is_integer() && z.is_integer());\n\
    \n    x.to_double() == (x + y + z).to_double()\n}\n\nfn main() {\n    let candidate\
    \ = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmpxnl2jh6j.rs:14:21\n   |\n14 |     debug_assert!(x.is_integer()\
    \ && y.is_integer() && z.is_integer());\n   |                     ^^^^^^^^^^ method\
    \ not found in `f64`\n\nerror[E0599]: no method named `is_integer` found for type\
    \ `f64` in the current scope\n  --> /tmp/tmpxnl2jh6j.rs:14:39\n   |\n14 |    \
    \ debug_assert!(x.is_integer() && y.is_integer() && z.is_integer());\n   |   \
    \                                    ^^^^^^^^^^ method not found in `f64`\n\n\
    error[E0599]: no method named `is_integer` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpxnl2jh6j.rs:14:57\n   |\n14 |     debug_assert!(x.is_integer()\
    \ && y.is_integer() && z.is_integer());\n   |                                \
    \                         ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `to_double` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmpxnl2jh6j.rs:16:7\n   |\n16 |     x.to_double() == (x + y + z).to_double()\n\
    \   |       ^^^^^^^^^ method not found in `f64`\n\nerror[E0599]: no method named\
    \ `to_double` found for type `f64` in the current scope\n  --> /tmp/tmpxnl2jh6j.rs:16:34\n\
    \   |\n16 |     x.to_double() == (x + y + z).to_double()\n   |               \
    \                   ^^^^^^^^^ method not found in `f64`\n\nerror: aborting due\
    \ to 5 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    match x, y, z {\n        (f32, _, _) if x == f32 + y &&\
    \ y == f32 + z => true,\n        _ => false,\n    }\n}\n\nfn main() {\n    let\
    \ candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `.`, `::`, `?`, `{`, or an operator, found\
    \ `,`\n  --> /tmp/tmpu95ykxa5.rs:14:12\n   |\n14 |     match x, y, z {\n   | \
    \    -----  ^ expected one of `!`, `.`, `::`, `?`, `{`, or an operator\n   | \
    \    |\n   |     while parsing this `match` expression\n\nerror: aborting due\
    \ to previous error\n\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    let z = z - z % 1f64;\n    (x - x * z + y + z * y) <= 0\n\
    }\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_p_myp8c.rs:15:32\n   |\n\
    15 |     (x - x * z + y + z * y) <= 0\n   |                                ^\n\
    \   |                                |\n   |                                expected\
    \ `f64`, found integer\n   |                                help: use a float\
    \ literal: `0.0`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    x.checked_add(y).is_ok() && x.checked_add(z).is_ok() &&\
    \ y.checked_add(z).is_ok()\n}\n\nfn main() {\n    let candidate = any_int;\n \
    \   assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `checked_add` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmpis7_ipb9.rs:14:7\n   |\n14 |     x.checked_add(y).is_ok()\
    \ && x.checked_add(z).is_ok() && y.checked_add(z).is_ok()\n   |       ^^^^^^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no method named `checked_add` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmpis7_ipb9.rs:14:35\n   |\n\
    14 |     x.checked_add(y).is_ok() && x.checked_add(z).is_ok() && y.checked_add(z).is_ok()\n\
    \   |                                   ^^^^^^^^^^^ method not found in `f64`\n\
    \nerror[E0599]: no method named `checked_add` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpis7_ipb9.rs:14:63\n   |\n14 |     x.checked_add(y).is_ok()\
    \ && x.checked_add(z).is_ok() && y.checked_add(z).is_ok()\n   |              \
    \                                                 ^^^^^^^^^^^ method not found\
    \ in `f64`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    match z {\n        f64 => x.is_integer()\n            &&\
    \ y.is_integer()\n            && x.is_positive() && y.is_positive() && z.is_integer(),\n\
    \        _ => false,\n    }\n}\n\nfn main() {\n    let candidate = any_int;\n\
    \    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmp8dge9qz3.rs:15:18\n   |\n15 |         f64 => x.is_integer()\n\
    \   |                  ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]: no\
    \ method named `is_integer` found for type `f64` in the current scope\n  --> /tmp/tmp8dge9qz3.rs:16:18\n\
    \   |\n16 |             && y.is_integer()\n   |                  ^^^^^^^^^^ method\
    \ not found in `f64`\n\nwarning: use of deprecated associated function `core::f64::<impl\
    \ f64>::is_positive`: renamed to is_sign_positive\n  --> /tmp/tmp8dge9qz3.rs:17:18\n\
    \   |\n17 |             && x.is_positive() && y.is_positive() && z.is_integer(),\n\
    \   |                  ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on\
    \ by default\n\nwarning: use of deprecated associated function `core::f64::<impl\
    \ f64>::is_positive`: renamed to is_sign_positive\n  --> /tmp/tmp8dge9qz3.rs:17:37\n\
    \   |\n17 |             && x.is_positive() && y.is_positive() && z.is_integer(),\n\
    \   |                                     ^^^^^^^^^^^\n\nerror[E0599]: no method\
    \ named `is_integer` found for type `f64` in the current scope\n  --> /tmp/tmp8dge9qz3.rs:17:56\n\
    \   |\n17 |             && x.is_positive() && y.is_positive() && z.is_integer(),\n\
    \   |                                                        ^^^^^^^^^^ method\
    \ not found in `f64`\n\nerror: aborting due to 3 previous errors; 2 warnings emitted\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    let x: i64 = x as i64;\n    let y: i64 = y as i64;\n   \
    \ let z: i64 = z as i64;\n    (x != 0 || y != 0 || z != 0) && (x != y || z !=\
    \ y || x != z)\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpy7viqs9o.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978606
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    (x == z) || (y == z)\n}\n\nfn main() {\n    let candidate\
    \ = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp52t6df20.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    match x, y, z {\n        (x, y, z) =>\n            (x.is_integer(),\
    \ y.is_integer(), z.is_integer()) && (x + y + z).is_integer(),\n        _ => false,\n\
    \    }\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `.`, `::`, `?`, `{`, or an operator, found\
    \ `,`\n  --> /tmp/tmphbm31pkh.rs:14:12\n   |\n14 |     match x, y, z {\n   | \
    \    -----  ^ expected one of `!`, `.`, `::`, `?`, `{`, or an operator\n   | \
    \    |\n   |     while parsing this `match` expression\n\nerror: aborting due\
    \ to previous error\n\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    if x == y + z && x == z && y == x {\n        true\n    }\
    \ else {\n        false\n    }\n}\n\nfn main() {\n    let candidate = any_int;\n\
    \    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpygug6fm1.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978606
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    (x > y + z && y > z && x > y) || (x > z && z > y)\n}\n\n\
    fn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0,\
    \ 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpen8eoq_y.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978606
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    let mut x_f64 = x.to_f64();\n    let mut y_f64 = y.to_f64();\n\
    \    let mut z_f64 = z.to_f64();\n\n    if x_f64 < y_f64 {\n        if x_f64 <\
    \ z_f64 {\n            return true;\n        }\n    } else {\n        if y_f64\
    \ < z_f64 {\n            return true;\n        }\n    }\n    return false;\n}\n\
    \nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0,\
    \ 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_f64` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmppm8w9xm1.rs:14:23\n   |\n14 |     let mut x_f64 = x.to_f64();\n\
    \   |                       ^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `to_f64` found for type `f64` in the current scope\n  --> /tmp/tmppm8w9xm1.rs:15:23\n\
    \   |\n15 |     let mut y_f64 = y.to_f64();\n   |                       ^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no method named `to_f64` found for\
    \ type `f64` in the current scope\n  --> /tmp/tmppm8w9xm1.rs:16:23\n   |\n16 |\
    \     let mut z_f64 = z.to_f64();\n   |                       ^^^^^^ method not\
    \ found in `f64`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    !(x == z && y == z && z <= INT_MAX + 1 && z >= INT_MIN -\
    \ 1) || x == z || y == z\n}\n\nfn main() {\n    let candidate = any_int;\n   \
    \ assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0,\
    \ 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `INT_MAX` in this scope\n  --> /tmp/tmpaekrfdsr.rs:14:32\n\
    \   |\n14 |     !(x == z && y == z && z <= INT_MAX + 1 && z >= INT_MIN - 1) ||\
    \ x == z || y == z\n   |                                ^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `INT_MIN` in this scope\n  --> /tmp/tmpaekrfdsr.rs:14:52\n\
    \   |\n14 |     !(x == z && y == z && z <= INT_MAX + 1 && z >= INT_MIN - 1) ||\
    \ x == z || y == z\n   |                                                    ^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    x.is_integer() && y.is_integer() && z.is_integer() && x\
    \ + y + z == Some(z.into())\n}\n\nfn main() {\n    let candidate = any_int;\n\
    \    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmpotv0h900.rs:14:7\n   |\n14 |     x.is_integer()\
    \ && y.is_integer() && z.is_integer() && x + y + z == Some(z.into())\n   |   \
    \    ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]: no method named `is_integer`\
    \ found for type `f64` in the current scope\n  --> /tmp/tmpotv0h900.rs:14:25\n\
    \   |\n14 |     x.is_integer() && y.is_integer() && z.is_integer() && x + y +\
    \ z == Some(z.into())\n   |                         ^^^^^^^^^^ method not found\
    \ in `f64`\n\nerror[E0599]: no method named `is_integer` found for type `f64`\
    \ in the current scope\n  --> /tmp/tmpotv0h900.rs:14:43\n   |\n14 |     x.is_integer()\
    \ && y.is_integer() && z.is_integer() && x + y + z == Some(z.into())\n   |   \
    \                                        ^^^^^^^^^^ method not found in `f64`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpotv0h900.rs:14:72\n   |\n14 |\
    \     x.is_integer() && y.is_integer() && z.is_integer() && x + y + z == Some(z.into())\n\
    \   |                                                                        ^^^^^^^^^^^^^^\
    \ expected `f64`, found enum `Option`\n   |\n   = note: expected type `f64`\n\
    \              found enum `Option<_>`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    x.is_integer() && y.is_integer() && z.is_integer()\n}\n\n\
    fn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0,\
    \ 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmpiq28w1sr.rs:14:7\n   |\n14 |     x.is_integer()\
    \ && y.is_integer() && z.is_integer()\n   |       ^^^^^^^^^^ method not found\
    \ in `f64`\n\nerror[E0599]: no method named `is_integer` found for type `f64`\
    \ in the current scope\n  --> /tmp/tmpiq28w1sr.rs:14:25\n   |\n14 |     x.is_integer()\
    \ && y.is_integer() && z.is_integer()\n   |                         ^^^^^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no method named `is_integer` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmpiq28w1sr.rs:14:43\n   |\n\
    14 |     x.is_integer() && y.is_integer() && z.is_integer()\n   |            \
    \                               ^^^^^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978604
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    x.is_integer() && y.is_integer() && z.is_integer()\n   \
    \     && x == y + z\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmp6xgomxhh.rs:14:7\n   |\n14 |     x.is_integer()\
    \ && y.is_integer() && z.is_integer()\n   |       ^^^^^^^^^^ method not found\
    \ in `f64`\n\nerror[E0599]: no method named `is_integer` found for type `f64`\
    \ in the current scope\n  --> /tmp/tmp6xgomxhh.rs:14:25\n   |\n14 |     x.is_integer()\
    \ && y.is_integer() && z.is_integer()\n   |                         ^^^^^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no method named `is_integer` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmp6xgomxhh.rs:14:43\n   |\n\
    14 |     x.is_integer() && y.is_integer() && z.is_integer()\n   |            \
    \                               ^^^^^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    if x == y {\n        if x == z {\n            return true;\n\
    \        }\n    }\n    if x == z {\n        return false;\n    }\n    // No need\
    \ to check y or z.\n    if x < y || y < z {\n        return false;\n    }\n  \
    \  let min = f64::min(x, y);\n    if min == z {\n        return false;\n    }\n\
    \    if max < z {\n        return false;\n    }\n    let max = f64::max(x, y);\n\
    \    if max == z {\n        return true;\n    }\n    if min < max {\n        return\
    \ true;\n    }\n    if x < max {\n        return false;\n    }\n    if x < z {\n\
    \        return true;\n    }\n    if x > z {\n        return false;\n    }\n}\n\
    \nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0,\
    \ 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `max` in this scope\n  --> /tmp/tmpvvurmjgl.rs:30:8\n\
    \   |\n30 |     if max < z {\n   |        ^^^ not found in this scope\n   |\n\
    help: consider importing this function\n   |\n1  | use std::cmp::max;\n   |\n\n\
    error[E0317]: `if` may be missing an `else` clause\n  --> /tmp/tmpvvurmjgl.rs:46:5\n\
    \   |\n13 |   fn any_int(x: f64, y: f64, z: f64) -> bool {\n   |             \
    \                            ---- expected `bool` because of this return type\n\
    ...\n46 | /     if x > z {\n47 | |         return false;\n48 | |     }\n   | |_____^\
    \ expected `bool`, found `()`\n   |\n   = note: `if` expressions without `else`\
    \ evaluate to `()`\n   = help: consider adding an `else` block that evaluates\
    \ to the expected type\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0317, E0425.\nFor more information about an error,\
    \ try `rustc --explain E0317`.\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    if x < y && x < z {\n        return true;\n    } else if\
    \ x < y {\n        return true;\n    } else if x < z {\n        return false;\n\
    \    } else {\n        return false;\n    }\n}\n\nfn main() {\n    let candidate\
    \ = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmprcpfvesq.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978606
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    match x {\n        x if x == y || x == z => true,\n    \
    \    _ => false,\n    }\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpswvqc7q9.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    let abs = f64::abs(x).max(|x| f64::abs(x)).unwrap();\n \
    \   if f64::abs(y).max(|y| f64::abs(y)).unwrap() > abs {\n        return false;\n\
    \    }\n    if f64::abs(z).max(|z| f64::abs(z)).unwrap() > abs {\n        return\
    \ false;\n    }\n    x < y && x < z\n}\n\nfn main() {\n    let candidate = any_int;\n\
    \    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd_eej3n1.rs:14:31\n   |\n\
    14 |     let abs = f64::abs(x).max(|x| f64::abs(x)).unwrap();\n   |          \
    \                     ^^^^^^^^^^^^^^^ expected `f64`, found closure\n   |\n  \
    \ = note: expected type `f64`\n           found closure `[closure@/tmp/tmpd_eej3n1.rs:14:31:\
    \ 14:46]`\n\nerror[E0599]: no method named `unwrap` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmpd_eej3n1.rs:14:48\n   |\n14 |     let abs = f64::abs(x).max(|x|\
    \ f64::abs(x)).unwrap();\n   |                                               \
    \ ^^^^^^ method not found in `f64`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpd_eej3n1.rs:15:24\n\
    \   |\n15 |     if f64::abs(y).max(|y| f64::abs(y)).unwrap() > abs {\n   |   \
    \                     ^^^^^^^^^^^^^^^ expected `f64`, found closure\n   |\n  \
    \ = note: expected type `f64`\n           found closure `[closure@/tmp/tmpd_eej3n1.rs:15:24:\
    \ 15:39]`\n\nerror[E0599]: no method named `unwrap` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmpd_eej3n1.rs:15:41\n   |\n15 |     if f64::abs(y).max(|y|\
    \ f64::abs(y)).unwrap() > abs {\n   |                                        \
    \ ^^^^^^ method not found in `f64`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpd_eej3n1.rs:18:24\n\
    \   |\n18 |     if f64::abs(z).max(|z| f64::abs(z)).unwrap() > abs {\n   |   \
    \                     ^^^^^^^^^^^^^^^ expected `f64`, found closure\n   |\n  \
    \ = note: expected type `f64`\n           found closure `[closure@/tmp/tmpd_eej3n1.rs:18:24:\
    \ 18:39]`\n\nerror[E0599]: no method named `unwrap` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmpd_eej3n1.rs:18:41\n   |\n18 |     if f64::abs(z).max(|z|\
    \ f64::abs(z)).unwrap() > abs {\n   |                                        \
    \ ^^^^^^ method not found in `f64`\n\nerror: aborting due to 6 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978606
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    if x.is_integer() && x.is_integer() && y.is_integer() &&\
    \ z.is_integer() {\n        (x.to_f64() + y.to_f64() + z.to_f64()).to_f64() ==\
    \ (x.to_f64() + y.to_f64() + z.to_f64()).to_f64()\n    } else {\n        false\n\
    \    }\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmp7_u5fvho.rs:14:10\n   |\n14 |     if x.is_integer()\
    \ && x.is_integer() && y.is_integer() && z.is_integer() {\n   |          ^^^^^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no method named `is_integer` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmp7_u5fvho.rs:14:28\n   |\n\
    14 |     if x.is_integer() && x.is_integer() && y.is_integer() && z.is_integer()\
    \ {\n   |                            ^^^^^^^^^^ method not found in `f64`\n\n\
    error[E0599]: no method named `is_integer` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmp7_u5fvho.rs:14:46\n   |\n14 |     if x.is_integer() &&\
    \ x.is_integer() && y.is_integer() && z.is_integer() {\n   |                 \
    \                             ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `is_integer` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmp7_u5fvho.rs:14:64\n   |\n14 |     if x.is_integer() && x.is_integer()\
    \ && y.is_integer() && z.is_integer() {\n   |                                \
    \                                ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `to_f64` found for type `f64` in the current scope\n  --> /tmp/tmp7_u5fvho.rs:15:12\n\
    \   |\n15 |         (x.to_f64() + y.to_f64() + z.to_f64()).to_f64() == (x.to_f64()\
    \ + y.to_f64() + z.to_f64()).to_f64()\n   |            ^^^^^^ method not found\
    \ in `f64`\n\nerror[E0599]: no method named `to_f64` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmp7_u5fvho.rs:15:25\n   |\n15 |         (x.to_f64()\
    \ + y.to_f64() + z.to_f64()).to_f64() == (x.to_f64() + y.to_f64() + z.to_f64()).to_f64()\n\
    \   |                         ^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `to_f64` found for type `f64` in the current scope\n  --> /tmp/tmp7_u5fvho.rs:15:38\n\
    \   |\n15 |         (x.to_f64() + y.to_f64() + z.to_f64()).to_f64() == (x.to_f64()\
    \ + y.to_f64() + z.to_f64()).to_f64()\n   |                                  \
    \    ^^^^^^ method not found in `f64`\n\nerror[E0599]: no method named `to"
  stdout: ''
  timestamp: 1659978606
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    let sum = x + y + z;\n    match sum {\n        Some(val)\
    \ => val.is_integer(),\n        None => false,\n    }\n}\n\nfn main() {\n    let\
    \ candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsxraiyj2.rs:16:9\n   |\n\
    15 |     match sum {\n   |           --- this expression has type `f64`\n16 |\
    \         Some(val) => val.is_integer(),\n   |         ^^^^^^^^^ expected `f64`,\
    \ found enum `Option`\n   |\n   = note: expected type `f64`\n              found\
    \ enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsxraiyj2.rs:17:9\n\
    \   |\n15 |     match sum {\n   |           --- this expression has type `f64`\n\
    16 |         Some(val) => val.is_integer(),\n17 |         None => false,\n   |\
    \         ^^^^ expected `f64`, found enum `Option`\n   |\n   = note: expected\
    \ type `f64`\n              found enum `Option<_>`\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    let x = x.floor();\n    let y = y.floor();\n    let z =\
    \ z.floor();\n    let xs = x.ceil();\n    let ys = y.ceil();\n    let zs = z.ceil();\n\
    \    (xs == x) + (ys == y) + (zs == z) == (xs + ys + zs) == xs + ys + zs\n}\n\n\
    fn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0,\
    \ 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmpii7_6fgv.rs:20:39\n\
    \   |\n20 |     (xs == x) + (ys == y) + (zs == z) == (xs + ys + zs) == xs + ys\
    \ + zs\n   |                                       ^^                ^^\n   |\n\
    help: split the comparison into two\n   |\n20 |     (xs == x) + (ys == y) + (zs\
    \ == z) == (xs + ys + zs) && (xs + ys + zs) == xs + ys + zs\n   |            \
    \                                             +++++++++++++++++\n\nerror[E0369]:\
    \ cannot add `bool` to `bool`\n  --> /tmp/tmpii7_6fgv.rs:20:15\n   |\n20 |   \
    \  (xs == x) + (ys == y) + (zs == z) == (xs + ys + zs) == xs + ys + zs\n   | \
    \    --------- ^ --------- bool\n   |     |\n   |     bool\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpii7_6fgv.rs:20:60\n   |\n20 |     (xs == x) + (ys == y)\
    \ + (zs == z) == (xs + ys + zs) == xs + ys + zs\n   |                        \
    \                                    ^^^^^^^^^^^^ expected `bool`, found `f64`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978606
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    if x == y && y == z && x == z.to_f64() {\n        true\n\
    \    } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate = any_int;\n\
    \    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_f64` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmp3es34z6p.rs:14:35\n   |\n14 |     if x == y && y == z &&\
    \ x == z.to_f64() {\n   |                                   ^^^^^^ method not\
    \ found in `f64`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978606
- exit_code: 101
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    if x == y || x == z || y == z {\n        true\n    } else\
    \ {\n        false\n    }\n}\n\nfn main() {\n    let candidate = any_int;\n  \
    \  assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpw56s7gd6.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978606
- exit_code: 1
  program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
    /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n///\
    \ true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z:\
    \ f64) -> bool {\n    // First, make sure all numbers are integers.\n    let x_i\
    \ = x.floor();\n    let y_i = y.floor();\n    let z_i = z.floor();\n    match\
    \ x_i {\n        None => return false,\n        Some(x_i) => match y_i {\n   \
    \         None => return false,\n            Some(y_i) => match z_i {\n      \
    \          None => return false,\n                Some(z_i) => x_i == x_i + y_i\
    \ + z_i,\n            },\n        },\n    }\n}\n\nfn main() {\n    let candidate\
    \ = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpku2bbeu1.rs:19:9\n   |\n\
    18 |     match x_i {\n   |           --- this expression has type `f64`\n19 |\
    \         None => return false,\n   |         ^^^^ expected `f64`, found enum\
    \ `Option`\n   |\n   = note: expected type `f64`\n              found enum `Option<_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpku2bbeu1.rs:20:9\n   |\n18 | \
    \    match x_i {\n   |           --- this expression has type `f64`\n19 |    \
    \     None => return false,\n20 |         Some(x_i) => match y_i {\n   |     \
    \    ^^^^^^^^^ expected `f64`, found enum `Option`\n   |\n   = note: expected\
    \ type `f64`\n              found enum `Option<_>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpku2bbeu1.rs:21:13\n   |\n20 |         Some(x_i) => match\
    \ y_i {\n   |                            --- this expression has type `f64`\n\
    21 |             None => return false,\n   |             ^^^^ expected `f64`,\
    \ found enum `Option`\n   |\n   = note: expected type `f64`\n              found\
    \ enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpku2bbeu1.rs:22:13\n\
    \   |\n20 |         Some(x_i) => match y_i {\n   |                           \
    \ --- this expression has type `f64`\n21 |             None => return false,\n\
    22 |             Some(y_i) => match z_i {\n   |             ^^^^^^^^^ expected\
    \ `f64`, found enum `Option`\n   |\n   = note: expected type `f64`\n         \
    \     found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpku2bbeu1.rs:23:17\n\
    \   |\n22 |             Some(y_i) => match z_i {\n   |                       \
    \         --- this expression has type `f64`\n23 |                 None => return\
    \ false,\n   |                 ^^^^ expected `f64`, found enum `Option`\n   |\n\
    \   = note: expected type `f64`\n              found enum `Option<_>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpku2bbeu1.rs:24:17\n   |\n22 |             Some(y_i)\
    \ => match z_i {\n   |                                --- this expression has\
    \ type `f64`\n23 |                 None => return false,\n24 |               \
    \  Some(z_i) => x_i == x_i + y_i + z_i,\n   |                 ^^^^^"
  stdout: ''
  timestamp: 1659978606
