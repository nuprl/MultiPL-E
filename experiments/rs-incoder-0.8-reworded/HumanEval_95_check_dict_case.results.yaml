language: rs
name: HumanEval_95_check_dict_case
results:
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if !dict.is_empty() {\n        let mut\
    \ lower_case_keys = String::new();\n        let mut upper_case_keys = String::new();\n\
    \        for v in dict.keys() {\n            if v.len() > 0 {\n              \
    \  match v.toLower() {\n                    Ok(s) => lower_case_keys.push_str(s),\n\
    \                    Err(_) => (),\n                };\n                match\
    \ v.toUpper() {\n                    Ok(s) => upper_case_keys.push_str(s),\n \
    \                   Err(_) => (),\n                };\n            }\n       \
    \ }\n        if lower_case_keys.eq(&upper_case_keys) {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `toLower` found for reference `&String` in\
    \ the current scope\n  --> /tmp/tmp92e8cqk9.rs:23:25\n   |\n23 |             \
    \    match v.toLower() {\n   |                         ^^^^^^^ method not found\
    \ in `&String`\n\nerror[E0599]: no method named `toUpper` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmp92e8cqk9.rs:27:25\n   |\n27 |\
    \                 match v.toUpper() {\n   |                         ^^^^^^^ method\
    \ not found in `&String`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.contains_key(\"Name\") && dict.contains_key(\"\
    age\") && dict.contains_key(\"city\") && dict.contains_key(\"zipcode\")\n}\n\n\
    fn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmps85i7466.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    // Check all keys are lower-case\n \
    \   let mut lower = String::new();\n    for value in dict.iter() {\n        *lower\
    \ += value.key().to_lowercase();\n    }\n    if !dict.is_empty() {\n        *lower\
    \ += dict\n            .values()\n            .into_iter()\n            .map(|value|\
    \ value.key().to_lowercase())\n            .reduce(\"\".to_lowercase());\n   \
    \ }\n\n    // Check all keys are upper-case\n    let mut upper = String::new();\n\
    \    for value in dict.iter() {\n        *upper += value.key().to_uppercase();\n\
    \    }\n    if !dict.is_empty() {\n        *upper += dict\n            .values()\n\
    \            .into_iter()\n            .map(|value| value.key().to_uppercase())\n\
    \            .reduce(\"\".to_uppercase());\n    }\n\n    lower == upper\n}\n\n\
    fn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `key` found for tuple `(&String, &String)`\
    \ in the current scope\n  --> /tmp/tmp1sr3ma0r.rs:21:25\n   |\n21 |         *lower\
    \ += value.key().to_lowercase();\n   |                         ^^^ method not\
    \ found in `(&String, &String)`\n\nerror[E0599]: no method named `key` found for\
    \ reference `&String` in the current scope\n  --> /tmp/tmp1sr3ma0r.rs:27:32\n\
    \   |\n27 |             .map(|value| value.key().to_lowercase())\n   |       \
    \                         ^^^ method not found in `&String`\n\nerror[E0277]: expected\
    \ a `FnMut<(_, _)>` closure, found `String`\n    --> /tmp/tmp1sr3ma0r.rs:28:21\n\
    \     |\n28   |             .reduce(\"\".to_lowercase());\n     |            \
    \  ------ ^^^^^^^^^^^^^^^^^ expected an `FnMut<(_, _)>` closure, found `String`\n\
    \     |              |\n     |              required by a bound introduced by\
    \ this call\n     |\n     = help: the trait `FnMut<(_, _)>` is not implemented\
    \ for `String`\nnote: required by a bound in `reduce`\n\nerror[E0368]: binary\
    \ assignment operation `+=` cannot be applied to type `str`\n  --> /tmp/tmp1sr3ma0r.rs:24:9\n\
    \   |\n24 |           *lower += dict\n   |           ^-----\n   |           |\n\
    \   |  _________cannot use `+=` on type `str`\n   | |\n25 | |             .values()\n\
    26 | |             .into_iter()\n27 | |             .map(|value| value.key().to_lowercase())\n\
    28 | |             .reduce(\"\".to_lowercase());\n   | |______________________________________^\n\
    \nerror[E0599]: no method named `key` found for tuple `(&String, &String)` in\
    \ the current scope\n  --> /tmp/tmp1sr3ma0r.rs:34:25\n   |\n34 |         *upper\
    \ += value.key().to_uppercase();\n   |                         ^^^ method not\
    \ found in `(&String, &String)`\n\nerror[E0599]: no method named `key` found for\
    \ reference `&String` in the current scope\n  --> /tmp/tmp1sr3ma0r.rs:40:32\n\
    \   |\n40 |             .map(|value| value.key().to_uppercase())\n   |       \
    \                         ^^^ method not found in `&String`\n\nerror[E0277]: expected\
    \ a `FnMut<(_, _)>` closure, found `String`\n    --> /tmp/tmp1sr3ma0r.rs:41:21\n\
    \     |\n41   |            "
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    // Check if all the keys are strings\
    \ in lower case\n    let is_lower_case = dict.iter().all(|&(_, value)| value.as_str().to_lowercase()\
    \ == value.as_str());\n\n    // Check if all the keys are strings in upper case\n\
    \    let is_upper_case = dict.iter().all(|&(_, value)| value.as_str().to_uppercase()\
    \ == value.as_str());\n\n    is_lower_case && is_upper_case\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjrnx4cgm.rs:19:42\n   |\n\
    19 |     let is_lower_case = dict.iter().all(|&(_, value)| value.as_str().to_lowercase()\
    \ == value.as_str());\n   |                                          ^^^^^^^^^^-\n\
    \   |                                          |         |\n   |             \
    \                             |         expected due to this\n   |           \
    \                               expected tuple, found reference\n   |\n   = note:\
    \  expected tuple `(&String, &String)`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpjrnx4cgm.rs:22:42\n   |\n22 |     let is_upper_case\
    \ = dict.iter().all(|&(_, value)| value.as_str().to_uppercase() == value.as_str());\n\
    \   |                                          ^^^^^^^^^^-\n   |             \
    \                             |         |\n   |                              \
    \            |         expected due to this\n   |                            \
    \              expected tuple, found reference\n   |\n   = note:  expected tuple\
    \ `(&String, &String)`\n           found reference `&_`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010963
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    !dict.contains_key(\"name\") && !dict.contains_key(\"\
    age\") && !dict.contains_key(\"city\")\n}\n\nfn main() {\n    let candidate =\
    \ check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"\
    ), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpvomlhxb9.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, val)| {\n   \
    \     // Only strings in lower case or all strings in upper case\n        if !key.as_ref().to_ascii_lowercase().eq(&key.as_ref().to_ascii_uppercase())\
    \ {\n            return false\n        }\n        true\n    })\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpey1v1u7i.rs:20:17\n\
    \   |\n20 |         if !key.as_ref().to_ascii_lowercase().eq(&key.as_ref().to_ascii_uppercase())\
    \ {\n   |             ----^^^^^^--\n   |             |   |\n   |             |\
    \   cannot infer type for type parameter `T` declared on the trait `AsRef`\n \
    \  |             this method call resolves to `&T`\n   |\n   = note: type must\
    \ be known at this point\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n\n    let mut keys = dict.values().cloned().collect::<Vec<String>>();\n\
    \    let mut keys_lower = keys.clone();\n\n    for (key, value) in dict {\n  \
    \      if key.is_lowercase() {\n            keys_lower.push(key);\n        } else\
    \ {\n            if !keys_lower.contains(&key.to_lowercase()) {\n            \
    \    return false;\n            }\n        }\n    }\n\n    for &key in keys {\n\
    \        if !keys_lower.contains(&key.to_lowercase()) {\n            return false;\n\
    \        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lowercase` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp7tw4qnod.rs:26:16\n   |\n26 |         if\
    \ key.is_lowercase() {\n   |                ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp7tw4qnod.rs:35:9\n   |\n35 |     for &key in keys {\n   |     \
    \    ^^^^    ---- this expression has type `Option<String>`\n   |         |\n\
    \   |         expected struct `String`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `key`\n   |\n   = note: expected struct\
    \ `String`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.contains_key(\"a\") && dict.contains_key(\"\
    A\") && dict.contains_key(\"b\") && dict.contains_key(\"B\")\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpxe4y4vxn.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(k, _)| k.is_lower_case()\
    \ || k.is_uppercase())\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lower_case` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpi1sxna0l.rs:18:32\n   |\n18 |     dict.iter().all(|(k,\
    \ _)| k.is_lower_case() || k.is_uppercase())\n   |                           \
    \     ^^^^^^^^^^^^^ help: there is an associated function with a similar name:\
    \ `to_lowercase`\n\nerror[E0599]: no method named `is_uppercase` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmpi1sxna0l.rs:18:53\n   |\n18 |\
    \     dict.iter().all(|(k, _)| k.is_lower_case() || k.is_uppercase())\n   |  \
    \                                                   ^^^^^^^^^^^^ help: there is\
    \ an associated function with a similar name: `to_uppercase`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.len() == 0 {\n        return\
    \ false;\n    }\n    let mut lowercase = true;\n    let mut uppercase = true;\n\
    \    for entry in dict.iter() {\n        if let Some(value) = entry.value {\n\
    \            match value.to_lowercase() {\n                Ok(value) => lowercase\
    \ = true,\n                Err(_) => lowercase = false,\n            }\n     \
    \       match value.to_uppercase() {\n                Ok(value) => uppercase =\
    \ true,\n                Err(_) => uppercase = false,\n            }\n       \
    \ } else {\n            if !lowercase {\n                return false;\n     \
    \       }\n            if !uppercase {\n                return false;\n      \
    \      }\n        }\n    }\n    if !lowercase {\n        return false;\n    }\n\
    \    if !uppercase {\n        return false;\n    }\n    return true;\n}\n\nfn\
    \ main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0609]: no field `value` on type `(&String, &String)`\n  --> /tmp/tmpui7t_o13.rs:24:36\n\
    \   |\n24 |         if let Some(value) = entry.value {\n   |                 \
    \                   ^^^^^\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0609`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    !dict.iter().any(|(_, val)| val.len()\
    \ != 1)\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpki2t7n1l.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(_key, _val)| _key\
    \ == _val.to_lowercase())\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&String` with `String`\n  --> /tmp/tmpgvbbojr7.rs:18:41\n\
    \   |\n18 |     dict.iter().all(|(_key, _val)| _key == _val.to_lowercase())\n\
    \   |                                         ^^ no implementation for `&String\
    \ == String`\n   |\n   = help: the trait `PartialEq<String>` is not implemented\
    \ for `&String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    match dict.len() {\n        0 => true,\n\
    \        _ => false,\n    }\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpw4er2qdu.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|&(k, v: &str)| {\n\
    \        match k.to_lowercase() {\n            true => v.to_lowercase() == k,\n\
    \            false => v.to_uppercase() == k,\n        }\n    })\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `)`, `,`, `@`, or `|`, found `:`\n  --> /tmp/tmpvf6e55ct.rs:18:28\n\
    \   |\n18 |     dict.iter().all(|&(k, v: &str)| {\n   |                      \
    \      ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: expected one of `!`,\
    \ `(`, `::`, `<`, or `|`, found `)`\n  --> /tmp/tmpvf6e55ct.rs:18:34\n   |\n18\
    \ |     dict.iter().all(|&(k, v: &str)| {\n   |                              \
    \    ^ expected one of `!`, `(`, `::`, `<`, or `|`\n\nerror: aborting due to 2\
    \ previous errors\n\n"
  stdout: ''
  timestamp: 1660010963
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n\n    for k in dict.keys() {\n        let v = dict.get(k);\n\
    \        if !v.is_string() {\n            return false;\n        }\n        let\
    \ lc = k.to_lowercase();\n        let uc = k.to_uppercase();\n        if lc !=\
    \ v || uc != v {\n            return false;\n        }\n    }\n    true\n}\n\n\
    fn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_string` found for enum `Option` in the\
    \ current scope\n  --> /tmp/tmp0oqcpch5.rs:24:15\n   |\n24 |         if !v.is_string()\
    \ {\n   |               ^^^^^^^^^ method not found in `Option<&String>`\n\nerror[E0277]:\
    \ can't compare `String` with `Option<&String>`\n  --> /tmp/tmp0oqcpch5.rs:29:15\n\
    \   |\n29 |         if lc != v || uc != v {\n   |               ^^ no implementation\
    \ for `String == Option<&String>`\n   |\n   = help: the trait `PartialEq<Option<&String>>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0277]: can't compare `String` with `Option<&String>`\n\
    \  --> /tmp/tmp0oqcpch5.rs:29:26\n   |\n29 |         if lc != v || uc != v {\n\
    \   |                          ^^ no implementation for `String == Option<&String>`\n\
    \   |\n   = help: the trait `PartialEq<Option<&String>>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    // Iterate over the items of the map,\
    \ and check if any item is a string in lower or upper case.\n    // The items\
    \ with keys in lower case or upper case will make the map to be invalid.\n   \
    \ match dict.iter() {\n        iter::Empty::<_, String>() => {\n            false\n\
    \        }\n        iter::Some(_) => true,\n    }\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `iter`\n\
    \  --> /tmp/tmpck1bm2sg.rs:21:9\n   |\n21 |         iter::Empty::<_, String>()\
    \ => {\n   |         ^^^^ use of undeclared crate or module `iter`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared crate or module `iter`\n  --> /tmp/tmpck1bm2sg.rs:24:9\n\
    \   |\n24 |         iter::Some(_) => true,\n   |         ^^^^ use of undeclared\
    \ crate or module `iter`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if let Some(mut kvs) = dict.into_iter()\
    \ {\n        // First check if all values are strings.\n        for (_, val) in\
    \ kvs.into_iter().filter(|&(_, val)| !val.is_string()) {\n            return false;\
    \ // fail if any values are strings.\n        }\n\n        // Second check if\
    \ all keys are strings in lower case.\n        for (_key, val) in kvs.into_iter().filter(|&(_key,\
    \ val)| !_key.is_string()) {\n            return false; // fail if any keys are\
    \ strings.\n        }\n\n        // Third check if all keys are strings in upper\
    \ case.\n        for (_key, val) in kvs.into_iter().filter(|&(_key, val)| !_key.case()\
    \ == _key.case()) {\n            return false; // fail if any keys are strings.\n\
    \        }\n\n        return true; // succeed if all keys are strings.\n    }\n\
    \    false\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppj87l2j1.rs:18:12\n   |\n\
    18 |     if let Some(mut kvs) = dict.into_iter() {\n   |            ^^^^^^^^^^^^^\
    \   ---------------- this expression has type `std::collections::hash_map::IntoIter<String,\
    \ String>`\n   |            |\n   |            expected struct `std::collections::hash_map::IntoIter`,\
    \ found enum `Option`\n   |\n   = note: expected struct `std::collections::hash_map::IntoIter<String,\
    \ String>`\n                found enum `Option<_>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n\n    let mut has_upper_case = false;\n    let mut has_lower_case\
    \ = false;\n    for kv in dict {\n        match kv.key() {\n            Ok(Key::VStr(s))\
    \ => {\n                if s.chars().all(b => b >= 'A' && b <= 'Z') {\n      \
    \              has_upper_case = true;\n                } else {\n            \
    \        has_lower_case = true;\n                }\n            }\n          \
    \  Ok(Key::VBool(true)) => {\n                has_lower_case = true;\n       \
    \     }\n            Ok(Key::VBool(false)) => {\n                has_upper_case\
    \ = true;\n            }\n            _ => {}\n        }\n    }\n\n    !(has_upper_case\
    \ && has_lower_case)\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator,\
    \ found `=>`\n  --> /tmp/tmpiukcj75g.rs:27:36\n   |\n27 |                 if s.chars().all(b\
    \ => b >= 'A' && b <= 'Z') {\n   |                                    ^^ expected\
    \ one of 8 possible tokens\n\nerror: expected `{`, found `=>`\n  --> /tmp/tmpiukcj75g.rs:27:36\n\
    \   |\n27 |                 if s.chars().all(b => b >= 'A' && b <= 'Z') {\n  \
    \ |                 --                 ^^ expected `{`\n   |                 |\n\
    \   |                 this `if` expression has a condition, but no block\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Key`\n  --> /tmp/tmpiukcj75g.rs:26:16\n\
    \   |\n26 |             Ok(Key::VStr(s)) => {\n   |                ^^^ use of\
    \ undeclared type `Key`\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `Key`\n  --> /tmp/tmpiukcj75g.rs:33:16\n   |\n33 |             Ok(Key::VBool(true))\
    \ => {\n   |                ^^^ use of undeclared type `Key`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Key`\n  --> /tmp/tmpiukcj75g.rs:36:16\n\
    \   |\n36 |             Ok(Key::VBool(false)) => {\n   |                ^^^ use\
    \ of undeclared type `Key`\n\nerror[E0599]: no method named `key` found for tuple\
    \ `(String, String)` in the current scope\n  --> /tmp/tmpiukcj75g.rs:25:18\n \
    \  |\n25 |         match kv.key() {\n   |                  ^^^ method not found\
    \ in `(String, String)`\n\nerror: aborting due to 6 previous errors\n\nSome errors\
    \ have detailed explanations: E0433, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut it = dict.iter().collect::<Vec<_>>();\n\
    \    it.sort_by(|x, y| x.1.cmp(&y.1));\n    let first: bool = it.next().is_ok()\
    \ && !it.next().is_ok();\n    first\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `next` found for struct `Vec<(&String, &String)>`\
    \ in the current scope\n  --> /tmp/tmp2a1hl2js.rs:20:26\n   |\n20 |     let first:\
    \ bool = it.next().is_ok() && !it.next().is_ok();\n   |                      \
    \    ^^^^ method not found in `Vec<(&String, &String)>`\n\nerror[E0599]: no method\
    \ named `next` found for struct `Vec<(&String, &String)>` in the current scope\n\
    \  --> /tmp/tmp2a1hl2js.rs:20:48\n   |\n20 |     let first: bool = it.next().is_ok()\
    \ && !it.next().is_ok();\n   |                                               \
    \ ^^^^ method not found in `Vec<(&String, &String)>`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    match dict.len() {\n        0 => true,\n\
    \        _ => check_dict_case(dict.values_mut().collect()),\n    }\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `HashMap<String, String>` cannot be built\
    \ from an iterator over elements of type `&mut String`\n    --> /tmp/tmpc4pj2zd9.rs:20:30\n\
    \     |\n20   |         _ => check_dict_case(dict.values_mut().collect()),\n \
    \    |              --------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^ value of type\
    \ `HashMap<String, String>` cannot be built from `std::iter::Iterator<Item=&mut\
    \ String>`\n     |              |\n     |              required by a bound introduced\
    \ by this call\n     |\n     = help: the trait `FromIterator<&mut String>` is\
    \ not implemented for `HashMap<String, String>`\n     = help: the trait `FromIterator<(K,\
    \ V)>` is implemented for `HashMap<K, V, S>`\nnote: required by a bound in `collect`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.len() == dict.keys().len() || dict.len()\
    \ == dict.iter().map(|k|k.to_lowercase()).count() == dict.keys().len() ||\n  \
    \      dict.len() == dict.iter().map(|k|k.to_uppercase()).count() == dict.keys().len()\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmpgj4f6nri.rs:18:51\n\
    \   |\n18 |     dict.len() == dict.keys().len() || dict.len() == dict.iter().map(|k|k.to_lowercase()).count()\
    \ == dict.keys().len() ||\n   |                                              \
    \     ^^                                              ^^\n   |\nhelp: split the\
    \ comparison into two\n   |\n18 |     dict.len() == dict.keys().len() || dict.len()\
    \ == dict.iter().map(|k|k.to_lowercase()).count() && dict.iter().map(|k|k.to_lowercase()).count()\
    \ == dict.keys().len() ||\n   |                                              \
    \                                                     +++++++++++++++++++++++++++++++++++++++++++++++\n\
    \nerror: comparison operators cannot be chained\n  --> /tmp/tmpgj4f6nri.rs:19:20\n\
    \   |\n19 |         dict.len() == dict.iter().map(|k|k.to_uppercase()).count()\
    \ == dict.keys().len()\n   |                    ^^                           \
    \                   ^^\n   |\nhelp: split the comparison into two\n   |\n19 |\
    \         dict.len() == dict.iter().map(|k|k.to_uppercase()).count() && dict.iter().map(|k|k.to_uppercase()).count()\
    \ == dict.keys().len()\n   |                                                 \
    \                   +++++++++++++++++++++++++++++++++++++++++++++++\n\nerror[E0599]:\
    \ no method named `to_lowercase` found for tuple `(&String, &String)` in the current\
    \ scope\n  --> /tmp/tmpgj4f6nri.rs:18:75\n   |\n18 |     dict.len() == dict.keys().len()\
    \ || dict.len() == dict.iter().map(|k|k.to_lowercase()).count() == dict.keys().len()\
    \ ||\n   |                                                                   \
    \        ^^^^^^^^^^^^ method not found in `(&String, &String)`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpgj4f6nri.rs:18:102\n   |\n18 |     dict.len()\
    \ == dict.keys().len() || dict.len() == dict.iter().map(|k|k.to_lowercase()).count()\
    \ == dict.keys().len() ||\n   |                                              \
    \                                                        ^^^^^^^^^^^^^^^^^ expected\
    \ `bool`, found `usize`\n\nerror[E0599]: no method named `to_uppercase` fo"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.is_empty()\n        || let HashMap<String,\
    \ String>::Iter(mut entries) = dict.iter() {\n        for (key, value) in entries\
    \ {\n            match key.to_lowercase().as_ref() {\n                Some(\"\
    a\") | Some(\"b\") | Some(\"c\") | Some(\"d\") | Some(\"e\") | Some(\"f\") | Some(\"\
    g\") | Some(\"h\") | Some(\"i\") | Some(\"j\") | Some(\"k\") | Some(\"l\") | Some(\"\
    m\") | Some(\"n\") | Some(\"o\") | Some(\"p\") | Some(\"q\") | Some(\"r\") | Some(\"\
    s\") | Some(\"t\") | Some(\"u\") | Some(\"v\") | Some(\"w\") | Some(\"x\") | Some(\"\
    y\") | Some(\"z\") => true,\n                _ => false\n            }\n     \
    \   }\n        true\n    }\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `=`, `@`, or `|`, found `<`\n  --> /tmp/tmpz_8qxeqw.rs:19:23\n\
    \   |\n19 |         || let HashMap<String, String>::Iter(mut entries) = dict.iter()\
    \ {\n   |                       ^ expected one of `=`, `@`, or `|`\n\nerror: aborting\
    \ due to previous error\n\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut found_keys = false;\n    let\
    \ mut found_keys_upper = false;\n    for pair in dict.iter() {\n        let key\
    \ = pair.key();\n        if key.is_uppercase() {\n            found_keys_upper\
    \ = true;\n        }\n        if key.is_lowercase() {\n            found_keys\
    \ = true;\n        }\n    }\n\n    if found_keys && found_keys_upper {\n     \
    \   false\n    } else if found_keys {\n        true\n    } else {\n        false\n\
    \    }\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `key` found for tuple `(&String, &String)`\
    \ in the current scope\n  --> /tmp/tmpch5m0sqq.rs:21:24\n   |\n21 |         let\
    \ key = pair.key();\n   |                        ^^^ method not found in `(&String,\
    \ &String)`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       match key {\n            String::from(\"name\") => value.chars().all(|c|\
    \ c >= 'A' && c <= 'Z'),\n            String::from(\"state\") => value.chars().all(|c|\
    \ c >= 'a' && c <= 'z'),\n            String::from(\"zip\") => value.chars().all(|c|\
    \ c >= '0' && c <= '9'),\n            _ => false,\n        }\n    })\n}\n\nfn\
    \ main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0164]: expected tuple struct or tuple variant, found associated\
    \ function `String::from`\n  --> /tmp/tmpe5b04ddp.rs:20:13\n   |\n20 |       \
    \      String::from(\"name\") => value.chars().all(|c| c >= 'A' && c <= 'Z'),\n\
    \   |             ^^^^^^^^^^^^^^^^^^^^ `fn` calls are not allowed in patterns\n\
    \   |\n   = help: for more information, visit https://doc.rust-lang.org/book/ch18-00-patterns.html\n\
    \nerror[E0164]: expected tuple struct or tuple variant, found associated function\
    \ `String::from`\n  --> /tmp/tmpe5b04ddp.rs:21:13\n   |\n21 |             String::from(\"\
    state\") => value.chars().all(|c| c >= 'a' && c <= 'z'),\n   |             ^^^^^^^^^^^^^^^^^^^^^\
    \ `fn` calls are not allowed in patterns\n   |\n   = help: for more information,\
    \ visit https://doc.rust-lang.org/book/ch18-00-patterns.html\n\nerror[E0164]:\
    \ expected tuple struct or tuple variant, found associated function `String::from`\n\
    \  --> /tmp/tmpe5b04ddp.rs:22:13\n   |\n22 |             String::from(\"zip\"\
    ) => value.chars().all(|c| c >= '0' && c <= '9'),\n   |             ^^^^^^^^^^^^^^^^^^^\
    \ `fn` calls are not allowed in patterns\n   |\n   = help: for more information,\
    \ visit https://doc.rust-lang.org/book/ch18-00-patterns.html\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0164`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut iter1 = dict.iter();\n    let\
    \ mut iter2 = dict.iter();\n    while iter2.next() {\n        match iter1.next().key().to_string()\
    \ {\n            \"string\" => return false,\n            \"string\".to_string()\
    \ => return false,\n            _ => (),\n        }\n    }\n    true\n}\n\nfn\
    \ main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `...`, `..=`, `..`, `=>`, `if`, or `|`, found `.`\n\
    \  --> /tmp/tmpvrtqksnn.rs:23:21\n   |\n23 |             \"string\".to_string()\
    \ => return false,\n   |                     ^ expected one of `...`, `..=`, `..`,\
    \ `=>`, `if`, or `|`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvrtqksnn.rs:20:11\n\
    \   |\n20 |     while iter2.next() {\n   |           ^^^^^^^^^^^^ expected `bool`,\
    \ found enum `Option`\n   |\n   = note: expected type `bool`\n              found\
    \ enum `Option<(&String, &String)>`\n\nerror[E0599]: no method named `key` found\
    \ for enum `Option` in the current scope\n  --> /tmp/tmpvrtqksnn.rs:21:28\n  \
    \ |\n21 |         match iter1.next().key().to_string() {\n   |               \
    \             ^^^ method not found in `Option<(&String, &String)>`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    !dict.keys().contains(&String::from(\"\
    None\"))\n        && !dict.keys().contains(&String::from(\"NULL\"))\n        &&\
    \ dict.keys().contains(&String::from(\"False\"))\n        && dict.keys().contains(&String::from(\"\
    true\"))\n        && dict.keys().contains(&String::from(\"False\"))\n        &&\
    \ dict.keys().contains(&String::from(\"false\"))\n        && dict.keys().contains(&String::from(\"\
    Zero\"))\n        && dict.keys().contains(&String::from(\"None\"))\n        &&\
    \ dict.keys().contains(&String::from(\"null\"))\n        && dict.keys().contains(&String::from(\"\
    Empty\"))\n        && dict.keys().contains(&String::from(\"NULL\"))\n        &&\
    \ dict.keys().contains(&String::from(\"null\"))\n        && dict.keys().contains(&String::from(\"\
    Null\"))\n        && dict.keys().contains(&String::from(\"NULL\"))\n        &&\
    \ dict.keys().contains(&String::from(\"Null\"))\n        && dict.keys().contains(&String::from(\"\
    Null\"))\n        && dict.keys().contains(&String::from(\"Null\"))\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `contains` found for struct `std::collections::hash_map::Keys`\
    \ in the current scope\n  --> /tmp/tmp8yub9aab.rs:18:18\n   |\n18 |     !dict.keys().contains(&String::from(\"\
    None\"))\n   |                  ^^^^^^^^ method not found in `std::collections::hash_map::Keys<'_,\
    \ String, String>`\n\nerror[E0599]: no method named `contains` found for struct\
    \ `std::collections::hash_map::Keys` in the current scope\n  --> /tmp/tmp8yub9aab.rs:19:25\n\
    \   |\n19 |         && !dict.keys().contains(&String::from(\"NULL\"))\n   |  \
    \                       ^^^^^^^^ method not found in `std::collections::hash_map::Keys<'_,\
    \ String, String>`\n\nerror[E0599]: no method named `contains` found for struct\
    \ `std::collections::hash_map::Keys` in the current scope\n  --> /tmp/tmp8yub9aab.rs:20:24\n\
    \   |\n20 |         && dict.keys().contains(&String::from(\"False\"))\n   |  \
    \                      ^^^^^^^^ method not found in `std::collections::hash_map::Keys<'_,\
    \ String, String>`\n\nerror[E0599]: no method named `contains` found for struct\
    \ `std::collections::hash_map::Keys` in the current scope\n  --> /tmp/tmp8yub9aab.rs:21:24\n\
    \   |\n21 |         && dict.keys().contains(&String::from(\"true\"))\n   |   \
    \                     ^^^^^^^^ method not found in `std::collections::hash_map::Keys<'_,\
    \ String, String>`\n\nerror[E0599]: no method named `contains` found for struct\
    \ `std::collections::hash_map::Keys` in the current scope\n  --> /tmp/tmp8yub9aab.rs:22:24\n\
    \   |\n22 |         && dict.keys().contains(&String::from(\"False\"))\n   |  \
    \                      ^^^^^^^^ method not found in `std::collections::hash_map::Keys<'_,\
    \ String, String>`\n\nerror[E0599]: no method named `contains` found for struct\
    \ `std::collections::hash_map::Keys` in the current scope\n  --> /tmp/tmp8yub9aab.rs:23:24\n\
    \   |\n23 |         && dict.keys().contains(&String::from(\"false\"))\n   |  \
    \                      ^^^^^^^^ method not found in `std::collections::hash_map::Keys<'_,\
    \ String, String>`\n\nerror[E0599]: no method named `contains` found for struct\
    \ `std::collections::hash_map::Keys` in the current sco"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut iter = dict.iter();\n    let\
    \ len = dict.len();\n    while let Some((key, val)) = iter.next() {\n        if\
    \ key\n            .to_lowercase()\n            .unwrap()\n            .chars()\n\
    \            .all(|c| *c != '_')\n        {\n            return false;\n     \
    \   }\n        if key\n            .to_uppercase()\n            .unwrap()\n  \
    \          .chars()\n            .all(|c| *c != '_')\n        {\n            return\
    \ false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpxpagfvg5.rs:23:14\n   |\n23 |             .unwrap()\n\
    \   |              ^^^^^^ method not found in `String`\n\nerror[E0599]: no method\
    \ named `unwrap` found for struct `String` in the current scope\n  --> /tmp/tmpxpagfvg5.rs:31:14\n\
    \   |\n31 |             .unwrap()\n   |              ^^^^^^ method not found in\
    \ `String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n\n    for value in dict.values() {\n        let (lower_case,\
    \ upper_case) = match String::from_str(&value).unwrap() {\n            Ok(value)\
    \ => value,\n            Err(_) => return false,\n        };\n\n        if lower_case\
    \ != upper_case {\n            return false;\n        }\n    }\n    true\n}\n\n\
    fn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no function or associated item named `from_str` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmpb5debv1c.rs:23:54\n   |\n\
    23 |         let (lower_case, upper_case) = match String::from_str(&value).unwrap()\
    \ {\n   |                                                      ^^^^^^^^ function\
    \ or associated item not found in `String`\n   |\n   = help: items from traits\
    \ can only be used if the trait is in scope\nhelp: the following trait is implemented\
    \ but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::str::FromStr;\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.len() == 0 {\n        return\
    \ false;\n    }\n    let mut iter = dict.iter();\n    let mut current_key = iter.next().unwrap();\n\
    \    for next_key in iter {\n        let current_key = next_key.unwrap();\n  \
    \      if !is_string_case(current_key, next_key) {\n            return false;\n\
    \        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_string_case` in this scope\n  -->\
    \ /tmp/tmpstn9f90k.rs:25:13\n   |\n25 |         if !is_string_case(current_key,\
    \ next_key) {\n   |             ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0599]:\
    \ no method named `unwrap` found for tuple `(&String, &String)` in the current\
    \ scope\n  --> /tmp/tmpstn9f90k.rs:24:36\n   |\n24 |         let current_key =\
    \ next_key.unwrap();\n   |                                    ^^^^^^ method not\
    \ found in `(&String, &String)`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0425, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.len() == 0 {\n        return\
    \ false;\n    }\n    for (key, value) in dict {\n        if key.to_lowercase()\
    \ == key.to_lowercase() {\n            return false;\n        }\n        if key.to_uppercase()\
    \ == key.to_uppercase() {\n            return false;\n        }\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpa4cpjaua.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    if keys.is_empty()\
    \ {\n        return false;\n    }\n\n    for k in keys {\n        // All values\
    \ are strings in lowercase or uppercase\n        let v = dict.get(k).unwrap_or(String::from(\"\
    \"));\n        if v.len() < 2 || v.len() > 3 {\n            return false;\n  \
    \      }\n\n        let v_lower = v.to_lowercase();\n        if v_lower != v {\n\
    \            return false;\n        }\n\n        let v_upper = v.to_uppercase();\n\
    \        if v_upper != v {\n            return false;\n        }\n    }\n\n  \
    \  return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0658]: use of unstable library feature 'exact_size_is_empty'\n \
    \ --> /tmp/tmp1cooz4su.rs:19:13\n   |\n19 |     if keys.is_empty() {\n   |   \
    \          ^^^^^^^^\n   |\n   = note: see issue #35428 <https://github.com/rust-lang/rust/issues/35428>\
    \ for more information\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1cooz4su.rs:25:39\n\
    \   |\n25 |         let v = dict.get(k).unwrap_or(String::from(\"\"));\n   | \
    \                                      ^^^^^^^^^^^^^^^^\n   |                \
    \                       |\n   |                                       expected\
    \ `&String`, found struct `String`\n   |                                     \
    \  help: consider borrowing here: `&String::from(\"\")`\n\nerror[E0277]: can't\
    \ compare `String` with `&String`\n  --> /tmp/tmp1cooz4su.rs:31:20\n   |\n31 |\
    \         if v_lower != v {\n   |                    ^^ no implementation for\
    \ `String == &String`\n   |\n   = help: the trait `PartialEq<&String>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n         \
    \    <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0277]: can't compare `String` with `&String`\n\
    \  --> /tmp/tmp1cooz4su.rs:36:20\n   |\n36 |         if v_upper != v {\n   | \
    \                   ^^ no implementation for `String == &String`\n   |\n   = help:\
    \ the trait `PartialEq<&String>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `PartialEq<Rhs>`:\n             <&'a str\
    \ as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n     \
    \        <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n   "
  stdout: ''
  timestamp: 1660010964
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    match dict.len() {\n        0 => false,\n\
    \        1 => true,\n        _ => false,\n    }\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp2mqrr570.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    \n    // TODO: improve the complexity\n\
    \    let mut string_key_counter = 0;\n    \n    for (key, value) in dict.iter()\
    \ {\n        \n        // all keys must be strings in lower case or all keys must\
    \ be strings in upper case\n        // TODO: improve the complexity\n        \n\
    \        if !key.chars().any(|c| !c.is_ascii()) {\n            \n            if\
    \ let Some(mut v) = string_key_counter.get(value) {\n                string_key_counter.entry(value).or_insert(0)\
    \ += 1;\n            }\n        }\n    }\n    \n    !string_key_counter.is_empty()\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0689]: can't call method `get` on ambiguous numeric type `{integer}`\n\
    \  --> /tmp/tmpv2awd7kf.rs:29:53\n   |\n29 |             if let Some(mut v) =\
    \ string_key_counter.get(value) {\n   |                                      \
    \               ^^^\n   |\nhelp: you must specify a type for this binding, like\
    \ `i32`\n   |\n20 |     let mut string_key_counter: i32 = 0;\n   |         ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror[E0689]: can't call method `entry` on ambiguous numeric type `{integer}`\n\
    \  --> /tmp/tmpv2awd7kf.rs:30:36\n   |\n30 |                 string_key_counter.entry(value).or_insert(0)\
    \ += 1;\n   |                                    ^^^^^\n   |\nhelp: you must specify\
    \ a type for this binding, like `i32`\n   |\n20 |     let mut string_key_counter:\
    \ i32 = 0;\n   |         ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0067]: invalid\
    \ left-hand side of assignment\n  --> /tmp/tmpv2awd7kf.rs:30:62\n   |\n30 |  \
    \               string_key_counter.entry(value).or_insert(0) += 1;\n   |     \
    \            -------------------------------------------- ^^\n   |           \
    \      |\n   |                 cannot assign to this expression\n\nerror[E0689]:\
    \ can't call method `is_empty` on ambiguous numeric type `{integer}`\n  --> /tmp/tmpv2awd7kf.rs:35:25\n\
    \   |\n35 |     !string_key_counter.is_empty()\n   |                         ^^^^^^^^\n\
    \   |\nhelp: you must specify a type for this binding, like `i32`\n   |\n20 |\
    \     let mut string_key_counter: i32 = 0;\n   |         ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0689.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    match dict.len() {\n        0 => false,\n\
    \        1 => {\n            let (key, val) = *dict.keys().next().unwrap();\n\
    \            match val {\n                String::from(\"apple\") => String::from(key).is_ascii_lowercase(),\n\
    \                String::from(\"banana\") => String::from(key).is_ascii_lowercase(),\n\
    \                _ => false,\n            }\n        },\n        2 => {\n    \
    \        let (key, val) = *dict.keys().next().unwrap();\n            match val\
    \ {\n                String::from(\"apple\") => String::from(key).is_ascii_lowercase(),\n\
    \                String::from(\"banana\") => String::from(key).is_ascii_lowercase(),\n\
    \                String::from(\"apple\") => String::from(key).is_ascii_uppercase(),\n\
    \                _ => false,\n            }\n        },\n        _ => false,\n\
    \    }\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz6cbg190.rs:21:17\n   |\n\
    21 |             let (key, val) = *dict.keys().next().unwrap();\n   |        \
    \         ^^^^^^^^^^   ---------------------------- this expression has type `String`\n\
    \   |                 |\n   |                 expected struct `String`, found\
    \ tuple\n   |\n   = note: expected struct `String`\n               found tuple\
    \ `(_, _)`\n\nerror[E0164]: expected tuple struct or tuple variant, found associated\
    \ function `String::from`\n  --> /tmp/tmpz6cbg190.rs:23:17\n   |\n23 |       \
    \          String::from(\"apple\") => String::from(key).is_ascii_lowercase(),\n\
    \   |                 ^^^^^^^^^^^^^^^^^^^^^ `fn` calls are not allowed in patterns\n\
    \   |\n   = help: for more information, visit https://doc.rust-lang.org/book/ch18-00-patterns.html\n\
    \nerror[E0164]: expected tuple struct or tuple variant, found associated function\
    \ `String::from`\n  --> /tmp/tmpz6cbg190.rs:24:17\n   |\n24 |                \
    \ String::from(\"banana\") => String::from(key).is_ascii_lowercase(),\n   |  \
    \               ^^^^^^^^^^^^^^^^^^^^^^ `fn` calls are not allowed in patterns\n\
    \   |\n   = help: for more information, visit https://doc.rust-lang.org/book/ch18-00-patterns.html\n\
    \nerror[E0599]: no method named `is_ascii_lowercase` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpz6cbg190.rs:23:60\n   |\n23 |          \
    \       String::from(\"apple\") => String::from(key).is_ascii_lowercase(),\n \
    \  |                                                            ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_lowercase`\n\
    \nerror[E0599]: no method named `is_ascii_lowercase` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpz6cbg190.rs:24:61\n   |\n24 |          \
    \       String::from(\"banana\") => String::from(key).is_ascii_lowercase(),\n\
    \   |                                                             ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_lowercase`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpz6cbg190.rs:29:17\n   |\n29 |\
    \             let "
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    // TODO: HashMap should have a .keys()\
    \ method to avoid a copy here\n    for pair in dict.keys() {\n        // We have\
    \ to ignore None key\n        if pair.unwrap_or_default() == None {\n        \
    \    continue;\n        }\n        let key: String = pair.unwrap_or_default().clone();\n\
    \        if key.len() > 0 && !key.to_lowercase().is_empty() {\n            return\
    \ false;\n        }\n        if key.len() > 0 && !key.to_uppercase().is_empty()\
    \ {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap_or_default` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmplwnqacon.rs:21:17\n   |\n21 |         if\
    \ pair.unwrap_or_default() == None {\n   |                 ^^^^^^^^^^^^^^^^^ method\
    \ not found in `&String`\n\nerror[E0599]: no method named `unwrap_or_default`\
    \ found for reference `&String` in the current scope\n  --> /tmp/tmplwnqacon.rs:24:32\n\
    \   |\n24 |         let key: String = pair.unwrap_or_default().clone();\n   |\
    \                                ^^^^^^^^^^^^^^^^^ method not found in `&String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    match dict.len() {\n        0 => true,\n\
    \        _ => false,\n    }\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpw4er2qdu.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    !dict.is_empty() && dict.values().all(|x|\
    \ x.to_lowercase() == x)\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `String` with `&String`\n  --> /tmp/tmpclc2819d.rs:18:64\n\
    \   |\n18 |     !dict.is_empty() && dict.values().all(|x| x.to_lowercase() ==\
    \ x)\n   |                                                                ^^ no\
    \ implementation for `String == &String`\n   |\n   = help: the trait `PartialEq<&String>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    !dict.is_empty() &&\n    dict.keys().all(|&x|\
    \ x.is_string() && x.to_lowercase() == x)\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_string` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmp1rs5tucp.rs:19:28\n   |\n19 |     dict.keys().all(|&x|\
    \ x.is_string() && x.to_lowercase() == x)\n   |                            ^^^^^^^^^\
    \ help: there is an associated function with a similar name: `as_str`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.len() == 0 {\n        return\
    \ false;\n    }\n    for elem in dict.values() {\n        if elem.len() != 1 {\n\
    \            return false;\n        }\n        if elem.to_lowercase().is_empty()\
    \ {\n            return false;\n        }\n        if elem.to_uppercase().is_empty()\
    \ {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpz9yoxgao.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|&(ref key, ref value)|\
    \ {\n        key.to_lowercase().eq_ignore_ascii_case(value.to_lowercase())\n \
    \   })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0er9_30h.rs:18:22\n   |\n\
    18 |     dict.iter().all(|&(ref key, ref value)| {\n   |                     \
    \ ^^^^^^^^^^^^^^^^^^^^-\n   |                      |                   |\n   |\
    \                      |                   expected due to this\n   |        \
    \              expected tuple, found reference\n   |\n   = note:  expected tuple\
    \ `(&String, &String)`\n           found reference `&_`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    match dict.len() {\n        0 => true,\n\
    \        1 => dict.values().iter().filter(|x| x.is_string()).all(|x| x.is_lowercase()),\n\
    \        _ => dict.values().iter().filter(|x| x.is_string()).all(|x| x.is_uppercase()),\n\
    \    }\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `std::collections::hash_map::Values`\
    \ in the current scope\n  --> /tmp/tmpacv6lfag.rs:20:28\n   |\n20 |         1\
    \ => dict.values().iter().filter(|x| x.is_string()).all(|x| x.is_lowercase()),\n\
    \   |                            ^^^^ method not found in `std::collections::hash_map::Values<'_,\
    \ String, String>`\n\nerror[E0599]: no method named `iter` found for struct `std::collections::hash_map::Values`\
    \ in the current scope\n  --> /tmp/tmpacv6lfag.rs:21:28\n   |\n21 |         _\
    \ => dict.values().iter().filter(|x| x.is_string()).all(|x| x.is_uppercase()),\n\
    \   |                            ^^^^ method not found in `std::collections::hash_map::Values<'_,\
    \ String, String>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    match dict.len() {\n        0 => true,\n\
    \        _ => false,\n    }\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpw4er2qdu.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.is_empty() || dict\n        .iter()\n\
    \        .map(|kv| kv.key.to_lowercase())\n        .all(|k| *k == kv.key) || dict\n\
    \        .iter()\n        .map(|kv| kv.key.to_uppercase())\n        .all(|k| *k\
    \ == kv.key)\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `kv` in this scope\n  --> /tmp/tmppnp9fd6d.rs:21:24\n\
    \   |\n21 |         .all(|k| *k == kv.key) || dict\n   |                     \
    \   ^^ help: a local variable with a similar name exists: `k`\n\nerror[E0425]:\
    \ cannot find value `kv` in this scope\n  --> /tmp/tmppnp9fd6d.rs:24:24\n   |\n\
    24 |         .all(|k| *k == kv.key)\n   |                        ^^ help: a local\
    \ variable with a similar name exists: `k`\n\nerror[E0609]: no field `key` on\
    \ type `(&String, &String)`\n  --> /tmp/tmppnp9fd6d.rs:20:22\n   |\n20 |     \
    \    .map(|kv| kv.key.to_lowercase())\n   |                      ^^^\n\nerror[E0609]:\
    \ no field `key` on type `(&String, &String)`\n  --> /tmp/tmppnp9fd6d.rs:23:22\n\
    \   |\n23 |         .map(|kv| kv.key.to_uppercase())\n   |                   \
    \   ^^^\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0425, E0609.\nFor more information about an error, try `rustc\
    \ --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n    for k in dict.keys() {\n        let v = dict.get(k);\n  \
    \      if v.len() != 0 {\n            let s = v.clone();\n            s.to_lowercase();\n\
    \            s.to_uppercase();\n            if s == v {\n                return\
    \ false;\n            }\n        }\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmp514t3163.rs:23:14\n   |\n23 |         if v.len() != 0 {\n\
    \   |              ^^^ method not found in `Option<&String>`\n\nerror[E0599]:\
    \ no method named `to_lowercase` found for enum `Option` in the current scope\n\
    \  --> /tmp/tmp514t3163.rs:25:15\n   |\n25 |             s.to_lowercase();\n \
    \  |               ^^^^^^^^^^^^ method not found in `Option<&String>`\n\nerror[E0599]:\
    \ no method named `to_uppercase` found for enum `Option` in the current scope\n\
    \  --> /tmp/tmp514t3163.rs:26:15\n   |\n26 |             s.to_uppercase();\n \
    \  |               ^^^^^^^^^^^^ method not found in `Option<&String>`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n    \n    let mut contains_upper_case = false;\n    let mut contains_lower_case\
    \ = false;\n    let mut contains_all_upper = false;\n    let mut contains_all_lower\
    \ = false;\n    for (key, value) in dict {\n        contains_all_upper |= (key\
    \ as &str).contains(\"A\") || \n                             (key as &str).contains(\"\
    B\") || \n                             (key as &str).contains(\"C\") || \n   \
    \                          (key as &str).contains(\"D\") || \n               \
    \              (key as &str).contains(\"E\") || \n                           \
    \  (key as &str).contains(\"F\") || \n                             (key as &str).contains(\"\
    G\") || \n                             (key as &str).contains(\"H\") || \n   \
    \                          (key as &str).contains(\"I\") || \n               \
    \              (key as &str).contains(\"J\") || \n                           \
    \  (key as &str).contains(\"K\") || \n                             (key as &str).contains(\"\
    L\") || \n                             (key as &str).contains(\"M\") || \n   \
    \                          (key as &str).contains(\"N\") || \n               \
    \              (key as &str).contains(\"O\") || \n                           \
    \  (key as &str).contains(\"P\") || \n                             (key as &str).contains(\"\
    Q\") || \n                             (key as &str).contains(\"R\") || \n   \
    \                          (key as &str).contains(\"S\") || \n               \
    \              (key as &str).contains(\"T\") || \n                           \
    \  (key as &str).contains(\"U\") || \n                             (key as &str).contains(\"\
    V\") || \n                             (key as &str).contains(\"W\") || \n   \
    \                          (key as &str).contains(\"X\") || \n               \
    \              (key as &str).contains(\"Y\") || \n                           \
    \  (key as &str).contains(\"Z\");\n        contains_all_lower |= (key as &str).contains(\"\
    a\") || \n                             (key as &str).contains(\"b\") || \n   \
    \                          (key as &str).contains(\"c\") || \n               \
    \              (key as &str).contains(\"d\") || \n                           \
    \  (key as &str).contains(\"e\") || \n                             (key as &str).contains(\"\
    f\") || \n                             (key as &str).contains(\"g\") || \n   \
    \                          (key as &str).contains(\"h\") || \n               \
    \              (key as &str).contains(\"i\") || \n\n}\n\nfn main() {\n    let\
    \ candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmplhdr7oke.rs:74:3\n\
    \   |\n17 | fn check_dict_case(dict: HashMap<String, String>) -> bool {\n   |\
    \                                                           - unclosed delimiter\n\
    ...\n26 |     for (key, value) in dict {\n   |                              -\
    \ this delimiter might not be properly closed...\n...\n63 | }\n   | - ...as it\
    \ matches this but it has different indentation\n...\n74 | }\n   |   ^\n\nerror:\
    \ expected expression, found `}`\n  --> /tmp/tmplhdr7oke.rs:63:1\n   |\n63 | }\n\
    \   | ^ expected expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplhdr7oke.rs:17:54\n\
    \   |\n17 | fn check_dict_case(dict: HashMap<String, String>) -> bool {\n   |\
    \    ---------------                                   ^^^^ expected `bool`, found\
    \ `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or\
    \ `return` expression\n\nerror[E0605]: non-primitive cast: `String` as `&str`\n\
    \  --> /tmp/tmplhdr7oke.rs:27:31\n   |\n27 |         contains_all_upper |= (key\
    \ as &str).contains(\"A\") || \n   |                               ^^^^^^^^^^^^^\
    \ invalid cast\n   |\nhelp: consider borrowing the value\n   |\n27 |         contains_all_upper\
    \ |= (&key as &str).contains(\"A\") || \n   |                                +\n\
    \nerror[E0605]: non-primitive cast: `String` as `&str`\n  --> /tmp/tmplhdr7oke.rs:28:30\n\
    \   |\n28 | ...                   (key as &str).contains(\"B\") || \n   |    \
    \                   ^^^^^^^^^^^^^ invalid cast\n   |\nhelp: consider borrowing\
    \ the value\n   |\n28 |                              (&key as &str).contains(\"\
    B\") || \n   |                               +\n\nerror[E0605]: non-primitive\
    \ cast: `String` as `&str`\n  --> /tmp/tmplhdr7oke.rs:29:30\n   |\n29 | ...  \
    \                 (key as &str).contains(\"C\") || \n   |                    \
    \   ^^^^^^^^^^^^^ invalid cast\n   |\nhelp: consider borrowing the value\n   |\n\
    29 |                              (&key as &str).contains(\"C\") || \n   |   \
    \                            +\n\nerror[E0605]: non-primitive cast: `String` as\
    \ `&str`\n  --> /tmp/tmplhdr7oke.rs:30:30\n   |\n30 | ..."
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|&(k, v)| k.is_lowercase()\
    \ || k.is_uppercase()) || dict.iter().all(|&(k, v)| v.is_lowercase() || v.is_uppercase())\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpt731qv_y.rs:18:22\n   |\n\
    18 |     dict.iter().all(|&(k, v)| k.is_lowercase() || k.is_uppercase()) || dict.iter().all(|&(k,\
    \ v)| v.is_lowercase() || v.is_uppercase())\n   |                      ^^^^^^-\n\
    \   |                      |     |\n   |                      |     expected due\
    \ to this\n   |                      expected tuple, found reference\n   |\n \
    \  = note:  expected tuple `(&String, &String)`\n           found reference `&_`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpt731qv_y.rs:18:89\n   |\n18 |\
    \     dict.iter().all(|&(k, v)| k.is_lowercase() || k.is_uppercase()) || dict.iter().all(|&(k,\
    \ v)| v.is_lowercase() || v.is_uppercase())\n   |                            \
    \                                                             ^^^^^^-\n   |  \
    \                                                                            \
    \           |     |\n   |                                                    \
    \                                     |     expected due to this\n   |       \
    \                                                                            \
    \      expected tuple, found reference\n   |\n   = note:  expected tuple `(&String,\
    \ &String)`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, _)| key.to_lowercase()\
    \ == key)\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `String` with `&String`\n  --> /tmp/tmprfhfodvd.rs:18:51\n\
    \   |\n18 |     dict.iter().all(|(key, _)| key.to_lowercase() == key)\n   |  \
    \                                                 ^^ no implementation for `String\
    \ == &String`\n   |\n   = help: the trait `PartialEq<&String>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.keys().all(|key| {\n        key.chars().all(|ch|\
    \ {\n            ch.to_ascii_lowercase()\n            || ch.to_ascii_uppercase()\n\
    \        })\n    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsfh6jblf.rs:20:13\n   |\n\
    20 |             ch.to_ascii_lowercase()\n   |             ^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `bool`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsfh6jblf.rs:21:16\n\
    \   |\n21 |             || ch.to_ascii_uppercase()\n   |                ^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `bool`, found `char`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut keys = dict.keys();\n    while\
    \ let Some(k) = keys.next() {\n        match k {\n            String::from(x)\
    \ => x.to_lowercase().is_match(x),\n            String::from(x) => x.to_uppercase().is_match(x),\n\
    \            _ => return false,\n        };\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0164]: expected tuple struct or tuple variant, found associated\
    \ function `String::from`\n  --> /tmp/tmpon8k0kyf.rs:21:13\n   |\n21 |       \
    \      String::from(x) => x.to_lowercase().is_match(x),\n   |             ^^^^^^^^^^^^^^^\
    \ `fn` calls are not allowed in patterns\n   |\n   = help: for more information,\
    \ visit https://doc.rust-lang.org/book/ch18-00-patterns.html\n\nerror[E0164]:\
    \ expected tuple struct or tuple variant, found associated function `String::from`\n\
    \  --> /tmp/tmpon8k0kyf.rs:22:13\n   |\n22 |             String::from(x) => x.to_uppercase().is_match(x),\n\
    \   |             ^^^^^^^^^^^^^^^ `fn` calls are not allowed in patterns\n   |\n\
    \   = help: for more information, visit https://doc.rust-lang.org/book/ch18-00-patterns.html\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0164`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    match dict.len() {\n        0 => false,\n\
    \        1 => true,\n        _ => {\n            for entry in dict.iter() {\n\
    \                if entry.get_key().is_lowercase() {\n                    return\
    \ true\n                }\n                if entry.get_key().is_uppercase() {\n\
    \                    return true\n                }\n            }\n         \
    \   false\n        }\n    }\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `get_key` found for tuple `(&String, &String)`\
    \ in the current scope\n  --> /tmp/tmpux_lpnc7.rs:23:26\n   |\n23 |          \
    \       if entry.get_key().is_lowercase() {\n   |                          ^^^^^^^\
    \ method not found in `(&String, &String)`\n\nerror[E0599]: no method named `get_key`\
    \ found for tuple `(&String, &String)` in the current scope\n  --> /tmp/tmpux_lpnc7.rs:26:26\n\
    \   |\n26 |                 if entry.get_key().is_uppercase() {\n   |        \
    \                  ^^^^^^^ method not found in `(&String, &String)`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.is_empty()\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpcnag6z2b.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010781
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    !dict.is_empty() && dict.values().all(|x|\
    \ x.is_lowercase())\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpyc3z8lfd.rs:18:49\n   |\n18 |     !dict.is_empty()\
    \ && dict.values().all(|x| x.is_lowercase())\n   |                           \
    \                      ^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `to_lowercase`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.into_iter().all(|(_, v)| {\n  \
    \      let mut v = v.to_lowercase();\n        !v.contains('_')\n    })\n}\n\n\
    fn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpezi3xzkt.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut map_string = dict.iter().map(|&(_,\
    \ val)| val.clone());\n    map_string.sort();\n    map_string.dedup();\n    map_string.into_iter().all(|&x|\
    \ x.to_string().as_str().to_lowercase() == x)\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgw1x4w1q.rs:18:43\n   |\n\
    18 |     let mut map_string = dict.iter().map(|&(_, val)| val.clone());\n   |\
    \                                           ^^^^^^^^-\n   |                  \
    \                         |       |\n   |                                    \
    \       |       expected due to this\n   |                                   \
    \        expected tuple, found reference\n   |\n   = note:  expected tuple `(&String,\
    \ &String)`\n           found reference `&_`\n\nerror[E0599]: no method named\
    \ `sort` found for struct `Map` in the current scope\n  --> /tmp/tmpgw1x4w1q.rs:19:16\n\
    \   |\n19 |     map_string.sort();\n   |                ^^^^ method not found\
    \ in `Map<std::collections::hash_map::Iter<'_, String, String>, _>`\n\nerror[E0599]:\
    \ no method named `dedup` found for struct `Map` in the current scope\n  --> /tmp/tmpgw1x4w1q.rs:20:16\n\
    \   |\n20 |     map_string.dedup();\n   |                ^^^^^ method not found\
    \ in `Map<std::collections::hash_map::Iter<'_, String, String>, _>`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    match dict.len() {\n        0 => true,\n\
    \        _ => dict.iter().all(|(k, _)| k.chars().all_bytes().all(|c| c.is_lowercase()\
    \ || c.is_uppercase())),\n    }\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `all_bytes` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmp921cmgz7.rs:20:49\n   |\n20 |         _ => dict.iter().all(|(k,\
    \ _)| k.chars().all_bytes().all(|c| c.is_lowercase() || c.is_uppercase())),\n\
    \   |                                                 ^^^^^^^^^ method not found\
    \ in `Chars<'_>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n    for (key, value) in dict {\n        match value.to_lowercase()\
    \ {\n            true => {\n                if key.is_lowercase() {\n        \
    \            return true;\n                } else {\n                    return\
    \ false;\n                }\n            }\n            false => if key.is_uppercase()\
    \ {\n                    return true;\n                } else {\n            \
    \        return false;\n                }\n            },\n        }\n    }\n\
    \    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\"\
    )), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error: unexpected closing delimiter: `}`\n  --> /tmp/tmpy9xnchcd.rs:39:1\n\
    \   |\n17 | fn check_dict_case(dict: HashMap<String, String>) -> bool {\n   |\
    \                                                           - this opening brace...\n\
    ...\n37 |     }\n   |     - ...matches this closing brace\n38 |     return true;\n\
    39 | }\n   | ^ unexpected closing delimiter\n\nerror: aborting due to previous\
    \ error\n\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict\n        .iter()\n        .all(|&(k,\
    \ v): &String| v.len() == v.len());\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgernqmr7.rs:20:16\n   |\n\
    20 |         .all(|&(k, v): &String| v.len() == v.len());\n   |              \
    \  ^^^^^^  ------- expected due to this\n   |                |\n   |         \
    \       expected struct `String`, found tuple\n   |\n   = note: expected struct\
    \ `String`\n               found tuple `(_, _)`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpgernqmr7.rs:17:54\n   |\n17 | fn check_dict_case(dict: HashMap<String,\
    \ String>) -> bool {\n   |    ---------------                                \
    \   ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n...\n20 |         .all(|&(k,\
    \ v): &String| v.len() == v.len());\n   |                                    \
    \                - help: remove this semicolon\n\nerror[E0631]: type mismatch\
    \ in closure arguments\n    --> /tmp/tmpgernqmr7.rs:20:10\n     |\n20   |    \
    \     .all(|&(k, v): &String| v.len() == v.len());\n     |          ^^^ -------------------------------------\
    \ found signature of `for<'r> fn(&'r String) -> _`\n     |          |\n     |\
    \          expected signature of `fn((&String, &String)) -> _`\n     |\nnote:\
    \ required by a bound in `all`\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0631.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower = false;\n    let mut\
    \ upper = false;\n    for (key, value) in dict.iter() {\n        if key.is_lowercase()\
    \ {\n            lower = true;\n        } else if key.is_uppercase() {\n     \
    \       upper = true;\n        } else {\n            return false;\n        }\n\
    \    }\n    lower && upper\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpdctr7fvh.rs:21:16\n   |\n21 |         if\
    \ key.is_lowercase() {\n   |                ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named\
    \ `is_uppercase` found for reference `&String` in the current scope\n  --> /tmp/tmpdctr7fvh.rs:23:23\n\
    \   |\n23 |         } else if key.is_uppercase() {\n   |                     \
    \  ^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.is_empty() || dict.values()\n \
    \       .into_iter()\n        .all(|val| val.as_bytes()\n            .filter(|c|\
    \ c.to_ascii_lowercase()\n                .map_or(false, |c| c.to_ascii_uppercase())\
    \ == true)\n            .collect::<Vec<_>>())\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `&[u8]` is not an iterator\n  --> /tmp/tmphfsm76dk.rs:21:14\n\
    \   |\n21 |             .filter(|c| c.to_ascii_lowercase()\n   |             \
    \ ^^^^^^ `&[u8]` is not an iterator; try calling `.iter()`\n   |\n   = note: the\
    \ following trait bounds were not satisfied:\n           `&[u8]: Iterator`\n \
    \          which is required by `&mut &[u8]: Iterator`\n           `[u8]: Iterator`\n\
    \           which is required by `&mut [u8]: Iterator`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n    match dict.keys().collect() {\n        vec![String::from(\"\
    a\"), String::from(\"A\")] => true,\n        vec![String::from(\"b\"), String::from(\"\
    B\")] => true,\n        _ => false,\n    }\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error: arbitrary expressions aren't allowed in patterns\n  --> /tmp/tmptacqwwa6.rs:22:9\n\
    \   |\n22 |         vec![String::from(\"a\"), String::from(\"A\")] => true,\n\
    \   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = note: this\
    \ error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace\
    \ for more info)\n\nerror: arbitrary expressions aren't allowed in patterns\n\
    \  --> /tmp/tmptacqwwa6.rs:23:9\n   |\n23 |         vec![String::from(\"b\"),\
    \ String::from(\"B\")] => true,\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |\n   = note: this error originates in the macro `vec` (in Nightly builds,\
    \ run with -Z macro-backtrace for more info)\n\nerror: aborting due to 2 previous\
    \ errors\n\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.keys().all(|key| {\n        if\
    \ let Ok(value) = dict.remove(key) {\n            key.to_lowercase() == value.to_lowercase()\n\
    \        } else {\n            false\n        }\n    })\n}\n\nfn main() {\n  \
    \  let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsqj7zee7.rs:19:16\n   |\n\
    19 |         if let Ok(value) = dict.remove(key) {\n   |                ^^^^^^^^^\
    \   ---------------- this expression has type `Option<String>`\n   |         \
    \       |\n   |                expected enum `Option`, found enum `Result`\n \
    \  |\n   = note: expected enum `Option<String>`\n              found enum `Result<_,\
    \ _>`\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.len() == 0 || dict.len() == dict.keys().len()\
    \ || dict.len() == dict.keys().len() * 2\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp27w5adqe.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.len() == 0 {\n        return\
    \ false;\n    }\n    for key in dict.keys() {\n        let key = key.to_lowercase();\n\
    \        let value = dict.get(key).unwrap();\n        if !is_string_lowercase(key)\
    \ && !is_string_uppercase(key) {\n            return false;\n        }\n     \
    \   if !is_string_lowercase(value) {\n            return false;\n        }\n \
    \   }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_string_lowercase` in this scope\n\
    \  --> /tmp/tmpqey0s0gz.rs:24:13\n   |\n24 |         if !is_string_lowercase(key)\
    \ && !is_string_uppercase(key) {\n   |             ^^^^^^^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `is_string_uppercase` in\
    \ this scope\n  --> /tmp/tmpqey0s0gz.rs:24:42\n   |\n24 |         if !is_string_lowercase(key)\
    \ && !is_string_uppercase(key) {\n   |                                       \
    \   ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `is_string_lowercase` in this scope\n  --> /tmp/tmpqey0s0gz.rs:27:13\n   |\n\
    27 |         if !is_string_lowercase(value) {\n   |             ^^^^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqey0s0gz.rs:23:30\n\
    \   |\n23 |         let value = dict.get(key).unwrap();\n   |                \
    \              ^^^\n   |                              |\n   |                \
    \              expected reference, found struct `String`\n   |               \
    \               help: consider borrowing here: `&key`\n   |\n   = note: expected\
    \ reference `&_`\n                 found struct `String`\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    match dict.len() {\n        0 => false,\n\
    \        _ => true,\n    }\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpn0s5p7f0.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut iter = dict.iter();\n    loop\
    \ {\n        let key = iter.next().unwrap();\n        match key.as_ref() {\n \
    \           Some(ref key) if !key.is_string() => return false,\n            _\
    \ => (),\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `as_ref` found for tuple `(&String, &String)`\
    \ in the current scope\n  --> /tmp/tmpot3ijy_w.rs:21:19\n   |\n21 |         match\
    \ key.as_ref() {\n   |                   ^^^^^^ method not found in `(&String,\
    \ &String)`\n\nwarning: unreachable expression\n  --> /tmp/tmpot3ijy_w.rs:26:5\n\
    \   |\n19 | /     loop {\n20 | |         let key = iter.next().unwrap();\n21 |\
    \ |         match key.as_ref() {\n22 | |             Some(ref key) if !key.is_string()\
    \ => return false,\n23 | |             _ => (),\n24 | |         }\n25 | |    \
    \ }\n   | |_____- any code following this expression is unreachable\n26 |    \
    \   true\n   |       ^^^^ unreachable expression\n   |\n   = note: `#[warn(unreachable_code)]`\
    \ on by default\n\nerror: aborting due to previous error; 1 warning emitted\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.keys().all(|k| k.is_lowercase()\
    \ || k.is_uppercase()) ||\n    dict.keys().all(|k| !k.is_lowercase() && !k.is_uppercase())\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpy5s8p0if.rs:18:27\n   |\n18 |     dict.keys().all(|k|\
    \ k.is_lowercase() || k.is_uppercase()) ||\n   |                           ^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_lowercase`\n\n\
    error[E0599]: no method named `is_uppercase` found for reference `&String` in\
    \ the current scope\n  --> /tmp/tmpy5s8p0if.rs:18:47\n   |\n18 |     dict.keys().all(|k|\
    \ k.is_lowercase() || k.is_uppercase()) ||\n   |                             \
    \                  ^^^^^^^^^^^^ help: there is an associated function with a similar\
    \ name: `to_uppercase`\n\nerror[E0599]: no method named `is_lowercase` found for\
    \ reference `&String` in the current scope\n  --> /tmp/tmpy5s8p0if.rs:19:28\n\
    \   |\n19 |     dict.keys().all(|k| !k.is_lowercase() && !k.is_uppercase())\n\
    \   |                            ^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `is_uppercase`\
    \ found for reference `&String` in the current scope\n  --> /tmp/tmpy5s8p0if.rs:19:49\n\
    \   |\n19 |     dict.keys().all(|k| !k.is_lowercase() && !k.is_uppercase())\n\
    \   |                                                 ^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_uppercase`\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut result = true;\n    for (_key,\
    \ val) in dict.iter() {\n        let mut lower_key = String::from(&key::to_lowercase(&_key));\n\
    \        let mut lower_val = String::from(&val::to_lowercase(&val));\n       \
    \ if lower_key.to_lowercase() != lower_val.to_lowercase() {\n            result\
    \ = false;\n            break;\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `key`\n\
    \  --> /tmp/tmp10sio38s.rs:20:43\n   |\n20 |         let mut lower_key = String::from(&key::to_lowercase(&_key));\n\
    \   |                                           ^^^ use of undeclared crate or\
    \ module `key`\n\nerror[E0433]: failed to resolve: use of undeclared crate or\
    \ module `val`\n  --> /tmp/tmp10sio38s.rs:21:43\n   |\n21 |         let mut lower_val\
    \ = String::from(&val::to_lowercase(&val));\n   |                            \
    \               ^^^ use of undeclared crate or module `val`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0433`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.len() == 0 {\n        return\
    \ false;\n    }\n\n    if let Some(key) = dict.get_mut(key) {\n        let value\
    \ = dict.get(key).unwrap();\n\n        if let Some(mut v) = key.as_mut() {\n \
    \           v.to_lowercase();\n        }\n\n        if let Some(mut v) = value.as_mut()\
    \ {\n            v.to_lowercase();\n        }\n\n        if key == value {\n \
    \           return true;\n        }\n\n        return key.as_ref() == value.as_ref();\n\
    \    }\n\n    return dict.len() == 1;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `key` in this scope\n  --> /tmp/tmpfwj8eeqh.rs:22:37\n\
    \   |\n22 |     if let Some(key) = dict.get_mut(key) {\n   |                 \
    \                    ^^^ not found in this scope\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpfwj8eeqh.rs:25:16\n   |\n25 |         if let Some(mut v) = key.as_mut()\
    \ {\n   |                ^^^^^^^^^^^   ------------ this expression has type `&mut\
    \ str`\n   |                |\n   |                expected `str`, found enum\
    \ `Option`\n   |\n   = note: expected type `str`\n              found enum `Option<_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpfwj8eeqh.rs:29:16\n   |\n29 |\
    \         if let Some(mut v) = value.as_mut() {\n   |                ^^^^^^^^^^^\
    \   -------------- this expression has type `&mut str`\n   |                |\n\
    \   |                expected `str`, found enum `Option`\n   |\n   = note: expected\
    \ type `str`\n              found enum `Option<_>`\n\nerror: aborting due to 3\
    \ previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.len() == 0 {\n        return\
    \ false;\n    }\n    let mut is_all_uppercase = false;\n    let mut is_all_lowercase\
    \ = false;\n    for (key, value) in dict {\n        if is_uppercase(key) {\n \
    \           is_all_uppercase = true;\n        }\n        if is_lowercase(key)\
    \ {\n            is_all_lowercase = true;\n        }\n    }\n    is_all_uppercase\
    \ && is_all_lowercase\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_uppercase` in this scope\n  -->\
    \ /tmp/tmpw3xvyft2.rs:24:12\n   |\n24 |         if is_uppercase(key) {\n   | \
    \           ^^^^^^^^^^^^ help: a local variable with a similar name exists: `is_all_uppercase`\n\
    \nerror[E0425]: cannot find function `is_lowercase` in this scope\n  --> /tmp/tmpw3xvyft2.rs:27:12\n\
    \   |\n27 |         if is_lowercase(key) {\n   |            ^^^^^^^^^^^^ help:\
    \ a local variable with a similar name exists: `is_all_lowercase`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.len() == 0 || dict.iter().all(|&(_,\
    \ value)| {\n        value.len() == 0 || std::collections::string::to_lowercase(value).unwrap()\
    \ == value\n    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n \
    \   assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: could not find `string` in `collections`\n\
    \  --> /tmp/tmpxs5lclhk.rs:19:47\n   |\n19 |         value.len() == 0 || std::collections::string::to_lowercase(value).unwrap()\
    \ == value\n   |                                               ^^^^^^ could not\
    \ find `string` in `collections`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxs5lclhk.rs:18:41\n\
    \   |\n18 |     dict.len() == 0 || dict.iter().all(|&(_, value)| {\n   |     \
    \                                    ^^^^^^^^^^-\n   |                       \
    \                  |         |\n   |                                         |\
    \         expected due to this\n   |                                         expected\
    \ tuple, found reference\n   |\n   = note:  expected tuple `(&String, &String)`\n\
    \           found reference `&_`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.len() == 0 {\n        return\
    \ false;\n    }\n    let mut is_string = true;\n    for (key, _) in dict.iter()\
    \ {\n        if !key\n            .as_str()\n            .to_lowercase()\n   \
    \         .chars()\n            .all(|c| c == Some(' ') || c == Some('A') || c\
    \ == Some('Z'))\n        {\n            is_string = false;\n        }\n    }\n\
    \    is_string\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfhxqj68o.rs:27:27\n   |\n\
    27 |             .all(|c| c == Some(' ') || c == Some('A') || c == Some('Z'))\n\
    \   |                           ^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpfhxqj68o.rs:27:45\n   |\n27 |\
    \             .all(|c| c == Some(' ') || c == Some('A') || c == Some('Z'))\n \
    \  |                                             ^^^^^^^^^ expected `char`, found\
    \ enum `Option`\n   |\n   = note: expected type `char`\n              found enum\
    \ `Option<char>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfhxqj68o.rs:27:63\n\
    \   |\n27 |             .all(|c| c == Some(' ') || c == Some('A') || c == Some('Z'))\n\
    \   |                                                               ^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<char>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.into_iter().all(|(key, value)|\
    \ {\n        match key.to_lowercase().as_str() {\n            Some(\"name\") =>\
    \ value.to_lowercase().as_str() == \"john\",\n            Some(\"age\") => value.to_lowercase().as_str()\
    \ == \"36\",\n            Some(\"city\") => value.to_lowercase().as_str() == \"\
    houston\",\n            Some(\"state\") => value.to_lowercase().as_str() == \"\
    nc\",\n            Some(\"zip\") => value.to_lowercase().as_str() == \"12345\"\
    ,\n            None => false,\n        }\n    })\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvak_48sz.rs:20:13\n   |\n\
    19 |         match key.to_lowercase().as_str() {\n   |               ---------------------------\
    \ this expression has type `&str`\n20 |             Some(\"name\") => value.to_lowercase().as_str()\
    \ == \"john\",\n   |             ^^^^^^^^^^^^ expected `str`, found enum `Option`\n\
    \   |\n   = note: expected type `str`\n              found enum `Option<_>`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpvak_48sz.rs:21:13\n   |\n19 |  \
    \       match key.to_lowercase().as_str() {\n   |               ---------------------------\
    \ this expression has type `&str`\n20 |             Some(\"name\") => value.to_lowercase().as_str()\
    \ == \"john\",\n21 |             Some(\"age\") => value.to_lowercase().as_str()\
    \ == \"36\",\n   |             ^^^^^^^^^^^ expected `str`, found enum `Option`\n\
    \   |\n   = note: expected type `str`\n              found enum `Option<_>`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpvak_48sz.rs:22:13\n   |\n19 |  \
    \       match key.to_lowercase().as_str() {\n   |               ---------------------------\
    \ this expression has type `&str`\n...\n22 |             Some(\"city\") => value.to_lowercase().as_str()\
    \ == \"houston\",\n   |             ^^^^^^^^^^^^ expected `str`, found enum `Option`\n\
    \   |\n   = note: expected type `str`\n              found enum `Option<_>`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpvak_48sz.rs:23:13\n   |\n19 |  \
    \       match key.to_lowercase().as_str() {\n   |               ---------------------------\
    \ this expression has type `&str`\n...\n23 |             Some(\"state\") => value.to_lowercase().as_str()\
    \ == \"nc\",\n   |             ^^^^^^^^^^^^^ expected `str`, found enum `Option`\n\
    \   |\n   = note: expected type `str`\n              found enum `Option<_>`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpvak_48sz.rs:24:13\n   |\n19 |  \
    \       match key.to_lowercase().as_str() {\n   |               ---------------------------\
    \ this expression has type `&str`\n...\n24 |             Some(\"zip\") => value.to_lowercase().as_str()\
    \ == \"12345\",\n   |             ^^^^^^^^^^^ expected `str`, found en"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.keys().all(|&key| {\n        if\
    \ key.len() == 0 {\n            return false;\n        }\n        if key.to_lowercase()\
    \ == key {\n            return true;\n        }\n        if key.to_uppercase()\
    \ == key {\n            return true;\n        }\n        false\n    })\n}\n\n\
    fn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0507]: cannot move out of a shared reference\n  --> /tmp/tmpa4a0_geu.rs:18:22\n\
    \   |\n18 |     dict.keys().all(|&key| {\n   |                      ^---\n   |\
    \                      ||\n   |                      |data moved here\n   |  \
    \                    |move occurs because `key` has type `String`, which does\
    \ not implement the `Copy` trait\n   |                      help: consider removing\
    \ the `&`: `key`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0507`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.len() == 0 {\n        return\
    \ false;\n    }\n    true\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpqhjicd0v.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.len() == 0 {\n        return\
    \ false;\n    }\n\n    for (key, val) in dict {\n        match key.to_lowercase()\
    \ {\n            true => {\n                if !val.to_lowercase().is_empty()\
    \ {\n                    return false;\n                }\n            }\n   \
    \         false => {\n                if !val.to_uppercase().is_empty() {\n  \
    \                  return false;\n                }\n            }\n        };\n\
    \    }\n\n    true\n}\n\nfn main() {\n    let candidate = check_dict_case;\n \
    \   assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6bgu7mm4.rs:24:13\n   |\n\
    23 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n24 |             true => {\n   |        \
    \     ^^^^ expected struct `String`, found `bool`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp6bgu7mm4.rs:29:13\n   |\n23 |         match key.to_lowercase()\
    \ {\n   |               ------------------ this expression has type `String`\n\
    ...\n29 |             false => {\n   |             ^^^^^ expected struct `String`,\
    \ found `bool`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if let Some(dict) = dict {\n       \
    \ let mut it = dict.iter();\n        loop {\n            let (mut key, mut value)\
    \ = it.next();\n            \n            if key == String::from(\"a\") {\n  \
    \              key = String::from(\"A\");\n            } else if key == String::from(\"\
    A\") {\n                key = String::from(\"a\");\n            }\n\n        \
    \    if value == String::from(\"apple\") {\n                value = String::from(\"\
    apple\");\n            } else if value == String::from(\"banana\") {\n       \
    \         value = String::from(\"banana\");\n            }\n\n            it.next();\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpa822lcsk.rs:18:12\n   |\n\
    18 |     if let Some(dict) = dict {\n   |            ^^^^^^^^^^   ---- this expression\
    \ has type `HashMap<String, String>`\n   |            |\n   |            expected\
    \ struct `HashMap`, found enum `Option`\n   |\n   = note: expected struct `HashMap<String,\
    \ String>`\n                found enum `Option<_>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    !dict.is_empty() && dict.keys().all(|k|\
    \ k.is_uppercase())\n        && dict.keys().all(|k| k.is_lowercase())\n}\n\nfn\
    \ main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_uppercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpn384m03l.rs:18:47\n   |\n18 |     !dict.is_empty()\
    \ && dict.keys().all(|k| k.is_uppercase())\n   |                             \
    \                  ^^^^^^^^^^^^ help: there is an associated function with a similar\
    \ name: `to_uppercase`\n\nerror[E0599]: no method named `is_lowercase` found for\
    \ reference `&String` in the current scope\n  --> /tmp/tmpn384m03l.rs:19:34\n\
    \   |\n19 |         && dict.keys().all(|k| k.is_lowercase())\n   |           \
    \                       ^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `to_lowercase`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    // If dict is empty, return true.\n\
    \    if dict.len() == 0 {\n        return true;\n    }\n    \n    // Check that\
    \ all the keys are strings in lower case or uppercase.\n    for key in dict.keys()\
    \ {\n        let s = String::from(key.to_string());\n        \n        // If s\
    \ contains only uppercase characters, return false. \n        if s.chars().all(|c|\
    \ !c.is_uppercase()) {\n            return false;\n        }\n        // If s\
    \ contains only lowercase characters, return false. \n        if s.chars().all(|c|\
    \ !c.is_lowercase()) {\n            return false;\n        }\n    }\n    \n  \
    \  // If dict contains both lowercase and uppercase strings, return true.\n  \
    \  if dict.contains_key(String::from(\"name\")) && dict.contains_key(String::from(\"\
    NAME\")) {\n        return true;\n    }\n    \n    // If dict contains only lowercase\
    \ strings, return true. \n    if dict.contains_key(String::from(\"name\")) &&\
    \ dict.contains_key(String::from(\"name\")) {\n        return true;\n    }\n \
    \   \n    // If dict contains only uppercase strings, return true.\n    if dict.contains_key(String::from(\"\
    name\")) && dict.contains_key(String::from(\"NAME\")) {\n        return true;\n\
    \    }\n    \n    // If dict contains both lowercase and uppercase strings, return\
    \ true.\n    if dict.contains_key(String::from(\"Age\")) && dict.contains_key(String::from(\"\
    age\")) {\n        return true;\n    }\n    \n    // If dict contains only lowercase\
    \ strings, return true.\n    if dict.contains_key(String::from(\"Age\")) && dict.contains_key(String::from(\"\
    age\")) {\n        return true;\n    }\n    \n    // If dict contains only uppercase\
    \ strings, return true.\n    if dict.contains_key(String::from(\"Age\")) && dict.contains_key(String::from(\"\
    AGE\")) {\n        return true;\n    }\n    \n    // If dict contains both lowercase\
    \ and uppercase strings, return true.\n    if dict.contains_key(String::from(\"\
    state\")) && dict.contains_key(String::from(\"state\")) {\n        return true;\n\
    \    }\n    \n    // If dict contains only lowercase strings, return true.\n \
    \   if dict.contains_key(String::from(\"state\")) && dict.contains_key(String::from(\"\
    state\")) {\n        return true;\n    }\n    \n    // If dict contains only uppercase\
    \ strings, return true.\n    if dict.contains_key(String::from(\"state\")) &&\
    \ dict.contains_key(String::from(\"STATE\")) {\n        return true;\n    }\n\
    \    \n    // If dict contains both lowercase and uppercase strings, return true.\n\
    \    if dict.contains_key(String::from(\"zip\")) && dict.contains_key(String::from(\"\
    zip\")) {\n        return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp5bxfulzn.rs:96:3\n\
    \   |\n17 | fn check_dict_case(dict: HashMap<String, String>) -> bool {\n   |\
    \                                                           - unclosed delimiter\n\
    ...\n83 |     if dict.contains_key(String::from(\"zip\")) && dict.contains_key(String::from(\"\
    zip\")) {\n   |                                                              \
    \                           - this delimiter might not be properly closed...\n\
    84 |         return true;\n85 | }\n   | - ...as it matches this but it has different\
    \ indentation\n...\n96 | }\n   |   ^\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp5bxfulzn.rs:38:26\n   |\n38 |     if dict.contains_key(String::from(\"\
    name\")) && dict.contains_key(String::from(\"NAME\")) {\n   |                \
    \          ^^^^^^^^^^^^^^^^^^^^\n   |                          |\n   |       \
    \                   expected reference, found struct `String`\n   |          \
    \                help: consider borrowing here: `&String::from(\"name\")`\n  \
    \ |\n   = note: expected reference `&_`\n                 found struct `String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp5bxfulzn.rs:38:69\n   |\n38 |\
    \     if dict.contains_key(String::from(\"name\")) && dict.contains_key(String::from(\"\
    NAME\")) {\n   |                                                             \
    \        ^^^^^^^^^^^^^^^^^^^^\n   |                                          \
    \                           |\n   |                                          \
    \                           expected reference, found struct `String`\n   |  \
    \                                                                   help: consider\
    \ borrowing here: `&String::from(\"NAME\")`\n   |\n   = note: expected reference\
    \ `&_`\n                 found struct `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp5bxfulzn.rs:43:26\n   |\n43 |     if dict.contains_key(String::from(\"\
    name\")) && dict.contains_key(String::from(\"name\")) {\n   |                \
    \          ^^^^^^^^^^^^^^^^^^^^\n   |                          |\n   |       \
    \                   expected reference, found struct `Stri"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    match dict.len() {\n        0 => false,\
    \ // empty map\n        _ => let mut keys = dict.keys().cloned().collect::<Vec<_>>();\n\
    \        keys.sort();\n        !keys.iter().all(|k| k.is_upper() && k.len() ==\
    \ k.to_ascii_lowercase().len()),\n    }\n}\n\nfn main() {\n    let candidate =\
    \ check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"\
    ), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `,`, `.`, `?`, `}`, or an operator, found `;`\n\
    \  --> /tmp/tmpkq2jxkxz.rs:20:69\n   |\n20 |         _ => let mut keys = dict.keys().cloned().collect::<Vec<_>>();\n\
    \   |           -- while parsing the `match` arm starting here            ^ expected\
    \ one of `,`, `.`, `?`, `}`, or an operator\n\nerror[E0658]: `let` expressions\
    \ in this position are unstable\n  --> /tmp/tmpkq2jxkxz.rs:20:14\n   |\n20 | \
    \        _ => let mut keys = dict.keys().cloned().collect::<Vec<_>>();\n   | \
    \             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n\
    \   = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667>\
    \ for more information\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0658`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n    dict.keys().all(|key| key.to_lowercase().is_ok())\n     \
    \   || dict.keys().all(|key| key.to_uppercase().is_ok())\n}\n\nfn main() {\n \
    \   let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ok` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpcatq8iu2.rs:21:46\n   |\n21 |     dict.keys().all(|key|\
    \ key.to_lowercase().is_ok())\n   |                                          \
    \    ^^^^^ method not found in `String`\n\nerror[E0599]: no method named `is_ok`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpcatq8iu2.rs:22:53\n\
    \   |\n22 |         || dict.keys().all(|key| key.to_uppercase().is_ok())\n   |\
    \                                                     ^^^^^ method not found in\
    \ `String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    // Your code goes here\n    let mut\
    \ temp_dict: HashMap<String, String> = HashMap::new();\n    for key in dict.get_keys().cloned().collect::<Vec<String>>()\
    \ {\n        if let Some(val) = dict.get(key) {\n            match (val.to_lowercase(),\
    \ val.to_uppercase()) {\n                (Some(l), Some(u)) if l == u => temp_dict.remove(key);\n\
    \                _ => temp_dict,\n            }\n        }\n    }\n    temp_dict.len()\
    \ == dict.get_len()\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error: `match` arm body without braces\n  --> /tmp/tmpof6vfek8.rs:23:49\n\
    \   |\n23 |                 (Some(l), Some(u)) if l == u => temp_dict.remove(key);\n\
    \   |                                              -- ^^^^^^^^^^^^^^^^^^^^^- help:\
    \ use a comma to end a `match` arm expression: `,`\n   |                     \
    \                         |  |\n   |                                         \
    \     |  this statement is not surrounded by a body\n   |                    \
    \                          while parsing the `match` arm starting here\n\nerror[E0599]:\
    \ no method named `get_keys` found for struct `HashMap` in the current scope\n\
    \  --> /tmp/tmpof6vfek8.rs:20:21\n   |\n20 |     for key in dict.get_keys().cloned().collect::<Vec<String>>()\
    \ {\n   |                     ^^^^^^^^ help: there is an associated function with\
    \ a similar name: `keys`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpof6vfek8.rs:23:18\n\
    \   |\n22 |             match (val.to_lowercase(), val.to_uppercase()) {\n   |\
    \                   ---------------------------------------- this expression has\
    \ type `(String, String)`\n23 |                 (Some(l), Some(u)) if l == u =>\
    \ temp_dict.remove(key);\n   |                  ^^^^^^^ expected struct `String`,\
    \ found enum `Option`\n   |\n   = note: expected struct `String`\n           \
    \     found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpof6vfek8.rs:23:27\n\
    \   |\n22 |             match (val.to_lowercase(), val.to_uppercase()) {\n   |\
    \                   ---------------------------------------- this expression has\
    \ type `(String, String)`\n23 |                 (Some(l), Some(u)) if l == u =>\
    \ temp_dict.remove(key);\n   |                           ^^^^^^^ expected struct\
    \ `String`, found enum `Option`\n   |\n   = note: expected struct `String`\n \
    \               found enum `Option<_>`\n\nerror[E0599]: no method named `get_len`\
    \ found for struct `HashMap` in the current scope\n  --> /tmp/tmpof6vfek8.rs:28:29\n\
    \   |\n28 |     temp_dict.len() == dict.get_len()\n   |                      \
    \       ^^^^^^^ method not found in `HashMap<String, String>`\n\nerror"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n    for (key, value) in dict.iter() {\n        if key.islower()\
    \ || key.isupper() {\n            return false;\n        }\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `islower` found for reference `&String` in\
    \ the current scope\n  --> /tmp/tmpboogpuhd.rs:22:16\n   |\n22 |         if key.islower()\
    \ || key.isupper() {\n   |                ^^^^^^^ method not found in `&String`\n\
    \nerror[E0599]: no method named `isupper` found for reference `&String` in the\
    \ current scope\n  --> /tmp/tmpboogpuhd.rs:22:33\n   |\n22 |         if key.islower()\
    \ || key.isupper() {\n   |                                 ^^^^^^^ method not\
    \ found in `&String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.is_empty() || dict\n        .iter()\n\
    \        .all(|(key_in, value_in)| key_in == String::from(value_in.to_lowercase())\
    \ || key_in == String::from(value_in.to_uppercase()))\n}\n\nfn main() {\n    let\
    \ candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&String` with `String`\n  --> /tmp/tmphjngbvq5.rs:20:42\n\
    \   |\n20 |         .all(|(key_in, value_in)| key_in == String::from(value_in.to_lowercase())\
    \ || key_in == String::from(value_in.to_uppercase()))\n   |                  \
    \                        ^^ no implementation for `&String == String`\n   |\n\
    \   = help: the trait `PartialEq<String>` is not implemented for `&String`\n \
    \  = help: the following other types implement trait `PartialEq<Rhs>`:\n     \
    \        <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `&String` with `String`\n  --> /tmp/tmphjngbvq5.rs:20:93\n   |\n20 |       \
    \  .all(|(key_in, value_in)| key_in == String::from(value_in.to_lowercase()) ||\
    \ key_in == String::from(value_in.to_uppercase()))\n   |                     \
    \                                                                        ^^ no\
    \ implementation for `&String == String`\n   |\n   = help: the trait `PartialEq<String>`\
    \ is not implemented for `&String`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut keys = dict.values().clone().unwrap();\n\
    \    \n    // If the dictionary is empty, return true\n    if keys.is_empty()\
    \ {\n        return true;\n    }\n\n    // Remove all non-strings\n    for key\
    \ in keys {\n        if !key.is_string() {\n            keys.remove(key);\n  \
    \      }\n    }\n    \n    // If the dictionary now has no strings return true\n\
    \    if keys.is_empty() {\n        return true;\n    }\n\n    // If any key is\
    \ a lowercase string, then all keys must be in lower case\n    for key in keys\
    \ {\n        if !key.is_lowercase() {\n            return false;\n        }\n\
    \    }\n    \n    // If any key is an uppercase string, then all keys must be\
    \ in upper case\n    for key in keys {\n        if !key.is_uppercase() {\n   \
    \         return false;\n        }\n    }\n\n    // If all keys are in lower case,\
    \ all keys must be in upper case\n    for key in keys {\n        if key.is_lowercase()\
    \ {\n            return false;\n        }\n    }\n\n    // If all keys are in\
    \ upper case, all keys must be in lower case\n    for key in keys {\n        if\
    \ key.is_uppercase() {\n            return false;\n        }\n    }\n\n    //\
    \ If we get to here, all keys must be in either lower or upper case\n    return\
    \ true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap` found for struct `std::collections::hash_map::Values`\
    \ in the current scope\n  --> /tmp/tmp0sev7p1b.rs:18:42\n   |\n18 |     let mut\
    \ keys = dict.values().clone().unwrap();\n   |                               \
    \           ^^^^^^ method not found in `std::collections::hash_map::Values<'_,\
    \ String, String>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n    let mut values = dict.values();\n    let mut first = true;\n\
    \    let mut done = false;\n    while !done && values.next().is_some() {\n   \
    \     if first {\n            first = false;\n        } else {\n            match\
    \ &*values.next().unwrap().as_ref() {\n                String::from(\"a\") =>\
    \ return false,\n                String::from(\"b\") => return false,\n      \
    \          String::from(\"A\") => return false,\n                String::from(\"\
    B\") => return false,\n                _ => {\n                    done = true;\n\
    \                }\n            }\n        }\n    }\n    return true;\n}\n\nfn\
    \ main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0164]: expected tuple struct or tuple variant, found associated\
    \ function `String::from`\n  --> /tmp/tmpe1e6lbr8.rs:29:17\n   |\n29 |       \
    \          String::from(\"a\") => return false,\n   |                 ^^^^^^^^^^^^^^^^^\
    \ `fn` calls are not allowed in patterns\n   |\n   = help: for more information,\
    \ visit https://doc.rust-lang.org/book/ch18-00-patterns.html\n\nerror[E0164]:\
    \ expected tuple struct or tuple variant, found associated function `String::from`\n\
    \  --> /tmp/tmpe1e6lbr8.rs:30:17\n   |\n30 |                 String::from(\"b\"\
    ) => return false,\n   |                 ^^^^^^^^^^^^^^^^^ `fn` calls are not\
    \ allowed in patterns\n   |\n   = help: for more information, visit https://doc.rust-lang.org/book/ch18-00-patterns.html\n\
    \nerror[E0164]: expected tuple struct or tuple variant, found associated function\
    \ `String::from`\n  --> /tmp/tmpe1e6lbr8.rs:31:17\n   |\n31 |                \
    \ String::from(\"A\") => return false,\n   |                 ^^^^^^^^^^^^^^^^^\
    \ `fn` calls are not allowed in patterns\n   |\n   = help: for more information,\
    \ visit https://doc.rust-lang.org/book/ch18-00-patterns.html\n\nerror[E0164]:\
    \ expected tuple struct or tuple variant, found associated function `String::from`\n\
    \  --> /tmp/tmpe1e6lbr8.rs:32:17\n   |\n32 |                 String::from(\"B\"\
    ) => return false,\n   |                 ^^^^^^^^^^^^^^^^^ `fn` calls are not\
    \ allowed in patterns\n   |\n   = help: for more information, visit https://doc.rust-lang.org/book/ch18-00-patterns.html\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0164`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n\n    let mut iter = dict.iter().filter(|(_, v)| v.is_string()).cloned();\n\
    \    let mut lowers = iter.collect::<Vec<_>>();\n    let mut uppers = iter.collect::<Vec<_>>();\n\
    \    while iter.any() {\n        match iter.next() {\n            Some((k, u))\
    \ => {\n                lowers.push(k);\n                uppers.push(u);\n   \
    \         }\n            None => break,\n        }\n    }\n\n    // Check if all\
    \ strings are either in lower or upper case\n    // If they are, then the whole\
    \ dictionary is either in lower or upper case\n    lowers.iter().all(|&s| s.is_ascii_lowercase())\
    \ || uppers.iter().all(|&s| s.is_ascii_uppercase())\n}\n\nfn main() {\n    let\
    \ candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_string` found for reference `&&String`\
    \ in the current scope\n  --> /tmp/tmp6rb_cwo5.rs:22:50\n   |\n22 |     let mut\
    \ iter = dict.iter().filter(|(_, v)| v.is_string()).cloned();\n   |          \
    \                                        ^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `as_str`\n\nerror[E0271]: type mismatch resolving\
    \ `<Filter<std::collections::hash_map::Iter<'_, String, String>, [closure@/tmp/tmp6rb_cwo5.rs:22:39:\
    \ 22:61]> as Iterator>::Item == &_`\n    --> /tmp/tmp6rb_cwo5.rs:22:63\n     |\n\
    22   |     let mut iter = dict.iter().filter(|(_, v)| v.is_string()).cloned();\n\
    \     |                                                               ^^^^^^ expected\
    \ reference, found tuple\n     |\n     = note: expected reference `&_`\n     \
    \               found tuple `(&String, &String)`\nnote: required by a bound in\
    \ `cloned`\n\nerror[E0599]: the method `collect` exists for struct `Cloned<Filter<std::collections::hash_map::Iter<'_,\
    \ String, String>, [closure@/tmp/tmp6rb_cwo5.rs:22:39: 22:61]>>`, but its trait\
    \ bounds were not satisfied\n  --> /tmp/tmp6rb_cwo5.rs:23:27\n   |\n23 |     \
    \   let mut lowers = iter.collect::<Vec<_>>();\n   |                         \
    \     ^^^^^^^ method cannot be called on `Cloned<Filter<std::collections::hash_map::Iter<'_,\
    \ String, String>, [closure@/tmp/tmp6rb_cwo5.rs:22:39: 22:61]>>` due to unsatisfied\
    \ trait bounds\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `<Filter<std::collections::hash_map::Iter<'_, String, String>, [closure@/tmp/tmp6rb_cwo5.rs:22:39:\
    \ 22:61]> as Iterator>::Item = &_`\n           which is required by `Cloned<Filter<std::collections::hash_map::Iter<'_,\
    \ String, String>, [closure@/tmp/tmp6rb_cwo5.rs:22:39: 22:61]>>: Iterator`\n \
    \          `Cloned<Filter<std::collections::hash_map::Iter<'_, String, String>,\
    \ [closure@/tmp/tmp6rb_cwo5.rs:22:39: 22:61]>>: Iterator`\n           which is\
    \ required by `&mut Cloned<Filter<std::collections::hash_map::Iter<'_, String,\
    \ String>, [closure@/tmp/tmp6rb_cwo5.rs:22:39: 22:61]>>: Iter"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.len() == 0 {\n        return\
    \ false;\n    }\n\n    for k in dict.keys().cloned() {\n        if k.is_uppercase()\
    \ {\n            return false;\n        }\n    }\n\n    for k in dict.keys().cloned()\
    \ {\n        if !k.is_lowercase() {\n            return false;\n        }\n  \
    \  }\n\n    for k in dict.keys().cloned() {\n        if !k.is_uppercase() {\n\
    \            return false;\n        }\n    }\n\n    return true;\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_uppercase` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpkblvfqny.rs:23:14\n   |\n23 |         if\
    \ k.is_uppercase() {\n   |              ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named\
    \ `is_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmpkblvfqny.rs:29:15\n\
    \   |\n29 |         if !k.is_lowercase() {\n   |               ^^^^^^^^^^^^ help:\
    \ there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]:\
    \ no method named `is_uppercase` found for struct `String` in the current scope\n\
    \  --> /tmp/tmpkblvfqny.rs:35:15\n   |\n35 |         if !k.is_uppercase() {\n\
    \   |               ^^^^^^^^^^^^ help: there is an associated function with a\
    \ similar name: `to_uppercase`\n\nerror: aborting due to 3 previous errors\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.len() > 0\n        && dict.iter().all(|(_,\
    \ val)| {\n            let str = val.to_lowercase();\n            str.is_lowercase()\n\
    \        })\n        && dict.iter().all(|(_, val)| {\n            let str = val.to_uppercase();\n\
    \            str.is_uppercase()\n        })\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lowercase` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpvfv6hyte.rs:21:17\n   |\n21 |          \
    \   str.is_lowercase()\n   |                 ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named\
    \ `is_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmpvfv6hyte.rs:25:17\n\
    \   |\n25 |             str.is_uppercase()\n   |                 ^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_uppercase`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let len = dict.len();\n    if len ==\
    \ 0 {\n        return false;\n    }\n    for i in 0..len {\n        if dict.value(i).len()\
    \ > 2 {\n            return false;\n        }\n        if dict.value(i).len()\
    \ < 2 {\n            return false;\n        }\n        if dict.value(i).to_lowercase().is_empty()\
    \ {\n            return false;\n        }\n        if dict.value(i).to_uppercase().is_empty()\
    \ {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `value` found for struct `HashMap` in the\
    \ current scope\n  --> /tmp/tmppb4pq0to.rs:23:17\n   |\n23 |         if dict.value(i).len()\
    \ > 2 {\n   |                 ^^^^^ help: there is an associated function with\
    \ a similar name: `values`\n\nerror[E0599]: no method named `value` found for\
    \ struct `HashMap` in the current scope\n  --> /tmp/tmppb4pq0to.rs:26:17\n   |\n\
    26 |         if dict.value(i).len() < 2 {\n   |                 ^^^^^ help: there\
    \ is an associated function with a similar name: `values`\n\nerror[E0599]: no\
    \ method named `value` found for struct `HashMap` in the current scope\n  -->\
    \ /tmp/tmppb4pq0to.rs:29:17\n   |\n29 |         if dict.value(i).to_lowercase().is_empty()\
    \ {\n   |                 ^^^^^ help: there is an associated function with a similar\
    \ name: `values`\n\nerror[E0599]: no method named `value` found for struct `HashMap`\
    \ in the current scope\n  --> /tmp/tmppb4pq0to.rs:32:17\n   |\n32 |         if\
    \ dict.value(i).to_uppercase().is_empty() {\n   |                 ^^^^^ help:\
    \ there is an associated function with a similar name: `values`\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    use std::collections::HashSet;\n\n \
    \   let mut dict = dict;\n    let mut found = false;\n    while !found {\n   \
    \     found = true;\n        for (key, value) in dict.iter() {\n            if\
    \ let String::from(_) = key.to_lowercase() {\n                dict.entry(key.to_lowercase()).and_modify(|e|\
    \ {\n                    *e = value;\n                });\n                found\
    \ = false;\n            }\n            if let String::from(_) = key.to_uppercase()\
    \ {\n                dict.entry(key.to_uppercase()).and_modify(|e| {\n       \
    \             *e = value;\n                });\n                found = false;\n\
    \            }\n        }\n    }\n\n    dict.is_empty()\n}\n\nfn main() {\n  \
    \  let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "warning: unused import: `std::collections::HashSet`\n  --> /tmp/tmp6zlm_wjo.rs:18:9\n\
    \   |\n18 |     use std::collections::HashSet;\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |\n   = note: `#[warn(unused_imports)]` on by default\n\nerror[E0164]: expected\
    \ tuple struct or tuple variant, found associated function `String::from`\n  -->\
    \ /tmp/tmp6zlm_wjo.rs:25:20\n   |\n25 |             if let String::from(_) = key.to_lowercase()\
    \ {\n   |                    ^^^^^^^^^^^^^^^ `fn` calls are not allowed in patterns\n\
    \   |\n   = help: for more information, visit https://doc.rust-lang.org/book/ch18-00-patterns.html\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp6zlm_wjo.rs:27:26\n   |\n27 |\
    \                     *e = value;\n   |                     --   ^^^^^- help:\
    \ try using a conversion method: `.to_string()`\n   |                     |  \
    \  |\n   |                     |    expected struct `String`, found `&String`\n\
    \   |                     expected due to the type of this binding\n\nerror[E0164]:\
    \ expected tuple struct or tuple variant, found associated function `String::from`\n\
    \  --> /tmp/tmp6zlm_wjo.rs:31:20\n   |\n31 |             if let String::from(_)\
    \ = key.to_uppercase() {\n   |                    ^^^^^^^^^^^^^^^ `fn` calls are\
    \ not allowed in patterns\n   |\n   = help: for more information, visit https://doc.rust-lang.org/book/ch18-00-patterns.html\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp6zlm_wjo.rs:33:26\n   |\n33 |\
    \                     *e = value;\n   |                     --   ^^^^^- help:\
    \ try using a conversion method: `.to_string()`\n   |                     |  \
    \  |\n   |                     |    expected struct `String`, found `&String`\n\
    \   |                     expected due to the type of this binding\n\nerror: aborting\
    \ due to 4 previous errors; 1 warning emitted\n\nSome errors have detailed explanations:\
    \ E0164, E0308.\nFor more information about an error, try `rustc --explain E0164`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    match dict.len() {\n        0 => true,\n\
    \        n => {\n            let mut keys_iter = dict.iter().keys();\n       \
    \     let mut values_iter = dict.iter().values();\n            let mut key_next:\
    \ bool = false;\n            let mut value_next: bool = false;\n            for\
    \ k in keys_iter {\n                match k.as_ref() {\n                    None\
    \ => return false,\n                    Some(String::from(x)) if !x.is_ascii()\
    \ || x.is_lowercase() || x.is_uppercase() => key_next = true;\n              \
    \      Some(String::from(x)) if !x.is_ascii() || x.is_uppercase() || x.is_lowercase()\
    \ => value_next = true;\n                }\n            }\n            key_next\
    \ && value_next\n        }\n    }\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found keyword `if`\n  --> /tmp/tmpliks35e9.rs:29:43\n\
    \   |\n29 |                     Some(String::from(x)) if !x.is_ascii() || x.is_uppercase()\
    \ || x.is_lowercase() => value_next = true;\n   |                            \
    \               ^^ expected identifier, found keyword\n\nerror: expected one of\
    \ `,`, `.`, `?`, `}`, or an operator, found `;`\n  --> /tmp/tmpliks35e9.rs:28:118\n\
    \   |\n28 |                     Some(String::from(x)) if !x.is_ascii() || x.is_lowercase()\
    \ || x.is_uppercase() => key_next = true;\n   |                              \
    \                                                                      --    \
    \            ^ expected one of `,`, `.`, `?`, `}`, or an operator\n   |      \
    \                                                                            \
    \                  |\n   |                                                   \
    \                                                 while parsing the `match` arm\
    \ starting here\n\nerror[E0599]: no method named `keys` found for struct `std::collections::hash_map::Iter`\
    \ in the current scope\n  --> /tmp/tmpliks35e9.rs:21:45\n   |\n21 |          \
    \   let mut keys_iter = dict.iter().keys();\n   |                            \
    \                 ^^^^ method not found in `std::collections::hash_map::Iter<'_,\
    \ String, String>`\n\nerror[E0599]: no method named `values` found for struct\
    \ `std::collections::hash_map::Iter` in the current scope\n  --> /tmp/tmpliks35e9.rs:22:47\n\
    \   |\n22 |             let mut values_iter = dict.iter().values();\n   |    \
    \                                           ^^^^^^ method not found in `std::collections::hash_map::Iter<'_,\
    \ String, String>`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut map = dict;\n    map.insert(String::from(\"\
    state\"), String::from(\"NC\"));\n    map.insert(String::from(\"zip\"), String::from(\"\
    12345\"));\n    map.insert(String::from(\"City\"), String::from(\"Houston\"));\n\
    \    for (_, key) in map.iter() {\n        if key.is_lower(), !key.is_upper()\
    \ {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `,`\n  --> /tmp/tmp_n3n_cwa.rs:23:26\n   |\n\
    23 |         if key.is_lower(), !key.is_upper() {\n   |         --           \
    \    ^ expected `{`\n   |         |\n   |         this `if` expression has a condition,\
    \ but no block\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut checker = String::new();\n \
    \   checker.push_str(\"All keys should be in lower case\");\n    for k in dict.keys()\
    \ {\n        let mut key = k.to_string();\n        if key.chars().filter(|x| x\
    \ == ' ').count() > 0 ||\n            key.chars().filter(|x| x == ' ').count()\
    \ == key.chars().count() {\n            checker.push_str(\",\");\n           \
    \ checker.push_str(key);\n            checker.push_str(\",\");\n        } else\
    \ {\n            checker.push_str(key);\n        }\n    }\n    checker.push_str(\"\
    ,\");\n    checker.push_str(dict.values().join());\n    checker.push_str(\",\"\
    );\n    !checker.is_empty()\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpcsgpsosr.rs:22:37\n\
    \   |\n22 |         if key.chars().filter(|x| x == ' ').count() > 0 ||\n   | \
    \                                    ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpcsgpsosr.rs:23:38\n   |\n23 |   \
    \          key.chars().filter(|x| x == ' ').count() == key.chars().count() {\n\
    \   |                                      ^^ no implementation for `&char ==\
    \ char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpcsgpsosr.rs:25:30\n   |\n25 |             checker.push_str(key);\n\
    \   |                              ^^^\n   |                              |\n\
    \   |                              expected `&str`, found struct `String`\n  \
    \ |                              help: consider borrowing here: `&key`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpcsgpsosr.rs:28:30\n   |\n28 |             checker.push_str(key);\n\
    \   |                              ^^^\n   |                              |\n\
    \   |                              expected `&str`, found struct `String`\n  \
    \ |                              help: consider borrowing here: `&key`\n\nerror[E0599]:\
    \ no method named `join` found for struct `std::collections::hash_map::Values`\
    \ in the current scope\n  --> /tmp/tmpcsgpsosr.rs:32:36\n   |\n32 |     checker.push_str(dict.values().join());\n\
    \   |                                    ^^^^ method not found in `std::collections::hash_map::Values<'_,\
    \ String, String>`\n\nerror: aborting due to 5 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut res = true;\n    for (_, v)\
    \ in dict {\n        if v.to_lowercase() == v {\n            debug!(\"{}\", v);\n\
    \        } else {\n            res = false;\n        }\n    }\n    res\n}\n\n\
    fn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error: cannot find macro `debug` in this scope\n  --> /tmp/tmpzmanqtq3.rs:21:13\n\
    \   |\n21 |             debug!(\"{}\", v);\n   |             ^^^^^\n\nerror: aborting\
    \ due to previous error\n\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.len() == 0 {\n        return\
    \ false;\n    }\n    let mut keys_upper = dict.values();\n    for k in keys_upper\
    \ {\n        if k.len() == 1 && k.chars().next().unwrap().unwrap().is_uppercase()\
    \ {\n            continue;\n        }\n        return false;\n    }\n    \n  \
    \  let mut keys_lower = dict.values();\n    for k in keys_lower {\n        if\
    \ k.len() == 1 && k.chars().next().unwrap().unwrap().is_lowercase() {\n      \
    \      continue;\n        }\n        return false;\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpzz6ot9a2.rs:23:54\n   |\n23 |         if k.len() == 1 &&\
    \ k.chars().next().unwrap().unwrap().is_uppercase() {\n   |                  \
    \                                    ^^^^^^ method not found in `char`\n\nerror[E0599]:\
    \ no method named `unwrap` found for type `char` in the current scope\n  --> /tmp/tmpzz6ot9a2.rs:31:54\n\
    \   |\n31 |         if k.len() == 1 && k.chars().next().unwrap().unwrap().is_lowercase()\
    \ {\n   |                                                      ^^^^^^ method not\
    \ found in `char`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict\n        .iter()\n        .all(|(key,\
    \ _)| key\n            .as_ref()\n            .to_lowercase()\n            .as_ref()\n\
    \            == key.as_ref()\n                .to_lowercase()\n        )\n   \
    \     || dict\n            .iter()\n            .all(|(key, _)| key\n        \
    \        .as_ref()\n                .to_uppercase()\n                .as_ref()\n\
    \                == key.as_ref()\n                    .to_uppercase()\n      \
    \      )\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmp0c30xzj5.rs:21:14\n\
    \   |\n20 |           .all(|(key, _)| key\n   |  _________________________-\n\
    21 | |             .as_ref()\n   | |______________^^^^^^_- this method call resolves\
    \ to `&T`\n   |                |\n   |                cannot infer type for type\
    \ parameter `T` declared on the trait `AsRef`\n   |\n   = note: type must be known\
    \ at this point\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    match dict.len() {\n        0 => true,\n\
    \        _ => false,\n    }\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpw4er2qdu.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    // 1. check all keys are strings in\
    \ lower case\n    if let Ok(vec) = dict.keys() {\n        for s in vec.iter()\
    \ {\n            if s.is_lowercase() {\n                continue;\n          \
    \  }\n            return false;\n        }\n        return true;\n    }\n    //\
    \ 2. check all keys are strings in upper case\n    if let Ok(vec) = dict.keys()\
    \ {\n        for s in vec.iter() {\n            if s.is_uppercase() {\n      \
    \          continue;\n            }\n            return false;\n        }\n  \
    \      return true;\n    }\n    // 3. no keys\n    if dict.len() == 0 {\n    \
    \    return false;\n    }\n    // 4. no keys and values are strings\n    if let\
    \ Ok(vec) = dict.keys() {\n        for s in vec.iter() {\n            return false;\n\
    \        }\n    }\n    // 5. all values are strings\n    if let Ok(vec) = dict.keys()\
    \ {\n        for s in vec.iter() {\n            return true;\n        }\n    }\n\
    \    // 6. all values are strings and all keys are strings\n    if let Ok(vec)\
    \ = dict.keys() {\n        for s in vec.iter() {\n            return true;\n \
    \       }\n    }\n    // 7. all values are strings and no keys are strings\n \
    \   if let Ok(vec) = dict.keys() {\n        for s in vec.iter() {\n          \
    \  return false;\n        }\n    }\n    // 8. all values are strings and no keys\
    \ are strings\n    if let Ok(vec) = dict.keys() {\n        for s in vec.iter()\
    \ {\n            return true;\n        }\n    }\n    // 9. all values are strings\
    \ and all keys are strings\n    if let Ok(vec) = dict.keys() {\n        for s\
    \ in vec.iter() {\n            return true;\n        }\n    }\n    // 10. all\
    \ values are strings and all keys are strings\n    if let Ok(vec) = dict.keys()\
    \ {\n        for s in vec.iter() {\n            return true;\n        }\n    }\n\
    \    // 11. all values are strings and no keys are strings\n    if let Ok(vec)\
    \ = dict.keys() {\n        for s in vec.iter() {\n            return true;\n \
    \       }\n    }\n    // 12. all values are strings and no keys are strings\n\
    \    if let Ok(vec) = dict.keys() {\n        for s in vec.iter() {\n         \
    \   return true;\n        }\n    }\n    // 13. all values are strings and all\
    \ keys are strings\n    if let Ok(vec) = dict.keys() {\n        for s in vec.iter()\
    \ {\n            return true;\n        }\n    }\n    // 14. all values are strings\
    \ and all keys are strings\n    if let Ok(vec) = dict.keys() {\n        for s\
    \ in vec.iter() {\n            return true;\n        }\n    }\n    // 15. all\
    \ values are strings and no keys are strings\n    if let Ok(vec) = dict.keys()\
    \ {\n        for s in vec.iter() {\n\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpkow3kgn7.rs:123:3\n\
    \    |\n17  | fn check_dict_case(dict: HashMap<String, String>) -> bool {\n  \
    \  |                                                           - unclosed delimiter\n\
    ...\n109 |     if let Ok(vec) = dict.keys() {\n    |                         \
    \         - unclosed delimiter\n110 |         for s in vec.iter() {\n    |   \
    \                          - this delimiter might not be properly closed...\n\
    111 | \n112 | }\n    | - ...as it matches this but it has different indentation\n\
    ...\n123 | }\n    |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkow3kgn7.rs:19:12\n\
    \   |\n19 |     if let Ok(vec) = dict.keys() {\n   |            ^^^^^^^   -----------\
    \ this expression has type `std::collections::hash_map::Keys<'_, String, String>`\n\
    \   |            |\n   |            expected struct `std::collections::hash_map::Keys`,\
    \ found enum `Result`\n   |\n   = note: expected struct `std::collections::hash_map::Keys<'_,\
    \ String, String>`\n                found enum `Result<_, _>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpkow3kgn7.rs:29:12\n   |\n29 |     if let Ok(vec)\
    \ = dict.keys() {\n   |            ^^^^^^^   ----------- this expression has type\
    \ `std::collections::hash_map::Keys<'_, String, String>`\n   |            |\n\
    \   |            expected struct `std::collections::hash_map::Keys`, found enum\
    \ `Result`\n   |\n   = note: expected struct `std::collections::hash_map::Keys<'_,\
    \ String, String>`\n                found enum `Result<_, _>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpkow3kgn7.rs:43:12\n   |\n43 |     if let Ok(vec)\
    \ = dict.keys() {\n   |            ^^^^^^^   ----------- this expression has type\
    \ `std::collections::hash_map::Keys<'_, String, String>`\n   |            |\n\
    \   |            expected struct `std::collections::hash_map::Keys`, found enum\
    \ `Result`\n   |\n   = note: expected struct `std::collections::hash_map::Keys<'_,\
    \ String, String>`\n                found enum `Result<_, _>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpkow3kgn7.rs:49:12\n   |\n49 |     if let Ok(vec)\
    \ = dict."
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    match dict.values() {\n        None\
    \ => true,\n        Some(values) => values.is_ok() && values.all(|v| v.is_string()\
    \ && v.is_lowercase() || v.is_uppercase()),\n    }\n}\n\nfn main() {\n    let\
    \ candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnbc06tek.rs:19:9\n   |\n\
    18 |     match dict.values() {\n   |           ------------- this expression has\
    \ type `std::collections::hash_map::Values<'_, String, String>`\n19 |        \
    \ None => true,\n   |         ^^^^ expected struct `std::collections::hash_map::Values`,\
    \ found enum `Option`\n   |\n   = note: expected struct `std::collections::hash_map::Values<'_,\
    \ String, String>`\n                found enum `Option<_>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpnbc06tek.rs:20:9\n   |\n18 |     match dict.values() {\n\
    \   |           ------------- this expression has type `std::collections::hash_map::Values<'_,\
    \ String, String>`\n19 |         None => true,\n20 |         Some(values) => values.is_ok()\
    \ && values.all(|v| v.is_string() && v.is_lowercase() || v.is_uppercase()),\n\
    \   |         ^^^^^^^^^^^^ expected struct `std::collections::hash_map::Values`,\
    \ found enum `Option`\n   |\n   = note: expected struct `std::collections::hash_map::Values<'_,\
    \ String, String>`\n                found enum `Option<_>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(_, v)| is_lower_case_or_upper_case(v))\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_lower_case_or_upper_case` in this\
    \ scope\n  --> /tmp/tmp_t11v9xd.rs:18:30\n   |\n18 |     dict.iter().all(|(_,\
    \ v)| is_lower_case_or_upper_case(v))\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    match dict.len() {\n        0 => true,\n\
    \        _ => {\n            let mut iter = dict.iter();\n            let mut\
    \ keys: Vec<String> = Vec::new();\n            iter.for_each(|(key, value)| {\n\
    \                if key.to_lowercase() != key {\n                    keys.push(key);\n\
    \                    keys.push(key.to_uppercase());\n                } else {\n\
    \                    keys.push(key);\n                }\n            });\n   \
    \         if !keys.is_sorted() {\n                return false;\n            }\n\
    \            let mut iter = dict.iter();\n            iter.for_each(|(key, value)|\
    \ {\n                if key.to_lowercase() != key {\n                    if key.to_uppercase()\
    \ != key {\n                        return false;\n                    }\n   \
    \             }\n                keys.push(key);\n            });\n          \
    \  if !keys.is_sorted() {\n                return false;\n            }\n    \
    \        true\n        }\n    }\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2ltmx6_t.rs:25:31\n   |\n\
    25 |                     keys.push(key);\n   |                               ^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \             |\n   |                               expected struct `String`,\
    \ found `&String`\n\nerror[E0277]: can't compare `String` with `&String`\n  -->\
    \ /tmp/tmp2ltmx6_t.rs:24:39\n   |\n24 |                 if key.to_lowercase()\
    \ != key {\n   |                                       ^^ no implementation for\
    \ `String == &String`\n   |\n   = help: the trait `PartialEq<&String>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n         \
    \    <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2ltmx6_t.rs:28:31\n\
    \   |\n28 |                     keys.push(key);\n   |                        \
    \       ^^^- help: try using a conversion method: `.to_string()`\n   |       \
    \                        |\n   |                               expected struct\
    \ `String`, found `&String`\n\nerror[E0658]: use of unstable library feature 'is_sorted':\
    \ new API\n  --> /tmp/tmp2ltmx6_t.rs:31:22\n   |\n31 |             if !keys.is_sorted()\
    \ {\n   |                      ^^^^^^^^^\n   |\n   = note: see issue #53485 <https://github.com/rust-lang/rust/issues/53485>\
    \ for more information\n\nerror[E0277]: can't compare `String` with `&String`\n\
    \  --> /tmp/tmp2ltmx6_t.rs:36:39\n   |\n36 |                 if key.to_lowercase()\
    \ != key {\n   |                                       ^^ no implementation for\
    \ `String == &String`\n   |\n   = help: the trait `PartialEq<&String>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `PartialEq<Rh"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut res = true;\n    for (_, value)\
    \ in dict {\n        if !value.is_lowercase() && !value.is_uppercase() {\n   \
    \         res = false;\n            break;\n        }\n    }\n    res\n}\n\nfn\
    \ main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lowercase` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmptd7hmmi9.rs:20:19\n   |\n20 |         if\
    \ !value.is_lowercase() && !value.is_uppercase() {\n   |                   ^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_lowercase`\n\n\
    error[E0599]: no method named `is_uppercase` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmptd7hmmi9.rs:20:44\n   |\n20 |         if !value.is_lowercase()\
    \ && !value.is_uppercase() {\n   |                                           \
    \ ^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all().map(|(s, _)| s.as_bytes().to_lowercase()).unwrap_or(dict.iter().all().map(|(s,\
    \ _)| s.as_bytes().to_uppercase()).unwrap_or(false))\n}\n\nfn main() {\n    let\
    \ candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmpjrl8whn9.rs:18:17\n     |\n18   |     dict.iter().all().map(|(s,\
    \ _)| s.as_bytes().to_lowercase()).unwrap_or(dict.iter().all().map(|(s, _)| s.as_bytes().to_uppercase()).unw...\n\
    \     |                 ^^^- supplied 0 arguments\n     |                 |\n\
    \     |                 expected 1 argument\n     |\nnote: associated function\
    \ defined here\n\nerror[E0599]: `bool` is not an iterator\n  --> /tmp/tmpjrl8whn9.rs:18:23\n\
    \   |\n18 |     dict.iter().all().map(|(s, _)| s.as_bytes().to_lowercase()).unwrap_or(dict.iter().all().map(|(s,\
    \ _)| s.as_bytes().to_uppercase()).unw...\n   |                       ^^^ `bool`\
    \ is not an iterator\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `bool: Iterator`\n           which is required by `&mut bool: Iterator`\n\
    \nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmpjrl8whn9.rs:18:87\n     |\n18   |     dict.iter().all().map(|(s,\
    \ _)| s.as_bytes().to_lowercase()).unwrap_or(dict.iter().all().map(|(s, _)| s.as_bytes().to_uppercase()).unw...\n\
    \     |                                                                      \
    \                 ^^^- supplied 0 arguments\n     |                          \
    \                                                             |\n     |      \
    \                                                                            \
    \     expected 1 argument\n     |\nnote: associated function defined here\n\n\
    error[E0599]: `bool` is not an iterator\n  --> /tmp/tmpjrl8whn9.rs:18:93\n   |\n\
    18 |     dict.iter().all().map(|(s, _)| s.as_bytes().to_lowercase()).unwrap_or(dict.iter().all().map(|(s,\
    \ _)| s.as_bytes().to_uppercase()).unw...\n   |                              \
    \                                                               ^^^ `bool` is\
    \ not an iterator\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `bool: Iterator`\n           which is required by `&mut bool: Iterator`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have d"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.len() == 0 {\n        return\
    \ false;\n    }\n    let mut res = true;\n    for (key, value) in dict {\n   \
    \     if !key.to_string().is_lowercase() && !key.to_string().is_uppercase() {\n\
    \            res = false;\n        }\n    }\n    res\n}\n\nfn main() {\n    let\
    \ candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lowercase` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp8flsdb2w.rs:23:29\n   |\n23 |         if\
    \ !key.to_string().is_lowercase() && !key.to_string().is_uppercase() {\n   | \
    \                            ^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `is_uppercase`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmp8flsdb2w.rs:23:64\n\
    \   |\n23 |         if !key.to_string().is_lowercase() && !key.to_string().is_uppercase()\
    \ {\n   |                                                                ^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_uppercase`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.is_empty()\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpcnag6z2b.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010781
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.len() == 0 {\n        false\n\
    \    } else {\n        let mut keys = &*dict;\n        for (_, key) in keys.iter_mut()\
    \ {\n            key.to_lowercase();\n            key.to_uppercase();\n      \
    \  }\n        for (_, key) in keys.iter_mut() {\n            if !dict.is_key(key)\
    \ {\n                false\n            }\n        }\n        true\n    }\n}\n\
    \nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `HashMap<String, String>` cannot be dereferenced\n \
    \ --> /tmp/tmpd8_vhbn_.rs:21:25\n   |\n21 |         let mut keys = &*dict;\n \
    \  |                         ^^^^^\n\nerror[E0599]: no method named `is_key` found\
    \ for struct `HashMap` in the current scope\n  --> /tmp/tmpd8_vhbn_.rs:27:22\n\
    \   |\n27 |             if !dict.is_key(key) {\n   |                      ^^^^^^\
    \ help: there is an associated function with a similar name: `contains_key`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpd8_vhbn_.rs:28:17\n   |\n27 | /\
    \             if !dict.is_key(key) {\n28 | |                 false\n   | |   \
    \              ^^^^^ expected `()`, found `bool`\n29 | |             }\n   | |_____________-\
    \ expected this to be `()`\n   |\nhelp: you might have meant to return this value\n\
    \   |\n28 |                 return false;\n   |                 ++++++      +\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599, E0614.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut upper_case = false;\n    let\
    \ mut lower_case = false;\n    for key in dict.values() {\n        if key.is_upper()\
    \ {\n            upper_case = true;\n        }\n        if key.is_lower() {\n\
    \            lower_case = true;\n        }\n    }\n    upper_case && lower_case\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_upper` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpadcp9f6p.rs:21:16\n   |\n21 |         if\
    \ key.is_upper() {\n   |                ^^^^^^^^ method not found in `&String`\n\
    \nerror[E0599]: no method named `is_lower` found for reference `&String` in the\
    \ current scope\n  --> /tmp/tmpadcp9f6p.rs:24:16\n   |\n24 |         if key.is_lower()\
    \ {\n   |                ^^^^^^^^ method not found in `&String`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.contains_key(\"Name\") && dict.contains_key(\"\
    Age\") && dict.contains_key(\"City\")\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp9ytlz5ym.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(_, v)| {\n       \
    \ v.is_lowercase() || v.is_uppercase()\n    })\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpk1ghuzm0.rs:19:11\n   |\n19 |         v.is_lowercase()\
    \ || v.is_uppercase()\n   |           ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named\
    \ `is_uppercase` found for reference `&String` in the current scope\n  --> /tmp/tmpk1ghuzm0.rs:19:31\n\
    \   |\n19 |         v.is_lowercase() || v.is_uppercase()\n   |               \
    \                ^^^^^^^^^^^^ help: there is an associated function with a similar\
    \ name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut has_upper = false;\n    let\
    \ mut has_lower = false;\n\n    for (_, val) in dict.iter() {\n        if let\
    \ Some(key) = val.to_lowercase() {\n            if has_lower {\n             \
    \   return false;\n            }\n\n            has_lower = true;\n        } else\
    \ if let Some(key) = val.to_uppercase() {\n            if has_upper {\n      \
    \          return false;\n            }\n\n            has_upper = true;\n   \
    \     }\n    }\n\n    has_lower && has_upper\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpquahawti.rs:22:16\n   |\n\
    22 |         if let Some(key) = val.to_lowercase() {\n   |                ^^^^^^^^^\
    \   ------------------ this expression has type `String`\n   |               \
    \ |\n   |                expected struct `String`, found enum `Option`\n   |\n\
    \   = note: expected struct `String`\n                found enum `Option<_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpquahawti.rs:28:23\n   |\n28 |\
    \         } else if let Some(key) = val.to_uppercase() {\n   |               \
    \        ^^^^^^^^^   ------------------ this expression has type `String`\n  \
    \ |                       |\n   |                       expected struct `String`,\
    \ found enum `Option`\n   |\n   = note: expected struct `String`\n           \
    \     found enum `Option<_>`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n\n    let mut strings = Vec::new();\n\n    for element in &dict\
    \ {\n        let string = match element.key {\n            String::from(x) =>\
    \ x,\n            _ => return false,\n        };\n        strings.push(string);\n\
    \    }\n\n    let mut lower: strings = Vec::new();\n    let mut upper: strings\
    \ = Vec::new();\n\n    for element in &dict {\n        let string = match element.key\
    \ {\n            String::from(x) => x,\n            _ => return false,\n     \
    \   };\n        lower.push(string);\n    }\n\n    let mut upper_index: usize =\
    \ 0;\n    let mut lower_index: usize = 0;\n\n    for element in &dict {\n    \
    \    let string = match element.key {\n            String::from(x) => x,\n   \
    \         _ => return false,\n        };\n        lower.push(string);\n    }\n\
    \n    for element in &dict {\n        let string = match element.key {\n     \
    \       String::from(x) => x,\n            _ => return false,\n        };\n  \
    \      upper.push(string);\n\n        if string.as_str().to_lowercase() == string\
    \ {\n            lower_index += 1;\n        }\n\n        if string.as_str().to_uppercase()\
    \ == string {\n            upper_index += 1;\n        }\n    }\n\n    if lower_index\
    \ == strings.len() && upper_index == strings.len() {\n        return true;\n \
    \   }\n\n    return false;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0573]: expected type, found local variable `strings`\n   --> /tmp/tmpy316fwjh.rs:32:20\n\
    \    |\n32  |       let mut lower: strings = Vec::new();\n    |              \
    \        ^^^^^^^ help: a struct with a similar name exists: `String`\n\nerror[E0573]:\
    \ expected type, found local variable `strings`\n   --> /tmp/tmpy316fwjh.rs:33:20\n\
    \    |\n33  |       let mut upper: strings = Vec::new();\n    |              \
    \        ^^^^^^^ help: a struct with a similar name exists: `String`\n\nerror[E0609]:\
    \ no field `key` on type `(&String, &String)`\n  --> /tmp/tmpy316fwjh.rs:25:36\n\
    \   |\n25 |         let string = match element.key {\n   |                   \
    \                 ^^^\n\nerror[E0164]: expected tuple struct or tuple variant,\
    \ found associated function `String::from`\n  --> /tmp/tmpy316fwjh.rs:26:13\n\
    \   |\n26 |             String::from(x) => x,\n   |             ^^^^^^^^^^^^^^^\
    \ `fn` calls are not allowed in patterns\n   |\n   = help: for more information,\
    \ visit https://doc.rust-lang.org/book/ch18-00-patterns.html\n\nerror[E0609]:\
    \ no field `key` on type `(&String, &String)`\n  --> /tmp/tmpy316fwjh.rs:36:36\n\
    \   |\n36 |         let string = match element.key {\n   |                   \
    \                 ^^^\n\nerror[E0164]: expected tuple struct or tuple variant,\
    \ found associated function `String::from`\n  --> /tmp/tmpy316fwjh.rs:37:13\n\
    \   |\n37 |             String::from(x) => x,\n   |             ^^^^^^^^^^^^^^^\
    \ `fn` calls are not allowed in patterns\n   |\n   = help: for more information,\
    \ visit https://doc.rust-lang.org/book/ch18-00-patterns.html\n\nerror[E0609]:\
    \ no field `key` on type `(&String, &String)`\n  --> /tmp/tmpy316fwjh.rs:47:36\n\
    \   |\n47 |         let string = match element.key {\n   |                   \
    \                 ^^^\n\nerror[E0164]: expected tuple struct or tuple variant,\
    \ found associated function `String::from`\n  --> /tmp/tmpy316fwjh.rs:48:13\n\
    \   |\n48 |             String::from(x) => x,\n   |             ^^^^^^^^^^^^^^^\
    \ `fn` calls are not allowed in patterns\n   |\n   = help: for more information,\
    \ visit https://doc.rust-lang.org/book/ch18-00-patterns.h"
  stdout: ''
  timestamp: 1660010964
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.is_empty()\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpcnag6z2b.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010781
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n\n    for entry in dict.iter() {\n        if let Some(val) =\
    \ entry.value {\n            let mut lower: String = String::from(\"a\");\n  \
    \          let mut upper: String = String::from(\"A\");\n\n            if !val.is_lowercase()\
    \ {\n                lower = String::from(\"a\");\n            }\n\n         \
    \   if !val.is_uppercase() {\n                upper = String::from(\"A\");\n \
    \           }\n\n            if val != String::from(lower) || val != String::from(upper)\
    \ {\n                return false;\n            }\n        }\n    }\n\n    true\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0609]: no field `value` on type `(&String, &String)`\n  --> /tmp/tmp63zif_f9.rs:23:34\n\
    \   |\n23 |         if let Some(val) = entry.value {\n   |                   \
    \               ^^^^^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0609`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(_, v)| {\n       \
    \ let v = v.to_lowercase();\n        dict.contains_key(&v)\n    })\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpaclna9io.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    // For each key, check if the key equals\
    \ both lower and upper\n    let mut lower = dict.values().cloned().collect::<Vec<_>>();\n\
    \    let mut upper = dict.values().cloned().collect::<Vec<_>>();\n    lower.sort();\n\
    \    upper.sort();\n    lower.remove(0, 1); // Remove first and last\n    upper.remove(0);\n\
    \    let mut found = true;\n    for k in lower {\n        if k != k {\n      \
    \      found = false;\n            break;\n        }\n    }\n    for k in upper\
    \ {\n        if k != k {\n            found = false;\n            break;\n   \
    \     }\n    }\n    found\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmphs5y2q2z.rs:23:11\n     |\n23   |     lower.remove(0, 1); //\
    \ Remove first and last\n     |           ^^^^^^ -  - supplied 2 arguments\n \
    \    |           |\n     |           expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.contains_key(\"key1\".to_string())\
    \ && \n    dict.contains_key(\"KEY2\".to_string()) && \n    !dict.contains_key(\"\
    key3\".to_string()) &&\n    !dict.contains_key(\"key3\".to_owned())\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpo4kbh6mi.rs:18:23\n   |\n\
    18 |     dict.contains_key(\"key1\".to_string()) && \n   |                   \
    \    ^^^^^^^^^^^^^^^^^^\n   |                       |\n   |                  \
    \     expected reference, found struct `String`\n   |                       help:\
    \ consider borrowing here: `&\"key1\".to_string()`\n   |\n   = note: expected\
    \ reference `&_`\n                 found struct `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpo4kbh6mi.rs:19:23\n   |\n19 |     dict.contains_key(\"\
    KEY2\".to_string()) && \n   |                       ^^^^^^^^^^^^^^^^^^\n   | \
    \                      |\n   |                       expected reference, found\
    \ struct `String`\n   |                       help: consider borrowing here: `&\"\
    KEY2\".to_string()`\n   |\n   = note: expected reference `&_`\n              \
    \   found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo4kbh6mi.rs:20:24\n\
    \   |\n20 |     !dict.contains_key(\"key3\".to_string()) &&\n   |            \
    \            ^^^^^^^^^^^^^^^^^^\n   |                        |\n   |         \
    \               expected reference, found struct `String`\n   |              \
    \          help: consider borrowing here: `&\"key3\".to_string()`\n   |\n   =\
    \ note: expected reference `&_`\n                 found struct `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpo4kbh6mi.rs:21:24\n   |\n21 |     !dict.contains_key(\"\
    key3\".to_owned())\n   |                        ^^^^^^^^^^^^^^^^^\n   |      \
    \                  |\n   |                        expected reference, found struct\
    \ `String`\n   |                        help: consider borrowing here: `&\"key3\"\
    .to_owned()`\n   |\n   = note: expected reference `&_`\n                 found\
    \ struct `String`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    !dict.is_empty() && dict.iter().all(|(_,\
    \ value)| \n        match value{\n            Ok(val) => \n                if\
    \ val == String::from(\"UPPER\") {\n                    true\n               \
    \ } else {\n                    false\n                },\n            Err(_)\
    \ => {\n                false\n            }\n        }\n    )\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9pcpe64b.rs:20:13\n   |\n\
    19 |         match value{\n   |               ----- this expression has type `&String`\n\
    20 |             Ok(val) => \n   |             ^^^^^^^ expected struct `String`,\
    \ found enum `Result`\n   |\n   = note: expected struct `String`\n           \
    \     found enum `Result<_, _>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9pcpe64b.rs:26:13\n\
    \   |\n19 |         match value{\n   |               ----- this expression has\
    \ type `&String`\n...\n26 |             Err(_) => {\n   |             ^^^^^^ expected\
    \ struct `String`, found enum `Result`\n   |\n   = note: expected struct `String`\n\
    \                found enum `Result<_, _>`\n\nerror[E0277]: the size for values\
    \ of type `str` cannot be known at compilation time\n   --> /tmp/tmp9pcpe64b.rs:20:13\n\
    \    |\n20  |             Ok(val) => \n    |             ^^^^^^^ doesn't have\
    \ a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented\
    \ for `str`\nnote: required by a bound in `Ok`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut map = dict;\n    if map.is_empty()\
    \ {\n        return false;\n    }\n\n    // Convert all keys to lowercase\n  \
    \  let mut new_map = map.clone();\n    new_map.iter().for_each(|(key, value)|\
    \ {\n        let key = key.to_lowercase();\n        if value != &new_map.get(&key).unwrap()\
    \ {\n            new_map.insert(key, value.to_lowercase());\n        }\n    });\n\
    \n    // Convert all keys to uppercase\n    new_map.iter().for_each(|(key, value)|\
    \ {\n        let key = key.to_uppercase();\n        if value != &new_map.get(&key).unwrap()\
    \ {\n            new_map.insert(key, value.to_uppercase());\n        }\n    });\n\
    \n    // All keys are either lower case or uppercase\n    map.iter().all(|(key,\
    \ value)| {\n        let key = key.to_lowercase();\n        match value.to_lowercase()\
    \ {\n            true => key == key,\n            false => key == key,\n     \
    \   }\n    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `String` with `&String`\n  --> /tmp/tmpiq1ibmsb.rs:27:18\n\
    \   |\n27 |         if value != &new_map.get(&key).unwrap() {\n   |          \
    \        ^^ no implementation for `String == &String`\n   |\n   = help: the trait\
    \ `PartialEq<&String>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n\
    \             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n   = note: required because of the requirements on the\
    \ impl of `PartialEq<&&String>` for `&String`\n\nerror[E0277]: can't compare `String`\
    \ with `&String`\n  --> /tmp/tmpiq1ibmsb.rs:35:18\n   |\n35 |         if value\
    \ != &new_map.get(&key).unwrap() {\n   |                  ^^ no implementation\
    \ for `String == &String`\n   |\n   = help: the trait `PartialEq<&String>` is\
    \ not implemented for `String`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n   = note: required because of the requirements on the\
    \ impl of `PartialEq<&&String>` for `&String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpiq1ibmsb.rs:44:13\n   |\n43 |         match value.to_lowercase()\
    \ {\n   |               -------------------- this expression has type `String`\n\
    44 |             true => key == key,\n   |             ^^^^ expected struct `String`,\
    \ found `bool`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpiq1ibmsb.rs:45:13\n\
    \   |\n43 |         match "
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.len() == 0 ||\n    dict.iter().all(|(k,\
    \ _)| k.to_lowercase().is_ok() && k.to_uppercase().is_ok())\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ok` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmprws29pod.rs:19:47\n   |\n19 |     dict.iter().all(|(k,\
    \ _)| k.to_lowercase().is_ok() && k.to_uppercase().is_ok())\n   |            \
    \                                   ^^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `is_ok` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmprws29pod.rs:19:75\n   |\n19 |     dict.iter().all(|(k, _)| k.to_lowercase().is_ok()\
    \ && k.to_uppercase().is_ok())\n   |                                         \
    \                                  ^^^^^ method not found in `String`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n    dict\n        .keys()\n        .iter()\n        .all(|key|\
    \ key.to_lowercase() == key)\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `std::collections::hash_map::Keys`\
    \ in the current scope\n  --> /tmp/tmp611rnnh2.rs:23:10\n   |\n23 |         .iter()\n\
    \   |          ^^^^ method not found in `std::collections::hash_map::Keys<'_,\
    \ String, String>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       let mut key: string = key;\n        let mut value: string = value;\n \
    \       key.to_ascii_lowercase();\n        value.to_ascii_lowercase();\n     \
    \   key == value\n    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `string` in this scope\n   --> /tmp/tmphc5jnosp.rs:19:22\n\
    \    |\n19  |           let mut key: string = key;\n    |                    \
    \    ^^^^^^ help: a struct with a similar name exists (notice the capitalization):\
    \ `String`\n\nerror[E0412]: cannot find type `string` in this scope\n   --> /tmp/tmphc5jnosp.rs:20:24\n\
    \    |\n20  |           let mut value: string = value;\n    |                \
    \          ^^^^^^ help: a struct with a similar name exists (notice the capitalization):\
    \ `String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n    for k in dict.keys().cloned() {\n        if k.len() != k[0].len_utf8()\
    \ {\n            return false;\n        }\n    }\n    for k in dict.keys().cloned()\
    \ {\n        if !k.is_ascii_lowercase() {\n            return false;\n       \
    \ }\n    }\n    for k in dict.keys().cloned() {\n        if !k.is_ascii_uppercase()\
    \ {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpsv1o9cxv.rs:22:23\n   |\n22 |         if k.len() != k[0].len_utf8()\
    \ {\n   |                       ^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `is_ascii_lowercase` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmpsv1o9cxv.rs:27:15\n   |\n27 | \
    \        if !k.is_ascii_lowercase() {\n   |               ^^^^^^^^^^^^^^^^^^ help:\
    \ there is an associated function with a similar name: `to_ascii_lowercase`\n\n\
    error[E0599]: no method named `is_ascii_uppercase` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmpsv1o9cxv.rs:32:15\n   |\n32 |         if !k.is_ascii_uppercase()\
    \ {\n   |               ^^^^^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `to_ascii_uppercase`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n    for pair in dict.iter() {\n        match pair.1.to_lowercase()\
    \ {\n            \"state\" => return false,\n            \"zip\" => return false,\n\
    \            _ => (),\n        }\n    }\n    for pair in dict.iter() {\n     \
    \   match pair.1.to_uppercase() {\n            \"STATE\" => return false,\n  \
    \          \"ZIP\" => return false,\n            _ => (),\n        }\n    }\n\
    \    true\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpao0pfc8m.rs:23:13\n   |\n\
    22 |         match pair.1.to_lowercase() {\n   |               ---------------------\
    \ this expression has type `String`\n23 |             \"state\" => return false,\n\
    \   |             ^^^^^^^ expected struct `String`, found `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpao0pfc8m.rs:24:13\n   |\n22 |         match\
    \ pair.1.to_lowercase() {\n   |               --------------------- this expression\
    \ has type `String`\n23 |             \"state\" => return false,\n24 |       \
    \      \"zip\" => return false,\n   |             ^^^^^ expected struct `String`,\
    \ found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpao0pfc8m.rs:30:13\n\
    \   |\n29 |         match pair.1.to_uppercase() {\n   |               ---------------------\
    \ this expression has type `String`\n30 |             \"STATE\" => return false,\n\
    \   |             ^^^^^^^ expected struct `String`, found `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpao0pfc8m.rs:31:13\n   |\n29 |         match\
    \ pair.1.to_uppercase() {\n   |               --------------------- this expression\
    \ has type `String`\n30 |             \"STATE\" => return false,\n31 |       \
    \      \"ZIP\" => return false,\n   |             ^^^^^ expected struct `String`,\
    \ found `&str`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    match dict.len() {\n        0 => false\n\
    \        1 => false\n        2 => false\n        3 => false\n        4 => true\n\
    \        _ => false\n    }\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `,`, `.`, `?`, `}`, or an operator, found `1`\n\
    \  --> /tmp/tmpa0mr_fvc.rs:20:9\n   |\n19 |         0 => false\n   |         \
    \  --      - expected one of `,`, `.`, `?`, `}`, or an operator\n   |        \
    \   |\n   |           while parsing the `match` arm starting here\n20 |      \
    \   1 => false\n   |         ^ unexpected token\n\nerror: aborting due to previous\
    \ error\n\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut upper_case_keys = HashMap::new();\n\
    \    let mut lower_case_keys = HashMap::new();\n    for key in dict.keys() {\n\
    \        if key.isupper() {\n            upper_case_keys.insert(key, &dict[key]);\n\
    \        } else if key.islower() {\n            lower_case_keys.insert(key, &dict[key]);\n\
    \        } else {\n            return false;\n        }\n    }\n    lower_case_keys.is_subset(&upper_case_keys)\
    \ && upper_case_keys.is_subset(&lower_case_keys)\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `isupper` found for reference `&String` in\
    \ the current scope\n  --> /tmp/tmplv5bznmy.rs:21:16\n   |\n21 |         if key.isupper()\
    \ {\n   |                ^^^^^^^ method not found in `&String`\n\nerror[E0599]:\
    \ no method named `islower` found for reference `&String` in the current scope\n\
    \  --> /tmp/tmplv5bznmy.rs:23:23\n   |\n23 |         } else if key.islower() {\n\
    \   |                       ^^^^^^^ method not found in `&String`\n\nerror[E0599]:\
    \ no method named `is_subset` found for struct `HashMap` in the current scope\n\
    \  --> /tmp/tmplv5bznmy.rs:29:21\n   |\n29 |     lower_case_keys.is_subset(&upper_case_keys)\
    \ && upper_case_keys.is_subset(&lower_case_keys)\n   |                     ^^^^^^^^^\
    \ method not found in `HashMap<&String, &String>`\n\nerror[E0599]: no method named\
    \ `is_subset` found for struct `HashMap` in the current scope\n  --> /tmp/tmplv5bznmy.rs:29:68\n\
    \   |\n29 |     lower_case_keys.is_subset(&upper_case_keys) && upper_case_keys.is_subset(&lower_case_keys)\n\
    \   |                                                                    ^^^^^^^^^\
    \ method not found in `HashMap<&String, &String>`\n\nerror: aborting due to 4\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut keys = dict.values();\n    let\
    \ mut keys_lower = vec![];\n    let mut keys_upper = vec![];\n    for k in keys\
    \ {\n        if k.is_lowercase() {\n            keys_lower.push(k);\n        }\
    \ else {\n            keys_upper.push(k);\n        }\n    }\n\n    if keys_lower.len()\
    \ != keys_upper.len() {\n        return false;\n    }\n    for key in dict.keys()\
    \ {\n        if keys_lower\n            .iter()\n            .any(|key| key.to_lowercase().to_string()\
    \ == key.to_string()) {\n            return false;\n        }\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmphfwexa7q.rs:22:14\n   |\n22 |         if\
    \ k.is_lowercase() {\n   |              ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.keys().all(|s| s.chars().all(|c|\
    \ *c == c.to_ascii_lowercase()))\n    || dict.keys().all(|s| s.chars().all(|c|\
    \ *c == c.to_ascii_uppercase()))\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpj9r183s2.rs:18:43\n\
    \   |\n18 |     dict.keys().all(|s| s.chars().all(|c| *c == c.to_ascii_lowercase()))\n\
    \   |                                           ^^\n\nerror[E0614]: type `char`\
    \ cannot be dereferenced\n  --> /tmp/tmpj9r183s2.rs:19:46\n   |\n19 |     || dict.keys().all(|s|\
    \ s.chars().all(|c| *c == c.to_ascii_uppercase()))\n   |                     \
    \                         ^^\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    !dict.keys().contains(|key| key.is_lowercase()\
    \ || key.is_uppercase())\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `contains` found for struct `std::collections::hash_map::Keys`\
    \ in the current scope\n  --> /tmp/tmpnt9fsvlw.rs:18:18\n   |\n18 |     !dict.keys().contains(|key|\
    \ key.is_lowercase() || key.is_uppercase())\n   |                  ^^^^^^^^ method\
    \ not found in `std::collections::hash_map::Keys<'_, String, String>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.keys().all(|key| key.is_lower())\n\
    \        || dict.keys().all(|key| key.is_upper())\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lower` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmp6g3owt50.rs:18:31\n   |\n18 |     dict.keys().all(|key|\
    \ key.is_lower())\n   |                               ^^^^^^^^ method not found\
    \ in `&String`\n\nerror[E0599]: no method named `is_upper` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmp6g3owt50.rs:19:38\n   |\n19 |\
    \         || dict.keys().all(|key| key.is_upper())\n   |                     \
    \                 ^^^^^^^^ method not found in `&String`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut keys = dict.keys();\n    let\
    \ mut values = dict.values();\n    loop {\n        if keys.next().is_none() {\n\
    \            return values.next().is_none();\n        }\n        if keys.next().unwrap().is_lower()\
    \ || values.next().unwrap().is_upper() {\n            return false;\n        }\n\
    \    }\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lower` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpmuekyema.rs:24:33\n   |\n24 |         if\
    \ keys.next().unwrap().is_lower() || values.next().unwrap().is_upper() {\n   |\
    \                                 ^^^^^^^^ method not found in `&String`\n\nerror[E0599]:\
    \ no method named `is_upper` found for reference `&String` in the current scope\n\
    \  --> /tmp/tmpmuekyema.rs:24:70\n   |\n24 |         if keys.next().unwrap().is_lower()\
    \ || values.next().unwrap().is_upper() {\n   |                               \
    \                                       ^^^^^^^^ method not found in `&String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if !dict.contains_key(\"name\") && !dict.contains_key(\"\
    names\") {\n        return true;\n    }\n    if !dict.contains_key(\"name\") &&\
    \ dict.contains_key(\"names\") {\n        return false;\n    }\n    if dict.contains_key(\"\
    name\") && (dict.get(\"name\").len() != dict.get(\"names\").len()) {\n       \
    \ return false;\n    }\n    for k in dict.keys() {\n        if k.to_lowercase()\
    \ != k.to_lowercase() {\n            return false;\n        }\n    }\n    for\
    \ k in dict.keys() {\n        if k.to_uppercase() != k.to_uppercase() {\n    \
    \        return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmpm_e49vad.rs:24:55\n   |\n24 |     if dict.contains_key(\"\
    name\") && (dict.get(\"name\").len() != dict.get(\"names\").len()) {\n   |   \
    \                                                    ^^^ method not found in `Option<&String>`\n\
    \nerror[E0599]: no method named `len` found for enum `Option` in the current scope\n\
    \  --> /tmp/tmpm_e49vad.rs:24:82\n   |\n24 |     if dict.contains_key(\"name\"\
    ) && (dict.get(\"name\").len() != dict.get(\"names\").len()) {\n   |         \
    \                                                                         ^^^\
    \ method not found in `Option<&String>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut is_case_insensitive = true;\n\
    \    for (_key, val) in dict.iter() {\n        match val.to_lowercase() {\n  \
    \          Some(val) => is_case_insensitive = is_case_insensitive && val != key,\n\
    \            None => (),\n        }\n    }\n    is_case_insensitive\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `key` in this scope\n  --> /tmp/tmpsgtza3pt.rs:21:78\n\
    \   |\n21 |             Some(val) => is_case_insensitive = is_case_insensitive\
    \ && val != key,\n   |                                                       \
    \                       ^^^ help: a local variable with a similar name exists:\
    \ `_key`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsgtza3pt.rs:21:13\n\
    \   |\n20 |         match val.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n21 |             Some(val) => is_case_insensitive\
    \ = is_case_insensitive && val != key,\n   |             ^^^^^^^^^ expected struct\
    \ `String`, found enum `Option`\n   |\n   = note: expected struct `String`\n \
    \               found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpsgtza3pt.rs:22:13\n   |\n20 |         match val.to_lowercase() {\n \
    \  |               ------------------ this expression has type `String`\n21 |\
    \             Some(val) => is_case_insensitive = is_case_insensitive && val !=\
    \ key,\n22 |             None => (),\n   |             ^^^^ expected struct `String`,\
    \ found enum `Option`\n   |\n   = note: expected struct `String`\n           \
    \     found enum `Option<_>`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(k, vs)| {\n      \
    \  vs.iter().all(|v| v.len() == v.chars().filter(|&b| b != b'A' && b != b'a' &&\
    \ b != b'B' && b != b'b').count())\n    })\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for reference `&String` in the\
    \ current scope\n  --> /tmp/tmpwi_h3jpx.rs:19:12\n   |\n19 |         vs.iter().all(|v|\
    \ v.len() == v.chars().filter(|&b| b != b'A' && b != b'a' && b != b'B' && b !=\
    \ b'b').count())\n   |            ^^^^ method not found in `&String`\n   |\nhelp:\
    \ because of the in-memory representation of `&str`, to obtain an `Iterator` over\
    \ each of its codepoint use method `chars`\n   |\n19 |         vs.chars().all(|v|\
    \ v.len() == v.chars().filter(|&b| b != b'A' && b != b'a' && b != b'B' && b !=\
    \ b'b').count())\n   |            ~~~~~\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|pair| {\n        match\
    \ pair.key().to_lowercase() {\n            Some(\"state\".to_lowercase()) => pair.key().is_upper(),\n\
    \            Some(\"zip\".to_lowercase()) => pair.key().is_upper(),\n        \
    \    _ => pair.key().is_lowercase()\n        }\n    })\n}\n\nfn main() {\n   \
    \ let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `)`, `,`, `...`, `..=`, `..`, or `|`, found `.`\n\
    \  --> /tmp/tmpcmjtiyi3.rs:20:25\n   |\n20 |             Some(\"state\".to_lowercase())\
    \ => pair.key().is_upper(),\n   |                         ^\n   |            \
    \             |\n   |                         expected one of `)`, `,`, `...`,\
    \ `..=`, `..`, or `|`\n   |                         help: missing `,`\n\nerror:\
    \ expected one of `)`, `,`, `...`, `..=`, `..`, or `|`, found `.`\n  --> /tmp/tmpcmjtiyi3.rs:21:23\n\
    \   |\n21 |             Some(\"zip\".to_lowercase()) => pair.key().is_upper(),\n\
    \   |                       ^\n   |                       |\n   |            \
    \           expected one of `)`, `,`, `...`, `..=`, `..`, or `|`\n   |       \
    \                help: missing `,`\n\nerror[E0531]: cannot find tuple struct or\
    \ tuple variant `to_lowercase` in this scope\n  --> /tmp/tmpcmjtiyi3.rs:20:26\n\
    \   |\n20 |             Some(\"state\".to_lowercase()) => pair.key().is_upper(),\n\
    \   |                          ^^^^^^^^^^^^ not found in this scope\n\nerror[E0531]:\
    \ cannot find tuple struct or tuple variant `to_lowercase` in this scope\n  -->\
    \ /tmp/tmpcmjtiyi3.rs:21:24\n   |\n21 |             Some(\"zip\".to_lowercase())\
    \ => pair.key().is_upper(),\n   |                        ^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror[E0599]: no method named `key` found for tuple `(&String,\
    \ &String)` in the current scope\n  --> /tmp/tmpcmjtiyi3.rs:19:20\n   |\n19 |\
    \         match pair.key().to_lowercase() {\n   |                    ^^^ method\
    \ not found in `(&String, &String)`\n\nerror[E0023]: this pattern has 2 fields,\
    \ but the corresponding tuple variant has 1 field\n   --> /tmp/tmpcmjtiyi3.rs:20:18\n\
    \    |\n20  |             Some(\"state\".to_lowercase()) => pair.key().is_upper(),\n\
    \    |                  ^^^^^^^ ^^^^^^^^^^^^^^ expected 1 field, found 2\n\nerror[E0023]:\
    \ this pattern has 2 fields, but the corresponding tuple variant has 1 field\n\
    \   --> /tmp/tmpcmjtiyi3.rs:21:18\n    |\n21  |             Some(\"zip\".to_lowercase())\
    \ => pair.key().is_upper(),\n    |                  ^^^^^ ^^^^^^^^^^^^^^ expected\
    \ 1 field, found 2\n\ner"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    match dict.len() {\n        0 => true,\n\
    \        _ => {\n            let mut iter = dict.iter();\n            let mut\
    \ first = iter.next();\n            let mut second = iter.next();\n          \
    \  let mut third = iter.next();\n\n            while let Some(key) = first {\n\
    \                if *key != *second.unwrap() {\n                    return false;\n\
    \                }\n                first = iter.next();\n                second\
    \ = iter.next();\n            }\n\n            while let Some(key) = second {\n\
    \                if *key != *third.unwrap() {\n                    return false;\n\
    \                }\n                first = iter.next();\n                third\
    \ = iter.next();\n            }\n            true\n        }\n    }\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `(&String, &String)` cannot be dereferenced\n  --> /tmp/tmpm2ngn4gw.rs:27:20\n\
    \   |\n27 |                 if *key != *second.unwrap() {\n   |              \
    \      ^^^^\n\nerror[E0614]: type `(&String, &String)` cannot be dereferenced\n\
    \  --> /tmp/tmpm2ngn4gw.rs:27:28\n   |\n27 |                 if *key != *second.unwrap()\
    \ {\n   |                            ^^^^^^^^^^^^^^^^\n\nerror[E0614]: type `(&String,\
    \ &String)` cannot be dereferenced\n  --> /tmp/tmpm2ngn4gw.rs:35:20\n   |\n35\
    \ |                 if *key != *third.unwrap() {\n   |                    ^^^^\n\
    \nerror[E0614]: type `(&String, &String)` cannot be dereferenced\n  --> /tmp/tmpm2ngn4gw.rs:35:28\n\
    \   |\n35 |                 if *key != *third.unwrap() {\n   |               \
    \             ^^^^^^^^^^^^^^^\n\nerror: aborting due to 4 previous errors\n\n\
    For more information about this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.len() == 0 ||\n    (dict.len()\
    \ == 1 && \n     dict[String::from(\"\")] == String::from(\"\")) ||\n    (dict.len()\
    \ == 2 && \n     dict[String::from(\"\")] == String::from(\"\") && \n     dict[String::from(\"\
    A\")] == String::from(\"A\")) ||\n    (dict.len() == 3 &&\n     dict[String::from(\"\
    \")] == String::from(\"\") && \n     dict[String::from(\"A\")] == String::from(\"\
    A\") && \n     dict[String::from(\"A\")] == String::from(\"a\"))\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpua69g3z6.rs:20:11\n   |\n\
    20 |      dict[String::from(\"\")] == String::from(\"\")) ||\n   |           ^^^^^^^^^^^^^^^^\n\
    \   |           |\n   |           expected reference, found struct `String`\n\
    \   |           help: consider borrowing here: `&String::from(\"\")`\n   |\n \
    \  = note: expected reference `&_`\n                 found struct `String`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpua69g3z6.rs:22:11\n   |\n22 |  \
    \    dict[String::from(\"\")] == String::from(\"\") && \n   |           ^^^^^^^^^^^^^^^^\n\
    \   |           |\n   |           expected reference, found struct `String`\n\
    \   |           help: consider borrowing here: `&String::from(\"\")`\n   |\n \
    \  = note: expected reference `&_`\n                 found struct `String`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpua69g3z6.rs:23:11\n   |\n23 |  \
    \    dict[String::from(\"A\")] == String::from(\"A\")) ||\n   |           ^^^^^^^^^^^^^^^^^\n\
    \   |           |\n   |           expected reference, found struct `String`\n\
    \   |           help: consider borrowing here: `&String::from(\"A\")`\n   |\n\
    \   = note: expected reference `&_`\n                 found struct `String`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpua69g3z6.rs:25:11\n   |\n25 |  \
    \    dict[String::from(\"\")] == String::from(\"\") && \n   |           ^^^^^^^^^^^^^^^^\n\
    \   |           |\n   |           expected reference, found struct `String`\n\
    \   |           help: consider borrowing here: `&String::from(\"\")`\n   |\n \
    \  = note: expected reference `&_`\n                 found struct `String`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpua69g3z6.rs:26:11\n   |\n26 |  \
    \    dict[String::from(\"A\")] == String::from(\"A\") && \n   |           ^^^^^^^^^^^^^^^^^\n\
    \   |           |\n   |           expected reference, found struct `String`\n\
    \   |           help: consider borrowing here: `&String::from(\"A\")`\n   |\n\
    \   = note: expected reference `&_`\n                 found struct `String`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpua69g3z6.rs:27:11\n   |\n27 |  \
    \    dict[String::from(\"A\")] == String::from(\"a\"))\n   |           ^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.len() > 0\n        && dict.keys().all(|&x|\
    \ x.is_lowercase())\n        && dict.keys().all(|&x| x.is_uppercase())\n}\n\n\
    fn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lowercase` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpr291ghi6.rs:19:35\n   |\n19 |         &&\
    \ dict.keys().all(|&x| x.is_lowercase())\n   |                               \
    \    ^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\
    \nerror[E0599]: no method named `is_uppercase` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpr291ghi6.rs:20:35\n   |\n20 |         && dict.keys().all(|&x|\
    \ x.is_uppercase())\n   |                                   ^^^^^^^^^^^^ help:\
    \ there is an associated function with a similar name: `to_uppercase`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    match dict.len() {\n        0 => true,\n\
    \        _ => {\n            for k in dict.keys() {\n                if k.len()\
    \ != 1 {\n                    return false;\n                }\n            }\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: `match` arms have incompatible types\n  --> /tmp/tmpyn54kvfj.rs:21:13\n\
    \   |\n18 |       match dict.len() {\n   |       ---------------- `match` arms\
    \ have incompatible types\n19 |           0 => true,\n   |                ----\
    \ this is found to be of type `bool`\n20 |           _ => {\n21 | /          \
    \   for k in dict.keys() {\n22 | |                 if k.len() != 1 {\n23 | | \
    \                    return false;\n24 | |                 }\n25 | |         \
    \    }\n   | |_____________^ expected `bool`, found `()`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut it = dict.iter();\n    loop\
    \ {\n        let (_key, value) = it.next();\n        if let (Some(k), Some(v))\
    \ = (key, value) {\n            match k.to_lowercase() {\n                Some(lower)\
    \ => match v.to_lowercase() {\n                    Some(lower) => true,\n    \
    \                None => false,\n                },\n                None => match\
    \ v.to_uppercase() {\n                    Some(upper) => true,\n             \
    \       None => false,\n                },\n            }\n        } else { break;\
    \ }\n    }\n    false\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `key` in this scope\n  --> /tmp/tmpk7lr7h16.rs:21:38\n\
    \   |\n21 |         if let (Some(k), Some(v)) = (key, value) {\n   |         \
    \                             ^^^ help: a local variable with a similar name exists:\
    \ `_key`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk7lr7h16.rs:20:13\n\
    \   |\n20 |         let (_key, value) = it.next();\n   |             ^^^^^^^^^^^^^\
    \   --------- this expression has type `Option<(&String, &String)>`\n   |    \
    \         |\n   |             expected enum `Option`, found tuple\n   |\n   =\
    \ note: expected enum `Option<(&String, &String)>`\n             found tuple `(_,\
    \ _)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk7lr7h16.rs:22:13\n   |\n\
    21 |  /         if let (Some(k), Some(v)) = (key, value) {\n22 |  |          \
    \   match k.to_lowercase() {\n   |  |_____________^\n23 | ||                 Some(lower)\
    \ => match v.to_lowercase() {\n24 | ||                     Some(lower) => true,\n\
    25 | ||                     None => false,\n...  ||\n30 | ||                 },\n\
    31 | ||             }\n   | ||_____________^ expected `()`, found `bool`\n32 |\
    \  |         } else { break; }\n   |  |_________________________- expected this\
    \ to be `()`\n   |\nhelp: consider using a semicolon here\n   |\n31 |        \
    \     };\n   |              +\nhelp: consider using a semicolon here\n   |\n32\
    \ |         } else { break; };\n   |                          +\nhelp: you might\
    \ have meant to return this value\n   |\n22 ~             return match k.to_lowercase()\
    \ {\n23 |                 Some(lower) => match v.to_lowercase() {\n24 |      \
    \               Some(lower) => true,\n25 |                     None => false,\n\
    26 |                 },\n27 |                 None => match v.to_uppercase() {\n\
    \ ...\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|x| x.is_string() ||\
    \ x.is_ascii_lowercase())\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_string` found for tuple `(&String, &String)`\
    \ in the current scope\n  --> /tmp/tmp5jfap_ez.rs:18:27\n   |\n18 |     dict.iter().all(|x|\
    \ x.is_string() || x.is_ascii_lowercase())\n   |                           ^^^^^^^^^\
    \ method not found in `(&String, &String)`\n\nerror[E0599]: no method named `is_ascii_lowercase`\
    \ found for tuple `(&String, &String)` in the current scope\n  --> /tmp/tmp5jfap_ez.rs:18:44\n\
    \   |\n18 |     dict.iter().all(|x| x.is_string() || x.is_ascii_lowercase())\n\
    \   |                                            ^^^^^^^^^^^^^^^^^^ method not\
    \ found in `(&String, &String)`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       if key.len() > value.len() {\n            false\n        } else {\n  \
    \          let mut string = String::from(key);\n            let mut uppercase\
    \ = false;\n            let mut lowercase = false;\n            while string.len()\
    \ > 0 {\n                uppercase = uppercase\n                    || string[0..1].chars().any(|c|\
    \ *c == c as u32);\n                lowercase = lowercase\n                  \
    \  || string[0..1].chars().any(|c| *c == c as u32);\n                string =\
    \ &string[1..];\n            }\n            if uppercase == true {\n         \
    \       true\n            } else {\n                false\n            }\n   \
    \     }\n    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpz8fill7m.rs:27:53\n\
    \   |\n27 |                     || string[0..1].chars().any(|c| *c == c as u32);\n\
    \   |                                                     ^^\n\nerror[E0614]:\
    \ type `char` cannot be dereferenced\n  --> /tmp/tmpz8fill7m.rs:29:53\n   |\n\
    29 |                     || string[0..1].chars().any(|c| *c == c as u32);\n  \
    \ |                                                     ^^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpz8fill7m.rs:30:26\n   |\n22 |             let mut string\
    \ = String::from(key);\n   |                              ----------------- expected\
    \ due to this value\n...\n30 |                 string = &string[1..];\n   |  \
    \                        ^^^^^^^^^^^^ expected struct `String`, found `&str`\n\
    \   |\nhelp: try using a conversion method\n   |\n30 |                 string\
    \ = (&string[1..]).to_string();\n   |                          +            +++++++++++++\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0614.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n\n    for k in dict.keys() {\n        let v = dict.get(k);\n\n\
    \        // if the value is not in lower case, return false\n        if v.to_lowercase().is_none()\
    \ {\n            return false;\n        }\n\n        // if the value is not in\
    \ upper case, return false\n        if v.to_uppercase().is_none() {\n        \
    \    return false;\n        }\n    }\n\n    return true;\n}\n\nfn main() {\n \
    \   let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_lowercase` found for enum `Option` in\
    \ the current scope\n  --> /tmp/tmpoqkhks_k.rs:26:14\n   |\n26 |         if v.to_lowercase().is_none()\
    \ {\n   |              ^^^^^^^^^^^^ method not found in `Option<&String>`\n\n\
    error[E0599]: no method named `to_uppercase` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmpoqkhks_k.rs:31:14\n   |\n31 |         if v.to_uppercase().is_none()\
    \ {\n   |              ^^^^^^^^^^^^ method not found in `Option<&String>`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut res = false;\n    for k in dict.keys().cloned()\
    \ {\n        match k.to_lowercase() {\n            None => res = false,\n    \
    \        Some(_) => (),\n        }\n        match k.to_uppercase() {\n       \
    \     None => res = false,\n            Some(_) => (),\n        }\n    }\n   \
    \ res\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpo4iryy_0.rs:21:13\n   |\n\
    20 |         match k.to_lowercase() {\n   |               ---------------- this\
    \ expression has type `String`\n21 |             None => res = false,\n   |  \
    \           ^^^^ expected struct `String`, found enum `Option`\n   |\n   = note:\
    \ expected struct `String`\n                found enum `Option<_>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpo4iryy_0.rs:22:13\n   |\n20 |         match\
    \ k.to_lowercase() {\n   |               ---------------- this expression has\
    \ type `String`\n21 |             None => res = false,\n22 |             Some(_)\
    \ => (),\n   |             ^^^^^^^ expected struct `String`, found enum `Option`\n\
    \   |\n   = note: expected struct `String`\n                found enum `Option<_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpo4iryy_0.rs:25:13\n   |\n24 |\
    \         match k.to_uppercase() {\n   |               ---------------- this expression\
    \ has type `String`\n25 |             None => res = false,\n   |             ^^^^\
    \ expected struct `String`, found enum `Option`\n   |\n   = note: expected struct\
    \ `String`\n                found enum `Option<_>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpo4iryy_0.rs:26:13\n   |\n24 |         match k.to_uppercase()\
    \ {\n   |               ---------------- this expression has type `String`\n25\
    \ |             None => res = false,\n26 |             Some(_) => (),\n   |  \
    \           ^^^^^^^ expected struct `String`, found enum `Option`\n   |\n   =\
    \ note: expected struct `String`\n                found enum `Option<_>`\n\nerror:\
    \ aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut result = true;\n    for (key,\
    \ _) in dict {\n        result = key.chars().all(|x| *x == x.to_lowercase()) ||\
    \ key.chars().all(|x| *x == x.to_uppercase());\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmp9sid1ep4.rs:20:38\n\
    \   |\n20 |         result = key.chars().all(|x| *x == x.to_lowercase()) || key.chars().all(|x|\
    \ *x == x.to_uppercase());\n   |                                      ^^\n\nerror[E0614]:\
    \ type `char` cannot be dereferenced\n  --> /tmp/tmp9sid1ep4.rs:20:85\n   |\n\
    20 |         result = key.chars().all(|x| *x == x.to_lowercase()) || key.chars().all(|x|\
    \ *x == x.to_uppercase());\n   |                                             \
    \                                        ^^\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.len() == 0 {\n        return\
    \ false;\n    }\n\n    let mut first_key = true;\n    let mut second_key = true;\n\
    \    for x in dict.keys() {\n        if first_key {\n            if !x.is_lowercase()\
    \ {\n                return false;\n            }\n            first_key = false;\n\
    \        } else {\n            if !x.is_uppercase() {\n                return\
    \ false;\n            }\n            second_key = false;\n        }\n    }\n \
    \   first_key && second_key\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpe2wmuj9u.rs:26:19\n   |\n26 |          \
    \   if !x.is_lowercase() {\n   |                   ^^^^^^^^^^^^ help: there is\
    \ an associated function with a similar name: `to_lowercase`\n\nerror[E0599]:\
    \ no method named `is_uppercase` found for reference `&String` in the current\
    \ scope\n  --> /tmp/tmpe2wmuj9u.rs:31:19\n   |\n31 |             if !x.is_uppercase()\
    \ {\n   |                   ^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    match dict.len() {\n        0 => false,\n\
    \        _ => {\n            let mut found = false;\n            let mut i = dict.keys().next().unwrap();\n\
    \            while i != None {\n                found = true;\n              \
    \  for j in 0..dict.len() {\n                    if !dict.values().next().unwrap().contains(&j)\
    \ && dict.values().next().unwrap().contains(&i) {\n                        found\
    \ = false;\n                    }\n                }\n                i = dict.keys().next().unwrap();\n\
    \            }\n            found\n        }\n    }\n}\n\nfn main() {\n    let\
    \ candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&String` with `Option<_>`\n  --> /tmp/tmps31zq8oi.rs:23:21\n\
    \   |\n23 |             while i != None {\n   |                     ^^ no implementation\
    \ for `&String == Option<_>`\n   |\n   = help: the trait `PartialEq<Option<_>>`\
    \ is not implemented for `&String`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0277]: expected a `Fn<(char,)>` closure, found\
    \ `usize`\n    --> /tmp/tmps31zq8oi.rs:26:64\n     |\n26   |                 \
    \    if !dict.values().next().unwrap().contains(&j) && dict.values().next().unwrap().contains(&i)\
    \ {\n     |                                                       -------- ^^\
    \ expected an `Fn<(char,)>` closure, found `usize`\n     |                   \
    \                                    |\n     |                               \
    \                        required by a bound introduced by this call\n     |\n\
    \     = help: the trait `Fn<(char,)>` is not implemented for `usize`\n     = help:\
    \ the following other types implement trait `Pattern<'a>`:\n               &'b\
    \ String\n               &'b [char; N]\n               &'b [char]\n          \
    \     &'b str\n               &'c &'b str\n               [char; N]\n        \
    \       char\n               pattern::MultiCharEqPattern<C>\n     = note: required\
    \ because of the requirements on the impl of `FnOnce<(char,)>` for `&usize`\n\
    \     = note: required because of the requirements on the impl of `Pattern<'_>`\
    \ for `&usize`\nnote: required by a bound in `core::str::<impl str>::contains`\n\
    \nerror[E0277]: expected a `Fn<(char,)>` closure, found `String`\n    --> /tmp/tmps31zq8oi.rs:26:110\n\
    \     |\n26   |                     if !dict.values().next().unwrap().contains(&j)\
    \ && "
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut iter = dict.into_iter().keys().peekable();\n\
    \    let mut first_item = iter.next().unwrap();\n    while let Some(key) = iter.next()\
    \ {\n        if first_item.to_string().to_lowercase() == key.to_string().to_lowercase()\
    \ {\n            return false;\n        }\n        if first_item.to_string().to_uppercase()\
    \ == key.to_string().to_uppercase() {\n            return false;\n        }\n\
    \        first_item = key;\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `keys` found for struct `std::collections::hash_map::IntoIter`\
    \ in the current scope\n  --> /tmp/tmpmjh5q574.rs:18:37\n   |\n18 |     let mut\
    \ iter = dict.into_iter().keys().peekable();\n   |                           \
    \          ^^^^ method not found in `std::collections::hash_map::IntoIter<String,\
    \ String>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lowercase: bool = true;\n  \
    \  let mut uppercase: bool = true;\n\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n\n    for pair in dict.iter() {\n        if !pair.key().is_lowercase()\
    \ {\n            lowercase = false;\n        }\n\n        if !pair.key().is_uppercase()\
    \ {\n            uppercase = false;\n        }\n    }\n\n    return !uppercase\
    \ && !lowercase;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n   \
    \ assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\"\
    )), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `key` found for tuple `(&String, &String)`\
    \ in the current scope\n  --> /tmp/tmpafwvvzce.rs:26:18\n   |\n26 |         if\
    \ !pair.key().is_lowercase() {\n   |                  ^^^ method not found in\
    \ `(&String, &String)`\n\nerror[E0599]: no method named `key` found for tuple\
    \ `(&String, &String)` in the current scope\n  --> /tmp/tmpafwvvzce.rs:30:18\n\
    \   |\n30 |         if !pair.key().is_uppercase() {\n   |                  ^^^\
    \ method not found in `(&String, &String)`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    !dict.is_empty() && dict.iter().all(|(key,\
    \ _)| {\n        key.to_lowercase() == key\n    })\n}\n\nfn main() {\n    let\
    \ candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `String` with `&String`\n  --> /tmp/tmpjvhbnc18.rs:19:28\n\
    \   |\n19 |         key.to_lowercase() == key\n   |                          \
    \  ^^ no implementation for `String == &String`\n   |\n   = help: the trait `PartialEq<&String>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.len() == 0 {\n        return\
    \ false;\n    }\n    let mut lower = true;\n    let mut upper = true;\n    for\
    \ key in &dict.keys() {\n        if key.to_lowercase() != key.to_uppercase() {\n\
    \            lower = false;\n        }\n        if !lower.is_false() {\n     \
    \       upper = false;\n        }\n    }\n    return lower || upper;\n}\n\nfn\
    \ main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&std::collections::hash_map::Keys<'_, String, String>` is\
    \ not an iterator\n  --> /tmp/tmpjdo33n4p.rs:23:16\n   |\n23 |     for key in\
    \ &dict.keys() {\n   |                -^^^^^^^^^^^\n   |                |\n  \
    \ |                `&std::collections::hash_map::Keys<'_, String, String>` is\
    \ not an iterator\n   |                help: consider removing the leading `&`-reference\n\
    \   |\n   = help: the trait `Iterator` is not implemented for `&std::collections::hash_map::Keys<'_,\
    \ String, String>`\n   = note: `Iterator` is implemented for `&mut std::collections::hash_map::Keys<'_,\
    \ std::string::String, std::string::String>`, but not for `&std::collections::hash_map::Keys<'_,\
    \ std::string::String, std::string::String>`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `&std::collections::hash_map::Keys<'_,\
    \ String, String>`\n\nerror[E0599]: no method named `is_false` found for type\
    \ `bool` in the current scope\n  --> /tmp/tmpjdo33n4p.rs:27:19\n   |\n27 |   \
    \      if !lower.is_false() {\n   |                   ^^^^^^^^ method not found\
    \ in `bool`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower = false;\n    let mut\
    \ upper = false;\n    \n    for kv in dict.into_iter() {\n        if kv.1.len()\
    \ > 1 {\n            upper = true;\n        }\n        if kv.1.len() < 1 {\n \
    \           lower = true;\n        }\n    }\n    lower || upper\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmph6_s96cd.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    !dict.is_empty() &&\n    dict.values()\n\
    \        .iter()\n        .map(|s| s.to_lowercase())\n        .all(|s| s.is_lowercase())\
    \ ||\n    !dict.values()\n        .iter()\n        .map(|s| s.to_uppercase())\n\
    \        .all(|s| s.is_uppercase())\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `std::collections::hash_map::Values`\
    \ in the current scope\n  --> /tmp/tmpc0mwfexd.rs:20:10\n   |\n20 |         .iter()\n\
    \   |          ^^^^ method not found in `std::collections::hash_map::Values<'_,\
    \ String, String>`\n\nerror[E0599]: no method named `iter` found for struct `std::collections::hash_map::Values`\
    \ in the current scope\n  --> /tmp/tmpc0mwfexd.rs:24:10\n   |\n24 |         .iter()\n\
    \   |          ^^^^ method not found in `std::collections::hash_map::Values<'_,\
    \ String, String>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    match dict.len() {\n        0 => false,\n\
    \        _ => true,\n    }\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpn0s5p7f0.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.len() == 0 {\n        return\
    \ false;\n    }\n    let mut res = true;\n    for key in dict.keys() {\n     \
    \   let s = key.name();\n        if s.len() == 0 {\n            res = false;\n\
    \            break;\n        }\n        if s.is_lowercase() {\n            let\
    \ k = dict.get(&key).unwrap_or(&key);\n            if k.is_lowercase() {\n   \
    \             res = false;\n                break;\n            }\n        } else\
    \ {\n            let k = dict.get(&key).unwrap_or(&key);\n            if k.is_uppercase()\
    \ {\n                res = false;\n                break;\n            }\n   \
    \     }\n    }\n    res\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `name` found for reference `&String` in the\
    \ current scope\n  --> /tmp/tmpt7yi2yfw.rs:23:21\n   |\n23 |         let s = key.name();\n\
    \   |                     ^^^^ method not found in `&String`\n\nerror[E0277]:\
    \ the trait bound `String: Borrow<&String>` is not satisfied\n   --> /tmp/tmpt7yi2yfw.rs:29:30\n\
    \    |\n29  |             let k = dict.get(&key).unwrap_or(&key);\n    |     \
    \                     --- ^^^^ the trait `Borrow<&String>` is not implemented\
    \ for `String`\n    |                          |\n    |                      \
    \    required by a bound introduced by this call\n    |\n    = help: the trait\
    \ `Borrow<str>` is implemented for `String`\nnote: required by a bound in `HashMap::<K,\
    \ V, S>::get`\n\nerror[E0599]: no method named `is_lowercase` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmpt7yi2yfw.rs:30:18\n   |\n30 |\
    \             if k.is_lowercase() {\n   |                  ^^^^^^^^^^^^ help:\
    \ there is an associated function with a similar name: `to_lowercase`\n\nerror[E0277]:\
    \ the trait bound `String: Borrow<&String>` is not satisfied\n   --> /tmp/tmpt7yi2yfw.rs:35:30\n\
    \    |\n35  |             let k = dict.get(&key).unwrap_or(&key);\n    |     \
    \                     --- ^^^^ the trait `Borrow<&String>` is not implemented\
    \ for `String`\n    |                          |\n    |                      \
    \    required by a bound introduced by this call\n    |\n    = help: the trait\
    \ `Borrow<str>` is implemented for `String`\nnote: required by a bound in `HashMap::<K,\
    \ V, S>::get`\n\nerror[E0599]: no method named `is_uppercase` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmpt7yi2yfw.rs:36:18\n   |\n36 |\
    \             if k.is_uppercase() {\n   |                  ^^^^^^^^^^^^ help:\
    \ there is an associated function with a similar name: `to_uppercase`\n\nerror:\
    \ aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    !dict.is_empty() && dict.values().all(|val|\
    \ {\n        match val {\n            String::from(val) => val.is_lowercase(),\n\
    \            String::from(val) => val.is_uppercase(),\n        }\n    })\n}\n\n\
    fn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0164]: expected tuple struct or tuple variant, found associated\
    \ function `String::from`\n  --> /tmp/tmp4vj7bap8.rs:20:13\n   |\n20 |       \
    \      String::from(val) => val.is_lowercase(),\n   |             ^^^^^^^^^^^^^^^^^\
    \ `fn` calls are not allowed in patterns\n   |\n   = help: for more information,\
    \ visit https://doc.rust-lang.org/book/ch18-00-patterns.html\n\nerror[E0164]:\
    \ expected tuple struct or tuple variant, found associated function `String::from`\n\
    \  --> /tmp/tmp4vj7bap8.rs:21:13\n   |\n21 |             String::from(val) =>\
    \ val.is_uppercase(),\n   |             ^^^^^^^^^^^^^^^^^ `fn` calls are not allowed\
    \ in patterns\n   |\n   = help: for more information, visit https://doc.rust-lang.org/book/ch18-00-patterns.html\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0164`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut iter = dict.iter();\n    let\
    \ mut last_key = String::from(\"\");\n    let mut last_value = String::from(\"\
    \");\n    match iter.next() {\n        Some((k, v)) => {\n            if k.to_lowercase()\
    \ != k.to_uppercase() {\n                return false;\n            }\n      \
    \      if k == last_key && v != last_value {\n                return false;\n\
    \            }\n            last_key = k;\n            last_value = v;\n     \
    \   }\n        None => true,\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&String` with `String`\n  --> /tmp/tmpynqv88eu.rs:26:18\n\
    \   |\n26 |             if k == last_key && v != last_value {\n   |          \
    \        ^^ no implementation for `&String == String`\n   |\n   = help: the trait\
    \ `PartialEq<String>` is not implemented for `&String`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n\
    \             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpynqv88eu.rs:29:24\n\
    \   |\n19 |     let mut last_key = String::from(\"\");\n   |                 \
    \       ---------------- expected due to this value\n...\n29 |             last_key\
    \ = k;\n   |                        ^- help: try using a conversion method: `.to_string()`\n\
    \   |                        |\n   |                        expected struct `String`,\
    \ found `&String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpynqv88eu.rs:30:26\n\
    \   |\n20 |     let mut last_value = String::from(\"\");\n   |               \
    \           ---------------- expected due to this value\n...\n30 |           \
    \  last_value = v;\n   |                          ^- help: try using a conversion\
    \ method: `.to_string()`\n   |                          |\n   |              \
    \            expected struct `String`, found `&String`\n\nerror[E0308]: `match`\
    \ arms have incompatible types\n  --> /tmp/tmpynqv88eu.rs:32:17\n   |\n21 | /\
    \     match iter.next() {\n22 | |         Some((k, v)) => {\n23 | |          \
    \   if k.to_lowercase() != k.to_uppercase() {\n24 | |                 return false;\n\
    ...  |\n30 | |             last_value = v;\n   | |             ---------------\
    \ this is found to be of type `()`\n31 | |         }\n32 | |         None => true,\n\
    \   | |                 ^^^^ expected `()`, found `bool`\n33 | |     }\n   | |_____"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n    for (k, v) in dict {\n        if let Some(v) = v.to_lowercase()\
    \ {\n            if v != k {\n                return false;\n            }\n \
    \       } else {\n            if v != k.to_uppercase() {\n                return\
    \ false;\n            }\n        }\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3nkzybgx.rs:22:16\n   |\n\
    22 |         if let Some(v) = v.to_lowercase() {\n   |                ^^^^^^^\
    \   ---------------- this expression has type `String`\n   |                |\n\
    \   |                expected struct `String`, found enum `Option`\n   |\n   =\
    \ note: expected struct `String`\n                found enum `Option<_>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    match dict.len() {\n        0 => false,\n\
    \        1 => true,\n        _ => {\n            let mut res = true;\n       \
    \     for (key, _) in dict {\n                if key.len() != 1 && key.len() !=\
    \ 2 {\n                    res = false;\n                    break;\n        \
    \        }\n            }\n            res\n        }\n    }\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpo25rr5l0.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    match dict.len() {\n        0 => true,\n\
    \        1 => false,\n        _ => match (dict.keys().collect::<Vec<_>>().iter().map(String::from).collect::<Vec<_>>(),\
    \ dict.values().collect::<Vec<_>>().iter().map(String::from).collect::<Vec<_>>())\
    \ {\n            (vec::from_iter(vec![\"a\", \"A\", \"b\", \"B\"]), vec::from_iter(vec![\"\
    apple\", \"apple\", \"banana\", \"banana\"])) => true,\n            (vec::from_iter(vec![\"\
    a\", \"A\", \"b\", \"B\", \"c\", \"C\"]), vec::from_iter(vec![\"apple\", \"apple\"\
    , \"banana\", \"banana\", \"carrot\", \"carrot\"])) => true,\n            _ =>\
    \ false,\n        }\n    }\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `vec`\n\
    \  --> /tmp/tmpfhro2uvk.rs:22:14\n   |\n22 |             (vec::from_iter(vec![\"\
    a\", \"A\", \"b\", \"B\"]), vec::from_iter(vec![\"apple\", \"apple\", \"banana\"\
    , \"banana\"])) => true,\n   |              ^^^ use of undeclared crate or module\
    \ `vec`\n\nerror[E0433]: failed to resolve: use of undeclared crate or module\
    \ `vec`\n  --> /tmp/tmpfhro2uvk.rs:22:56\n   |\n22 |             (vec::from_iter(vec![\"\
    a\", \"A\", \"b\", \"B\"]), vec::from_iter(vec![\"apple\", \"apple\", \"banana\"\
    , \"banana\"])) => true,\n   |                                               \
    \         ^^^ use of undeclared crate or module `vec`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared crate or module `vec`\n  --> /tmp/tmpfhro2uvk.rs:23:14\n\
    \   |\n23 | ...   (vec::from_iter(vec![\"a\", \"A\", \"b\", \"B\", \"c\", \"C\"\
    ]), vec::from_iter(vec![\"apple\", \"apple\", \"banana\", \"banana\", \"carrot\"\
    , \"carrot\"])...\n   |        ^^^ use of undeclared crate or module `vec`\n\n\
    error[E0433]: failed to resolve: use of undeclared crate or module `vec`\n  -->\
    \ /tmp/tmpfhro2uvk.rs:23:66\n   |\n23 | ...   (vec::from_iter(vec![\"a\", \"A\"\
    , \"b\", \"B\", \"c\", \"C\"]), vec::from_iter(vec![\"apple\", \"apple\", \"banana\"\
    , \"banana\", \"carrot\", \"carrot\"])...\n   |                              \
    \                              ^^^ use of undeclared crate or module `vec`\n\n\
    error: arbitrary expressions aren't allowed in patterns\n  --> /tmp/tmpfhro2uvk.rs:22:29\n\
    \   |\n22 |             (vec::from_iter(vec![\"a\", \"A\", \"b\", \"B\"]), vec::from_iter(vec![\"\
    apple\", \"apple\", \"banana\", \"banana\"])) => true,\n   |                 \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = note: this error originates\
    \ in the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more\
    \ info)\n\nerror: arbitrary expressions aren't allowed in patterns\n  --> /tmp/tmpfhro2uvk.rs:22:71\n\
    \   |\n22 |             (vec::from_iter(vec![\"a\", \"A\", \"b\", \"B\"]), vec::from_iter(vec![\"\
    apple\", \"apple\", \"banana\", \"banana\"])) => true,\n   |                 \
    \                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n\n    for entry in &dict {\n        if let Some(key) = entry.keys()\
    \ {\n            for key_char in key.chars() {\n                if key_char >=\
    \ 'A' && key_char <= 'Z' ||\n                    key_char >= 'a' && key_char <=\
    \ 'z' {\n                    return true;\n                }\n            }\n\
    \        }\n    }\n\n    return false;\n}\n\nfn main() {\n    let candidate =\
    \ check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"\
    ), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `keys` found for tuple `(&String, &String)`\
    \ in the current scope\n  --> /tmp/tmp0i7omol8.rs:23:34\n   |\n23 |         if\
    \ let Some(key) = entry.keys() {\n   |                                  ^^^^ method\
    \ not found in `(&String, &String)`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n\n    dict\n        .iter()\n        .any(|(key, value)| {\n\
    \            if key.len() > key.len() {\n                return false;\n     \
    \       }\n\n            if key.len() < key.len() {\n                return true;\n\
    \            }\n\n            if key.to_lowercase() == key.to_lowercase() {\n\
    \                return true;\n            }\n\n            if key.to_uppercase()\
    \ == key.to_uppercase() {\n                return true;\n            }\n\n   \
    \         return false;\n        })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpysjckkbv.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut iter = dict.iter();\n    if\
    \ iter.next().is_none() {\n        return false;\n    }\n    let mut first_letter\
    \ = String::from(\"\".into());\n    let mut first_case_letter = String::from(\"\
    \".into());\n    for &(k, v) in iter.next() {\n        if first_letter.is_empty()\
    \ {\n            first_letter = k;\n        }\n        if first_case_letter.is_empty()\
    \ {\n            first_case_letter = k.to_lowercase();\n        }\n        if\
    \ k.to_lowercase() != k {\n            return false;\n        }\n        if k\
    \ != k.to_uppercase() {\n            return false;\n        }\n        if k !=\
    \ first_case_letter && k != first_letter {\n            return false;\n      \
    \  }\n    }\n    true\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprwp54c3q.rs:24:9\n   |\n\
    24 |     for &(k, v) in iter.next() {\n   |         ^^^^^^^    ----------- this\
    \ expression has type `Option<(&String, &String)>`\n   |         |\n   |     \
    \    expected tuple, found reference\n   |\n   = note:  expected tuple `(&String,\
    \ &String)`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut s = String::new();\n    for\
    \ key in dict.keys() {\n        if !key.is_lower() && !key.is_upper() {\n    \
    \        return false;\n        }\n        s.append(key);\n    }\n    let mut\
    \ s = String::new();\n    for key in dict.keys() {\n        if !key.is_lower()\
    \ {\n            s.append(String::from(\"_\"));\n            s.append(key);\n\
    \        } else if !key.is_upper() {\n            s.append(String::from(\"_\"\
    ));\n            s.append(String::from(\"_\"));\n            s.append(key);\n\
    \        } else {\n            s.append(key);\n        }\n    }\n    !s.is_empty()\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lower` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmp6380pwmh.rs:20:17\n   |\n20 |         if\
    \ !key.is_lower() && !key.is_upper() {\n   |                 ^^^^^^^^ method not\
    \ found in `&String`\n\nerror[E0599]: no method named `is_upper` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmp6380pwmh.rs:20:36\n   |\n20 |\
    \         if !key.is_lower() && !key.is_upper() {\n   |                      \
    \              ^^^^^^^^ method not found in `&String`\n\nerror[E0599]: no method\
    \ named `append` found for struct `String` in the current scope\n  --> /tmp/tmp6380pwmh.rs:23:11\n\
    \   |\n23 |         s.append(key);\n   |           ^^^^^^ method not found in\
    \ `String`\n\nerror[E0599]: no method named `is_lower` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmp6380pwmh.rs:27:17\n   |\n27 |         if\
    \ !key.is_lower() {\n   |                 ^^^^^^^^ method not found in `&String`\n\
    \nerror[E0599]: no method named `append` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp6380pwmh.rs:28:15\n   |\n28 |             s.append(String::from(\"\
    _\"));\n   |               ^^^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `append` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmp6380pwmh.rs:29:15\n   |\n29 |             s.append(key);\n   |     \
    \          ^^^^^^ method not found in `String`\n\nerror[E0599]: no method named\
    \ `is_upper` found for reference `&String` in the current scope\n  --> /tmp/tmp6380pwmh.rs:30:24\n\
    \   |\n30 |         } else if !key.is_upper() {\n   |                        ^^^^^^^^\
    \ method not found in `&String`\n\nerror[E0599]: no method named `append` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmp6380pwmh.rs:31:15\n\
    \   |\n31 |             s.append(String::from(\"_\"));\n   |               ^^^^^^\
    \ method not found in `String`\n\nerror[E0599]: no method named `append` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmp6380pwmh.rs:32:15\n\
    \   |\n32 |             s.append(String::from(\"_\"));\n   |               ^^^^^^\
    \ method not found in `S"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    // 1. check keys\n    if dict.is_empty()\
    \ {\n        return false;\n    }\n    for value in dict.values() {\n        if\
    \ value.len() > MAX_DICT_VALUE_LEN {\n            return false;\n        }\n \
    \   }\n\n    // 2. check all values as string\n    let mut value_strings = vec![];\n\
    \    for value in dict.values() {\n        if !value_strings.contains(&value)\
    \ {\n            value_strings.push(value);\n        }\n    }\n    if value_strings.len()\
    \ != dict.len() {\n        return false;\n    }\n    for value in value_strings.iter()\
    \ {\n        if value.len() > MAX_DICT_VALUE_LEN {\n            return false;\n\
    \        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `MAX_DICT_VALUE_LEN` in this scope\n  -->\
    \ /tmp/tmprv7jrp3e.rs:23:26\n   |\n23 |         if value.len() > MAX_DICT_VALUE_LEN\
    \ {\n   |                          ^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find value `MAX_DICT_VALUE_LEN` in this scope\n  --> /tmp/tmprv7jrp3e.rs:39:26\n\
    \   |\n39 |         if value.len() > MAX_DICT_VALUE_LEN {\n   |              \
    \            ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.is_empty() || dict.values().all(|v|\
    \ v.is_lower())\n        || dict.values().all(|v| v.is_upper())\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lower` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmp4sps1eh0.rs:18:48\n   |\n18 |     dict.is_empty()\
    \ || dict.values().all(|v| v.is_lower())\n   |                               \
    \                 ^^^^^^^^ method not found in `&String`\n\nerror[E0599]: no method\
    \ named `is_upper` found for reference `&String` in the current scope\n  --> /tmp/tmp4sps1eh0.rs:19:36\n\
    \   |\n19 |         || dict.values().all(|v| v.is_upper())\n   |             \
    \                       ^^^^^^^^ method not found in `&String`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.keys().all(|key| {\n        key.to_lowercase()\
    \ == key.to_lowercase()\n    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpiwouc32s.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010965
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n\n    let mut lower = HashMap::new();\n    let mut upper = HashMap::new();\n\
    \n    for entry in dict.iter() {\n        if let (Some(s), Some(e)) = (entry.key(),\
    \ entry.value()) {\n            if s.chars().all(|c| c == c.to_ascii_lowercase())\
    \ {\n                lower.insert(s, e);\n            } else {\n             \
    \   upper.insert(s, e);\n            }\n        }\n    }\n\n    return !lower.is_empty()\
    \ && !upper.is_empty();\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `key` found for tuple `(&String, &String)`\
    \ in the current scope\n  --> /tmp/tmpz88rrj4d.rs:26:44\n   |\n26 |         if\
    \ let (Some(s), Some(e)) = (entry.key(), entry.value()) {\n   |              \
    \                              ^^^ method not found in `(&String, &String)`\n\n\
    error[E0599]: no method named `value` found for tuple `(&String, &String)` in\
    \ the current scope\n  --> /tmp/tmpz88rrj4d.rs:26:57\n   |\n26 |         if let\
    \ (Some(s), Some(e)) = (entry.key(), entry.value()) {\n   |                  \
    \                                       ^^^^^ method not found in `(&String, &String)`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.is_empty() || dict.values().all(|v|\
    \ v.chars().all(|c| *c == char::to_ascii_lowercase() || *c == char::to_ascii_uppercase()))\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpy9jy_tqc.rs:18:64\n\
    \   |\n18 |     dict.is_empty() || dict.values().all(|v| v.chars().all(|c| *c\
    \ == char::to_ascii_lowercase() || *c == char::to_ascii_uppercase()))\n   |  \
    \                                                              ^^\n\nerror[E0061]:\
    \ this function takes 1 argument but 0 arguments were supplied\n    --> /tmp/tmpy9jy_tqc.rs:18:70\n\
    \     |\n18   |     dict.is_empty() || dict.values().all(|v| v.chars().all(|c|\
    \ *c == char::to_ascii_lowercase() || *c == char::to_ascii_uppercase()))\n   \
    \  |                                                                      ^^^^^^^^^^^^^^^^^^^^^^^^--\
    \ supplied 0 arguments\n     |                                               \
    \                       |\n     |                                            \
    \                          expected 1 argument\n     |\nnote: associated function\
    \ defined here\n\nerror[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpy9jy_tqc.rs:18:100\n\
    \   |\n18 |     dict.is_empty() || dict.values().all(|v| v.chars().all(|c| *c\
    \ == char::to_ascii_lowercase() || *c == char::to_ascii_uppercase()))\n   |  \
    \                                                                            \
    \                      ^^\n\nerror[E0061]: this function takes 1 argument but\
    \ 0 arguments were supplied\n    --> /tmp/tmpy9jy_tqc.rs:18:106\n     |\n18  \
    \ |     dict.is_empty() || dict.values().all(|v| v.chars().all(|c| *c == char::to_ascii_lowercase()\
    \ || *c == char::to_ascii_uppercase()))\n     |                              \
    \                                                                            ^^^^^^^^^^^^^^^^^^^^^^^^--\
    \ supplied 0 arguments\n     |                                               \
    \                                                           |\n     |        \
    \                                                                            \
    \                      expected 1 argument\n     |\nnote: associated function\
    \ defined here\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0061, E0614.\nFor more"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n    let mut string_iter: HashMap<String, String>::Iter = dict.iter().cloned();\n\
    \    let mut current_key_str = String::from(\"\");\n    loop {\n        match\
    \ string_iter.next() {\n            Some((key, val)) => {\n                let\
    \ current_key_str = key.clone();\n                if current_key_str == String::from(\"\
    \") {\n                    string_iter.collect();\n                    return\
    \ true;\n                } else {\n                    string_iter.collect();\n\
    \                    current_key_str = String::from(\"\");\n                }\n\
    \            }\n            None => break\n        }\n    }\n    return false;\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0223]: ambiguous associated type\n  --> /tmp/tmpymza_knr.rs:21:26\n\
    \   |\n21 |     let mut string_iter: HashMap<String, String>::Iter = dict.iter().cloned();\n\
    \   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use fully-qualified\
    \ syntax: `<HashMap<String, String> as Trait>::Iter`\n\nerror[E0271]: type mismatch\
    \ resolving `<std::collections::hash_map::Iter<'_, String, String> as Iterator>::Item\
    \ == &_`\n    --> /tmp/tmpymza_knr.rs:21:70\n     |\n21   |     let mut string_iter:\
    \ HashMap<String, String>::Iter = dict.iter().cloned();\n     |              \
    \                                                        ^^^^^^ expected reference,\
    \ found tuple\n     |\n     = note: expected reference `&_`\n                \
    \    found tuple `(&String, &String)`\nnote: required by a bound in `cloned`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0223, E0271.\nFor more information about an error, try `rustc --explain E0223`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict\n        .iter()\n        .all(|(&key,\
    \ _)| key.chars().all(|c| c.is_lowercase()))\n        || dict\n            .iter()\n\
    \            .all(|(&key, _)| key.chars().all(|c| c.is_uppercase()))\n}\n\nfn\
    \ main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0507]: cannot move out of a shared reference\n  --> /tmp/tmpbmq2qbyd.rs:20:15\n\
    \   |\n20 |         .all(|(&key, _)| key.chars().all(|c| c.is_lowercase()))\n\
    \   |               ^^---^^^^\n   |                 |\n   |                 data\
    \ moved here\n   |                 move occurs because `key` has type `String`,\
    \ which does not implement the `Copy` trait\n\nerror[E0507]: cannot move out of\
    \ a shared reference\n  --> /tmp/tmpbmq2qbyd.rs:23:19\n   |\n23 |            \
    \ .all(|(&key, _)| key.chars().all(|c| c.is_uppercase()))\n   |              \
    \     ^^---^^^^\n   |                     |\n   |                     data moved\
    \ here\n   |                     move occurs because `key` has type `String`,\
    \ which does not implement the `Copy` trait\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0507`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n    for (_key, val) in dict {\n        match val.len() {\n  \
    \          2 => {\n                let lower = val.to_string().to_lowercase();\n\
    \                let upper = val.to_string().to_uppercase();\n               \
    \ if lower == upper {\n                    return true;\n                }\n \
    \           }\n            _ => {}\n        }\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp3luhjq8f.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010965
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lowercase: bool = false;\n \
    \   let mut uppercase: bool = false;\n\n    dict.into_iter().filter(|(_, val)|\
    \ val == String::from(\"_\")).count();\n    !dict.is_empty() && dict.keys().count()\
    \ == dict.len() && dict.values().count() == dict.len();\n    !dict.is_empty()\
    \ && dict.keys().count() == dict.len() && dict.values().count() == dict.len()\
    \ || \n        dict.keys().count() == dict.len() && dict.values().count() == dict.len()\
    \ && dict.keys().any(|key| key >= 'a' && key <= 'z') || \n        dict.keys().count()\
    \ == dict.len() && dict.values().count() == dict.len() && dict.keys().any(|key|\
    \ key >= 'A' && key <= 'Z');\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&String` with `String`\n  --> /tmp/tmpkk1jx10t.rs:21:44\n\
    \   |\n21 |     dict.into_iter().filter(|(_, val)| val == String::from(\"_\")).count();\n\
    \   |                                            ^^ no implementation for `&String\
    \ == String`\n   |\n   = help: the trait `PartialEq<String>` is not implemented\
    \ for `&String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpkk1jx10t.rs:24:114\n   |\n24 |         dict.keys().count()\
    \ == dict.len() && dict.values().count() == dict.len() && dict.keys().any(|key|\
    \ key >= 'a' && key <= 'z') || \n   |                                        \
    \                                                                          ^^^\
    \ expected `&String`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkk1jx10t.rs:24:128\n\
    \   |\n24 |         dict.keys().count() == dict.len() && dict.values().count()\
    \ == dict.len() && dict.keys().any(|key| key >= 'a' && key <= 'z') || \n   | \
    \                                                                            \
    \                                                   ^^^ expected `&String`, found\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkk1jx10t.rs:25:114\n\
    \   |\n25 |         dict.keys().count() == dict.len() && dict.values().count()\
    \ == dict.len() && dict.keys().any(|key| key >= 'A' && key <= 'Z');\n   |    \
    \                                                                            \
    \                                  ^^^ expected `&String`, found `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpkk1jx10t.rs:25:128\n   |\n25 |         dict.keys().count()\
    \ == dict.len() && dict.values().count() == dict."
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n    let mut keys = dict.get_keys();\n    for k in keys {\n  \
    \      let v = dict.get(k).unwrap();\n        match v.len() {\n            0 =>\
    \ return false,\n            _ => if v == k.to_lowercase() {\n               \
    \ return true,\n            }\n            _ => if v == k.to_uppercase() {\n \
    \               return true,\n            },\n        }\n    }\n    false\n}\n\
    \nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `,`\n\
    \  --> /tmp/tmpo5mlvfek.rs:27:28\n   |\n27 |                 return true,\n  \
    \ |                            ^ expected one of `.`, `;`, `?`, `}`, or an operator\n\
    \nerror: expected one of `.`, `;`, `?`, `}`, or an operator, found `,`\n  -->\
    \ /tmp/tmpo5mlvfek.rs:30:28\n   |\n30 |                 return true,\n   |   \
    \                         ^ expected one of `.`, `;`, `?`, `}`, or an operator\n\
    \nerror[E0599]: no method named `get_keys` found for struct `HashMap` in the current\
    \ scope\n  --> /tmp/tmpo5mlvfek.rs:21:25\n   |\n21 |     let mut keys = dict.get_keys();\n\
    \   |                         ^^^^^^^^ help: there is an associated function with\
    \ a similar name: `keys`\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    match dict.len() {\n        0 => false,\n\
    \        1 => true,\n        _ => {\n            let mut iter = dict.iter().keys().peekable();\n\
    \            let mut cur = iter.next();\n            let mut next_key = String::from(\"\
    \");\n            let mut next_val = String::from(\"\");\n            while cur.peek()\
    \ != Some(&next_key) {\n                let mut next_key = String::from(\"\");\n\
    \                let mut next_val = String::from(\"\");\n                while\
    \ cur.peek() != Some(&next_key) {\n                    let next_key_ = cur.get_mut();\n\
    \                    let next_key_ = next_key_.unwrap();\n                   \
    \ if !next_key_.is_empty() {\n                        next_key = next_key_;\n\
    \                    }\n                    cur = iter.next();\n             \
    \   }\n                let next_val_ = cur.get_mut();\n                let next_val_\
    \ = next_val_.unwrap();\n                if !next_val_.is_empty() {\n        \
    \            next_val = next_val_;\n                }\n            }\n       \
    \     if next_val == String::from(\"UPPER\") {\n                return true\n\
    \            } else if next_val == String::from(\"LOWER\") {\n               \
    \ return true\n            } else {\n                return false\n          \
    \  }\n        }\n    }\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `keys` found for struct `std::collections::hash_map::Iter`\
    \ in the current scope\n  --> /tmp/tmpbemef4i4.rs:22:40\n   |\n22 |          \
    \   let mut iter = dict.iter().keys().peekable();\n   |                      \
    \                  ^^^^ method not found in `std::collections::hash_map::Iter<'_,\
    \ String, String>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    // Your code here\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjiilw673.rs:17:54\n   |\n\
    17 | fn check_dict_case(dict: HashMap<String, String>) -> bool {\n   |    ---------------\
    \                                   ^^^^ expected `bool`, found `()`\n   |   \
    \ |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if let Ok(mut iter) = dict.iter() {\n\
    \        // We always try to iterate over all elements of the map.\n        //\
    \ If we succeed in iterating over all the elements, then all\n        // keys\
    \ are strings in lower case.\n        match iter.next() {\n            Some(Some(value))\
    \ if value.is_string() && value.to_lowercase() == value => true,\n           \
    \ Some(None) => false,\n            None => false,\n        }\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgdmjbi9e.rs:18:12\n   |\n\
    18 |     if let Ok(mut iter) = dict.iter() {\n   |            ^^^^^^^^^^^^   -----------\
    \ this expression has type `std::collections::hash_map::Iter<'_, String, String>`\n\
    \   |            |\n   |            expected struct `std::collections::hash_map::Iter`,\
    \ found enum `Result`\n   |\n   = note: expected struct `std::collections::hash_map::Iter<'_,\
    \ String, String>`\n                found enum `Result<_, _>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpgdmjbi9e.rs:22:9\n   |\n18 |  /     if let Ok(mut\
    \ iter) = dict.iter() {\n19 |  |         // We always try to iterate over all\
    \ elements of the map.\n20 |  |         // If we succeed in iterating over all\
    \ the elements, then all\n21 |  |         // keys are strings in lower case.\n\
    22 | /|         match iter.next() {\n23 | ||             Some(Some(value)) if\
    \ value.is_string() && value.to_lowercase() == value => true,\n24 | ||       \
    \      Some(None) => false,\n25 | ||             None => false,\n26 | ||     \
    \    }\n   | ||_________^ expected `()`, found `bool`\n27 |  |     }\n   |  |_____-\
    \ expected this to be `()`\n   |\nhelp: consider using a semicolon here\n   |\n\
    26 |         };\n   |          +\nhelp: consider using a semicolon here\n   |\n\
    27 |     };\n   |      +\nhelp: you might have meant to return this value\n  \
    \ |\n22 ~         return match iter.next() {\n23 |             Some(Some(value))\
    \ if value.is_string() && value.to_lowercase() == value => true,\n24 |       \
    \      Some(None) => false,\n25 |             None => false,\n26 ~         };\n\
    \   |\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut found = false;\n    for elem\
    \ in dict.iter() {\n        match elem.key() {\n            String::from(\"lower\"\
    ) => found = !elem.is_lowercase(),\n            String::from(\"upper\") => found\
    \ = !elem.is_uppercase(),\n            String::from(_) => {}\n        }\n    }\n\
    \    found\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `key` found for tuple `(&String, &String)`\
    \ in the current scope\n  --> /tmp/tmpmq8ymlo5.rs:20:20\n   |\n20 |         match\
    \ elem.key() {\n   |                    ^^^ method not found in `(&String, &String)`\n\
    \nerror[E0164]: expected tuple struct or tuple variant, found associated function\
    \ `String::from`\n  --> /tmp/tmpmq8ymlo5.rs:21:13\n   |\n21 |             String::from(\"\
    lower\") => found = !elem.is_lowercase(),\n   |             ^^^^^^^^^^^^^^^^^^^^^\
    \ `fn` calls are not allowed in patterns\n   |\n   = help: for more information,\
    \ visit https://doc.rust-lang.org/book/ch18-00-patterns.html\n\nerror[E0164]:\
    \ expected tuple struct or tuple variant, found associated function `String::from`\n\
    \  --> /tmp/tmpmq8ymlo5.rs:22:13\n   |\n22 |             String::from(\"upper\"\
    ) => found = !elem.is_uppercase(),\n   |             ^^^^^^^^^^^^^^^^^^^^^ `fn`\
    \ calls are not allowed in patterns\n   |\n   = help: for more information, visit\
    \ https://doc.rust-lang.org/book/ch18-00-patterns.html\n\nerror[E0164]: expected\
    \ tuple struct or tuple variant, found associated function `String::from`\n  -->\
    \ /tmp/tmpmq8ymlo5.rs:23:13\n   |\n23 |             String::from(_) => {}\n  \
    \ |             ^^^^^^^^^^^^^^^ `fn` calls are not allowed in patterns\n   |\n\
    \   = help: for more information, visit https://doc.rust-lang.org/book/ch18-00-patterns.html\n\
    \nerror[E0599]: no method named `is_lowercase` found for tuple `(&String, &String)`\
    \ in the current scope\n  --> /tmp/tmpmq8ymlo5.rs:21:52\n   |\n21 |          \
    \   String::from(\"lower\") => found = !elem.is_lowercase(),\n   |           \
    \                                         ^^^^^^^^^^^^ method not found in `(&String,\
    \ &String)`\n\nerror[E0599]: no method named `is_uppercase` found for tuple `(&String,\
    \ &String)` in the current scope\n  --> /tmp/tmpmq8ymlo5.rs:22:52\n   |\n22 |\
    \             String::from(\"upper\") => found = !elem.is_uppercase(),\n   | \
    \                                                   ^^^^^^^^^^^^ method not found\
    \ in `(&String, &String)`\n\nerror: aborting due to 6 previous errors\n\nSome\
    \ errors have detailed "
  stdout: ''
  timestamp: 1660010964
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    !dict.is_empty() && \n    (dict.keys().all(|key|\
    \ \n        key.to_string().to_lowercase() == key.to_string().to_lowercase()\n\
    \    ) || \n    dict.keys().all(|key| \n        key.to_string().to_uppercase()\
    \ == key.to_string().to_uppercase()\n    ))\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp9mg8pwhd.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010965
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    match dict.len() {\n        0 => false,\n\
    \        1 => dict.contains_key(String::from(dict.values().next())),\n       \
    \ _ => dict.values().into_iter().all(|v| v.to_lowercase() == dict.values().next().to_lowercase())\n\
    \    }\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `String: From<Option<&String>>` is not satisfied\n\
    \  --> /tmp/tmpb6i1wykp.rs:20:45\n   |\n20 |         1 => dict.contains_key(String::from(dict.values().next())),\n\
    \   |                                ------------ ^^^^^^^^^^^^^^^^^^^^ the trait\
    \ `From<Option<&String>>` is not implemented for `String`\n   |              \
    \                  |\n   |                                required by a bound\
    \ introduced by this call\n   |\n   = help: the following other types implement\
    \ trait `From<T>`:\n             <String as From<&String>>\n             <String\
    \ as From<&mut str>>\n             <String as From<&str>>\n             <String\
    \ as From<Box<str>>>\n             <String as From<Cow<'a, str>>>\n          \
    \   <String as From<char>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb6i1wykp.rs:20:32\n\
    \   |\n20 |         1 => dict.contains_key(String::from(dict.values().next())),\n\
    \   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\
    \                                |\n   |                                expected\
    \ reference, found struct `String`\n   |                                help:\
    \ consider borrowing here: `&String::from(dict.values().next())`\n   |\n   = note:\
    \ expected reference `&_`\n                 found struct `String`\n\nerror[E0599]:\
    \ no method named `to_lowercase` found for enum `Option` in the current scope\n\
    \  --> /tmp/tmpb6i1wykp.rs:21:89\n   |\n21 |         _ => dict.values().into_iter().all(|v|\
    \ v.to_lowercase() == dict.values().next().to_lowercase())\n   |             \
    \                                                                            ^^^^^^^^^^^^\
    \ method not found in `Option<&String>`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    !dict.keys().any(|key| key.len() !=\
    \ key.to_lowercase().len() || key.len() != key.to_uppercase().len())\n}\n\nfn\
    \ main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpdp2qryrj.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010965
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    match dict.len() {\n        0 => true,\n\
    \        _ => dict.iter().all(|(k, _)| k.to_lowercase() == k),\n    }\n}\n\nfn\
    \ main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `String` with `&String`\n  --> /tmp/tmpy8w74z6x.rs:20:56\n\
    \   |\n20 |         _ => dict.iter().all(|(k, _)| k.to_lowercase() == k),\n  \
    \ |                                                        ^^ no implementation\
    \ for `String == &String`\n   |\n   = help: the trait `PartialEq<&String>` is\
    \ not implemented for `String`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for k in\
    \ keys.unwrap() {\n        if !k.to_lowercase().is_ascii() {\n            return\
    \ false;\n        }\n        if !k.to_uppercase().is_ascii() {\n            return\
    \ false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap` found for struct `std::collections::hash_map::Keys`\
    \ in the current scope\n  --> /tmp/tmpdl5rxekn.rs:19:19\n   |\n19 |     for k\
    \ in keys.unwrap() {\n   |                   ^^^^^^ method not found in `std::collections::hash_map::Keys<'_,\
    \ String, String>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n\n    for key_v in dict.keys() {\n        let key_str = key_v.unwrap();\n\
    \        if key_str.is_lowercase() || key_str.is_uppercase() {\n            return\
    \ true;\n        }\n    }\n    \n    return false;\n}\n\nfn main() {\n    let\
    \ candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap` found for reference `&String` in\
    \ the current scope\n  --> /tmp/tmpjuu3m56e.rs:23:29\n   |\n23 |         let key_str\
    \ = key_v.unwrap();\n   |                             ^^^^^^ method not found\
    \ in `&String`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.len() == 0 {\n        return\
    \ false;\n    }\n\n    for entry in dict.iter() {\n        let key = entry.key().to_lowercase();\n\
    \        let value = entry.value().to_lowercase();\n        if !key.starts_with('\\\
    A') && !key.starts_with('\\z') && !value.starts_with('\\A') && !value.starts_with('\\\
    z') {\n            return false;\n        }\n    }\n\n    true\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error: unknown character escape: `A`\n  --> /tmp/tmpmm2i2nhg.rs:25:31\n\
    \   |\n25 |         if !key.starts_with('\\A') && !key.starts_with('\\z') && !value.starts_with('\\\
    A') && !value.starts_with('\\z') {\n   |                               ^ unknown\
    \ character escape\n   |\n   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\n\
    help: if you meant to write a literal backslash (perhaps escaping in a regular\
    \ expression), consider a raw string literal\n   |\n25 |         if !key.starts_with(r\"\
    \\A\") && !key.starts_with('\\z') && !value.starts_with('\\A') && !value.starts_with('\\\
    z') {\n   |                             ~~~~~\n\nerror: unknown character escape:\
    \ `z`\n  --> /tmp/tmpmm2i2nhg.rs:25:57\n   |\n25 |         if !key.starts_with('\\\
    A') && !key.starts_with('\\z') && !value.starts_with('\\A') && !value.starts_with('\\\
    z') {\n   |                                                         ^ unknown\
    \ character escape\n   |\n   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\n\
    help: if you meant to write a literal backslash (perhaps escaping in a regular\
    \ expression), consider a raw string literal\n   |\n25 |         if !key.starts_with('\\\
    A') && !key.starts_with(r\"\\z\") && !value.starts_with('\\A') && !value.starts_with('\\\
    z') {\n   |                                                       ~~~~~\n\nerror:\
    \ unknown character escape: `A`\n  --> /tmp/tmpmm2i2nhg.rs:25:85\n   |\n25 | \
    \        if !key.starts_with('\\A') && !key.starts_with('\\z') && !value.starts_with('\\\
    A') && !value.starts_with('\\z') {\n   |                                     \
    \                                                ^ unknown character escape\n\
    \   |\n   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\n\
    help: if you meant to write a literal backslash (perhaps escaping in a regular\
    \ expression), consider a raw string literal\n   |\n25 |         if !key.starts_with('\\\
    A') && !key.starts_with('\\z') && !value.starts_with(r\"\\A\") && !value.starts_with('\\\
    z') {\n  "
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    match dict {\n        HashMap::Nil =>\
    \ false,\n        HashMap::from(inner) if inner.len() == 0 => false,\n       \
    \ HashMap::from(inner) => inner.iter().all(|&(k, v)| k.len() == v.length()),\n\
    \    }\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no associated item named `Nil` found for struct `HashMap`\
    \ in the current scope\n  --> /tmp/tmpzjjeuftk.rs:19:18\n   |\n19 |         HashMap::Nil\
    \ => false,\n   |                  ^^^ associated item not found in `HashMap<_,\
    \ _, _>`\n\nerror[E0164]: expected tuple struct or tuple variant, found associated\
    \ function `HashMap::from`\n  --> /tmp/tmpzjjeuftk.rs:20:9\n   |\n20 |       \
    \  HashMap::from(inner) if inner.len() == 0 => false,\n   |         ^^^^^^^^^^^^^^^^^^^^\
    \ `fn` calls are not allowed in patterns\n   |\n   = help: for more information,\
    \ visit https://doc.rust-lang.org/book/ch18-00-patterns.html\n\nerror[E0164]:\
    \ expected tuple struct or tuple variant, found associated function `HashMap::from`\n\
    \  --> /tmp/tmpzjjeuftk.rs:21:9\n   |\n21 |         HashMap::from(inner) => inner.iter().all(|&(k,\
    \ v)| k.len() == v.length()),\n   |         ^^^^^^^^^^^^^^^^^^^^ `fn` calls are\
    \ not allowed in patterns\n   |\n   = help: for more information, visit https://doc.rust-lang.org/book/ch18-00-patterns.html\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0164, E0599.\nFor more information about an error, try `rustc --explain E0164`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n    for k in dict.keys() {\n        if !k.is_lowercase() {\n\
    \            return false;\n        }\n    }\n    for k in dict.keys() {\n   \
    \     if !k.is_uppercase() {\n            return false;\n        }\n    }\n  \
    \  true\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpp5tafh7y.rs:22:15\n   |\n22 |         if\
    \ !k.is_lowercase() {\n   |               ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named\
    \ `is_uppercase` found for reference `&String` in the current scope\n  --> /tmp/tmpp5tafh7y.rs:27:15\n\
    \   |\n27 |         if !k.is_uppercase() {\n   |               ^^^^^^^^^^^^ help:\
    \ there is an associated function with a similar name: `to_uppercase`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.contains_key(\"Name\") && dict.contains_key(\"\
    Age\") && dict.contains_key(\"City\") && dict.contains_key(\"State\") && dict.contains_key(\"\
    ZIP\")\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp3mow4bhb.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010965
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       match key.as_str() {\n            Ok(s) => s.as_bytes()\n            \
    \    .iter()\n                .all(|c| c == b'a' || c == b'A'),\n            Err(_)\
    \ => false,\n        }\n    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpq8ee10xm.rs:20:13\n   |\n\
    19 |         match key.as_str() {\n   |               ------------ this expression\
    \ has type `&str`\n20 |             Ok(s) => s.as_bytes()\n   |             ^^^^^\
    \ expected `str`, found enum `Result`\n   |\n   = note: expected type `str`\n\
    \              found enum `Result<_, _>`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpq8ee10xm.rs:23:13\n   |\n19 |         match key.as_str() {\n   |\
    \               ------------ this expression has type `&str`\n...\n23 |      \
    \       Err(_) => false,\n   |             ^^^^^^ expected `str`, found enum `Result`\n\
    \   |\n   = note: expected type `str`\n              found enum `Result<_, _>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    !dict.is_empty() && \n    dict.iter().all(|(key,\
    \ value)| {\n        let (lower, _) = key.to_string().to_lowercase();\n      \
    \  let (_, upper) = key.to_string().to_uppercase();\n        lower\n         \
    \   .eq_ignore_ascii_case(upper)\n            || \n            upper\n       \
    \     .eq_ignore_ascii_case(lower)\n    })\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpn3fip3_1.rs:20:13\n   |\n\
    20 |         let (lower, _) = key.to_string().to_lowercase();\n   |          \
    \   ^^^^^^^^^^   ------------------------------ this expression has type `String`\n\
    \   |             |\n   |             expected struct `String`, found tuple\n\
    \   |\n   = note: expected struct `String`\n               found tuple `(_, _)`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpn3fip3_1.rs:21:13\n   |\n21 |\
    \         let (_, upper) = key.to_string().to_uppercase();\n   |             ^^^^^^^^^^\
    \   ------------------------------ this expression has type `String`\n   |   \
    \          |\n   |             expected struct `String`, found tuple\n   |\n \
    \  = note: expected struct `String`\n               found tuple `(_, _)`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.len() == 0 {\n        return\
    \ false;\n    }\n\n    let mut first_key = String::from(\"\");\n    for (k, _)\
    \ in dict.iter() {\n        if k.len() > first_key.len() {\n            first_key\
    \ = k;\n        }\n    }\n\n    let mut first_val = String::from(\"\");\n    for\
    \ (k, v) in dict.iter() {\n        if v.len() > first_val.len() {\n          \
    \  first_val = v;\n        }\n    }\n\n    first_key == first_val\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0cyk60tz.rs:25:25\n   |\n\
    22 |     let mut first_key = String::from(\"\");\n   |                       \
    \  ---------------- expected due to this value\n...\n25 |             first_key\
    \ = k;\n   |                         ^- help: try using a conversion method: `.to_string()`\n\
    \   |                         |\n   |                         expected struct\
    \ `String`, found `&String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0cyk60tz.rs:32:25\n\
    \   |\n29 |     let mut first_val = String::from(\"\");\n   |                \
    \         ---------------- expected due to this value\n...\n32 |             first_val\
    \ = v;\n   |                         ^- help: try using a conversion method: `.to_string()`\n\
    \   |                         |\n   |                         expected struct\
    \ `String`, found `&String`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.is_empty() || dict.len() == dict.len()\
    \ && dict.values().iter().all(|x| x.is_string())\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `std::collections::hash_map::Values`\
    \ in the current scope\n  --> /tmp/tmpbjc9_tx1.rs:18:66\n   |\n18 |     dict.is_empty()\
    \ || dict.len() == dict.len() && dict.values().iter().all(|x| x.is_string())\n\
    \   |                                                                  ^^^^ method\
    \ not found in `std::collections::hash_map::Values<'_, String, String>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    match dict.len() {\n        0 => true,\n\
    \        _ => false\n    }\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpq046fe0q.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010965
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    match dict.len() {\n        0 => true,\n\
    \        1 => true,\n        _ => false,\n    }\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpgt6fxlpp.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010965
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    match dict.len() {\n        0 => false,\
    \ // empty dictionary\n        _ => true,\n    }\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpjx_j4zhn.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010965
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.len() == 0 {\n        return\
    \ false;\n    }\n    for (k, _) in dict {\n        if k.to_lowercase() == k {\n\
    \            continue;\n        }\n        if k.to_uppercase() == k {\n      \
    \      continue;\n        }\n        return false;\n    }\n    return true;\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpndu_p9qz.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010965
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.is_empty() || dict.keys().all(|&key|\
    \ key.casecmp(String::from(\"age\")) == 0 || key.casecmp(String::from(\"age\"\
    )) == 0)\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `casecmp` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp3zyu2f1w.rs:18:51\n   |\n18 |     dict.is_empty()\
    \ || dict.keys().all(|&key| key.casecmp(String::from(\"age\")) == 0 || key.casecmp(String::from(\"\
    age\")) == 0)\n   |                                                   ^^^^^^^\
    \ method not found in `String`\n\nerror[E0599]: no method named `casecmp` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmp3zyu2f1w.rs:18:92\n\
    \   |\n18 |     dict.is_empty() || dict.keys().all(|&key| key.casecmp(String::from(\"\
    age\")) == 0 || key.casecmp(String::from(\"age\")) == 0)\n   |               \
    \                                                                            \
    \ ^^^^^^^ method not found in `String`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.keys().all(|key| key.to_lowercase()\
    \ == key)\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `String` with `&String`\n  --> /tmp/tmpmrqizc97.rs:18:46\n\
    \   |\n18 |     dict.keys().all(|key| key.to_lowercase() == key)\n   |       \
    \                                       ^^ no implementation for `String == &String`\n\
    \   |\n   = help: the trait `PartialEq<&String>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut keys = dict.keys();\n\n    if\
    \ keys.is_empty() {\n        return false;\n    }\n\n    for key in keys {\n \
    \       if let Ok(value) = dict.get_mut(key) {\n            match value {\n  \
    \              Some(value) => {\n                    if let Ok(str_val) = value.to_string()\
    \ {\n                        if str_val.to_lowercase() == str_val {\n        \
    \                    return true;\n                        }\n               \
    \     }\n                }\n                None => {}\n            }\n      \
    \  }\n    }\n\n    false\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0658]: use of unstable library feature 'exact_size_is_empty'\n \
    \ --> /tmp/tmpy_zghuyp.rs:20:13\n   |\n20 |     if keys.is_empty() {\n   |   \
    \          ^^^^^^^^\n   |\n   = note: see issue #35428 <https://github.com/rust-lang/rust/issues/35428>\
    \ for more information\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpy_zghuyp.rs:25:16\n\
    \   |\n25 |         if let Ok(value) = dict.get_mut(key) {\n   |             \
    \   ^^^^^^^^^   ----------------- this expression has type `Option<&mut String>`\n\
    \   |                |\n   |                expected enum `Option`, found enum\
    \ `Result`\n   |\n   = note: expected enum `Option<&mut String>`\n           \
    \   found enum `Result<_, _>`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0658.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n    for k in dict.keys() {\n        match k.to_lowercase() {\n\
    \            \"a\" | \"A\" => return true,\n            \"b\" | \"B\" => return\
    \ true,\n            \"c\" | \"C\" => return true,\n            \"d\" | \"D\"\
    \ => return true,\n            \"e\" | \"E\" => return true,\n            \"f\"\
    \ | \"F\" => return true,\n            \"g\" | \"G\" => return true,\n       \
    \     \"h\" | \"H\" => return true,\n            \"i\" | \"I\" => return true,\n\
    \            \"j\" | \"J\" => return true,\n            \"k\" | \"K\" => return\
    \ true,\n            \"l\" | \"L\" => return true,\n            \"m\" | \"M\"\
    \ => return true,\n            \"n\" | \"N\" => return true,\n            \"o\"\
    \ | \"O\" => return true,\n            \"p\" | \"P\" => return true,\n       \
    \     \"q\" | \"Q\" => return true,\n            \"r\" | \"R\" => return true,\n\
    \            \"s\" | \"S\" => return true,\n            \"t\" | \"T\" => return\
    \ true,\n            \"u\" | \"U\" => return true,\n            \"v\" | \"V\"\
    \ => return true,\n            \"w\" | \"W\" => return true,\n            \"x\"\
    \ | \"X\" => return true,\n            \"y\" | \"Y\" => return true,\n       \
    \     \"z\" | \"Z\" => return true,\n            _ => return false,\n        }\n\
    \        match k.to_uppercase() {\n            \"A\" | \"a\" => return true,\n\
    \            \"B\" | \"b\" => return true,\n            \"C\" | \"c\" => return\
    \ true,\n            \"D\" | \"d\" => return true,\n            \"E\" | \"e\"\
    \ => return true,\n            \"F\" | \"f\" => return true,\n            \"G\"\
    \ | \"g\" => return true,\n            \"H\" | \"h\" => return true,\n       \
    \     \"I\" | \"i\" => return true,\n            \"J\" | \"j\" => return true,\n\
    \            \"K\" | \"k\" => return true,\n            \"L\" | \"l\" => return\
    \ true,\n            \"M\" | \"m\" => return true,\n            \"N\" | \"n\"\
    \ => return true,\n            \"O\" | \"o\" => return true,\n            \"P\"\
    \ | \"p\" => return true,\n            \"Q\" | \"q\" => return true,\n       \
    \     \"R\" | \"r\" => return true,\n            \"S\" | \"s\" => return true,\n\
    \            \"T\" | \"t\" => return true,\n            \"U\" | \"u\" => return\
    \ true,\n            \"V\" | \"v\" => return true,\n            \"W\" | \"w\"\
    \ => return true,\n            \"X\" | \"x\" => return true,\n            \"Y\"\
    \ | \"y\" => return true,\n            \"Z\" | \"z\" => return true,\n       \
    \     _ => return false,\n        }\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpbjnaykkx.rs:91:3\n\
    \   |\n17 | fn check_dict_case(dict: HashMap<String, String>) -> bool {\n   |\
    \                                                           - unclosed delimiter\n\
    ...\n21 |     for k in dict.keys() {\n   |                          - this delimiter\
    \ might not be properly closed...\n...\n80 | }\n   | - ...as it matches this but\
    \ it has different indentation\n...\n91 | }\n   |   ^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpbjnaykkx.rs:23:13\n   |\n22 |         match k.to_lowercase()\
    \ {\n   |               ---------------- this expression has type `String`\n23\
    \ |             \"a\" | \"A\" => return true,\n   |             ^^^ expected struct\
    \ `String`, found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbjnaykkx.rs:23:19\n\
    \   |\n22 |         match k.to_lowercase() {\n   |               ----------------\
    \ this expression has type `String`\n23 |             \"a\" | \"A\" => return\
    \ true,\n   |                   ^^^ expected struct `String`, found `&str`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpbjnaykkx.rs:24:13\n   |\n22 |  \
    \       match k.to_lowercase() {\n   |               ---------------- this expression\
    \ has type `String`\n23 |             \"a\" | \"A\" => return true,\n24 |    \
    \         \"b\" | \"B\" => return true,\n   |             ^^^ expected struct\
    \ `String`, found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbjnaykkx.rs:24:19\n\
    \   |\n22 |         match k.to_lowercase() {\n   |               ----------------\
    \ this expression has type `String`\n23 |             \"a\" | \"A\" => return\
    \ true,\n24 |             \"b\" | \"B\" => return true,\n   |                \
    \   ^^^ expected struct `String`, found `&str`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpbjnaykkx.rs:25:13\n   |\n22 |         match k.to_lowercase() {\n\
    \   |               ---------------- this expression has type `String`\n...\n\
    25 |             \"c\" | \"C\" => return true,\n   |             ^^^ expected\
    \ struct `String`, found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbjnaykkx.rs:25:19\n\
    \   |\n22 |         match k.to_lowercase() "
  stdout: ''
  timestamp: 1660010964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.is_empty() || dict.values().iter().all(|x|\
    \ x.is_str())\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `std::collections::hash_map::Values`\
    \ in the current scope\n  --> /tmp/tmpavkf5tbc.rs:18:38\n   |\n18 |     dict.is_empty()\
    \ || dict.values().iter().all(|x| x.is_str())\n   |                          \
    \            ^^^^ method not found in `std::collections::hash_map::Values<'_,\
    \ String, String>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010964
