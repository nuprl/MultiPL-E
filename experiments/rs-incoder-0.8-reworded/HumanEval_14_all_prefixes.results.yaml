language: rs
name: HumanEval_14_all_prefixes
results:
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    if string.is_empty() {\n        vec![]\n    } else {\n\
    \        let mut prefix = String::from(\"\");\n        prefix.push_str(&string[0]);\n\
    \        let mut out = vec![];\n        for s in string.chars().take(string.len()\
    \ - 1) {\n            let s = prefix.clone();\n            prefix.push_str(&s[1..]);\n\
    \            let new_s = prefix.clone();\n            out.push((s, new_s));\n\
    \        }\n        out\n    }\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n -->\
    \ /tmp/tmpg1j0osf6.rs:9:26\n  |\n9 |         prefix.push_str(&string[0]);\n  |\
    \                          ^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \  |\n  = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \   <String as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n\
    \            <String as Index<RangeInclusive<usize>>>\n            <String as\
    \ Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpg1j0osf6.rs:17:9\n   |\n4  | fn\
    \ all_prefixes(string: String) -> Vec<String> {\n   |                        \
    \            ----------- expected `Vec<String>` because of return type\n...\n\
    17 |         out\n   |         ^^^ expected struct `String`, found tuple\n   |\n\
    \   = note: expected struct `Vec<String>`\n              found struct `Vec<(String,\
    \ String)>`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    string.chars().collect::<Vec<String>>().into_iter()\n\
    \        .take_while(|&c| c.is_ascii_alphanumeric())\n        .collect()\n}\n\n\
    fn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmpezrob9rv.rs:5:20\n     |\n5  \
    \  |     string.chars().collect::<Vec<String>>().into_iter()\n     |         \
    \           ^^^^^^^ value of type `Vec<String>` cannot be built from `std::iter::Iterator<Item=char>`\n\
    \     |\n     = help: the trait `FromIterator<char>` is not implemented for `Vec<String>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0599]: no method named `is_ascii_alphanumeric`\
    \ found for struct `String` in the current scope\n --> /tmp/tmpezrob9rv.rs:6:28\n\
    \  |\n6 |         .take_while(|&c| c.is_ascii_alphanumeric())\n  |           \
    \                 ^^^^^^^^^^^^^^^^^^^^^ method not found in `String`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut result = Vec::new();\n    let mut prefix = String::from(\"\
    \");\n    for (i, c) in string.chars().enumerate() {\n        if i != 0 {\n  \
    \          result.push(prefix);\n            prefix = String::from(\"\");\n  \
    \      }\n        prefix += &c.to_string();\n    }\n    result.push(prefix)\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkgl9r_ny.rs:14:5\n   |\n\
    4  | fn all_prefixes(string: String) -> Vec<String> {\n   |                  \
    \                  ----------- expected `Vec<String>` because of return type\n\
    ...\n14 |     result.push(prefix)\n   |     ^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `Vec`, found `()`\n   |\n   = note: expected struct `Vec<String>`\n        \
    \   found unit type `()`\nnote: method `push` modifies its receiver in-place\n\
    \  --> /tmp/tmpkgl9r_ny.rs:14:12\n   |\n14 |     result.push(prefix)\n   |   \
    \  ------ ^^^^ this call modifies `result` in-place\n   |     |\n   |     you\
    \ probably want to use this value after calling the method...\n   = note: ...instead\
    \ of the `()` output of method `push`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 101
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    string\n        .split_whitespace()\n        .map(|s|\
    \ s.to_owned())\n        .collect()\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"asdfgh\"]`,\n right: `[\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"\
    ]`', /tmp/tmptjv52kov.rs:14:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut prefix = vec![\"\"];\n    for c in string.chars()\
    \ {\n        prefix.push(String::from(c));\n    }\n    prefix.iter().rev().collect::<Vec<String>>()\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpwdgyip86.rs:7:21\n  |\n7 |\
    \         prefix.push(String::from(c));\n  |                     ^^^^^^^^^^^^^^^\n\
    \  |                     |\n  |                     expected `&str`, found struct\
    \ `String`\n  |                     help: consider borrowing here: `&String::from(c)`\n\
    \nerror[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&&str`\n    --> /tmp/tmpwdgyip86.rs:9:25\n     |\n9 \
    \   |     prefix.iter().rev().collect::<Vec<String>>()\n     |               \
    \          ^^^^^^^ value of type `Vec<String>` cannot be built from `std::iter::Iterator<Item=&&str>`\n\
    \     |\n     = help: the trait `FromIterator<&&str>` is not implemented for `Vec<String>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    all_prefixes_iter(string).collect()\n}\n\nfn main() {\n\
    \    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\"\
    )), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\")),\
    \ vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `all_prefixes_iter` in this scope\n\
    \ --> /tmp/tmprq83cmmp.rs:5:5\n  |\n5 |     all_prefixes_iter(string).collect()\n\
    \  |     ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut prefix = vec![];\n\n    for c in string.chars()\
    \ {\n        prefix.push(c)?;\n    }\n    prefix\n}\n\nfn main() {\n    let candidate\
    \ = all_prefixes;\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"asdfgh\")), vec![String::from(\"a\"),\
    \ String::from(\"as\"), String::from(\"asd\"), String::from(\"asdf\"), String::from(\"\
    asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the `?` operator can only be applied to values that implement\
    \ `Try`\n --> /tmp/tmpp0fwfv_p.rs:8:9\n  |\n8 |         prefix.push(c)?;\n  |\
    \         ^^^^^^^^^^^^^^^ the `?` operator cannot be applied to type `()`\n  |\n\
    \  = help: the trait `Try` is not implemented for `()`\n\nerror[E0277]: the `?`\
    \ operator can only be used in a function that returns `Result` or `Option` (or\
    \ another type that implements `FromResidual`)\n  --> /tmp/tmpp0fwfv_p.rs:8:23\n\
    \   |\n4  | / fn all_prefixes(string: String) -> Vec<String> {\n5  | |     let\
    \ mut prefix = vec![];\n6  | |\n7  | |     for c in string.chars() {\n8  | | \
    \        prefix.push(c)?;\n   | |                       ^ cannot use the `?` operator\
    \ in a function that returns `Vec<String>`\n9  | |     }\n10 | |     prefix\n\
    11 | | }\n   | |_- this function should return `Result` or `Option` to accept\
    \ `?`\n   |\n   = help: the trait `FromResidual<_>` is not implemented for `Vec<String>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpp0fwfv_p.rs:10:5\n   |\n4  | fn\
    \ all_prefixes(string: String) -> Vec<String> {\n   |                        \
    \            ----------- expected `Vec<String>` because of return type\n...\n\
    10 |     prefix\n   |     ^^^^^^ expected struct `String`, found `char`\n   |\n\
    \   = note: expected struct `Vec<String>`\n              found struct `Vec<char>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    string\n        .iter()\n        .filter_map(|&c| c.chars().enumerate().filter_map(|(_,\
    \ i)| {\n            if i < 0 {\n                None\n            } else {\n\
    \                Some(\n                    String::from(input::chars::take_prefix(string,\
    \ i)),\n                )\n            }\n        }))\n        .collect()\n}\n\
    \nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `input`\n\
    \  --> /tmp/tmprs2ajy2u.rs:12:34\n   |\n12 |                     String::from(input::chars::take_prefix(string,\
    \ i)),\n   |                                  ^^^^^ use of undeclared crate or\
    \ module `input`\n\nerror[E0599]: no method named `iter` found for struct `String`\
    \ in the current scope\n --> /tmp/tmprs2ajy2u.rs:6:10\n  |\n6 |         .iter()\n\
    \  |          ^^^^ method not found in `String`\n  |\nhelp: because of the in-memory\
    \ representation of `&str`, to obtain an `Iterator` over each of its codepoint\
    \ use method `chars`\n  |\n6 |         .chars()\n  |          ~~~~~\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut prefix = Vec::new();\n    let mut string = string;\n\
    \    while string.len() > 0 {\n        prefix.push(string.as_str().to_owned());\n\
    \        string = &string.chars().skip(1).collect::<String>().to_string();\n \
    \   }\n    prefix\n}\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpgehbqrjr.rs:9:18\n  |\n6 |\
    \     let mut string = string;\n  |                      ------ expected due to\
    \ this value\n...\n9 |         string = &string.chars().skip(1).collect::<String>().to_string();\n\
    \  |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&String`\n  |\nhelp: consider removing the\
    \ borrow\n  |\n9 -         string = &string.chars().skip(1).collect::<String>().to_string();\n\
    9 +         string = string.chars().skip(1).collect::<String>().to_string();\n\
    \  | \n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut string = string.to_string();\n    let mut iter\
    \ = string.char_indices();\n\n    let mut result: Vec<String> = vec![];\n    for\
    \ i in iter.skip(1) {\n        result.push(i);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmps2ls5cla.rs:10:21\n   |\n\
    10 |         result.push(i);\n   |                     ^ expected struct `String`,\
    \ found tuple\n   |\n   = note: expected struct `String`\n               found\
    \ tuple `(usize, char)`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut prefix = vec![];\n    for (i, c) in string.chars().enumerate()\
    \ {\n        if i > 0 {\n            prefix.push(string[0..i]);\n        }\n \
    \       if c == c.chars().next().unwrap() {\n            prefix.push(string[0..i]);\n\
    \        }\n    }\n    prefix\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n   --> /tmp/tmpr2sz8ubf.rs:8:25\n    |\n8   |             prefix.push(string[0..i]);\n\
    \    |                    ---- ^^^^^^^^^^^^ doesn't have a size known at compile-time\n\
    \    |                    |\n    |                    required by a bound introduced\
    \ by this call\n    |\n    = help: the trait `Sized` is not implemented for `str`\n\
    note: required by a bound in `Vec::<T, A>::push`\n\nerror[E0277]: the size for\
    \ values of type `str` cannot be known at compilation time\n   --> /tmp/tmpr2sz8ubf.rs:5:22\n\
    \    |\n5   |     let mut prefix = vec![];\n    |                      ^^^^^^\
    \ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized`\
    \ is not implemented for `str`\nnote: required by a bound in `Vec::<T>::new`\n\
    \    = note: this error originates in the macro `vec` (in Nightly builds, run\
    \ with -Z macro-backtrace for more info)\n\nerror[E0277]: the size for values\
    \ of type `str` cannot be known at compilation time\n   --> /tmp/tmpr2sz8ubf.rs:5:22\n\
    \    |\n5   |     let mut prefix = vec![];\n    |                      ^^^^^^\
    \ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized`\
    \ is not implemented for `str`\nnote: required by a bound in `Vec`\n    = note:\
    \ this error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace\
    \ for more info)\n\nerror[E0599]: no method named `chars` found for type `char`\
    \ in the current scope\n  --> /tmp/tmpr2sz8ubf.rs:10:19\n   |\n10 |         if\
    \ c == c.chars().next().unwrap() {\n   |                   ^^^^^ method not found\
    \ in `char`\n\nerror[E0599]: the method `push` exists for struct `Vec<str>`, but\
    \ its trait bounds were not satisfied\n  --> /tmp/tmpr2sz8ubf.rs:11:20\n   |\n\
    11 |             prefix.push(string[0..i]);\n   |                    ^^^^ method\
    \ cannot be called on `Vec<str>` due to unsatisfied trait bounds\n   |\n   = note:\
    \ the following trait bounds were not satisfied:\n           `str: Sized`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpr2sz8ubf.rs:14:5\n   |\n4  | fn\
    \ all_pr"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut iter = string.chars().enumerate();\n    iter.by_ref().take_while(|&(_,\
    \ i)| i < string.len()).collect()\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpk_6plz70.rs:6:44\n  |\n6 |\
    \     iter.by_ref().take_while(|&(_, i)| i < string.len()).collect()\n  |    \
    \                                        ^^^^^^^^^^^^ expected `char`, found `usize`\n\
    \nerror[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `(usize, char)`\n    --> /tmp/tmpk_6plz70.rs:6:58\n  \
    \   |\n6    |     iter.by_ref().take_while(|&(_, i)| i < string.len()).collect()\n\
    \     |                                                          ^^^^^^^ value\
    \ of type `Vec<String>` cannot be built from `std::iter::Iterator<Item=(usize,\
    \ char)>`\n     |\n     = help: the trait `FromIterator<(usize, char)>` is not\
    \ implemented for `Vec<String>`\n     = help: the trait `FromIterator<T>` is implemented\
    \ for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut out = Vec::new();\n    let mut input = &string;\n\
    \    while let Some(prefix) = get_prefix(&mut input, &mut out) {\n        input\
    \ = &prefix;\n    }\n    out\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `get_prefix` in this scope\n --> /tmp/tmpn3nscdud.rs:7:30\n\
    \  |\n7 |     while let Some(prefix) = get_prefix(&mut input, &mut out) {\n  |\
    \                              ^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut prefixes = vec![];\n    for &s in string.chars()\
    \ {\n        if !prefixes.contains(&s) {\n            prefixes.push(s);\n    \
    \    }\n    }\n    prefixes\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpyd3lccd8.rs:6:9\n  |\n6 |\
    \     for &s in string.chars() {\n  |         ^^    -------------- this expression\
    \ has type `Option<char>`\n  |         |\n  |         expected `char`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `s`\n  |\n  =\
    \ note:   expected type `char`\n          found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut prefix_vec = Vec::new();\n    for &s in string.chars()\
    \ {\n        for &pref in prefix_vec.iter() {\n            pref\n            \
    \    .as_str()\n                .chars()\n                .filter(|c| c != s)\n\
    \                .collect::<String>()\n        }\n    }\n    prefix_vec\n}\n\n\
    fn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4uk07gja.rs:6:9\n  |\n6 |\
    \     for &s in string.chars() {\n  |         ^^    -------------- this expression\
    \ has type `Option<char>`\n  |         |\n  |         expected `char`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `s`\n  |\n  =\
    \ note:   expected type `char`\n          found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut prefix = String::from(\"\");\n    let mut remain\
    \ = string;\n\n    while remain.len() > 0 {\n        prefix.push(remain.as_str().to_owned());\n\
    \        remain = String::from(\"\");\n        for c in prefix.chars() {\n   \
    \         remain.push_str(c);\n            if !remain.as_str().starts_with(c)\
    \ {\n                break;\n            }\n        }\n    }\n\n    prefix.into_iter().collect()\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp7y9er829.rs:9:21\n  |\n9 |\
    \         prefix.push(remain.as_str().to_owned());\n  |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmp7y9er829.rs:12:29\n   |\n12 |             remain.push_str(c);\n\
    \   |                             ^ expected `&str`, found `char`\n\nerror[E0599]:\
    \ the method `into_iter` exists for struct `String`, but its trait bounds were\
    \ not satisfied\n   --> /tmp/tmp7y9er829.rs:19:12\n    |\n19  |       prefix.into_iter().collect()\n\
    \    |              ^^^^^^^^^\n    |\n    = note: the following trait bounds were\
    \ not satisfied:\n            `String: Iterator`\n            which is required\
    \ by `String: IntoIterator`\n            `&String: Iterator`\n            which\
    \ is required by `&String: IntoIterator`\n            `&mut String: Iterator`\n\
    \            which is required by `&mut String: IntoIterator`\n            `str:\
    \ Sized`\n            which is required by `str: IntoIterator`\n            `str:\
    \ Iterator`\n            which is required by `str: IntoIterator`\n          \
    \  `&str: Iterator`\n            which is required by `&str: IntoIterator`\n \
    \           `&mut str: Iterator`\n            which is required by `&mut str:\
    \ IntoIterator`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    string\n        .chars()\n        .flat_map(|c| {\n  \
    \          c.iter().filter(|c| !c.is_digit()).collect::<Vec<_>>()\n        })\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = all_prefixes;\n   \
    \ assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for type `char` in the current\
    \ scope\n --> /tmp/tmpvq8qyjl9.rs:8:15\n  |\n8 |             c.iter().filter(|c|\
    \ !c.is_digit()).collect::<Vec<_>>()\n  |               ^^^^ method not found\
    \ in `char`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut prefix = vec![];\n    let mut current_prefix =\
    \ String::from(\"\");\n    while current_prefix.length < string.len() {\n    \
    \    prefix.push(current_prefix);\n        current_prefix = &current_prefix[..];\n\
    \    }\n    prefix\n}\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0609]: no field `length` on type `String`\n --> /tmp/tmp1ltb_0k8.rs:7:26\n\
    \  |\n7 |     while current_prefix.length < string.len() {\n  |              \
    \            ^^^^^^ unknown field\n\nerror[E0308]: mismatched types\n --> /tmp/tmp1ltb_0k8.rs:9:26\n\
    \  |\n6 |     let mut current_prefix = String::from(\"\");\n  |              \
    \                ---------------- expected due to this value\n...\n9 |       \
    \  current_prefix = &current_prefix[..];\n  |                          ^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&str`\n  |\nhelp: try using a conversion method\n\
    \  |\n9 |         current_prefix = (&current_prefix[..]).to_string();\n  |   \
    \                       +                   +++++++++++++\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0609.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut prefixes: Vec<String> = vec![];\n    string.iter().for_each(|c|\
    \ {\n        let mut current = String::new();\n        while c.chars().next().unwrap()\
    \ != c {\n            current.push_str(&*c);\n        }\n        prefixes.push(current);\n\
    \    });\n    prefixes\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n --> /tmp/tmpjbp6itve.rs:6:12\n  |\n6 |     string.iter().for_each(|c|\
    \ {\n  |            ^^^^ method not found in `String`\n  |\nhelp: because of the\
    \ in-memory representation of `&str`, to obtain an `Iterator` over each of its\
    \ codepoint use method `chars`\n  |\n6 |     string.chars().for_each(|c| {\n \
    \ |            ~~~~~\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    string.chars().take_while(|c| !c.is_ascii()).collect()\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmpbknlvuix.rs:5:50\n     |\n5  \
    \  |     string.chars().take_while(|c| !c.is_ascii()).collect()\n     |      \
    \                                            ^^^^^^^ value of type `Vec<String>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n     |\n     = help:\
    \ the trait `FromIterator<char>` is not implemented for `Vec<String>`\n     =\
    \ help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut prefix = vec![];\n    let mut string = string.to_string();\n\
    \n    while string.len() > 0 {\n        prefix.push(string[0..string.len()]);\n\
    \        string = &string[string.len()..];\n    }\n\n    prefix\n}\n\nfn main()\
    \ {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n   --> /tmp/tmpztn3e_ha.rs:9:21\n    |\n9   |         prefix.push(string[0..string.len()]);\n\
    \    |                ---- ^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at\
    \ compile-time\n    |                |\n    |                required by a bound\
    \ introduced by this call\n    |\n    = help: the trait `Sized` is not implemented\
    \ for `str`\nnote: required by a bound in `Vec::<T, A>::push`\n\nerror[E0277]:\
    \ the size for values of type `str` cannot be known at compilation time\n   -->\
    \ /tmp/tmpztn3e_ha.rs:5:22\n    |\n5   |     let mut prefix = vec![];\n    | \
    \                     ^^^^^^ doesn't have a size known at compile-time\n    |\n\
    \    = help: the trait `Sized` is not implemented for `str`\nnote: required by\
    \ a bound in `Vec::<T>::new`\n    = note: this error originates in the macro `vec`\
    \ (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]:\
    \ the size for values of type `str` cannot be known at compilation time\n   -->\
    \ /tmp/tmpztn3e_ha.rs:5:22\n    |\n5   |     let mut prefix = vec![];\n    | \
    \                     ^^^^^^ doesn't have a size known at compile-time\n    |\n\
    \    = help: the trait `Sized` is not implemented for `str`\nnote: required by\
    \ a bound in `Vec`\n    = note: this error originates in the macro `vec` (in Nightly\
    \ builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpztn3e_ha.rs:10:18\n   |\n6  |     let mut string = string.to_string();\n\
    \   |                      ------------------ expected due to this value\n...\n\
    10 |         string = &string[string.len()..];\n   |                  ^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n\
    \   |\n10 |         string = (&string[string.len()..]).to_string();\n   |    \
    \              +                       +++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpztn3e_ha.rs:13:5\n   |\n4  | fn all_prefixes(string: String)\
    \ -> Vec<String> {\n   |                                    ----------- expect"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    shortest_prefixes(&string).iter()\n        .map(|s| s.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `shortest_prefixes` in this scope\n\
    \ --> /tmp/tmpmivqp7ji.rs:5:5\n  |\n5 |     shortest_prefixes(&string).iter()\n\
    \  |     ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    string.chars().flat_map(|c| {\n        vec![(c as u32).to_string(),\
    \ String::from(c.to_string())]\n    })\n}\n\nfn main() {\n    let candidate =\
    \ all_prefixes;\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"asdfgh\")), vec![String::from(\"a\"),\
    \ String::from(\"as\"), String::from(\"asd\"), String::from(\"asdf\"), String::from(\"\
    asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpe3q2y2rv.rs:5:5\n  |\n4 |\
    \   fn all_prefixes(string: String) -> Vec<String> {\n  |                    \
    \                  ----------- expected `Vec<String>` because of return type\n\
    5 | /     string.chars().flat_map(|c| {\n6 | |         vec![(c as u32).to_string(),\
    \ String::from(c.to_string())]\n7 | |     })\n  | |______^ expected struct `Vec`,\
    \ found struct `FlatMap`\n  |\n  = note: expected struct `Vec<_>`\n          \
    \   found struct `FlatMap<Chars<'_>, Vec<_>, [closure@/tmp/tmpe3q2y2rv.rs:5:29:\
    \ 7:6]>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut prefixes = vec![];\n    let mut current_prefix\
    \ = String::from(\"\");\n    string.chars().for_each(|c| {\n        if c == '!'\
    \ {\n            // The ! character marks the end of the current prefix\n    \
    \        // and the start of the next prefix\n            prefixes.push(current_prefix);\n\
    \            current_prefix = String::from(\"\");\n        } else if c == '.'\
    \ {\n            // The . character marks the end of the current prefix\n    \
    \        // and the start of the next prefix\n            prefixes.push(current_prefix);\n\
    \            current_prefix = String::from(\"\");\n        } else {\n        \
    \    // The character is not one of the special characters\n            // so\
    \ we append it to the current prefix and start a new prefix\n            current_prefix\
    \ = current_prefix.push_str(&c.to_string());\n        }\n    });\n\n    // The\
    \ last prefix will be ignored\n    prefixes.push(current_prefix);\n\n    prefixes\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgucz5drf.rs:21:30\n   |\n\
    6  |     let mut current_prefix = String::from(\"\");\n   |                  \
    \            ---------------- expected due to this value\n...\n21 |          \
    \   current_prefix = current_prefix.push_str(&c.to_string());\n   |          \
    \                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found `()`\n   |\nnote: method `push_str` modifies its receiver in-place\n \
    \ --> /tmp/tmpgucz5drf.rs:21:45\n   |\n21 |             current_prefix = current_prefix.push_str(&c.to_string());\n\
    \   |                              -------------- ^^^^^^^^ this call modifies\
    \ `current_prefix` in-place\n   |                              |\n   |       \
    \                       you probably want to use this value after calling the\
    \ method...\n   = note: ...instead of the `()` output of method `push_str`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    string\n        .chars()\n        .enumerate()\n     \
    \   .filter(|(i, &c)| c.is_ascii())\n        .filter(|(i, &c)| i > 0)\n      \
    \  .map(|(i, &c)| c.to_ascii_lowercase().to_string())\n        .collect()\n}\n\
    \nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp7qeqhw1q.rs:8:22\n  |\n8 |\
    \         .filter(|(i, &c)| c.is_ascii())\n  |                      ^^- expected\
    \ due to this\n  |                      |\n  |                      expected `char`,\
    \ found reference\n  |                      help: you can probably remove the\
    \ explicit borrow: `c`\n  |\n  = note:   expected type `char`\n          found\
    \ reference `&_`\n\nerror[E0308]: mismatched types\n --> /tmp/tmp7qeqhw1q.rs:9:22\n\
    \  |\n9 |         .filter(|(i, &c)| i > 0)\n  |                      ^^- expected\
    \ due to this\n  |                      |\n  |                      expected `char`,\
    \ found reference\n  |                      help: you can probably remove the\
    \ explicit borrow: `c`\n  |\n  = note:   expected type `char`\n          found\
    \ reference `&_`\n\nerror[E0308]: mismatched types\n --> /tmp/tmp7qeqhw1q.rs:9:31\n\
    \  |\n9 |         .filter(|(i, &c)| i > 0)\n  |                              \
    \ ^\n  |                               |\n  |                               expected\
    \ `&usize`, found integer\n  |                               help: consider borrowing\
    \ here: `&0`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7qeqhw1q.rs:10:19\n\
    \   |\n10 |         .map(|(i, &c)| c.to_ascii_lowercase().to_string())\n   | \
    \                  ^^- expected due to this\n   |                   |\n   |  \
    \                 expected `char`, found reference\n   |                   help:\
    \ you can probably remove the explicit borrow: `c`\n   |\n   = note:   expected\
    \ type `char`\n           found reference `&_`\n\nerror: aborting due to 4 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut prefixes: Vec<String> = vec![];\n    for i in\
    \ 0..string.len() {\n        for j in i..string.len() {\n            let prefix\
    \ = &string[..i];\n            let suffix = &string[j..];\n            prefixes.push(prefix);\n\
    \            prefixes.push(suffix);\n        }\n    }\n    prefixes\n}\n\nfn main()\
    \ {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjk3pvspo.rs:10:27\n   |\n\
    10 |             prefixes.push(prefix);\n   |                           ^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \         |\n   |                           expected struct `String`, found `&str`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpjk3pvspo.rs:11:27\n   |\n11 |\
    \             prefixes.push(suffix);\n   |                           ^^^^^^- help:\
    \ try using a conversion method: `.to_string()`\n   |                        \
    \   |\n   |                           expected struct `String`, found `&str`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    string\n        .split_prefix(string)\n        .map(String::from)\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = all_prefixes;\n   \
    \ assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `split_prefix` found for struct `String`\
    \ in the current scope\n --> /tmp/tmpv852grrz.rs:6:10\n  |\n6 |         .split_prefix(string)\n\
    \  |          ^^^^^^^^^^^^ help: there is an associated function with a similar\
    \ name: `strip_prefix`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut prefix = String::from(\"\");\n    for c in string.chars()\
    \ {\n        if c.is_alphanumeric() {\n            prefix.push(c);\n        }\
    \ else {\n            break;\n        }\n    }\n    prefix.bytes()\n        .enumerate()\n\
    \        .filter(|(_, c)| c.is_alphanumeric())\n        .collect::<Vec<(_, _)>>()\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_alphanumeric` found for reference `&u8`\
    \ in the current scope\n  --> /tmp/tmp8wisy1m4.rs:15:28\n   |\n15 |         .filter(|(_,\
    \ c)| c.is_alphanumeric())\n   |                            ^^^^^^^^^^^^^^^ help:\
    \ there is an associated function with a similar name: `is_ascii_alphanumeric`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp8wisy1m4.rs:13:5\n   |\n4  | \
    \  fn all_prefixes(string: String) -> Vec<String> {\n   |                    \
    \                  ----------- expected `Vec<String>` because of return type\n\
    ...\n13 | /     prefix.bytes()\n14 | |         .enumerate()\n15 | |         .filter(|(_,\
    \ c)| c.is_alphanumeric())\n16 | |         .collect::<Vec<(_, _)>>()\n   | |_________________________________^\
    \ expected struct `String`, found tuple\n   |\n   = note: expected struct `Vec<String>`\n\
    \              found struct `Vec<(usize, u8)>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut result = vec![];\n    for prefix in string.as_ref().split_ascii_whitespace()\
    \ {\n        result.push(prefix);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"asdfgh\")), vec![String::from(\"a\"),\
    \ String::from(\"as\"), String::from(\"asd\"), String::from(\"asdf\"), String::from(\"\
    asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n --> /tmp/tmpb4vcy934.rs:6:26\n\
    \  |\n6 |     for prefix in string.as_ref().split_ascii_whitespace() {\n  |  \
    \                 -------^^^^^^--\n  |                   |      |\n  |       \
    \            |      cannot infer type for type parameter `T` declared on the trait\
    \ `AsRef`\n  |                   this method call resolves to `&T`\n  |\n  = note:\
    \ type must be known at this point\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    string.chars().take_while(|c| *c != '\\0').collect()\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmpalpyzxh8.rs:5:47\n     |\n5  \
    \  |     string.chars().take_while(|c| *c != '\\0').collect()\n     |        \
    \                                       ^^^^^^^ value of type `Vec<String>` cannot\
    \ be built from `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait\
    \ `FromIterator<char>` is not implemented for `Vec<String>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut s = string;\n    s.clear();\n    let mut i = 0;\n\
    \    loop {\n        if i < s.len() {\n            s.insert(i, \".\");\n     \
    \   }\n        if i < s.len() {\n            i += 1;\n        }\n        if i\
    \ >= s.len() {\n            break;\n        }\n    }\n    s.split_whitespace().collect()\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl1rqyhly.rs:10:25\n   |\n\
    10 |             s.insert(i, \".\");\n   |                         ^^^ expected\
    \ `char`, found `&str`\n   |\nhelp: if you meant to write a `char` literal, use\
    \ single quotes\n   |\n10 |             s.insert(i, '.');\n   |              \
    \           ~~~\n\nerror[E0277]: a value of type `Vec<String>` cannot be built\
    \ from an iterator over elements of type `&str`\n    --> /tmp/tmpl1rqyhly.rs:19:26\n\
    \     |\n19   |     s.split_whitespace().collect()\n     |                   \
    \       ^^^^^^^ value of type `Vec<String>` cannot be built from `std::iter::Iterator<Item=&str>`\n\
    \     |\n     = help: the trait `FromIterator<&str>` is not implemented for `Vec<String>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut prefix = vec![];\n    let mut current = &string[..];\n\
    \    while let Some(current) = &current[..] {\n        prefix.push(current);\n\
    \        current = &string[..];\n    }\n    prefix\n}\n\nfn main() {\n    let\
    \ candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"asdfgh\")), vec![String::from(\"a\"),\
    \ String::from(\"as\"), String::from(\"asd\"), String::from(\"asdf\"), String::from(\"\
    asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpg909wqdl.rs:7:15\n  |\n7 |\
    \     while let Some(current) = &current[..] {\n  |               ^^^^^^^^^^^^^\
    \   ------------ this expression has type `&str`\n  |               |\n  |   \
    \            expected `str`, found enum `Option`\n  |\n  = note: expected type\
    \ `str`\n             found enum `Option<_>`\n\nerror[E0277]: the size for values\
    \ of type `str` cannot be known at compilation time\n   --> /tmp/tmpg909wqdl.rs:7:15\n\
    \    |\n7   |     while let Some(current) = &current[..] {\n    |            \
    \   ^^^^^^^^^^^^^ doesn't have a size known at compile-time\n    |\n    = help:\
    \ the trait `Sized` is not implemented for `str`\nnote: required by a bound in\
    \ `Some`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg909wqdl.rs:11:5\n \
    \  |\n4  | fn all_prefixes(string: String) -> Vec<String> {\n   |            \
    \                        ----------- expected `Vec<String>` because of return\
    \ type\n...\n11 |     prefix\n   |     ^^^^^^ expected struct `String`, found\
    \ `&str`\n   |\n   = note: expected struct `Vec<String>`\n              found\
    \ struct `Vec<&str>`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 101
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut prefixes: Vec<String> = vec![];\n    for ch in\
    \ string.chars() {\n        prefixes.push(ch.to_string());\n    }\n    prefixes\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"s\", \"d\", \"f\", \"g\", \"h\"]`,\n right: `[\"a\", \"as\", \"asd\"\
    , \"asdf\", \"asdfg\", \"asdfgh\"]`', /tmp/tmptf62qv7r.rs:15:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut result = vec![];\n    let mut prefix = String::from(\"\
    \");\n    while !string.starts_with(prefix) {\n        prefix.push(string.chars().next().unwrap());\n\
    \        result.push(prefix);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = all_prefixes;\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"asdfgh\")), vec![String::from(\"a\"),\
    \ String::from(\"as\"), String::from(\"asd\"), String::from(\"asdf\"), String::from(\"\
    asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n   \
    \ --> /tmp/tmpw__sm2rz.rs:7:31\n     |\n7    |     while !string.starts_with(prefix)\
    \ {\n     |                   ----------- ^^^^^^ expected an implementor of trait\
    \ `Pattern<'_>`\n     |                   |\n     |                   required\
    \ by a bound introduced by this call\n     |\n     = note: the trait bound `String:\
    \ Pattern<'_>` is not satisfied\n     = note: required because of the requirements\
    \ on the impl of `Pattern<'_>` for `String`\nnote: required by a bound in `core::str::<impl\
    \ str>::starts_with`\nhelp: consider borrowing here\n     |\n7    |     while\
    \ !string.starts_with(&prefix) {\n     |                               +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    string.chars()\n        .chain(string.chars().rev().filter(|c|\
    \ *c != '\\0'))\n        .collect()\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmpbs8nj024.rs:7:10\n     |\n7  \
    \  |         .collect()\n     |          ^^^^^^^ value of type `Vec<String>` cannot\
    \ be built from `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait\
    \ `FromIterator<char>` is not implemented for `Vec<String>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 101
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    string.chars().map(|c| String::from(c)).collect::<Vec<String>>()\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"s\", \"d\", \"f\", \"g\", \"h\"]`,\n right: `[\"a\", \"as\", \"asd\"\
    , \"asdf\", \"asdfg\", \"asdfgh\"]`', /tmp/tmpyr_9kt8m.rs:11:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    if let Ok(mut itr) = string.char_indices() {\n       \
    \ let mut prefixes = Vec::new();\n        let mut prefix = String::from(\"\");\n\
    \        let mut index = itr.next();\n        while let Some(c) = index {\n  \
    \          prefix += c;\n            if prefixes.iter().all(|&i| i.starts_with(&prefix))\
    \ {\n                prefixes.push(prefix);\n                prefix = String::from(\"\
    \");\n            } else {\n                index += 1;\n            }\n     \
    \   }\n        prefixes.push(prefix);\n        prefixes\n    } else {\n      \
    \  Vec::new()\n    }\n}\n\nfn main() {\n    let candidate = all_prefixes;\n  \
    \  assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp2s2erw5r.rs:5:12\n  |\n5 |\
    \     if let Ok(mut itr) = string.char_indices() {\n  |            ^^^^^^^^^^^\
    \   --------------------- this expression has type `CharIndices<'_>`\n  |    \
    \        |\n  |            expected struct `CharIndices`, found enum `Result`\n\
    \  |\n  = note: expected struct `CharIndices<'_>`\n               found enum `Result<_,\
    \ _>`\n\nerror[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `Option<&str>`\n  --> /tmp/tmp2s2erw5r.rs:15:17\n   |\n15 |                \
    \ index += 1;\n   |                 -----^^^^^\n   |                 |\n   | \
    \                cannot use `+=` on type `Option<&str>`\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0368.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    all_prefixes_iter(string).collect()\n}\n\nfn main() {\n\
    \    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\"\
    )), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\")),\
    \ vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `all_prefixes_iter` in this scope\n\
    \ --> /tmp/tmprq83cmmp.rs:5:5\n  |\n5 |     all_prefixes_iter(string).collect()\n\
    \  |     ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    all_prefixes_iter(string).collect()\n}\n\nfn main() {\n\
    \    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\"\
    )), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\")),\
    \ vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `all_prefixes_iter` in this scope\n\
    \ --> /tmp/tmprq83cmmp.rs:5:5\n  |\n5 |     all_prefixes_iter(string).collect()\n\
    \  |     ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 101
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    string.chars()\n        .map(|c| c.to_string())\n    \
    \    .collect()\n}\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"s\", \"d\", \"f\", \"g\", \"h\"]`,\n right: `[\"a\", \"as\", \"asd\"\
    , \"asdf\", \"asdfg\", \"asdfgh\"]`', /tmp/tmpx_krc83v.rs:13:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut prefix = vec![\"\".to_string()];\n    for c in\
    \ string.chars() {\n        prefix.push(c);\n    }\n    prefix\n}\n\nfn main()\
    \ {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmplka1w7y_.rs:7:21\n  |\n7 |\
    \         prefix.push(c);\n  |                     ^- help: try using a conversion\
    \ method: `.to_string()`\n  |                     |\n  |                     expected\
    \ struct `String`, found `char`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut prefix = vec![String::from(\"\")]; // add empty\
    \ prefix to ensure consistency\n    loop {\n        let mut suffix = String::from(\"\
    \");\n        for c in string.chars() {\n            prefix.push(c);\n       \
    \     if prefix.len() < string.len() {\n                break;\n            }\n\
    \            if string[prefix.len() - 1] == c {\n                suffix.push(c);\n\
    \            } else {\n                break;\n            }\n        }\n    \
    \    if suffix.len() > string.len() {\n            break;\n        }\n       \
    \ prefix.push(suffix);\n    }\n    prefix\n}\n\nfn main() {\n    let candidate\
    \ = all_prefixes;\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"asdfgh\")), vec![String::from(\"a\"),\
    \ String::from(\"as\"), String::from(\"asd\"), String::from(\"asdf\"), String::from(\"\
    asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp68y1achq.rs:9:25\n  |\n9 |\
    \             prefix.push(c);\n  |                         ^- help: try using\
    \ a conversion method: `.to_string()`\n  |                         |\n  |    \
    \                     expected struct `String`, found `char`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp68y1achq.rs:13:16\n\
    \   |\n13 |             if string[prefix.len() - 1] == c {\n   |             \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut current = String::from(\"\");\n    let mut res\
    \ = vec![];\n    for &s in string {\n        current = current.to_owned() + &s;\n\
    \        res.push_back(current);\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = all_prefixes;\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"asdfgh\")), vec![String::from(\"a\"),\
    \ String::from(\"as\"), String::from(\"asd\"), String::from(\"asdf\"), String::from(\"\
    asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n --> /tmp/tmpg9xjufqb.rs:7:15\n\
    \  |\n7 |     for &s in string {\n  |               ^^^^^^ `String` is not an\
    \ iterator; try calling `.chars()` or `.bytes()`\n  |\n  = help: the trait `Iterator`\
    \ is not implemented for `String`\n  = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `String`\n\nerror[E0277]: the size for values\
    \ of type `str` cannot be known at compilation time\n --> /tmp/tmpg9xjufqb.rs:7:10\n\
    \  |\n7 |     for &s in string {\n  |          ^ doesn't have a size known at\
    \ compile-time\n  |\n  = help: the trait `Sized` is not implemented for `str`\n\
    \  = note: all local variables must have a statically known size\n  = help: unsized\
    \ locals are gated as an unstable feature\n\nerror[E0599]: no method named `push_back`\
    \ found for struct `Vec<_>` in the current scope\n --> /tmp/tmpg9xjufqb.rs:9:13\n\
    \  |\n9 |         res.push_back(current);\n  |             ^^^^^^^^^ method not\
    \ found in `Vec<_>`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut prefix = String::from(\"\");\n    for ch in string.chars()\
    \ {\n        let mut prefixes = prefix.clone();\n        prefixes.push_str(&ch.to_string());\n\
    \        prefixes.push_str(&ch.to_string() + \"\");\n        prefixes.push_str(&ch.to_string()\
    \ + &ch.to_string());\n        prefixes.push_str(&ch.to_string() + &ch.to_string()\
    \ + &ch.to_string());\n        prefixes.push_str(&ch.to_string() + &ch.to_string()\
    \ + &ch.to_string() + &ch.to_string());\n        prefixes.push_str(&ch.to_string()\
    \ + &ch.to_string() + &ch.to_string() + &ch.to_string() + &ch.to_string());\n\
    \        prefixes.push_str(&ch.to_string() + &ch.to_string() + &ch.to_string()\
    \ + &ch.to_string() + &ch.to_string() + &ch.to_string());\n        prefixes.push_str(&ch.to_string()\
    \ + &ch.to_string() + &ch.to_string() + &ch.to_string() + &ch.to_string() + &ch.to_string()\
    \ + &ch.to_string());\n        prefixes.push_str(&ch.to_string() + &ch.to_string()\
    \ + &ch.to_string() + &ch.to_string() + &ch.to_string() + &ch.to_string() + &ch.to_string()\
    \ + &ch.to_string());\n        prefixes.push_str(&ch.to_string() + &ch.to_string()\
    \ + &ch.to_string() + &ch.to_string() + &ch.to_string() + &ch.to_string() + &ch.to_string()\
    \ + &ch.to_string() + &ch.to_string());\n        prefixes.push_str(&ch.to_string()\
    \ + &ch.to_string() + &ch.to_string() + &ch.to_string() + &ch.to_string() + &ch.to_string()\
    \ + &ch.to_string() + &ch.to_string() + &ch.to_string() + &ch.to_string());\n\
    \        prefixes.push_str(&ch.to_string() + &ch.to_string() + &ch.to_string()\
    \ + &ch.to_string() + &ch.to_string() + &ch.to_string() + &ch.to_string() + &ch.to_string()\
    \ + &ch.to_string() + &ch.to_string() + &ch.to_string());\n        prefixes.push_str(&ch.to_string()\
    \ + &ch.to_string() + &ch.to_string() + &ch.to_string() + &ch.to_string() + &ch.to_string()\
    \ + &ch.to_string() + &ch.to_string() + &ch.to_string() + &ch.to_string() + &ch.to_string());\n\
    \        prefixes.push_str(&ch.to_string() + &ch.to_string() + &ch.to_string()\
    \ + &ch.to_string() + &ch.to_string() + &\n}\n\nfn main() {\n    let candidate\
    \ = all_prefixes;\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"asdfgh\")), vec![String::from(\"a\"),\
    \ String::from(\"as\"), String::from(\"asd\"), String::from(\"asdf\"), String::from(\"\
    asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmph7fwqwnu.rs:29:3\n\
    \   |\n4  | fn all_prefixes(string: String) -> Vec<String> {\n   |           \
    \                                     - unclosed delimiter\n5  |     let mut prefix\
    \ = String::from(\"\");\n6  |     for ch in string.chars() {\n   |           \
    \                   - this delimiter might not be properly closed...\n...\n22\
    \ | }\n   | - ...as it matches this but it has different indentation\n...\n29\
    \ | }\n   |   ^\n\nerror: expected expression, found `)`\n  --> /tmp/tmph7fwqwnu.rs:22:1\n\
    \   |\n22 | }\n   | ^ expected expression\n\nerror: mismatched closing delimiter:\
    \ `}`\n  --> /tmp/tmph7fwqwnu.rs:21:26\n   |\n4  | fn all_prefixes(string: String)\
    \ -> Vec<String> {\n   |                                                - closing\
    \ delimiter possibly meant for this\n...\n21 |         prefixes.push_str(&ch.to_string()\
    \ + &ch.to_string() + &ch.to_string() + &ch.to_string() + &ch.to_string() + &\n\
    \   |                          ^ unclosed delimiter\n22 | }\n   | ^ mismatched\
    \ closing delimiter\n\nerror[E0369]: cannot add `&str` to `&String`\n --> /tmp/tmph7fwqwnu.rs:9:43\n\
    \  |\n9 |         prefixes.push_str(&ch.to_string() + \"\");\n  |            \
    \               --------------- ^ -- &str\n  |                           |   \
    \            |\n  |                           |               `+` cannot be used\
    \ to concatenate two `&str` strings\n  |                           &String\n \
    \ |\n  = note: string concatenation requires an owned `String` on the left\nhelp:\
    \ remove the borrow to obtain an owned `String`\n  |\n9 -         prefixes.push_str(&ch.to_string()\
    \ + \"\");\n9 +         prefixes.push_str(ch.to_string() + \"\");\n  | \n\nerror[E0369]:\
    \ cannot add `&String` to `&String`\n  --> /tmp/tmph7fwqwnu.rs:10:43\n   |\n10\
    \ |         prefixes.push_str(&ch.to_string() + &ch.to_string());\n   |      \
    \                     --------------- ^ --------------- &String\n   |        \
    \                   |               |\n   |                           |      \
    \         `+` cannot be used to concatenate two `&str` strings\n   |         \
    \                  &S"
  stdout: ''
  timestamp: 1659976676
- exit_code: 101
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    string.chars().map(|c| c.to_string()).collect()\n}\n\n\
    fn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"s\", \"d\", \"f\", \"g\", \"h\"]`,\n right: `[\"a\", \"as\", \"asd\"\
    , \"asdf\", \"asdfg\", \"asdfgh\"]`', /tmp/tmplzpv6aef.rs:11:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    all_prefixes_inner(string, String::new())\n}\n\nfn main()\
    \ {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `all_prefixes_inner` in this scope\n\
    \ --> /tmp/tmpuryzyhz_.rs:5:5\n  |\n5 |     all_prefixes_inner(string, String::new())\n\
    \  |     ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    string\n        .split_whitespace()\n        .filter_map(|c|\
    \ c.to_ascii_lowercase().chars().enumerate().collect())\n        .filter_map(|(i,\
    \ c)| {\n            if c.len() == 1 {\n                Some((i, c))\n       \
    \     } else {\n                Some((i, c.clone()))\n            }\n        })\n\
    \        .collect::<Vec<(std::usize, char)>>()\n}\n\nfn main() {\n    let candidate\
    \ = all_prefixes;\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"asdfgh\")), vec![String::from(\"a\"),\
    \ String::from(\"as\"), String::from(\"asd\"), String::from(\"asdf\"), String::from(\"\
    asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0573]: expected type, found module `std::usize`\n  --> /tmp/tmpkrjcsojd.rs:15:25\n\
    \   |\n15 |         .collect::<Vec<(std::usize, char)>>()\n   |              \
    \           ^^^^^^^^^^ not a type\n   |\nhelp: consider importing this builtin\
    \ type instead\n   |\n1  | use std::primitive::usize;\n   |\nhelp: if you import\
    \ `usize`, refer to it directly\n   |\n15 -         .collect::<Vec<(std::usize,\
    \ char)>>()\n15 +         .collect::<Vec<(usize, char)>>()\n   | \n\nerror[E0277]:\
    \ a value of type `Option<_>` cannot be built from an iterator over elements of\
    \ type `(usize, char)`\n    --> /tmp/tmpkrjcsojd.rs:7:68\n     |\n7    |     \
    \    .filter_map(|c| c.to_ascii_lowercase().chars().enumerate().collect())\n \
    \    |                                                                    ^^^^^^^\
    \ value of type `Option<_>` cannot be built from `std::iter::Iterator<Item=(usize,\
    \ char)>`\n     |\n     = help: the trait `FromIterator<(usize, char)>` is not\
    \ implemented for `Option<_>`\n     = help: the trait `FromIterator<Option<A>>`\
    \ is implemented for `Option<V>`\nnote: required by a bound in `collect`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0573.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut prefix = vec![\"\"];\n    let mut index = string.len();\n\
    \n    while index > 0 {\n        let next_index = string.rfind(\"_\", index);\n\
    \        prefix.push(string.split_at_index(next_index).unwrap());\n        index\
    \ = next_index + 1;\n    }\n    prefix\n}\n\nfn main() {\n    let candidate =\
    \ all_prefixes;\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"asdfgh\")), vec![String::from(\"a\"),\
    \ String::from(\"as\"), String::from(\"asd\"), String::from(\"asdf\"), String::from(\"\
    asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmphzqw7nnv.rs:9:33\n     |\n9    |         let next_index = string.rfind(\"\
    _\", index);\n     |                                 ^^^^^ ---  ----- supplied\
    \ 2 arguments\n     |                                 |\n     |              \
    \                   expected 1 argument\n     |\nnote: associated function defined\
    \ here\n\nerror[E0599]: no method named `split_at_index` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmphzqw7nnv.rs:10:28\n   |\n10 |         prefix.push(string.split_at_index(next_index).unwrap());\n\
    \   |                            ^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `split_at`\n\nerror[E0369]: cannot add `{integer}` to `Option<usize>`\n\
    \  --> /tmp/tmphzqw7nnv.rs:11:28\n   |\n11 |         index = next_index + 1;\n\
    \   |                 ---------- ^ - {integer}\n   |                 |\n   | \
    \                Option<usize>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphzqw7nnv.rs:13:5\n\
    \   |\n4  | fn all_prefixes(string: String) -> Vec<String> {\n   |           \
    \                         ----------- expected `Vec<String>` because of return\
    \ type\n...\n13 |     prefix\n   |     ^^^^^^ expected struct `String`, found\
    \ `&str`\n   |\n   = note: expected struct `Vec<String>`\n              found\
    \ struct `Vec<&str>`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0061, E0308, E0369, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut prefix = vec![String::from(\"\")];\n    for &ch\
    \ in string.chars() {\n        for &prefix in prefix {\n            if !prefix.is_empty()\
    \ && ch == prefix[0] {\n                break;\n            }\n        }\n   \
    \     prefix.push(ch);\n    }\n    prefix\n}\n\nfn main() {\n    let candidate\
    \ = all_prefixes;\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"asdfgh\")), vec![String::from(\"a\"),\
    \ String::from(\"as\"), String::from(\"asd\"), String::from(\"asdf\"), String::from(\"\
    asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpnsh0idh9.rs:6:9\n  |\n6 |\
    \     for &ch in string.chars() {\n  |         ^^^    -------------- this expression\
    \ has type `Option<char>`\n  |         |\n  |         expected `char`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `ch`\n  |\n  =\
    \ note:   expected type `char`\n          found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpnsh0idh9.rs:7:13\n  |\n7 |         for &prefix\
    \ in prefix {\n  |             ^^^^^^^    ------ this expression has type `Option<String>`\n\
    \  |             |\n  |             expected struct `String`, found reference\n\
    \  |             help: you can probably remove the explicit borrow: `prefix`\n\
    \  |\n  = note: expected struct `String`\n          found reference `&_`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    string.chars().filter_map(|c| Some(c)).collect()\n}\n\n\
    fn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmpt7fnl3ro.rs:5:44\n     |\n5  \
    \  |     string.chars().filter_map(|c| Some(c)).collect()\n     |            \
    \                                ^^^^^^^ value of type `Vec<String>` cannot be\
    \ built from `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait\
    \ `FromIterator<char>` is not implemented for `Vec<String>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    string\n        .chars()\n        .filter_map(|c| {\n\
    \            Some(\n                string.chars()\n                    .skip_while(|&b|\
    \ b != c)\n                    .take(std::cmp::min(c, c))\n                  \
    \  .to_vec(),\n            )\n        })\n        .flatten()\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpljy7xur7.rs:11:41\n   |\n\
    11 |                     .take(std::cmp::min(c, c))\n   |                    \
    \                     ^ expected `usize`, found `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpljy7xur7.rs:11:44\n   |\n11 |                     .take(std::cmp::min(c,\
    \ c))\n   |                                            ^ expected `usize`, found\
    \ `char`\n\nerror[E0599]: no method named `to_vec` found for struct `std::iter::Take`\
    \ in the current scope\n  --> /tmp/tmpljy7xur7.rs:12:22\n   |\n12 |          \
    \           .to_vec(),\n   |                      ^^^^^^ method not found in `std::iter::Take<SkipWhile<Chars<'_>,\
    \ [closure@/tmp/tmpljy7xur7.rs:10:33: 10:44]>>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    string.chars()\n        .filter(|c| !c.is_ascii_alphanumeric())\n\
    \        .map(|c| c.to_ascii_lowercase())\n        .collect()\n}\n\nfn main()\
    \ {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmp4e6nvbby.rs:8:10\n     |\n8  \
    \  |         .collect()\n     |          ^^^^^^^ value of type `Vec<String>` cannot\
    \ be built from `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait\
    \ `FromIterator<char>` is not implemented for `Vec<String>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    strings\n        .into_iter()\n        .enumerate()\n\
    \        .map(|(i, s)| (i, s.as_bytes().iter().take_while(|&b| !b == 0).collect()))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = all_prefixes;\n   \
    \ assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `strings` in this scope\n --> /tmp/tmpjmty5koi.rs:5:5\n\
    \  |\n5 |     strings\n  |     ^^^^^^^ help: a local variable with a similar name\
    \ exists: `string`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    string.into_iter().chain(string.chars().map(|c| c.to_string())).collect()\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: the method `into_iter` exists for struct `String`, but its\
    \ trait bounds were not satisfied\n   --> /tmp/tmp0uhmfplq.rs:5:12\n    |\n5 \
    \  |       string.into_iter().chain(string.chars().map(|c| c.to_string())).collect()\n\
    \    |              ^^^^^^^^^\n    |\n    = note: the following trait bounds were\
    \ not satisfied:\n            `String: Iterator`\n            which is required\
    \ by `String: IntoIterator`\n            `&String: Iterator`\n            which\
    \ is required by `&String: IntoIterator`\n            `&mut String: Iterator`\n\
    \            which is required by `&mut String: IntoIterator`\n            `str:\
    \ Sized`\n            which is required by `str: IntoIterator`\n            `str:\
    \ Iterator`\n            which is required by `str: IntoIterator`\n          \
    \  `&str: Iterator`\n            which is required by `&str: IntoIterator`\n \
    \           `&mut str: Iterator`\n            which is required by `&mut str:\
    \ IntoIterator`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    string\n        .chars()\n        .enumerate()\n     \
    \   .flat_map(|(i, _)| {\n            let mut prefixes: Vec<String> = Vec::new();\n\
    \            for _ in 0..i + 1 {\n                prefixes.push(String::from(\"\
    \"));\n            }\n            prefixes.extend(&string[i..]);\n           \
    \ prefixes\n        })\n        .collect()\n}\n\nfn main() {\n    let candidate\
    \ = all_prefixes;\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"asdfgh\")), vec![String::from(\"a\"),\
    \ String::from(\"as\"), String::from(\"asd\"), String::from(\"asdf\"), String::from(\"\
    asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&str` is not an iterator\n   --> /tmp/tmp14hgpgzc.rs:13:29\n\
    \    |\n13  |             prefixes.extend(&string[i..]);\n    |              \
    \        ------ ^^^^^^^^^^^^ `&str` is not an iterator; try calling `.chars()`\
    \ or `.bytes()`\n    |                      |\n    |                      required\
    \ by a bound introduced by this call\n    |\n    = help: the trait `Iterator`\
    \ is not implemented for `&str`\n    = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `&str`\nnote: required by a bound in `extend`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 101
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    string.chars()\n        .enumerate()\n        .filter(|&(_,\
    \ c)| c.is_alphanumeric())\n        .map(|(_, c)| String::from(c))\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"s\", \"d\", \"f\", \"g\", \"h\"]`,\n right: `[\"a\", \"as\", \"asd\"\
    , \"asdf\", \"asdfg\", \"asdfgh\"]`', /tmp/tmpc3eztzvk.rs:15:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut prefix = Vec::new();\n    let mut prefix_len =\
    \ prefix.len();\n    for char in string.chars() {\n        if char == char::from_u32(char::MAX)\
    \ {\n            prefix.pop();\n            prefix.push(String::new());\n    \
    \        prefix_len -= 1;\n        } else {\n            prefix.push(char);\n\
    \            prefix_len += 1;\n        }\n    }\n    prefix\n}\n\nfn main() {\n\
    \    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\"\
    )), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\")),\
    \ vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpi1u_fbwx.rs:8:35\n  |\n8 |\
    \         if char == char::from_u32(char::MAX) {\n  |                        \
    \           ^^^^^^^^^ expected `u32`, found `char`\n  |\nhelp: you can cast a\
    \ `char` to a `u32`, since a `char` always occupies 4 bytes\n  |\n8 |        \
    \ if char == char::from_u32(char::MAX as u32) {\n  |                         \
    \                    ++++++\n\nerror[E0308]: mismatched types\n --> /tmp/tmpi1u_fbwx.rs:8:20\n\
    \  |\n8 |         if char == char::from_u32(char::MAX) {\n  |                \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n  |\n  =\
    \ note: expected type `char`\n             found enum `Option<char>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpi1u_fbwx.rs:13:25\n   |\n13 |             prefix.push(char);\n\
    \   |                         ^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                         |\n   |                         expected struct\
    \ `String`, found `char`\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    string\n        .chars()\n        .filter_map(|c| c.is_ascii())\n\
    \        .take_while(|c| c != '\\0')\n        .collect()\n}\n\nfn main() {\n \
    \   let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\"\
    )), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\")),\
    \ vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpo3y6ee5u.rs:7:25\n  |\n7 |\
    \         .filter_map(|c| c.is_ascii())\n  |                         ^^^^^^^^^^^^\
    \ expected enum `Option`, found `bool`\n  |\n  = note: expected enum `Option<_>`\n\
    \             found type `bool`\nhelp: try wrapping the expression in `Some`\n\
    \  |\n7 |         .filter_map(|c| Some(c.is_ascii()))\n  |                   \
    \      +++++            +\n\nerror[E0277]: can't compare `&_` with `char`\n -->\
    \ /tmp/tmpo3y6ee5u.rs:8:27\n  |\n8 |         .take_while(|c| c != '\\0')\n  |\
    \                           ^^ no implementation for `&_ == char`\n  |\n  = help:\
    \ the trait `PartialEq<char>` is not implemented for `&_`\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    all_prefixes_impl(string, &mut vec![], &mut vec![])\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `all_prefixes_impl` in this scope\n\
    \ --> /tmp/tmp8ez0w7_f.rs:5:5\n  |\n5 |     all_prefixes_impl(string, &mut vec![],\
    \ &mut vec![])\n  |     ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    Self::shortest_to_longest_prefixes(string, string).to_vec()\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Self`\n --> /tmp/tmp6o4zmth3.rs:5:5\n\
    \  |\n5 |     Self::shortest_to_longest_prefixes(string, string).to_vec()\n  |\
    \     ^^^^ use of undeclared type `Self`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut prefix_list = Vec::new();\n    let mut prefix_len\
    \ = string.len();\n    let mut suffix_len = string.len();\n    let mut suffix\
    \ = String::new();\n\n    while prefix_len > 0 && suffix_len > 0 {\n        let\
    \ char = string[prefix_len - 1];\n        suffix.push(char);\n        prefix_len\
    \ -= 1;\n        suffix_len -= 1;\n        prefix_list.push(string.prefix(prefix_len));\n\
    \    }\n\n    prefix_list\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpigcdsvje.rs:11:20\n\
    \   |\n11 |         let char = string[prefix_len - 1];\n   |                 \
    \   ^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `prefix` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpigcdsvje.rs:15:33\n   |\n15 |         prefix_list.push(string.prefix(prefix_len));\n\
    \   |                                 ^^^^^^ help: there is an associated function\
    \ with a similar name: `strip_prefix`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    if string.is_empty() {\n        return vec![];\n    }\n\
    \n    all_bfs(&string, true, vec![], vec![]).into_iter().collect()\n}\n\nfn main()\
    \ {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `all_bfs` in this scope\n --> /tmp/tmperm539zl.rs:9:5\n\
    \  |\n9 |     all_bfs(&string, true, vec![], vec![]).into_iter().collect()\n \
    \ |     ^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    string\n        .chars()\n        .enumerate()\n     \
    \   .flat_map(|(i, c)| (i <= string.len() && c != string[i - 1].into()) ? Vec::new()\
    \ : Some(c.into()))\n        .collect()\n}\n\nfn main() {\n    let candidate =\
    \ all_prefixes;\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"asdfgh\")), vec![String::from(\"a\"),\
    \ String::from(\"as\"), String::from(\"asd\"), String::from(\"asdf\"), String::from(\"\
    asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `(`, `)`, `+`, `,`, `::`, or `<`, found `.`\n\
    \ --> /tmp/tmpup8bqxq4.rs:8:98\n  |\n8 |         .flat_map(|(i, c)| (i <= string.len()\
    \ && c != string[i - 1].into()) ? Vec::new() : Some(c.into()))\n  |          \
    \                                                                            \
    \    -       ^\n  |                                                          \
    \                                |       |\n  |                              \
    \                                                            |       expected\
    \ one of 7 possible tokens\n  |                                              \
    \                                            |       help: missing `,`\n  |  \
    \                                                                            \
    \            tried to parse a type due to this\n\nerror: expected one of `)`,\
    \ `,`, `.`, `?`, or an operator, found `Vec`\n --> /tmp/tmpup8bqxq4.rs:8:79\n\
    \  |\n8 |         .flat_map(|(i, c)| (i <= string.len() && c != string[i - 1].into())\
    \ ? Vec::new() : Some(c.into()))\n  |                                        \
    \                                      -^^^ expected one of `)`, `,`, `.`, `?`,\
    \ or an operator\n  |                                                        \
    \                      |\n  |                                                \
    \                              help: missing `,`\n\nerror[E0573]: expected type,\
    \ found variant `Some`\n --> /tmp/tmpup8bqxq4.rs:8:92\n  |\n8 |         .flat_map(|(i,\
    \ c)| (i <= string.len() && c != string[i - 1].into()) ? Vec::new() : Some(c.into()))\n\
    \  |                                                                         \
    \                   ^^^^^^^^^^^^^^\n  |                                      \
    \                                                      |\n  |                \
    \                                                                            expecting\
    \ a type here because of type ascription\n  |                                \
    \                                                            help: try using the\
    \ variant's enum: `std::option::Option`\n\nerror[E"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    string.chars().take(string.len()).collect()\n}\n\nfn main()\
    \ {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmp7vqij8ts.rs:5:39\n     |\n5  \
    \  |     string.chars().take(string.len()).collect()\n     |                 \
    \                      ^^^^^^^ value of type `Vec<String>` cannot be built from\
    \ `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<String>`\n     = help: the trait `FromIterator<T>`\
    \ is implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut prefix_vec = Vec::new();\n    let mut string_iter\
    \ = string.chars();\n    let mut prefix_iter = string.chars().map(|c| c.to_string()).collect::<Vec<_>>();\n\
    \    let mut current_prefix = &prefix_iter.next();\n    while let Some(prefix)\
    \ = current_prefix {\n        prefix_vec.push(prefix);\n        current_prefix\
    \ = &prefix_iter.next();\n    }\n    prefix_vec\n}\n\nfn main() {\n    let candidate\
    \ = all_prefixes;\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"asdfgh\")), vec![String::from(\"a\"),\
    \ String::from(\"as\"), String::from(\"asd\"), String::from(\"asdf\"), String::from(\"\
    asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `next` found for struct `Vec<String>` in\
    \ the current scope\n --> /tmp/tmpz0yfflc1.rs:8:43\n  |\n8 |     let mut current_prefix\
    \ = &prefix_iter.next();\n  |                                           ^^^^ method\
    \ not found in `Vec<String>`\n\nerror[E0599]: no method named `next` found for\
    \ struct `Vec<String>` in the current scope\n  --> /tmp/tmpz0yfflc1.rs:11:39\n\
    \   |\n11 |         current_prefix = &prefix_iter.next();\n   |              \
    \                         ^^^^ method not found in `Vec<String>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    string.chars()\n        .flat_map(|c| {\n            c.iter().take_while(|c|\
    \ !c.is_ascii_letter())\n        })\n        .collect()\n}\n\nfn main() {\n  \
    \  let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\")),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\")),\
    \ vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for type `char` in the current\
    \ scope\n --> /tmp/tmpftjkpwgs.rs:7:15\n  |\n7 |             c.iter().take_while(|c|\
    \ !c.is_ascii_letter())\n  |               ^^^^ method not found in `char`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    string.iter()\n        .map(|c| {\n            if c.is_ascii_lowercase()\
    \ {\n                String::from(c)\n            } else {\n                format!(\"\
    {}{}\", c, string[string.len() - string.len(c.len_utf8()) - 1])\n            }\n\
    \        })\n        .collect()\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n --> /tmp/tmpqrvwmo01.rs:5:12\n  |\n5 |     string.iter()\n  |      \
    \      ^^^^ method not found in `String`\n  |\nhelp: because of the in-memory\
    \ representation of `&str`, to obtain an `Iterator` over each of its codepoint\
    \ use method `chars`\n  |\n5 |     string.chars()\n  |            ~~~~~\n\nerror[E0061]:\
    \ this function takes 0 arguments but 1 argument was supplied\n    --> /tmp/tmpqrvwmo01.rs:10:65\n\
    \     |\n10   |                 format!(\"{}{}\", c, string[string.len() - string.len(c.len_utf8())\
    \ - 1])\n     |                                                              \
    \   ^^^ ------------ supplied 1 argument\n     |                             \
    \                                    |\n     |                               \
    \                                  expected 0 arguments\n     |\nnote: associated\
    \ function defined here\n\nerror[E0277]: the type `String` cannot be indexed by\
    \ `usize`\n  --> /tmp/tmpqrvwmo01.rs:10:36\n   |\n10 |                 format!(\"\
    {}{}\", c, string[string.len() - string.len(c.len_utf8()) - 1])\n   |        \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0061, E0277, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut len = string.len();\n    let mut prefix = vec![];\n\
    \    while len > 0 {\n        prefix.push(string.as_bytes().prefix(len).to_vec().to_owned());\n\
    \        len -= 1;\n    }\n    prefix\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `prefix` found for reference `&[u8]` in the\
    \ current scope\n --> /tmp/tmpexmatoyk.rs:8:39\n  |\n8 |         prefix.push(string.as_bytes().prefix(len).to_vec().to_owned());\n\
    \  |                                       ^^^^^^ help: there is an associated\
    \ function with a similar name: `strip_prefix`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    string.iter().map(|c| c.to_ascii_lowercase()).collect()\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n --> /tmp/tmpdxrm1evq.rs:5:12\n  |\n5 |     string.iter().map(|c| c.to_ascii_lowercase()).collect()\n\
    \  |            ^^^^ method not found in `String`\n  |\nhelp: because of the in-memory\
    \ representation of `&str`, to obtain an `Iterator` over each of its codepoint\
    \ use method `chars`\n  |\n5 |     string.chars().map(|c| c.to_ascii_lowercase()).collect()\n\
    \  |            ~~~~~\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    string.iter().enumerate().filter(|&(index, c)| c.is_ascii()).map(|(index,\
    \ c)| String::from(&string[index..index + 1])).collect()\n}\n\nfn main() {\n \
    \   let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\"\
    )), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\")),\
    \ vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n --> /tmp/tmp9p_jp04t.rs:5:12\n  |\n5 |     string.iter().enumerate().filter(|&(index,\
    \ c)| c.is_ascii()).map(|(index, c)| String::from(&string[index..index + 1])).collect()\n\
    \  |            ^^^^ method not found in `String`\n  |\nhelp: because of the in-memory\
    \ representation of `&str`, to obtain an `Iterator` over each of its codepoint\
    \ use method `chars`\n  |\n5 |     string.chars().enumerate().filter(|&(index,\
    \ c)| c.is_ascii()).map(|(index, c)| String::from(&string[index..index + 1])).collect()\n\
    \  |            ~~~~~\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    string.iter().cloned().take_while(char::is_alphabetic).collect()\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n --> /tmp/tmp4vofn2gk.rs:5:12\n  |\n5 |     string.iter().cloned().take_while(char::is_alphabetic).collect()\n\
    \  |            ^^^^ method not found in `String`\n  |\nhelp: because of the in-memory\
    \ representation of `&str`, to obtain an `Iterator` over each of its codepoint\
    \ use method `chars`\n  |\n5 |     string.chars().cloned().take_while(char::is_alphabetic).collect()\n\
    \  |            ~~~~~\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut result = Vec::new();\n    let mut prefix = String::from(\"\
    \");\n    for c in string.chars() {\n        if prefix == \"\" {\n           \
    \ prefix = c;\n        } else {\n            if prefix == c {\n              \
    \  continue;\n            }\n            result.push(prefix);\n            prefix\
    \ = c;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpi9kuh9tj.rs:9:22\n  |\n6 |\
    \     let mut prefix = String::from(\"\");\n  |                      ----------------\
    \ expected due to this value\n...\n9 |             prefix = c;\n  |          \
    \            ^- help: try using a conversion method: `.to_string()`\n  |     \
    \                 |\n  |                      expected struct `String`, found\
    \ `char`\n\nerror[E0277]: can't compare `String` with `char`\n  --> /tmp/tmpi9kuh9tj.rs:11:23\n\
    \   |\n11 |             if prefix == c {\n   |                       ^^ no implementation\
    \ for `String == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpi9kuh9tj.rs:15:22\n   |\n6  |     let mut prefix = String::from(\"\
    \");\n   |                      ---------------- expected due to this value\n\
    ...\n15 |             prefix = c;\n   |                      ^- help: try using\
    \ a conversion method: `.to_string()`\n   |                      |\n   |     \
    \                 expected struct `String`, found `char`\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut len = string.len();\n    let mut result = Vec::new();\n\
    \    while len > 0 {\n        result.push(string.substr(0, len));\n        len\
    \ -= 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `substr` found for struct `String` in the\
    \ current scope\n --> /tmp/tmprxh6yiz2.rs:8:28\n  |\n8 |         result.push(string.substr(0,\
    \ len));\n  |                            ^^^^^^ method not found in `String`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    if string.is_empty() {\n        return vec![];\n    }\n\
    \n    let mut prefix = String::from(\"\");\n    let mut prefixes = Vec::new();\n\
    \    let mut prefix_len = 0;\n\n    while let Some(prefix) = get_prefix(&prefix,\
    \ &string, &mut prefix_len) {\n        prefixes.push(prefix);\n    }\n\n    prefixes\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `get_prefix` in this scope\n  --> /tmp/tmp8x0ttggy.rs:13:30\n\
    \   |\n13 |     while let Some(prefix) = get_prefix(&prefix, &string, &mut prefix_len)\
    \ {\n   |                              ^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    all_prefixes_helper(string).collect()\n}\n\nfn main()\
    \ {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `all_prefixes_helper` in this scope\n\
    \ --> /tmp/tmpq57lm_2_.rs:5:5\n  |\n5 |     all_prefixes_helper(string).collect()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 101
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    string.chars().filter(|c| c.is_alphanumeric()).map(|c|\
    \ c.to_string()).collect()\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"s\", \"d\", \"f\", \"g\", \"h\"]`,\n right: `[\"a\", \"as\", \"asd\"\
    , \"asdf\", \"asdfg\", \"asdfgh\"]`', /tmp/tmp4sj80nys.rs:11:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    vec!.iter()\n        .map(|s| s.to_string())\n       \
    \ .take_while(|&s| !s.is_empty())\n        .collect()\n}\n\nfn main() {\n    let\
    \ candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"asdfgh\")), vec![String::from(\"a\"),\
    \ String::from(\"as\"), String::from(\"asd\"), String::from(\"asdf\"), String::from(\"\
    asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `(`, `[`, or `{`, found `.`\n --> /tmp/tmppbh7c897.rs:5:9\n\
    \  |\n5 |     vec!.iter()\n  |         ^ expected one of `(`, `[`, or `{`\n\n\
    error: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    string.chars()\n        .enumerate()\n        .map(|(idx,\
    \ _)| string.chars().nth(idx))\n        .collect()\n}\n\nfn main() {\n    let\
    \ candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"asdfgh\")), vec![String::from(\"a\"),\
    \ String::from(\"as\"), String::from(\"asd\"), String::from(\"asdf\"), String::from(\"\
    asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `Option<char>`\n    --> /tmp/tmph92obeyo.rs:8:10\n   \
    \  |\n8    |         .collect()\n     |          ^^^^^^^ value of type `Vec<String>`\
    \ cannot be built from `std::iter::Iterator<Item=Option<char>>`\n     |\n    \
    \ = help: the trait `FromIterator<Option<char>>` is not implemented for `Vec<String>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut prefix = vec![];\n    while !string.is_empty()\
    \ {\n        let prefix_len = string.removeprefix(1);\n        prefix.push(prefix_len);\n\
    \    }\n    prefix\n}\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `removeprefix` found for struct `String`\
    \ in the current scope\n --> /tmp/tmp79ib8a7z.rs:7:33\n  |\n7 |         let prefix_len\
    \ = string.removeprefix(1);\n  |                                 ^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `remove`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut prefix = vec![];\n    string\n        .chars()\n\
    \        .take_while(|&c| !c.is_ascii_lowercase())\n        .collect::<String>()\
    \ + string\n        .chars()\n        .take_while(|&c| !c.is_ascii_uppercase())\n\
    \        .collect::<String>() + string\n        .chars()\n        .take_while(|&c|\
    \ !c.is_ascii_punctuation())\n        .collect::<String>() + string\n        .chars()\n\
    \        .take_while(|&c| !c.is_ascii_digit())\n        .collect::<String>() +\
    \ string\n        .chars()\n        .take_while(|&c| !c.is_ascii_punctuation())\n\
    \        .collect::<String>() + string\n        .chars()\n        .take_while(|&c|\
    \ !c.is_ascii_letter())\n        .collect::<String>() + string\n        .chars()\n\
    \        .take_while(|&c| !c.is_ascii_letter() || c.is_ascii_digit())\n      \
    \  .collect::<String>() + string\n        .chars()\n        .take_while(|&c| !c.is_ascii_digit()\
    \ || c.is_ascii_punctuation())\n        .collect::<String>() + string\n      \
    \  .chars()\n        .take_while(|&c| !c.is_ascii_letter() || c.is_ascii_digit())\n\
    \        .collect::<String>() + string\n        .chars()\n        .take_while(|&c|\
    \ !c.is_ascii_letter() || c.is_ascii_punctuation())\n        .collect::<String>()\
    \ + string\n        .chars()\n        .take_while(|&c| !c.is_ascii_letter() ||\
    \ c.is_ascii_digit())\n        .collect::<String>() + string\n        .chars()\n\
    \        .take_while(|&c| !c.is_ascii_letter() || c.is_ascii_punctuation())\n\
    \        .collect::<String>() + string\n        .chars()\n        .take_while(|&c|\
    \ !c.is_ascii_letter() || c.is_ascii_digit())\n        .collect::<String>() +\
    \ string\n        .chars()\n        .take_while(|&c| !c.is_ascii_punctuation())\n\
    \        .collect::<String>() + string\n        .chars()\n        .take_while(|&c|\
    \ !c.is_ascii_letter())\n        .collect::<String>() + string\n        .chars()\n\
    \        .take_while(|&c| !c.is_ascii_letter() || c.is_ascii_digit())\n      \
    \  .collect\n}\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgeszmgke.rs:9:32\n   |\n\
    9  |           .collect::<String>() + string\n   |  ________________________________^\n\
    10 | |         .chars()\n11 | |         .take_while(|&c| !c.is_ascii_uppercase())\n\
    12 | |         .collect::<String>() + string\n   | |____________________________^\
    \ expected `&str`, found struct `String`\n   |\nhelp: consider borrowing here\n\
    \   |\n9  ~         .collect::<String>() + &string\n10 +         .chars()\n11\
    \ +         .take_while(|&c| !c.is_ascii_uppercase())\n12 ~         .collect::<String>()\
    \ + string\n   |\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgeszmgke.rs:12:32\n\
    \   |\n12 |           .collect::<String>() + string\n   |  ________________________________^\n\
    13 | |         .chars()\n14 | |         .take_while(|&c| !c.is_ascii_punctuation())\n\
    15 | |         .collect::<String>() + string\n   | |____________________________^\
    \ expected `&str`, found struct `String`\n   |\nhelp: consider borrowing here\n\
    \   |\n12 ~         .collect::<String>() + &string\n13 +         .chars()\n14\
    \ +         .take_while(|&c| !c.is_ascii_punctuation())\n15 ~         .collect::<String>()\
    \ + string\n   |\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgeszmgke.rs:15:32\n\
    \   |\n15 |           .collect::<String>() + string\n   |  ________________________________^\n\
    16 | |         .chars()\n17 | |         .take_while(|&c| !c.is_ascii_digit())\n\
    18 | |         .collect::<String>() + string\n   | |____________________________^\
    \ expected `&str`, found struct `String`\n   |\nhelp: consider borrowing here\n\
    \   |\n15 ~         .collect::<String>() + &string\n16 +         .chars()\n17\
    \ +         .take_while(|&c| !c.is_ascii_digit())\n18 ~         .collect::<String>()\
    \ + string\n   |\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgeszmgke.rs:18:32\n\
    \   |\n18 |           .collect::<String>() + string\n   |  ________________________________^\n\
    19 | |         .chars()\n20 | |         .take_while(|&c| !c.is_ascii_punctuation())\n\
    21 | |         .collect::<String>() + string\n   | |____________________________^\
    \ expected `&str`, found struct `String`\n   |\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    string.bytes().iter()\n        .map(|b| String::from_utf8(&b).unwrap())\n\
    \        .filter(|s| !s.is_empty())\n        .map(|s| s.to_string())\n       \
    \ .collect()\n}\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `std::str::Bytes`\
    \ in the current scope\n --> /tmp/tmpfs9t4in6.rs:5:20\n  |\n5 |     string.bytes().iter()\n\
    \  |                    ^^^^ method not found in `std::str::Bytes<'_>`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpfs9t4in6.rs:6:36\n  |\n6 |         .map(|b| String::from_utf8(&b).unwrap())\n\
    \  |                                    ^^ expected struct `Vec`, found reference\n\
    \  |\n  = note: expected struct `Vec<u8>`\n          found reference `&_`\nhelp:\
    \ consider removing the borrow\n  |\n6 -         .map(|b| String::from_utf8(&b).unwrap())\n\
    6 +         .map(|b| String::from_utf8(b).unwrap())\n  | \n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut prefix_vec = vec![];\n    let mut prefix = String::from(\"\
    \");\n    let mut suffixes = string.splitn(2, |c| !c.is_alphanumeric());\n   \
    \ for suffix in suffixes {\n        prefix = prefix.trim_right().to_string();\n\
    \        prefix_vec.push(prefix);\n    }\n    prefix_vec\n}\n\nfn main() {\n \
    \   let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\"\
    )), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\")),\
    \ vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n --> /tmp/tmpbodkjisa.rs:7:42\n\
    \  |\n7 |     let mut suffixes = string.splitn(2, |c| !c.is_alphanumeric());\n\
    \  |                                          ^ consider giving this closure parameter\
    \ a type\n  |\n  = note: type must be known at this point\n\nwarning: use of deprecated\
    \ associated function `core::str::<impl str>::trim_right`: superseded by `trim_end`\n\
    \ --> /tmp/tmpbodkjisa.rs:9:25\n  |\n9 |         prefix = prefix.trim_right().to_string();\n\
    \  |                         ^^^^^^^^^^ help: replace the use of the deprecated\
    \ associated function: `trim_end`\n  |\n  = note: `#[warn(deprecated)]` on by\
    \ default\n\nerror: aborting due to previous error; 1 warning emitted\n\nFor more\
    \ information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    string.chars()\n        .enumerate()\n        .map(|(i,\
    \ s)| {\n            String::from_utf8(s.to_vec()).unwrap()\n                .prefix(i\
    \ as usize)\n                .collect()\n        })\n        .collect()\n}\n\n\
    fn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_vec` found for type `char` in the current\
    \ scope\n --> /tmp/tmps7vs_0rt.rs:8:33\n  |\n8 |             String::from_utf8(s.to_vec()).unwrap()\n\
    \  |                                 ^^^^^^ method not found in `char`\n\nerror[E0599]:\
    \ no method named `prefix` found for struct `String` in the current scope\n -->\
    \ /tmp/tmps7vs_0rt.rs:9:18\n  |\n9 |                 .prefix(i as usize)\n  |\
    \                  ^^^^^^ help: there is an associated function with a similar\
    \ name: `strip_prefix`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 101
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut current = String::from(\"\");\n    let mut prefixes\
    \ = Vec::new();\n    for c in string.chars() {\n        current.push(c);\n   \
    \     if current.len() == string.len() {\n            prefixes.push(current);\n\
    \            current = String::from(\"\");\n        }\n    }\n    prefixes\n}\n\
    \nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"asdfgh\"]`,\n right: `[\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"\
    ]`', /tmp/tmpl1af35hj.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut result = Vec::new();\n    let mut prefix = String::from(\"\
    \");\n\n    for c in string.chars() {\n        if c.is_alphabetic() || c.is_digit()\
    \ {\n            if !prefix.is_empty() {\n                result.append(prefix);\n\
    \            }\n            prefix = String::from(\"\");\n            prefix.push(c);\n\
    \        } else {\n            if !prefix.is_empty() {\n                result.append(prefix);\n\
    \            }\n            prefix.push(c);\n        }\n    }\n\n    if !prefix.is_empty()\
    \ {\n        result.append(prefix);\n    }\n\n    result\n}\n\nfn main() {\n \
    \   let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\"\
    )), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\")),\
    \ vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \   --> /tmp/tmp_ee45kwc.rs:9:35\n    |\n9   |         if c.is_alphabetic() ||\
    \ c.is_digit() {\n    |                                   ^^^^^^^^- supplied 0\
    \ arguments\n    |                                   |\n    |                \
    \                   expected 1 argument\n    |\nnote: associated function defined\
    \ here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_ee45kwc.rs:11:31\n  \
    \ |\n11 |                 result.append(prefix);\n   |                       \
    \        ^^^^^^ expected `&mut Vec<_>`, found struct `String`\n   |\n   = note:\
    \ expected mutable reference `&mut Vec<_>`\n                         found struct\
    \ `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_ee45kwc.rs:17:31\n\
    \   |\n17 |                 result.append(prefix);\n   |                     \
    \          ^^^^^^ expected `&mut Vec<_>`, found struct `String`\n   |\n   = note:\
    \ expected mutable reference `&mut Vec<_>`\n                         found struct\
    \ `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_ee45kwc.rs:24:23\n\
    \   |\n24 |         result.append(prefix);\n   |                       ^^^^^^\
    \ expected `&mut Vec<_>`, found struct `String`\n   |\n   = note: expected mutable\
    \ reference `&mut Vec<_>`\n                         found struct `String`\n\n\
    error: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0308.\nFor more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    // Reverse the string and get the indices where they change\n\
    \    let mut indices = vec![0; string.len()];\n    for i in 1..string.len() {\n\
    \        if string[i - 1] != string[i - 2] {\n            indices.swap(i, i -\
    \ 1);\n            break;\n        }\n    }\n    for i in indices.iter_mut().rev()\
    \ {\n        string[i] = string[i - 1];\n    }\n    // Extract prefixes from indices\n\
    \    indices.iter().map(|i| &string[i..]).collect()\n}\n\nfn main() {\n    let\
    \ candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"asdfgh\")), vec![String::from(\"a\"),\
    \ String::from(\"as\"), String::from(\"asd\"), String::from(\"asdf\"), String::from(\"\
    asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpfmsvtkxx.rs:8:12\n\
    \  |\n8 |         if string[i - 1] != string[i - 2] {\n  |            ^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n  = help: the following other types implement\
    \ trait `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n     \
    \       <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n\
    \            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpfmsvtkxx.rs:8:29\n\
    \  |\n8 |         if string[i - 1] != string[i - 2] {\n  |                   \
    \          ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n  |\n  = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n  = help: the following\
    \ other types implement trait `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n\
    \            <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n\
    \            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0277]: the type `String` cannot be indexed by `&mut {integer}`\n  -->\
    \ /tmp/tmpfmsvtkxx.rs:14:9\n   |\n14 |         string[i] = string[i - 1];\n  \
    \ |         ^^^^^^^^^ `String` cannot be indexed by `&mut {integer}`\n   |\n \
    \  = help: the trait `Index<&mut {integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             "
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut result = vec![];\n\n    for c in string.chars().take(string.len()\
    \ - 1) {\n        if result.is_empty() {\n            result.push(c);\n      \
    \  } else {\n            result\n                .last_mut()\n               \
    \ .map(|prefix| prefix + c.to_string())\n                .collect::<Vec<String>>()\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot add `String` to `&mut char`\n  --> /tmp/tmp62bb2efm.rs:13:38\n\
    \   |\n13 |                 .map(|prefix| prefix + c.to_string())\n   |      \
    \                         ------ ^ ------------- String\n   |                \
    \               |\n   |                               &mut char\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp62bb2efm.rs:17:5\n   |\n4  | fn all_prefixes(string:\
    \ String) -> Vec<String> {\n   |                                    -----------\
    \ expected `Vec<String>` because of return type\n...\n17 |     result\n   |  \
    \   ^^^^^^ expected struct `String`, found `char`\n   |\n   = note: expected struct\
    \ `Vec<String>`\n              found struct `Vec<char>`\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0369.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut prefix = String::from(\"\");\n    let mut prefix\
    \ = prefix.chars().collect::<String>().into_iter().filter(|&c| *c == 'a' || *c\
    \ == 'b' || *c == 'c' || *c == 'd' || *c == 'e' || *c == 'f' || *c == 'g' || *c\
    \ == 'h' || *c == 'i' || *c == 'j' || *c == 'k' || *c == 'l' || *c == 'm' || *c\
    \ == 'n' || *c == 'o' || *c == 'p' || *c == 'q' || *c == 'r' || *c == 's' || *c\
    \ == 't' || *c == 'u' || *c == 'v' || *c == 'w' || *c == 'x' || *c == 'y' || *c\
    \ == 'z').collect();\n    let mut prefix = prefix.collect::<Vec<String>>();\n\
    \    prefix.reverse();\n    prefix.push(String::from(\"\"));\n    let mut prefix\
    \ = prefix.into_iter().collect::<Vec<String>>();\n    let mut prefix = prefix.reverse().collect::<Vec<String>>();\n\
    \    prefix.push(String::from(\"\"));\n    prefix.push(String::from(\"\"));\n\
    \    let mut prefix = prefix.into_iter().collect::<Vec<String>>();\n    prefix.push(String::from(\"\
    \"));\n    prefix.push(String::from(\"\"));\n    prefix.push(String::from(\"\"\
    ));\n    prefix.push(String::from(\"\"));\n    prefix.push(String::from(\"\"));\n\
    \    prefix.push(String::from(\"\"));\n    prefix.push(String::from(\"\"));\n\
    \    prefix.push(String::from(\"\"));\n    prefix.push(String::from(\"\"));\n\
    \    prefix.push(String::from(\"\"));\n    prefix.push(String::from(\"\"));\n\
    \    prefix.push(String::from(\"\"));\n    prefix.push(String::from(\"\"));\n\
    \    prefix.push(String::from(\"\"));\n    prefix.push(String::from(\"\"));\n\
    \    prefix.push(String::from(\"\"));\n    prefix.push(String::from(\"\"));\n\
    \    prefix.push(String::from(\"\"));\n    prefix.push(String::from(\"\"));\n\
    \    prefix.push(String::from(\"\"));\n    prefix.push(String::from(\"\"));\n\
    \    prefix.push(String::from(\"\"));\n    prefix.push(String::from(\"\"));\n\
    \    prefix.push(String::from(\"\"));\n    prefix.push(String::from(\"\"));\n\
    \    \n}\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: the method `into_iter` exists for struct `String`, but its\
    \ trait bounds were not satisfied\n   --> /tmp/tmpopixqhig.rs:6:57\n    |\n6 \
    \  |       let mut prefix = prefix.chars().collect::<String>().into_iter().filter(|&c|\
    \ *c == 'a' || *c == 'b' || *c == 'c' || *c == 'd' || *c ==...\n    |        \
    \                                                   ^^^^^^^^^\n    |\n    = note:\
    \ the following trait bounds were not satisfied:\n            `String: Iterator`\n\
    \            which is required by `String: IntoIterator`\n            `&String:\
    \ Iterator`\n            which is required by `&String: IntoIterator`\n      \
    \      `&mut String: Iterator`\n            which is required by `&mut String:\
    \ IntoIterator`\n            `str: Sized`\n            which is required by `str:\
    \ IntoIterator`\n            `str: Iterator`\n            which is required by\
    \ `str: IntoIterator`\n            `&str: Iterator`\n            which is required\
    \ by `&str: IntoIterator`\n            `&mut str: Iterator`\n            which\
    \ is required by `&mut str: IntoIterator`\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpopixqhig.rs:4:36\n  |\n4 | fn all_prefixes(string: String) -> Vec<String>\
    \ {\n  |    ------------                    ^^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<String>`\n     \
    \     found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    vec![\"a\".to_string() + \"ab\".to_string()\n        +\
    \ \"abc\".to_string(), \"a\".to_string() + \"b\".to_string()\n        + \"abc\"\
    .to_string(), \"a\".to_string() + \"c\".to_string()\n        + \"abc\".to_string(),\
    \ \"ab\".to_string() + \"c\".to_string()\n        + \"abc\".to_string(), \"ab\"\
    .to_string() + \"c\".to_string()\n        + \"abc\".to_string(), \"abc\".to_string()]\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpz4a0r9uf.rs:5:28\n  |\n5 |\
    \     vec![\"a\".to_string() + \"ab\".to_string()\n  |                       \
    \     ^^^^^^^^^^^^^^^^\n  |                            |\n  |                \
    \            expected `&str`, found struct `String`\n  |                     \
    \       help: consider borrowing here: `&\"ab\".to_string()`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpz4a0r9uf.rs:6:11\n  |\n6 |         + \"abc\"\
    .to_string(), \"a\".to_string() + \"b\".to_string()\n  |           ^^^^^^^^^^^^^^^^^\n\
    \  |           |\n  |           expected `&str`, found struct `String`\n  |  \
    \         help: consider borrowing here: `&\"abc\".to_string()`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpz4a0r9uf.rs:6:48\n  |\n6 |         + \"abc\"\
    .to_string(), \"a\".to_string() + \"b\".to_string()\n  |                     \
    \                           ^^^^^^^^^^^^^^^\n  |                             \
    \                   |\n  |                                                expected\
    \ `&str`, found struct `String`\n  |                                         \
    \       help: consider borrowing here: `&\"b\".to_string()`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpz4a0r9uf.rs:7:11\n  |\n7 |         + \"abc\".to_string(),\
    \ \"a\".to_string() + \"c\".to_string()\n  |           ^^^^^^^^^^^^^^^^^\n  |\
    \           |\n  |           expected `&str`, found struct `String`\n  |     \
    \      help: consider borrowing here: `&\"abc\".to_string()`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpz4a0r9uf.rs:7:48\n  |\n7 |         + \"abc\"\
    .to_string(), \"a\".to_string() + \"c\".to_string()\n  |                     \
    \                           ^^^^^^^^^^^^^^^\n  |                             \
    \                   |\n  |                                                expected\
    \ `&str`, found struct `String`\n  |                                         \
    \       help: consider borrowing here: `&\"c\".to_string()`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpz4a0r9uf.rs:8:11\n  |\n8 |         + \"abc\".to_string(),\
    \ \"ab\".to_string() + \"c\".to_string()\n  |           ^^^^^^^^^^^^^^^^^\n  |\
    \           |\n  |           expected `&str`, f"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    string\n        .chars()\n        .filter(|&c| c.is_alphanumeric())\n\
    \        .filter_map(|c| c.to_ascii_lowercase())\n        .collect::<Vec<_>>()\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp3kz57yn6.rs:8:25\n  |\n8 |\
    \         .filter_map(|c| c.to_ascii_lowercase())\n  |                       \
    \  ^^^^^^^^^^^^^^^^^^^^^^ expected enum `Option`, found `char`\n  |\n  = note:\
    \ expected enum `Option<_>`\n             found type `char`\nhelp: try wrapping\
    \ the expression in `Some`\n  |\n8 |         .filter_map(|c| Some(c.to_ascii_lowercase()))\n\
    \  |                         +++++                      +\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut prefix = Vec::new();\n    let mut it = string.char_indices();\n\
    \    let mut last = it.next();\n    let mut is_first = true;\n    let mut last_len\
    \ = prefix.len();\n    loop {\n        // if last has all characters of input\
    \ string, break\n        if last.index() == 0 && last.len() == string.len() {\n\
    \            break;\n        }\n        // if not first, remember current prefix\
    \ length\n        if is_first {\n            prefix.push(*last);\n           \
    \ last_len += 1;\n            is_first = false;\n        }\n        // if not\
    \ last, append current prefix and add current char to prefix\n        if !last.index()\
    \ {\n            prefix.push(String::from_utf8(last).unwrap());\n            prefix.push(*last);\n\
    \        } else {\n            prefix.push(*last);\n            last_len += 1;\n\
    \        }\n        // if last has all characters, break\n        if last.index()\
    \ == 0 && last.len() == string.len() {\n            break;\n        }\n      \
    \  // set next prefix length\n        last = it.next();\n        last_len += 1;\n\
    \    }\n    prefix\n}\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `index` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmpxo7tpghw.rs:12:17\n   |\n12 |         if last.index() ==\
    \ 0 && last.len() == string.len() {\n   |                 ^^^^^ method not found\
    \ in `Option<(usize, char)>`\n\nerror[E0599]: no method named `len` found for\
    \ enum `Option` in the current scope\n  --> /tmp/tmpxo7tpghw.rs:12:38\n   |\n\
    12 |         if last.index() == 0 && last.len() == string.len() {\n   |      \
    \                                ^^^ method not found in `Option<(usize, char)>`\n\
    \nerror[E0614]: type `Option<(usize, char)>` cannot be dereferenced\n  --> /tmp/tmpxo7tpghw.rs:17:25\n\
    \   |\n17 |             prefix.push(*last);\n   |                         ^^^^^\n\
    \nerror[E0599]: no method named `index` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmpxo7tpghw.rs:22:18\n   |\n22 |         if !last.index()\
    \ {\n   |                  ^^^^^ method not found in `Option<(usize, char)>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpxo7tpghw.rs:23:43\n   |\n23 |\
    \             prefix.push(String::from_utf8(last).unwrap());\n   |           \
    \                                ^^^^ expected struct `Vec`, found enum `Option`\n\
    \   |\n   = note: expected struct `Vec<u8>`\n                found enum `Option<(usize,\
    \ char)>`\n\nerror[E0614]: type `Option<(usize, char)>` cannot be dereferenced\n\
    \  --> /tmp/tmpxo7tpghw.rs:24:25\n   |\n24 |             prefix.push(*last);\n\
    \   |                         ^^^^^\n\nerror[E0614]: type `Option<(usize, char)>`\
    \ cannot be dereferenced\n  --> /tmp/tmpxo7tpghw.rs:26:25\n   |\n26 |        \
    \     prefix.push(*last);\n   |                         ^^^^^\n\nerror[E0599]:\
    \ no method named `index` found for enum `Option` in the current scope\n  -->\
    \ /tmp/tmpxo7tpghw.rs:30:17\n   |\n30 |         if last.index() == 0 && last.len()\
    \ == string.len() {\n   |                 ^^^^^ method not found in `Option<(usize,\
    \ char)>`\n\nerror[E0599]: no method named `len` found for enum `Option` in the\
    \ current scope\n  --> /tmp/tmpxo7tpghw.rs:30:38\n   |\n30 |         if last.index()\
    \ == 0 && last.len() == string.len() {"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    if string.len() == 0 {\n        return vec![];\n    }\n\
    \    let mut prefix_vec: Vec<String> = Vec::new();\n    let mut current_prefix\
    \ = String::new();\n    let mut string_iter = string.chars().nth(0);\n    let\
    \ mut i = 1;\n    loop {\n        match string_iter.next() {\n            None\
    \ => break,\n            Some(' ') => current_prefix.push_str(\"_\"),\n      \
    \      Some(c) => {\n                current_prefix.push_str(&c).unwrap();\n \
    \               prefix_vec.push(current_prefix);\n                i += 1;\n  \
    \              current_prefix = String::new();\n            }\n        }\n   \
    \ }\n    prefix_vec.push(current_prefix);\n    prefix_vec\n}\n\nfn main() {\n\
    \    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\"\
    )), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\")),\
    \ vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `next` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmp1y57m9r1.rs:13:27\n   |\n13 |         match string_iter.next()\
    \ {\n   |                           ^^^^ method not found in `Option<char>`\n\n\
    error[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n  --> /tmp/tmp1y57m9r1.rs:16:18\n   |\n16 |             Some(c) => {\n\
    \   |                  ^ doesn't have a size known at compile-time\n   |\n   =\
    \ help: the trait `Sized` is not implemented for `str`\n   = note: all local variables\
    \ must have a statically known size\n   = help: unsized locals are gated as an\
    \ unstable feature\n\nerror[E0277]: the size for values of type `str` cannot be\
    \ known at compilation time\n   --> /tmp/tmp1y57m9r1.rs:16:13\n    |\n16  |  \
    \           Some(c) => {\n    |             ^^^^^^^ doesn't have a size known\
    \ at compile-time\n    |\n    = help: the trait `Sized` is not implemented for\
    \ `str`\nnote: required by a bound in `Some`\n\nerror[E0599]: no method named\
    \ `unwrap` found for unit type `()` in the current scope\n  --> /tmp/tmp1y57m9r1.rs:17:45\n\
    \   |\n17 |                 current_prefix.push_str(&c).unwrap();\n   |      \
    \                                       ^^^^^^ method not found in `()`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    iterate_prefixes(string, 0, 0)\n}\n\nfn main() {\n   \
    \ let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\")),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\")),\
    \ vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `iterate_prefixes` in this scope\n -->\
    \ /tmp/tmphtqaft3j.rs:5:5\n  |\n5 |     iterate_prefixes(string, 0, 0)\n  |  \
    \   ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 101
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    string.chars()\n        .map(|c| String::from(c))\n  \
    \      .collect::<Vec<String>>()\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"s\", \"d\", \"f\", \"g\", \"h\"]`,\n right: `[\"a\", \"as\", \"asd\"\
    , \"asdf\", \"asdfg\", \"asdfgh\"]`', /tmp/tmpgi48f1zw.rs:13:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    string\n        .into_iter()\n        .chain(Self::prefix_range(&string.chars(),\
    \ 0, 1))\n        .collect()\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Self`\n --> /tmp/tmpspfzt_ig.rs:7:16\n\
    \  |\n7 |         .chain(Self::prefix_range(&string.chars(), 0, 1))\n  |     \
    \           ^^^^ use of undeclared type `Self`\n\nerror[E0599]: the method `into_iter`\
    \ exists for struct `String`, but its trait bounds were not satisfied\n   -->\
    \ /tmp/tmpspfzt_ig.rs:6:10\n    |\n6   |           .into_iter()\n    |       \
    \     ^^^^^^^^^\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `String: Iterator`\n            which is required by `String: IntoIterator`\n\
    \            `&String: Iterator`\n            which is required by `&String: IntoIterator`\n\
    \            `&mut String: Iterator`\n            which is required by `&mut String:\
    \ IntoIterator`\n            `str: Sized`\n            which is required by `str:\
    \ IntoIterator`\n            `str: Iterator`\n            which is required by\
    \ `str: IntoIterator`\n            `&str: Iterator`\n            which is required\
    \ by `&str: IntoIterator`\n            `&mut str: Iterator`\n            which\
    \ is required by `&mut str: IntoIterator`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    itertools::imap(string[..], |c| c.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `itertools`\n\
    \ --> /tmp/tmpkzz0ipra.rs:5:5\n  |\n5 |     itertools::imap(string[..], |c| c.to_string()).collect()\n\
    \  |     ^^^^^^^^^ use of undeclared crate or module `itertools`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    all_prefixes_impl(string, 0)\n}\n\nfn main() {\n    let\
    \ candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"asdfgh\")), vec![String::from(\"a\"),\
    \ String::from(\"as\"), String::from(\"asd\"), String::from(\"asdf\"), String::from(\"\
    asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `all_prefixes_impl` in this scope\n\
    \ --> /tmp/tmp9th4z0pr.rs:5:5\n  |\n5 |     all_prefixes_impl(string, 0)\n  |\
    \     ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    shortest_to_longest_prefix(string).iter().map(|s| s.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `shortest_to_longest_prefix` in this\
    \ scope\n --> /tmp/tmp2uc7issx.rs:5:5\n  |\n5 |     shortest_to_longest_prefix(string).iter().map(|s|\
    \ s.to_string()).collect()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut string = string.to_string();\n    let mut prefix\
    \ = String::from(\"a\");\n    let mut prefixes = Vec::new();\n    while !string.ends_with(&prefix)\
    \ {\n        prefix = prefix + 'a';\n        prefixes.push(prefix);\n    }\n \
    \   prefixes\n}\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp_wrji8gv.rs:9:27\n  |\n9 |\
    \         prefix = prefix + 'a';\n  |                           ^^^ expected `&str`,\
    \ found `char`\n  |\nhelp: if you meant to write a `str` literal, use double quotes\n\
    \  |\n9 |         prefix = prefix + \"a\";\n  |                           ~~~\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    string.iter().map(|c| String::from(c.to_string())).collect()\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n --> /tmp/tmpgn7a049c.rs:5:12\n  |\n5 |     string.iter().map(|c| String::from(c.to_string())).collect()\n\
    \  |            ^^^^ method not found in `String`\n  |\nhelp: because of the in-memory\
    \ representation of `&str`, to obtain an `Iterator` over each of its codepoint\
    \ use method `chars`\n  |\n5 |     string.chars().map(|c| String::from(c.to_string())).collect()\n\
    \  |            ~~~~~\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 101
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    string.chars().map(|c| String::from(c)).collect()\n}\n\
    \nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"s\", \"d\", \"f\", \"g\", \"h\"]`,\n right: `[\"a\", \"as\", \"asd\"\
    , \"asdf\", \"asdfg\", \"asdfgh\"]`', /tmp/tmp7w3k_1pw.rs:11:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut prefix = String::new();\n    let mut suffix_iter\
    \ = string.chars().take_while(|c| c != prefix.len());\n    let mut res = vec![];\n\
    \    loop {\n        res.push(prefix.clone());\n        match suffix_iter.next()\
    \ {\n            Some(suffix) => prefix += suffix,\n            None => break,\n\
    \        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpebuuqw49.rs:6:62\n  |\n6 |\
    \     let mut suffix_iter = string.chars().take_while(|c| c != prefix.len());\n\
    \  |                                                              ^^^^^^^^^^^^\
    \ expected `char`, found `usize`\n\nerror[E0277]: can't compare `&char` with `usize`\n\
    \ --> /tmp/tmpebuuqw49.rs:6:59\n  |\n6 |     let mut suffix_iter = string.chars().take_while(|c|\
    \ c != prefix.len());\n  |                                                   \
    \        ^^ no implementation for `&char == usize`\n  |\n  = help: the trait `PartialEq<usize>`\
    \ is not implemented for `&char`\n  = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpebuuqw49.rs:11:39\n\
    \   |\n11 |             Some(suffix) => prefix += suffix,\n   |              \
    \                         ^^^^^^ expected `&str`, found `char`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    string\n        .into_iter()\n        .map(|c| String::from(c))\n\
    \        .take_while(|c| !c.is_empty())\n        .collect()\n}\n\nfn main() {\n\
    \    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\"\
    )), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\")),\
    \ vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: the method `into_iter` exists for struct `String`, but its\
    \ trait bounds were not satisfied\n   --> /tmp/tmpue2u1ywn.rs:6:10\n    |\n6 \
    \  |           .into_iter()\n    |            ^^^^^^^^^\n    |\n    = note: the\
    \ following trait bounds were not satisfied:\n            `String: Iterator`\n\
    \            which is required by `String: IntoIterator`\n            `&String:\
    \ Iterator`\n            which is required by `&String: IntoIterator`\n      \
    \      `&mut String: Iterator`\n            which is required by `&mut String:\
    \ IntoIterator`\n            `str: Sized`\n            which is required by `str:\
    \ IntoIterator`\n            `str: Iterator`\n            which is required by\
    \ `str: IntoIterator`\n            `&str: Iterator`\n            which is required\
    \ by `&str: IntoIterator`\n            `&mut str: Iterator`\n            which\
    \ is required by `&mut str: IntoIterator`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut result = Vec::new();\n\n    if string.len() ==\
    \ 0 {\n        return result;\n    }\n\n    let mut prefix = String::from(\"\"\
    );\n    result.push(prefix);\n\n    for c in self.iter().rev() {\n        if c\
    \ != string[0] {\n            prefix = String::from(\"\");\n            result.push(prefix);\n\
    \        }\n        prefix = prefix.push_str(&string[1..]);\n    }\n\n    result\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0424]: expected value, found module `self`\n  --> /tmp/tmpv39j5u80.rs:14:14\n\
    \   |\n4  | fn all_prefixes(string: String) -> Vec<String> {\n   |    ------------\
    \ this function can't have a `self` parameter\n...\n14 |     for c in self.iter().rev()\
    \ {\n   |              ^^^^ `self` value is a keyword only available in methods\
    \ with a `self` parameter\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `{integer}`\n  --> /tmp/tmpv39j5u80.rs:15:17\n   |\n15 |         if c !=\
    \ string[0] {\n   |                 ^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpv39j5u80.rs:19:18\n\
    \   |\n11 |     let mut prefix = String::from(\"\");\n   |                   \
    \   ---------------- expected due to this value\n...\n19 |         prefix = prefix.push_str(&string[1..]);\n\
    \   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found `()`\n   |\nnote: method `push_str` modifies its receiver in-place\n \
    \ --> /tmp/tmpv39j5u80.rs:19:25\n   |\n19 |         prefix = prefix.push_str(&string[1..]);\n\
    \   |                  ------ ^^^^^^^^ this call modifies `prefix` in-place\n\
    \   |                  |\n   |                  you probably want to use this\
    \ value after calling the method...\n   = note: ...instead of the `()` output\
    \ of method `push_str`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308, E0424.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 101
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    string\n        .chars()\n        .filter(|c| !c.is_alphanumeric())\n\
    \        .map(|c| c.to_string())\n        .collect()\n}\n\nfn main() {\n    let\
    \ candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"asdfgh\")), vec![String::from(\"a\"),\
    \ String::from(\"as\"), String::from(\"asd\"), String::from(\"asdf\"), String::from(\"\
    asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"]`',\
    \ /tmp/tmpa1t4gsht.rs:15:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    string.chars().flat_map(|c| {\n        let s = String::from(c);\n\
    \        let mut iter = s.char_indices();\n        let mut prefix = String::new();\n\
    \        iter.next().unwrap().to_string().chars().take(1).for_each(|x|\n     \
    \       prefix.push(x)\n        );\n        prefix\n    })\n}\n\nfn main() {\n\
    \    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\"\
    )), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\")),\
    \ vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `(usize, char)` doesn't implement `std::fmt::Display`\n -->\
    \ /tmp/tmp2srtzcsx.rs:9:30\n  |\n9 |         iter.next().unwrap().to_string().chars().take(1).for_each(|x|\n\
    \  |                              ^^^^^^^^^ `(usize, char)` cannot be formatted\
    \ with the default formatter\n  |\n  = note: the following trait bounds were not\
    \ satisfied:\n          `(usize, char): std::fmt::Display`\n          which is\
    \ required by `(usize, char): ToString`\n\nerror[E0277]: `String` is not an iterator\n\
    \    --> /tmp/tmp2srtzcsx.rs:5:29\n     |\n5    |       string.chars().flat_map(|c|\
    \ {\n     |  ____________________--------_^\n     | |                    |\n \
    \    | |                    required by a bound introduced by this call\n6   \
    \ | |         let s = String::from(c);\n7    | |         let mut iter = s.char_indices();\n\
    8    | |         let mut prefix = String::new();\n...    |\n12   | |         prefix\n\
    13   | |     })\n     | |_____^ `String` is not an iterator; try calling `.chars()`\
    \ or `.bytes()`\n     |\n     = help: the trait `Iterator` is not implemented\
    \ for `String`\n     = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `String`\nnote: required by a bound in `flat_map`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp2srtzcsx.rs:5:5\n   |\n4  |   fn\
    \ all_prefixes(string: String) -> Vec<String> {\n   |                        \
    \              ----------- expected `Vec<String>` because of return type\n5  |\
    \ /     string.chars().flat_map(|c| {\n6  | |         let s = String::from(c);\n\
    7  | |         let mut iter = s.char_indices();\n8  | |         let mut prefix\
    \ = String::new();\n...  |\n12 | |         prefix\n13 | |     })\n   | |______^\
    \ expected struct `Vec`, found struct `FlatMap`\n   |\n   = note: expected struct\
    \ `Vec<String>`\n              found struct `FlatMap<Chars<'_>, String, [closure@/tmp/tmp2srtzcsx.rs:5:29:\
    \ 13:6]>`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    string.iter().map(|c| {\n        String::from(c)\n   \
    \ }).collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n --> /tmp/tmp3mve39y6.rs:5:12\n  |\n5 |     string.iter().map(|c| {\n\
    \  |            ^^^^ method not found in `String`\n  |\nhelp: because of the in-memory\
    \ representation of `&str`, to obtain an `Iterator` over each of its codepoint\
    \ use method `chars`\n  |\n5 |     string.chars().map(|c| {\n  |            ~~~~~\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    string.iter().cloned().map(|c| {\n        let mut prefix\
    \ = c.to_lowercase();\n        let mut i = 0;\n        loop {\n            i +=\
    \ 1;\n            if i >= prefix.len() {\n                break;\n           \
    \ }\n            prefix = prefix.insert(0, c.chars().nth(i).unwrap().to_lowercase());\n\
    \        }\n        prefix.into()\n    }).collect()\n}\n\nfn main() {\n    let\
    \ candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"asdfgh\")), vec![String::from(\"a\"),\
    \ String::from(\"as\"), String::from(\"asd\"), String::from(\"asdf\"), String::from(\"\
    asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n --> /tmp/tmp2tqerdeu.rs:5:12\n  |\n5 |     string.iter().cloned().map(|c|\
    \ {\n  |            ^^^^ method not found in `String`\n  |\nhelp: because of the\
    \ in-memory representation of `&str`, to obtain an `Iterator` over each of its\
    \ codepoint use method `chars`\n  |\n5 |     string.chars().cloned().map(|c| {\n\
    \  |            ~~~~~\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    all_prefixes_iter(string).collect()\n}\n\nfn main() {\n\
    \    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\"\
    )), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\")),\
    \ vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `all_prefixes_iter` in this scope\n\
    \ --> /tmp/tmprq83cmmp.rs:5:5\n  |\n5 |     all_prefixes_iter(string).collect()\n\
    \  |     ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    string.chars().take_while(|c| c != '\\0').collect()\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmpjpz7giix.rs:5:37\n\
    \  |\n5 |     string.chars().take_while(|c| c != '\\0').collect()\n  |       \
    \                              ^^ no implementation for `&char == char`\n  |\n\
    \  = help: the trait `PartialEq<char>` is not implemented for `&char`\n  = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: a value of\
    \ type `Vec<String>` cannot be built from an iterator over elements of type `char`\n\
    \    --> /tmp/tmpjpz7giix.rs:5:46\n     |\n5    |     string.chars().take_while(|c|\
    \ c != '\\0').collect()\n     |                                              ^^^^^^^\
    \ value of type `Vec<String>` cannot be built from `std::iter::Iterator<Item=char>`\n\
    \     |\n     = help: the trait `FromIterator<char>` is not implemented for `Vec<String>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut vec = Vec::new();\n    vec.push(\"\");\n    let\
    \ mut len = string.length();\n    let mut count = 1;\n    while count != 0 {\n\
    \        vec.push(string.chars().take(len).collect::<String>());\n        count\
    \ += 1;\n        len += 1;\n    }\n    vec\n}\n\nfn main() {\n    let candidate\
    \ = all_prefixes;\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"asdfgh\")), vec![String::from(\"a\"),\
    \ String::from(\"as\"), String::from(\"asd\"), String::from(\"asdf\"), String::from(\"\
    asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n --> /tmp/tmpux2fs0sy.rs:7:26\n  |\n7 |     let mut len = string.length();\n\
    \  |                          ^^^^^^ help: there is an associated function with\
    \ a similar name: `len`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpux2fs0sy.rs:10:18\n\
    \   |\n10 |         vec.push(string.chars().take(len).collect::<String>());\n\
    \   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |    \
    \              |\n   |                  expected `&str`, found struct `String`\n\
    \   |                  help: consider borrowing here: `&string.chars().take(len).collect::<String>()`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpux2fs0sy.rs:14:5\n   |\n4  | fn\
    \ all_prefixes(string: String) -> Vec<String> {\n   |                        \
    \            ----------- expected `Vec<String>` because of return type\n...\n\
    14 |     vec\n   |     ^^^ expected struct `String`, found `&str`\n   |\n   =\
    \ note: expected struct `Vec<String>`\n              found struct `Vec<&str>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    string\n        .chars()\n        .enumerate()\n     \
    \   .filter_map(|(i, c)| {\n            c < 'a' || i > string.length() - 1 ||\
    \ (c == 'a' && i != 'a') || (c == 'b' && i != 'a')\n        })\n        .map(|(i,\
    \ c)| String::from(&string[i .. i + 1]))\n        .collect()\n}\n\nfn main() {\n\
    \    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\"\
    )), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\")),\
    \ vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n --> /tmp/tmp75fyi985.rs:9:35\n  |\n9 |             c < 'a' ||\
    \ i > string.length() - 1 || (c == 'a' && i != 'a') || (c == 'b' && i != 'a')\n\
    \  |                                   ^^^^^^ help: there is an associated function\
    \ with a similar name: `len`\n\nerror[E0308]: mismatched types\n --> /tmp/tmp75fyi985.rs:9:69\n\
    \  |\n9 |             c < 'a' || i > string.length() - 1 || (c == 'a' && i !=\
    \ 'a') || (c == 'b' && i != 'a')\n  |                                        \
    \                             ^^^ expected `usize`, found `char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp75fyi985.rs:9:95\n  |\n9 |             c < 'a'\
    \ || i > string.length() - 1 || (c == 'a' && i != 'a') || (c == 'b' && i != 'a')\n\
    \  |                                                                         \
    \                      ^^^ expected `usize`, found `char`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp75fyi985.rs:9:13\n  |\n9 |             c < 'a' || i > string.length()\
    \ - 1 || (c == 'a' && i != 'a') || (c == 'b' && i != 'a')\n  |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected enum `Option`, found `bool`\n  |\n  = note: expected enum `Option<_>`\n\
    \             found type `bool`\nhelp: try wrapping the expression in `Some`\n\
    \  |\n9 |             Some(c < 'a' || i > string.length() - 1 || (c == 'a' &&\
    \ i != 'a') || (c == 'b' && i != 'a'))\n  |             +++++                \
    \                                                                      +\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut strings: Vec<String> = Vec::new();\n    let mut\
    \ prefixes: Vec<String> = Vec::new();\n    let mut prefix = String::new();\n \
    \   strings.extend_from_slice(string.chars().collect::<Vec<_>>());\n    while\
    \ strings.len() > 0 {\n        prefix = strings.pop().to_string();\n        prefixes.push(prefix);\n\
    \        for _ in 0..strings {\n            strings.remove(0).unwrap();\n    \
    \    }\n    }\n    prefixes.into_iter().collect()\n}\n\nfn main() {\n    let candidate\
    \ = all_prefixes;\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"asdfgh\")), vec![String::from(\"a\"),\
    \ String::from(\"as\"), String::from(\"asd\"), String::from(\"asdf\"), String::from(\"\
    asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpf8ut3g6p.rs:8:31\n  |\n8 |\
    \     strings.extend_from_slice(string.chars().collect::<Vec<_>>());\n  |    \
    \                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&[String]`,\
    \ found struct `Vec`\n  |\n  = note: expected reference `&[String]`\n        \
    \        found struct `Vec<char>`\n\nerror[E0599]: `Option<String>` doesn't implement\
    \ `std::fmt::Display`\n   --> /tmp/tmpf8ut3g6p.rs:10:32\n    |\n10  |        \
    \   prefix = strings.pop().to_string();\n    |                               \
    \   ^^^^^^^^^ `Option<String>` cannot be formatted with the default formatter\n\
    \    |\n    = note: the following trait bounds were not satisfied:\n         \
    \   `Option<String>: std::fmt::Display`\n            which is required by `Option<String>:\
    \ ToString`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf8ut3g6p.rs:12:21\n\
    \   |\n12 |         for _ in 0..strings {\n   |                     ^^^^^^^ expected\
    \ integer, found struct `Vec`\n   |\n   = note: expected type `{integer}`\n  \
    \          found struct `Vec<String>`\n\nerror[E0599]: no method named `unwrap`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpf8ut3g6p.rs:13:31\n\
    \   |\n13 |             strings.remove(0).unwrap();\n   |                    \
    \           ^^^^^^ method not found in `String`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    string.chars().filter(|c| !c.is_ascii_lowercase()).collect()\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmp8a345ndp.rs:5:56\n     |\n5  \
    \  |     string.chars().filter(|c| !c.is_ascii_lowercase()).collect()\n     |\
    \                                                        ^^^^^^^ value of type\
    \ `Vec<String>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<String>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    all_prefixes_iter(string).collect()\n}\n\nfn main() {\n\
    \    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\"\
    )), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\")),\
    \ vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `all_prefixes_iter` in this scope\n\
    \ --> /tmp/tmprq83cmmp.rs:5:5\n  |\n5 |     all_prefixes_iter(string).collect()\n\
    \  |     ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    string\n        .split_ascii_whitespace()\n        .filter_map(|s|\
    \ s.chars().enumerate().filter_map(|(i, c)| {\n            if i % 2 == 0 {\n \
    \               None\n            } else {\n                Some(String::from(c))\n\
    \            }\n        }))\n        .collect::<Vec<_>>()\n}\n\nfn main() {\n\
    \    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\"\
    )), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\")),\
    \ vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprycl80yl.rs:7:25\n   |\n\
    7  |           .filter_map(|s| s.chars().enumerate().filter_map(|(i, c)| {\n \
    \  |  _________________________^\n8  | |             if i % 2 == 0 {\n9  | | \
    \                None\n10 | |             } else {\n11 | |                 Some(String::from(c))\n\
    12 | |             }\n13 | |         }))\n   | |__________^ expected enum `Option`,\
    \ found struct `FilterMap`\n   |\n   = note: expected enum `Option<_>`\n     \
    \       found struct `FilterMap<Enumerate<Chars<'_>>, [closure@/tmp/tmprycl80yl.rs:7:58:\
    \ 13:10]>`\nhelp: try wrapping the expression in `Some`\n   |\n7  ~         .filter_map(|s|\
    \ Some(s.chars().enumerate().filter_map(|(i, c)| {\n8  |             if i % 2\
    \ == 0 {\n9  |                 None\n10 |             } else {\n11 |         \
    \        Some(String::from(c))\n12 |             }\n ...\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    string\n        .split_off(string.len() - 1)\n       \
    \ .map(|s| s.to_owned())\n        .collect()\n}\n\nfn main() {\n    let candidate\
    \ = all_prefixes;\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"asdfgh\")), vec![String::from(\"a\"),\
    \ String::from(\"as\"), String::from(\"asd\"), String::from(\"asdf\"), String::from(\"\
    asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `String` is not an iterator\n   --> /tmp/tmpmafsmo0p.rs:7:10\n\
    \    |\n7   |           .map(|s| s.to_owned())\n    |            ^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = note:\
    \ the following trait bounds were not satisfied:\n            `String: Iterator`\n\
    \            which is required by `&mut String: Iterator`\n            `str: Iterator`\n\
    \            which is required by `&mut str: Iterator`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut string = string;\n    let mut prefix = String::from(\"\
    \");\n    loop {\n        prefix.push(string);\n        string = &string[..];\n\
    \        if string.is_empty() {\n            break;\n        }\n    }\n    prefix.into_iter().collect()\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpu88i1gyx.rs:8:21\n  |\n8 |\
    \         prefix.push(string);\n  |                     ^^^^^^ expected `char`,\
    \ found struct `String`\n\nerror[E0308]: mismatched types\n --> /tmp/tmpu88i1gyx.rs:9:18\n\
    \  |\n5 |     let mut string = string;\n  |                      ------ expected\
    \ due to this value\n...\n9 |         string = &string[..];\n  |             \
    \     ^^^^^^^^^^^ expected struct `String`, found `&str`\n  |\nhelp: try using\
    \ a conversion method\n  |\n9 |         string = (&string[..]).to_string();\n\
    \  |                  +           +++++++++++++\n\nerror[E0599]: the method `into_iter`\
    \ exists for struct `String`, but its trait bounds were not satisfied\n   -->\
    \ /tmp/tmpu88i1gyx.rs:14:12\n    |\n14  |       prefix.into_iter().collect()\n\
    \    |              ^^^^^^^^^\n    |\n    = note: the following trait bounds were\
    \ not satisfied:\n            `String: Iterator`\n            which is required\
    \ by `String: IntoIterator`\n            `&String: Iterator`\n            which\
    \ is required by `&String: IntoIterator`\n            `&mut String: Iterator`\n\
    \            which is required by `&mut String: IntoIterator`\n            `str:\
    \ Sized`\n            which is required by `str: IntoIterator`\n            `str:\
    \ Iterator`\n            which is required by `str: IntoIterator`\n          \
    \  `&str: Iterator`\n            which is required by `&str: IntoIterator`\n \
    \           `&mut str: Iterator`\n            which is required by `&mut str:\
    \ IntoIterator`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut output = vec![];\n    let mut prefixes = {\n \
    \       let mut string = string;\n        let mut prefix = vec![];\n        loop\
    \ {\n            let index = string.find('_');\n            if index == String::npos\
    \ {\n                prefix = prefix.to_owned();\n                output.push(prefix.clone());\n\
    \                break;\n            }\n            prefix = prefix.to_owned();\n\
    \            prefix.push(string.trim_end());\n            string = string.trim_start()\
    \ + &string[index + 1..].to_string();\n        }\n    };\n    output\n}\n\nfn\
    \ main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no function or associated item named `npos` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmp1jtbbzry.rs:11:33\n   |\n11 | \
    \            if index == String::npos {\n   |                                \
    \ ^^^^ function or associated item not found in `String`\n\nerror[E0369]: cannot\
    \ add `{integer}` to `Option<usize>`\n  --> /tmp/tmp1jtbbzry.rs:18:58\n   |\n\
    18 |             string = string.trim_start() + &string[index + 1..].to_string();\n\
    \   |                                                    ----- ^ - {integer}\n\
    \   |                                                    |\n   |             \
    \                                       Option<usize>\n\nerror[E0369]: cannot\
    \ add `&String` to `&str`\n  --> /tmp/tmp1jtbbzry.rs:18:42\n   |\n18 |       \
    \      string = string.trim_start() + &string[index + 1..].to_string();\n   |\
    \                      ------------------- ^ --------------------------------\
    \ &String\n   |                      |                   |\n   |             \
    \         |                   `+` cannot be used to concatenate two `&str` strings\n\
    \   |                      &str\n   |\n   = note: string concatenation requires\
    \ an owned `String` on the left\nhelp: create an owned `String` from a string\
    \ reference\n   |\n18 |             string = string.trim_start().to_owned() +\
    \ &string[index + 1..].to_string();\n   |                                    \
    \     +++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1jtbbzry.rs:21:5\n\
    \   |\n4  | fn all_prefixes(string: String) -> Vec<String> {\n   |           \
    \                         ----------- expected `Vec<String>` because of return\
    \ type\n...\n21 |     output\n   |     ^^^^^^ expected struct `String`, found\
    \ struct `Vec`\n   |\n   = note: expected struct `Vec<String>`\n             \
    \ found struct `Vec<Vec<&str>>`\n\nerror: aborting due to 4 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0369, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    string.chars()\n        .filter_map(|c| c != '\\0')\n\
    \        .filter_map(|c| {\n            if c != '/' && c != '\\\\' {\n       \
    \         Some(c + '/')\n            } else {\n                None\n        \
    \    }\n        })\n        .take(string.len())\n        .collect()\n}\n\nfn main()\
    \ {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp9h01kqrr.rs:6:25\n  |\n6 |\
    \         .filter_map(|c| c != '\\0')\n  |                         ^^^^^^^^^ expected\
    \ enum `Option`, found `bool`\n  |\n  = note: expected enum `Option<_>`\n    \
    \         found type `bool`\nhelp: try wrapping the expression in `Some`\n  |\n\
    6 |         .filter_map(|c| Some(c != '\\0'))\n  |                         +++++\
    \         +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut out = Vec::new();\n    let mut iter = string.chars();\n\
    \    loop {\n        let next_char = iter.next().unwrap();\n        if next_char\
    \ == Some(Self::EOF || Self::NEW_LINE) {\n            break;\n        }\n    \
    \    let mut out_iter = out.iter();\n        let mut prefix = String::from(' ');\n\
    \        loop {\n            if prefix.len() == 0 || next_char == Some(Self::EOL)\
    \ {\n                out_iter.push(prefix);\n                break;\n        \
    \    }\n            if next_char == Some(Self::EOF) {\n                break;\n\
    \            }\n            if prefix.len() == 1 || next_char == Some(Self::NEW_LINE)\
    \ {\n                out_iter.push(prefix);\n                break;\n        \
    \    }\n            prefix.push(*next_char);\n        }\n        out.push(String::from(out_iter.next().unwrap()));\n\
    \    }\n    out\n}\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Self`\n --> /tmp/tmplawzgymm.rs:9:30\n\
    \  |\n9 |         if next_char == Some(Self::EOF || Self::NEW_LINE) {\n  |   \
    \                           ^^^^ use of undeclared type `Self`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Self`\n --> /tmp/tmplawzgymm.rs:9:43\n\
    \  |\n9 |         if next_char == Some(Self::EOF || Self::NEW_LINE) {\n  |   \
    \                                        ^^^^ use of undeclared type `Self`\n\n\
    error[E0433]: failed to resolve: use of undeclared type `Self`\n  --> /tmp/tmplawzgymm.rs:15:55\n\
    \   |\n15 |             if prefix.len() == 0 || next_char == Some(Self::EOL) {\n\
    \   |                                                       ^^^^ use of undeclared\
    \ type `Self`\n\nerror[E0433]: failed to resolve: use of undeclared type `Self`\n\
    \  --> /tmp/tmplawzgymm.rs:19:34\n   |\n19 |             if next_char == Some(Self::EOF)\
    \ {\n   |                                  ^^^^ use of undeclared type `Self`\n\
    \nerror[E0433]: failed to resolve: use of undeclared type `Self`\n  --> /tmp/tmplawzgymm.rs:22:55\n\
    \   |\n22 |             if prefix.len() == 1 || next_char == Some(Self::NEW_LINE)\
    \ {\n   |                                                       ^^^^ use of undeclared\
    \ type `Self`\n\nerror[E0308]: mismatched types\n --> /tmp/tmplawzgymm.rs:9:25\n\
    \  |\n9 |         if next_char == Some(Self::EOF || Self::NEW_LINE) {\n  |   \
    \                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found\
    \ enum `Option`\n  |\n  = note: expected type `char`\n             found enum\
    \ `Option<bool>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplawzgymm.rs:15:50\n\
    \   |\n15 |             if prefix.len() == 0 || next_char == Some(Self::EOL) {\n\
    \   |                                                  ^^^^^^^^^^^^^^^ expected\
    \ `char`, found enum `Option`\n   |\n   = note: expected type `char`\n       \
    \       found enum `Option<_>`\n\nerror[E0599]: no method named `push` found for\
    \ struct `std::slice::Iter` in the current scope\n  --> /tmp/tmplawzgymm.rs:16:26\n\
    \   |\n16 |                 out_iter.push(prefix);\n   |       "
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    all_prefixes_helper(string).collect()\n}\n\nfn main()\
    \ {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `all_prefixes_helper` in this scope\n\
    \ --> /tmp/tmpq57lm_2_.rs:5:5\n  |\n5 |     all_prefixes_helper(string).collect()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 101
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    string.chars().map(|c| String::from(c)).collect()\n}\n\
    \nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"s\", \"d\", \"f\", \"g\", \"h\"]`,\n right: `[\"a\", \"as\", \"asd\"\
    , \"asdf\", \"asdfg\", \"asdfgh\"]`', /tmp/tmp7w3k_1pw.rs:11:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut prefix = vec![];\n\n    for ch in string.chars()\
    \ {\n        prefix.push(&string[..ch]);\n    }\n\n    prefix\n}\n\nfn main()\
    \ {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `RangeTo<char>`\n\
    \ --> /tmp/tmpywym6e4k.rs:8:22\n  |\n8 |         prefix.push(&string[..ch]);\n\
    \  |                      ^^^^^^^^^^^^ `String` cannot be indexed by `RangeTo<char>`\n\
    \  |\n  = help: the trait `Index<RangeTo<char>>` is not implemented for `String`\n\
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \   <String as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n\
    \            <String as Index<RangeInclusive<usize>>>\n            <String as\
    \ Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpywym6e4k.rs:11:5\n   |\n4  | fn\
    \ all_prefixes(string: String) -> Vec<String> {\n   |                        \
    \            ----------- expected `Vec<String>` because of return type\n...\n\
    11 |     prefix\n   |     ^^^^^^ expected struct `String`, found reference\n \
    \  |\n   = note: expected struct `Vec<String>`\n              found struct `Vec<&_>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    string\n        .chars()\n        .filter(|c| !c.is_alphanumeric())\n\
    \        .chain(string.chars().take(string.len()))\n        .collect()\n}\n\n\
    fn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmpql77udou.rs:9:10\n     |\n9  \
    \  |         .collect()\n     |          ^^^^^^^ value of type `Vec<String>` cannot\
    \ be built from `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait\
    \ `FromIterator<char>` is not implemented for `Vec<String>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut prefix = vec![];\n    let mut tail = string;\n\
    \    while let Some(next) = tail.rfind(' ', ) {\n        prefix.push(tail[0..next]);\n\
    \        tail = tail.split_off(next);\n    }\n    prefix.push(tail);\n    prefix\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n   --> /tmp/tmp_bh7e8zf.rs:8:21\n    |\n8   |         prefix.push(tail[0..next]);\n\
    \    |                ---- ^^^^^^^^^^^^^ doesn't have a size known at compile-time\n\
    \    |                |\n    |                required by a bound introduced by\
    \ this call\n    |\n    = help: the trait `Sized` is not implemented for `str`\n\
    note: required by a bound in `Vec::<T, A>::push`\n\nerror[E0277]: the size for\
    \ values of type `str` cannot be known at compilation time\n   --> /tmp/tmp_bh7e8zf.rs:5:22\n\
    \    |\n5   |     let mut prefix = vec![];\n    |                      ^^^^^^\
    \ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized`\
    \ is not implemented for `str`\nnote: required by a bound in `Vec::<T>::new`\n\
    \    = note: this error originates in the macro `vec` (in Nightly builds, run\
    \ with -Z macro-backtrace for more info)\n\nerror[E0277]: the size for values\
    \ of type `str` cannot be known at compilation time\n   --> /tmp/tmp_bh7e8zf.rs:5:22\n\
    \    |\n5   |     let mut prefix = vec![];\n    |                      ^^^^^^\
    \ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized`\
    \ is not implemented for `str`\nnote: required by a bound in `Vec`\n    = note:\
    \ this error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace\
    \ for more info)\n\nerror[E0599]: the method `push` exists for struct `Vec<str>`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmp_bh7e8zf.rs:11:12\n \
    \  |\n11 |     prefix.push(tail);\n   |            ^^^^ method cannot be called\
    \ on `Vec<str>` due to unsatisfied trait bounds\n   |\n   = note: the following\
    \ trait bounds were not satisfied:\n           `str: Sized`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_bh7e8zf.rs:12:5\n   |\n4  | fn all_prefixes(string: String)\
    \ -> Vec<String> {\n   |                                    ----------- expected\
    \ `Vec<String>` because of return type\n...\n12 |     prefix\n   |     ^^^^^^\
    \ expected struct `String`, found `str`\n   |\n   = note: expected struct `Vec<String>`\n\
    \    "
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    all_prefixes_helper(string, string.chars().cloned())\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `all_prefixes_helper` in this scope\n\
    \ --> /tmp/tmprt3fempu.rs:5:5\n  |\n5 |     all_prefixes_helper(string, string.chars().cloned())\n\
    \  |     ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0271]: type mismatch\
    \ resolving `<Chars<'_> as Iterator>::Item == &_`\n    --> /tmp/tmprt3fempu.rs:5:48\n\
    \     |\n5    |     all_prefixes_helper(string, string.chars().cloned())\n   \
    \  |                                                ^^^^^^ expected reference,\
    \ found `char`\n     |\n     = note: expected reference `&_`\n               \
    \      found type `char`\nnote: required by a bound in `cloned`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0271, E0425.\n\
    For more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 101
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut prefix = Vec::new();\n    let mut len = string.len();\n\
    \    let mut pos = 0;\n    while len > 0 {\n        prefix.push(string.chars().skip(pos).take(len).collect::<String>());\n\
    \        len -= 1;\n        pos += 1;\n    }\n    prefix\n}\n\nfn main() {\n \
    \   let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\"\
    )), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\")),\
    \ vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"asdfgh\", \"sdfgh\", \"dfgh\", \"fgh\", \"gh\", \"h\"]`,\n right: `[\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"]`', /tmp/tmp5eeev82w.rs:19:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut string = string.to_string();\n    let mut prefix\
    \ = String::from(\"\");\n\n    while !string.is_empty() {\n        let start =\
    \ string.len() - 1;\n        let mut suffix = String::from(\"\");\n\n        while\
    \ start >= 0 {\n            let c = string.chars().nth(start).unwrap();\n    \
    \        suffix = if c >= 'a' && c <= 'z' { String::from(c) + suffix } else {\
    \ String::from(\"\") + suffix };\n            start -= 1;\n        }\n\n     \
    \   prefix.push(suffix);\n        string = string;\n    }\n\n    prefix.reverse();\n\
    \    vec![prefix]\n}\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwjs6pzg7.rs:14:66\n   |\n\
    14 |             suffix = if c >= 'a' && c <= 'z' { String::from(c) + suffix }\
    \ else { String::from(\"\") + suffix };\n   |                                \
    \                                  ^^^^^^\n   |                              \
    \                                    |\n   |                                 \
    \                                 expected `&str`, found struct `String`\n   |\
    \                                                                  help: consider\
    \ borrowing here: `&suffix`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwjs6pzg7.rs:14:101\n\
    \   |\n14 |             suffix = if c >= 'a' && c <= 'z' { String::from(c) + suffix\
    \ } else { String::from(\"\") + suffix };\n   |                              \
    \                                                                       ^^^^^^\n\
    \   |                                                                        \
    \                             |\n   |                                        \
    \                                                             expected `&str`,\
    \ found struct `String`\n   |                                                \
    \                                                     help: consider borrowing\
    \ here: `&suffix`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwjs6pzg7.rs:18:21\n\
    \   |\n18 |         prefix.push(suffix);\n   |                     ^^^^^^ expected\
    \ `char`, found struct `String`\n\nerror[E0599]: no method named `reverse` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmpwjs6pzg7.rs:22:12\n\
    \   |\n22 |     prefix.reverse();\n   |            ^^^^^^^ help: there is an associated\
    \ function with a similar name: `reserve`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut string = string[..];\n    let mut prefixes = Vec::new();\n\
    \    while !string.is_empty() {\n        let last_char = string.chars().last().unwrap();\n\
    \        prefixes.push(string.substr(0..string.len() - 1));\n        string =\
    \ &last_char;\n    }\n    prefixes\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n --> /tmp/tmpyyy5zdxh.rs:5:9\n  |\n5 |     let mut string = string[..];\n\
    \  |         ^^^^^^^^^^ doesn't have a size known at compile-time\n  |\n  = help:\
    \ the trait `Sized` is not implemented for `str`\n  = note: all local variables\
    \ must have a statically known size\n  = help: unsized locals are gated as an\
    \ unstable feature\nhelp: consider borrowing here\n  |\n5 |     let mut string\
    \ = &string[..];\n  |                      +\n\nerror[E0599]: no method named\
    \ `substr` found for type `str` in the current scope\n --> /tmp/tmpyyy5zdxh.rs:9:30\n\
    \  |\n9 |         prefixes.push(string.substr(0..string.len() - 1));\n  |    \
    \                          ^^^^^^ method not found in `str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpyyy5zdxh.rs:10:18\n   |\n5  |     let mut string = string[..];\n\
    \   |                      ---------- expected due to this value\n...\n10 |  \
    \       string = &last_char;\n   |                  ^^^^^^^^^^ expected `str`,\
    \ found `&char`\n\nerror[E0277]: the size for values of type `str` cannot be known\
    \ at compilation time\n  --> /tmp/tmpyyy5zdxh.rs:10:9\n   |\n10 |         string\
    \ = &last_char;\n   |         ^^^^^^ doesn't have a size known at compile-time\n\
    \   |\n   = help: the trait `Sized` is not implemented for `str`\n   = note: the\
    \ left-hand-side of an assignment must have a statically known size\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 101
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut prefix_vec = Vec::new();\n\n    for prefix in\
    \ string.to_lowercase().chars().take(string.len() - 1) {\n        prefix_vec.push(prefix.to_string());\n\
    \    }\n\n    prefix_vec\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp90_gsrxc.rs:7:54

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976676
- exit_code: 101
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut prefix = String::from(\"\");\n    let mut prefix\
    \ = prefix.clone();\n    prefix.push_str(&string);\n    prefix.push_str(&string);\n\
    \    prefix.push_str(&string);\n    vec![prefix]\n}\n\nfn main() {\n    let candidate\
    \ = all_prefixes;\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"asdfgh\")), vec![String::from(\"a\"),\
    \ String::from(\"as\"), String::from(\"asd\"), String::from(\"asdf\"), String::from(\"\
    asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"\"]`,\n right: `[]`', /tmp/tmpcpveczyk.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 101
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut prefix = Vec::new();\n    for ch in string.chars()\
    \ {\n        prefix.push(String::from(ch));\n    }\n    prefix\n}\n\nfn main()\
    \ {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"s\", \"d\", \"f\", \"g\", \"h\"]`,\n right: `[\"a\", \"as\", \"asd\"\
    , \"asdf\", \"asdfg\", \"asdfgh\"]`', /tmp/tmp78yw_2f_.rs:15:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    if string.len() < 2 {\n        return vec![String::from(\"\
    \")];\n    }\n\n    let mut prefixes = vec![];\n    let mut len = string.len();\n\
    \    let mut pos = 1;\n    while pos < len {\n        prefixes.push(string.to_ascii_lowercase()[pos\
    \ - 1]);\n        pos = prefixes.len() as i32;\n    }\n    prefixes\n}\n\nfn main()\
    \ {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpy6h_vnc3.rs:13:23\n\
    \   |\n13 |         prefixes.push(string.to_ascii_lowercase()[pos - 1]);\n   |\
    \                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpy6h_vnc3.rs:14:15\n\
    \   |\n11 |     let mut pos = 1;\n   |                   - expected due to this\
    \ value\n...\n14 |         pos = prefixes.len() as i32;\n   |               ^^^^^^^^^^^^^^^^^^^^^\
    \ expected `usize`, found `i32`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 101
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    string.split('a').map(|b| String::from(b)).collect()\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"\"]`,\n right: `[]`', /tmp/tmp1565ws1r.rs:10:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    string\n        .split_whitespace()\n        .flat_map(|s|\
    \ s.chars())\n        .filter(|&c| !c.is_whitespace())\n        .collect()\n}\n\
    \nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmp1jgb5k0f.rs:9:10\n     |\n9  \
    \  |         .collect()\n     |          ^^^^^^^ value of type `Vec<String>` cannot\
    \ be built from `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait\
    \ `FromIterator<char>` is not implemented for `Vec<String>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    string.chars()\n        .zip(string.chars().map(|c| c.to_lowercase()))\n\
    \        .filter(|(_, c): bool| c.is_ascii_letter())\n        .collect::<Vec<(&str,\
    \ &str)>>()\n}\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp52nckj54.rs:7:18\n  |\n7 |\
    \         .filter(|(_, c): bool| c.is_ascii_letter())\n  |                  ^^^^^^\
    \  ---- expected due to this\n  |                  |\n  |                  expected\
    \ `bool`, found tuple\n  |\n  = note: expected type `bool`\n            found\
    \ tuple `(_, _)`\n\nerror[E0277]: a value of type `Vec<(&str, &str)>` cannot be\
    \ built from an iterator over elements of type `(char, ToLowercase)`\n    -->\
    \ /tmp/tmp52nckj54.rs:8:10\n     |\n8    |         .collect::<Vec<(&str, &str)>>()\n\
    \     |          ^^^^^^^ value of type `Vec<(&str, &str)>` cannot be built from\
    \ `std::iter::Iterator<Item=(char, ToLowercase)>`\n     |\n     = help: the trait\
    \ `FromIterator<(char, ToLowercase)>` is not implemented for `Vec<(&str, &str)>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n --> /tmp/tmp52nckj54.rs:5:5\n\
    \  |\n4 |   fn all_prefixes(string: String) -> Vec<String> {\n  |            \
    \                          ----------- expected `Vec<String>` because of return\
    \ type\n5 | /     string.chars()\n6 | |         .zip(string.chars().map(|c| c.to_lowercase()))\n\
    7 | |         .filter(|(_, c): bool| c.is_ascii_letter())\n8 | |         .collect::<Vec<(&str,\
    \ &str)>>()\n  | |_______________________________________^ expected struct `String`,\
    \ found tuple\n  |\n  = note: expected struct `Vec<String>`\n             found\
    \ struct `Vec<(&str, &str)>`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 101
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    string\n        .chars()\n        .filter(|c| c.is_ascii())\n\
    \        .filter_map(|c| {\n            if c.is_ascii() {\n                Some(String::from(c.to_ascii_lowercase()))\n\
    \            } else {\n                None\n            }\n        })\n     \
    \   .collect()\n}\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"s\", \"d\", \"f\", \"g\", \"h\"]`,\n right: `[\"a\", \"as\", \"asd\"\
    , \"asdf\", \"asdfg\", \"asdfgh\"]`', /tmp/tmpovrefuds.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut prefix = Vec::new();\n    let mut current = string;\n\
    \    while let Some(next) = current.chars().nth(0) {\n        prefix.push(current);\n\
    \        current = next;\n    }\n    prefix.push(current);\n    prefix\n}\n\n\
    fn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpsbyplzom.rs:9:19\n  |\n6 |\
    \     let mut current = string;\n  |                       ------ expected due\
    \ to this value\n...\n9 |         current = next;\n  |                   ^^^^-\
    \ help: try using a conversion method: `.to_string()`\n  |                   |\n\
    \  |                   expected struct `String`, found `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut prefix = String::from(\"\");\n    for c in string.chars()\
    \ {\n        if prefix != \"\" {\n            prefix = prefix.push_str(&c);\n\
    \        } else {\n            prefix = c;\n        }\n    }\n    vec![prefix]\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpv5zkto81.rs:8:38\n  |\n8 |\
    \             prefix = prefix.push_str(&c);\n  |                             \
    \         ^^ expected `str`, found `char`\n  |\n  = note: expected reference `&str`\n\
    \             found reference `&char`\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmpv5zkto81.rs:8:22\n  |\n5 |     let mut prefix = String::from(\"\");\n\
    \  |                      ---------------- expected due to this value\n...\n8\
    \ |             prefix = prefix.push_str(&c);\n  |                      ^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `()`\n  |\nnote: method `push_str` modifies\
    \ its receiver in-place\n --> /tmp/tmpv5zkto81.rs:8:29\n  |\n8 |             prefix\
    \ = prefix.push_str(&c);\n  |                      ------ ^^^^^^^^ this call modifies\
    \ `prefix` in-place\n  |                      |\n  |                      you\
    \ probably want to use this value after calling the method...\n  = note: ...instead\
    \ of the `()` output of method `push_str`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpv5zkto81.rs:10:22\n   |\n5  |     let mut prefix = String::from(\"\
    \");\n   |                      ---------------- expected due to this value\n\
    ...\n10 |             prefix = c;\n   |                      ^- help: try using\
    \ a conversion method: `.to_string()`\n   |                      |\n   |     \
    \                 expected struct `String`, found `char`\n\nerror: aborting due\
    \ to 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut prefix = vec![];\n    let mut current = string.clone();\n\
    \    loop {\n        prefix.push(current.clone());\n        current.remove_prefix(1);\n\
    \        if current.len() <= 0 {\n            break;\n        }\n    }\n    prefix\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `remove_prefix` found for struct `String`\
    \ in the current scope\n --> /tmp/tmp7bxl7t0d.rs:9:17\n  |\n9 |         current.remove_prefix(1);\n\
    \  |                 ^^^^^^^^^^^^^ method not found in `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    iterate(string).collect()\n}\n\nfn main() {\n    let candidate\
    \ = all_prefixes;\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"asdfgh\")), vec![String::from(\"a\"),\
    \ String::from(\"as\"), String::from(\"asd\"), String::from(\"asdf\"), String::from(\"\
    asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `iterate` in this scope\n --> /tmp/tmpiwm731_i.rs:5:5\n\
    \  |\n5 |     iterate(string).collect()\n  |     ^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut prefixes = Vec::new();\n    let mut len = string.len();\n\
    \    for c in string.chars() {\n        if string.len() < len {\n            break;\n\
    \        }\n        if c != string.chars().nth(len).unwrap() {\n            break;\n\
    \        }\n        len -= 1;\n        prefixes.push(String::from(&string.chars()[..len]));\n\
    \    }\n    prefixes\n}\n\nfn main() {\n    let candidate = all_prefixes;\n  \
    \  assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0608]: cannot index into a value of type `Chars<'_>`\n  --> /tmp/tmpedntrxom.rs:15:37\n\
    \   |\n15 |         prefixes.push(String::from(&string.chars()[..len]));\n   |\
    \                                     ^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0608`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 101
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    string\n        .chars()\n        .map(|c| c.to_ascii_lowercase().to_string())\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = all_prefixes;\n   \
    \ assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"s\", \"d\", \"f\", \"g\", \"h\"]`,\n right: `[\"a\", \"as\", \"asd\"\
    , \"asdf\", \"asdfg\", \"asdfgh\"]`', /tmp/tmpv128pp8v.rs:14:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    shortest_prefixes\n        .iter()\n        .chain(longest_prefixes.iter())\n\
    \        .take_while(|prefix| prefix.len() >= string.len())\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `shortest_prefixes` in this scope\n -->\
    \ /tmp/tmpj04v6650.rs:5:5\n  |\n5 |     shortest_prefixes\n  |     ^^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `longest_prefixes`\
    \ in this scope\n --> /tmp/tmpj04v6650.rs:7:16\n  |\n7 |         .chain(longest_prefixes.iter())\n\
    \  |                ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    string\n        .into_iter()\n        .map(|x| x.chars().take_while(|c|\
    \ *c != '\\0').collect::<Vec<String>>())\n        .flatten()\n        .collect::<Vec<String>>()\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: the method `into_iter` exists for struct `String`, but its\
    \ trait bounds were not satisfied\n   --> /tmp/tmp7vhh527x.rs:6:10\n    |\n6 \
    \  |           .into_iter()\n    |            ^^^^^^^^^\n    |\n    = note: the\
    \ following trait bounds were not satisfied:\n            `String: Iterator`\n\
    \            which is required by `String: IntoIterator`\n            `&String:\
    \ Iterator`\n            which is required by `&String: IntoIterator`\n      \
    \      `&mut String: Iterator`\n            which is required by `&mut String:\
    \ IntoIterator`\n            `str: Sized`\n            which is required by `str:\
    \ IntoIterator`\n            `str: Iterator`\n            which is required by\
    \ `str: IntoIterator`\n            `&str: Iterator`\n            which is required\
    \ by `&str: IntoIterator`\n            `&mut str: Iterator`\n            which\
    \ is required by `&mut str: IntoIterator`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 101
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut prefix = Vec::new();\n\n    for ch in string.chars()\
    \ {\n        if ch != string.chars().next().unwrap() {\n            prefix.push(String::from(ch));\n\
    \        }\n    }\n\n    prefix\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"s\", \"d\", \"f\", \"g\", \"h\"]`,\n right: `[\"a\", \"as\", \"asd\", \"\
    asdf\", \"asdfg\", \"asdfgh\"]`', /tmp/tmplhnlmr74.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    if string.len() == 0 {\n        return vec![];\n    }\n\
    \n    let mut prefixes = vec![];\n    let mut len = string.len() - 1;\n    let\
    \ mut index = 0;\n    while index != len {\n        prefixes.push(string[index..]);\n\
    \        index += 1;\n    }\n    prefixes.push(string[index..]);\n    prefixes\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n   --> /tmp/tmps40x47p8.rs:13:23\n    |\n13  |         prefixes.push(string[index..]);\n\
    \    |                  ---- ^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n\
    \    |                  |\n    |                  required by a bound introduced\
    \ by this call\n    |\n    = help: the trait `Sized` is not implemented for `str`\n\
    note: required by a bound in `Vec::<T, A>::push`\n\nerror[E0277]: the size for\
    \ values of type `str` cannot be known at compilation time\n   --> /tmp/tmps40x47p8.rs:9:24\n\
    \    |\n9   |     let mut prefixes = vec![];\n    |                        ^^^^^^\
    \ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized`\
    \ is not implemented for `str`\nnote: required by a bound in `Vec::<T>::new`\n\
    \    = note: this error originates in the macro `vec` (in Nightly builds, run\
    \ with -Z macro-backtrace for more info)\n\nerror[E0277]: the size for values\
    \ of type `str` cannot be known at compilation time\n   --> /tmp/tmps40x47p8.rs:9:24\n\
    \    |\n9   |     let mut prefixes = vec![];\n    |                        ^^^^^^\
    \ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized`\
    \ is not implemented for `str`\nnote: required by a bound in `Vec`\n    = note:\
    \ this error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace\
    \ for more info)\n\nerror[E0599]: the method `push` exists for struct `Vec<str>`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmps40x47p8.rs:16:14\n \
    \  |\n16 |     prefixes.push(string[index..]);\n   |              ^^^^ method\
    \ cannot be called on `Vec<str>` due to unsatisfied trait bounds\n   |\n   = note:\
    \ the following trait bounds were not satisfied:\n           `str: Sized`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmps40x47p8.rs:17:5\n   |\n4  | fn\
    \ all_prefixes(string: String) -> Vec<String> {\n   |                        \
    \            ----------- expected `Vec<String>` because of return type\n...\n\
    17 |     prefixes\n   |     ^^^^^^^^ expected struct `String`, found `str`\n \
    \  |\n   = "
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    string.chars()\n        .enumerate()\n        .filter(|(_,\
    \ c)| c.is_ascii_letter())\n        .map(|(i, c)| string.clone())\n        .map(|s|\
    \ s.chars())\n        .filter(|s| s.is_ascii_letter())\n        .map(|s| s.chars().take(s.len()))\n\
    \        .collect::<Vec<Vec<char>>>(Vec::new())\n}\n\nfn main() {\n    let candidate\
    \ = all_prefixes;\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"asdfgh\")), vec![String::from(\"a\"),\
    \ String::from(\"as\"), String::from(\"asd\"), String::from(\"asdf\"), String::from(\"\
    asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n --> /tmp/tmp8jg9hzmh.rs:7:28\n  |\n7 |         .filter(|(_,\
    \ c)| c.is_ascii_letter())\n  |                            ^^^^^^^^^^^^^^^ help:\
    \ there is an associated function with a similar name: `is_ascii`\n\nerror[E0599]:\
    \ no method named `is_ascii_letter` found for reference `&Chars<'_>` in the current\
    \ scope\n  --> /tmp/tmp8jg9hzmh.rs:10:23\n   |\n10 |         .filter(|s| s.is_ascii_letter())\n\
    \   |                       ^^^^^^^^^^^^^^^ method not found in `&Chars<'_>`\n\
    \nerror[E0599]: no method named `chars` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmp8jg9hzmh.rs:11:20\n   |\n11 |         .map(|s| s.chars().take(s.len()))\n\
    \   |                    ^^^^^ method not found in `Chars<'_>`\n\nerror[E0599]:\
    \ no method named `len` found for struct `Chars` in the current scope\n  --> /tmp/tmp8jg9hzmh.rs:11:35\n\
    \   |\n11 |         .map(|s| s.chars().take(s.len()))\n   |                  \
    \                 ^^^ method not found in `Chars<'_>`\n\nerror[E0061]: this function\
    \ takes 0 arguments but 1 argument was supplied\n    --> /tmp/tmp8jg9hzmh.rs:12:10\n\
    \     |\n12   |         .collect::<Vec<Vec<char>>>(Vec::new())\n     |       \
    \   ^^^^^^^                   ---------- supplied 1 argument\n     |         \
    \ |\n     |          expected 0 arguments\n     |\nnote: associated function defined\
    \ here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8jg9hzmh.rs:5:5\n   |\n\
    4  |   fn all_prefixes(string: String) -> Vec<String> {\n   |                \
    \                      ----------- expected `Vec<String>` because of return type\n\
    5  | /     string.chars()\n6  | |         .enumerate()\n7  | |         .filter(|(_,\
    \ c)| c.is_ascii_letter())\n8  | |         .map(|(i, c)| string.clone())\n...\
    \  |\n11 | |         .map(|s| s.chars().take(s.len()))\n12 | |         .collect::<Vec<Vec<char>>>(Vec::new())\n\
    \   | |______________________________________________^ expected struct `String`,\
    \ found struct `Vec`\n   |\n   = note: expected struct `Vec<String>`\n       \
    \       found struct `Vec<Vec<char>"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    vec![\n        string\n            .split_last_mut()\n\
    \            .filter(|c| !c.is_ascii())\n            .collect::<String>(),\n \
    \   ]\n}\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `split_last_mut` found for struct `String`\
    \ in the current scope\n --> /tmp/tmpil2bttv9.rs:7:14\n  |\n7 |             .split_last_mut()\n\
    \  |              ^^^^^^^^^^^^^^ help: there is an associated function with a\
    \ similar name: `split_at`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut prefix = String::new();\n    for c in string.chars()\
    \ {\n        prefix = format!(\"{}{}\", prefix, c);\n    }\n\n    let mut result\
    \ = Vec::new();\n    prefix.chars().for_each(|c| {\n        result.push(c);\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = all_prefixes;\n  \
    \  assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5ze_a8ra.rs:14:5\n   |\n\
    4  | fn all_prefixes(string: String) -> Vec<String> {\n   |                  \
    \                  ----------- expected `Vec<String>` because of return type\n\
    ...\n14 |     result\n   |     ^^^^^^ expected struct `String`, found `char`\n\
    \   |\n   = note: expected struct `Vec<String>`\n              found struct `Vec<char>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    if string.len() < 2 {\n        return vec![];\n    }\n\
    \n    let mut result = vec![];\n    for i in 1..string.len() {\n        let mut\
    \ prefix = string[0..i];\n        let mut index = i;\n        while prefix ==\
    \ string[index..].to_lowercase() && index < string.len() {\n            prefix\
    \ += string[index..];\n            index += 1\n        }\n        result.push(prefix);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n  --> /tmp/tmp78o4777f.rs:11:13\n   |\n11 |         let mut prefix = string[0..i];\n\
    \   |             ^^^^^^^^^^ doesn't have a size known at compile-time\n   |\n\
    \   = help: the trait `Sized` is not implemented for `str`\n   = note: all local\
    \ variables must have a statically known size\n   = help: unsized locals are gated\
    \ as an unstable feature\nhelp: consider borrowing here\n   |\n11 |         let\
    \ mut prefix = &string[0..i];\n   |                          +\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `str`\n  --> /tmp/tmp78o4777f.rs:14:13\n\
    \   |\n14 |             prefix += string[index..];\n   |             ------^^^^^^^^^^^^^^^^^^^\n\
    \   |             |\n   |             cannot use `+=` on type `str`\n\nerror[E0277]:\
    \ the size for values of type `str` cannot be known at compilation time\n   -->\
    \ /tmp/tmp78o4777f.rs:17:21\n    |\n17  |         result.push(prefix);\n    |\
    \                ---- ^^^^^^ doesn't have a size known at compile-time\n    |\
    \                |\n    |                required by a bound introduced by this\
    \ call\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote:\
    \ required by a bound in `Vec::<T, A>::push`\n\nerror[E0277]: the size for values\
    \ of type `str` cannot be known at compilation time\n   --> /tmp/tmp78o4777f.rs:9:22\n\
    \    |\n9   |     let mut result = vec![];\n    |                      ^^^^^^\
    \ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized`\
    \ is not implemented for `str`\nnote: required by a bound in `Vec::<T>::new`\n\
    \    = note: this error originates in the macro `vec` (in Nightly builds, run\
    \ with -Z macro-backtrace for more info)\n\nerror[E0277]: the size for values\
    \ of type `str` cannot be known at compilation time\n   --> /tmp/tmp78o4777f.rs:9:22\n\
    \    |\n9   |     let mut result = vec![];\n    |                      ^^^^^^\
    \ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized`\
    \ is not implemented for `str`\nnote: required by a bound in `Vec`\n    = note:\
    \ th"
  stdout: ''
  timestamp: 1659976676
- exit_code: 101
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut prefix = vec![];\n    let mut curr = string.chars();\n\
    \    while let Some(mut curr) = curr.next() {\n        prefix.push(String::from(curr));\n\
    \    }\n    prefix\n}\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"s\", \"d\", \"f\", \"g\", \"h\"]`,\n right: `[\"a\", \"as\", \"asd\"\
    , \"asdf\", \"asdfg\", \"asdfgh\"]`', /tmp/tmp8mkx6g_1.rs:16:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    all_prefixes_rec(&string.chars().collect::<Vec<_>>(),\
    \ vec![])\n}\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `all_prefixes_rec` in this scope\n -->\
    \ /tmp/tmp7e44e0k9.rs:5:5\n  |\n5 |     all_prefixes_rec(&string.chars().collect::<Vec<_>>(),\
    \ vec![])\n  |     ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut result = Vec::with_capacity(string.len());\n\n\
    \    for prefix in string.chars().filter_map(|c| {\n        match c {\n      \
    \      c if c.is_alphabetic() {\n                Some(c.to_ascii_lowercase())\n\
    \            } else {\n                None\n            }\n        }\n    })\
    \ {\n        result.append(prefix.to_string());\n    }\n\n    result\n}\n\nfn\
    \ main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `=>`, `?`, or an operator, found `{`\n -->\
    \ /tmp/tmp90w13xpy.rs:9:36\n  |\n9 |             c if c.is_alphabetic() {\n  |\
    \                                    ^ expected one of `.`, `=>`, `?`, or an operator\n\
    \nerror[E0282]: type annotations needed\n  --> /tmp/tmp90w13xpy.rs:16:23\n   |\n\
    16 |         result.append(prefix.to_string());\n   |                       ^^^^^^\
    \ cannot infer type\n   |\n   = note: type must be known at this point\nhelp:\
    \ consider specifying the type arguments in the method call\n   |\n7  |     for\
    \ prefix in string.chars().filter_map::<B, F>(|c| {\n   |                    \
    \                        ++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    vec![(&string[0..]).to_string_lossy()].into_iter().collect()\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_string_lossy` found for reference `&str`\
    \ in the current scope\n --> /tmp/tmpf1akvu27.rs:5:25\n  |\n5 |     vec![(&string[0..]).to_string_lossy()].into_iter().collect()\n\
    \  |                         ^^^^^^^^^^^^^^^ method not found in `&str`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    string.chars().collect::<Vec<Char>>().into_iter().take_while(|c|\
    \ c.is_ascii()).collect()\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `Char` in this scope\n --> /tmp/tmpwkn3_e49.rs:5:34\n\
    \  |\n5 |     string.chars().collect::<Vec<Char>>().into_iter().take_while(|c|\
    \ c.is_ascii()).collect()\n  |                                  ^^^^\n  |\nhelp:\
    \ a builtin type with a similar name exists\n  |\n5 |     string.chars().collect::<Vec<char>>().into_iter().take_while(|c|\
    \ c.is_ascii()).collect()\n  |                                  ~~~~\nhelp: you\
    \ might be missing a type parameter\n  |\n4 | fn all_prefixes<Char>(string: String)\
    \ -> Vec<String> {\n  |                ++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut prefixes = Vec::new();\n    for &prefix in string.chars().take_while(|c|\
    \ !c.is_ascii_lowercase()) {\n        prefixes.push(prefix);\n    }\n    prefixes\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpgxlnk464.rs:6:9\n  |\n6 |\
    \     for &prefix in string.chars().take_while(|c| !c.is_ascii_lowercase()) {\n\
    \  |         ^^^^^^^    ------------------------------------------------------\
    \ this expression has type `Option<char>`\n  |         |\n  |         expected\
    \ `char`, found reference\n  |         help: you can probably remove the explicit\
    \ borrow: `prefix`\n  |\n  = note:   expected type `char`\n          found reference\
    \ `&_`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    // longest prefix is the last letter of the input string\n\
    \    // and we start from the end\n    string.chars().enumerate()\n        .filter(|(_,\
    \ s)| s != 0)\n        .map(|(_, s)| s.to_string())\n        .collect()\n}\n\n\
    fn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `{integer}`\n --> /tmp/tmpi3k42rrq.rs:8:28\n\
    \  |\n8 |         .filter(|(_, s)| s != 0)\n  |                            ^^\
    \ no implementation for `&char == {integer}`\n  |\n  = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&char`\n  = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0308]: mismatched types\n --> /tmp/tmpi3k42rrq.rs:8:31\n\
    \  |\n8 |         .filter(|(_, s)| s != 0)\n  |                              \
    \ ^ expected `char`, found integer\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    all_prefixes_iter(string).collect()\n}\n\nfn main() {\n\
    \    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\"\
    )), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\")),\
    \ vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `all_prefixes_iter` in this scope\n\
    \ --> /tmp/tmprq83cmmp.rs:5:5\n  |\n5 |     all_prefixes_iter(string).collect()\n\
    \  |     ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut s = string;\n    vec![];\n    while !s.is_empty()\
    \ {\n        let mut prefix = s;\n        prefix.remove(0, 1);\n        prefix.clear();\n\
    \        vec![prefix];\n    }\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmprou3pfsa.rs:9:16\n     |\n9    |         prefix.remove(0, 1);\n\
    \     |                ^^^^^^ -  - supplied 2 arguments\n     |              \
    \  |\n     |                expected 1 argument\n     |\nnote: associated function\
    \ defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprou3pfsa.rs:7:5\n\
    \   |\n4  |   fn all_prefixes(string: String) -> Vec<String> {\n   |         \
    \                             ----------- expected `Vec<String>` because of return\
    \ type\n...\n7  | /     while !s.is_empty() {\n8  | |         let mut prefix =\
    \ s;\n9  | |         prefix.remove(0, 1);\n10 | |         prefix.clear();\n11\
    \ | |         vec![prefix];\n12 | |     }\n   | |_____^ expected struct `Vec`,\
    \ found `()`\n   |\n   = note: expected struct `Vec<String>`\n           found\
    \ unit type `()`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0061, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    string\n        .chars()\n        .filter_map(|c| match\
    \ c.to_ascii_lowercase() {\n            \"a\" => Some(0),\n            \"b\" =>\
    \ Some(1),\n            \"c\" => Some(2),\n            _ => None,\n        })\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = all_prefixes;\n   \
    \ assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmphz3i9wkz.rs:8:13\n  |\n7 |\
    \         .filter_map(|c| match c.to_ascii_lowercase() {\n  |                \
    \               ---------------------- this expression has type `char`\n8 |  \
    \           \"a\" => Some(0),\n  |             ^^^ expected `char`, found `&str`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmphz3i9wkz.rs:9:13\n  |\n7 |    \
    \     .filter_map(|c| match c.to_ascii_lowercase() {\n  |                    \
    \           ---------------------- this expression has type `char`\n8 |      \
    \       \"a\" => Some(0),\n9 |             \"b\" => Some(1),\n  |            \
    \ ^^^ expected `char`, found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphz3i9wkz.rs:10:13\n\
    \   |\n7  |         .filter_map(|c| match c.to_ascii_lowercase() {\n   |     \
    \                          ---------------------- this expression has type `char`\n\
    ...\n10 |             \"c\" => Some(2),\n   |             ^^^ expected `char`,\
    \ found `&str`\n\nerror[E0277]: a value of type `Vec<String>` cannot be built\
    \ from an iterator over elements of type `{integer}`\n    --> /tmp/tmphz3i9wkz.rs:13:10\n\
    \     |\n13   |         .collect()\n     |          ^^^^^^^ value of type `Vec<String>`\
    \ cannot be built from `std::iter::Iterator<Item={integer}>`\n     |\n     = help:\
    \ the trait `FromIterator<{integer}>` is not implemented for `Vec<String>`\n \
    \    = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 101
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    string.chars().map(|c| c.to_string()).collect()\n}\n\n\
    fn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"s\", \"d\", \"f\", \"g\", \"h\"]`,\n right: `[\"a\", \"as\", \"asd\"\
    , \"asdf\", \"asdfg\", \"asdfgh\"]`', /tmp/tmplzpv6aef.rs:11:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    string.chars().flat_map(|&c| {\n        vec![String::from(&c),\
    \ &c + 1]\n    }).collect()\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpl3fmpm5l.rs:5:30\n  |\n5 |\
    \     string.chars().flat_map(|&c| {\n  |                              ^--\n \
    \ |                              ||\n  |                              |expected\
    \ due to this\n  |                              expected `char`, found reference\n\
    \  |                              help: did you mean `c`: `&char`\n  |\n  = note:\
    \   expected type `char`\n          found reference `&_`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut prefix_vec = Vec::new();\n\n    for prefix in\
    \ string.chars() {\n        if string.len() < prefix.length {\n            break;\n\
    \        }\n        prefix_vec.push(prefix);\n    }\n\n    prefix_vec\n}\n\nfn\
    \ main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0610]: `char` is a primitive type and therefore doesn't have fields\n\
    \ --> /tmp/tmppceyvbsv.rs:8:34\n  |\n8 |         if string.len() < prefix.length\
    \ {\n  |                                  ^^^^^^\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmppceyvbsv.rs:14:5\n   |\n4  | fn all_prefixes(string: String) ->\
    \ Vec<String> {\n   |                                    ----------- expected\
    \ `Vec<String>` because of return type\n...\n14 |     prefix_vec\n   |     ^^^^^^^^^^\
    \ expected struct `String`, found `char`\n   |\n   = note: expected struct `Vec<String>`\n\
    \              found struct `Vec<char>`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0610.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut res = Vec::new();\n    for (i, c) in string.chars().enumerate()\
    \ {\n        for (p, c) in string.chars().enumerate().rev() {\n            if\
    \ i != p {\n                continue;\n            }\n            if c == c {\n\
    \                res.push(String::from(c));\n                break;\n        \
    \    }\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \    --> /tmp/tmpaopbrb13.rs:7:50\n     |\n7    |         for (p, c) in string.chars().enumerate().rev()\
    \ {\n     |                                                  ^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n     |\n     = help: the following other\
    \ types implement trait `ExactSizeIterator`:\n               &mut I\n        \
    \       Args\n               ArgsOs\n               ArrayChunks<'_, T, N>\n  \
    \             ArrayChunksMut<'_, T, N>\n               ArrayWindows<'_, T, N>\n\
    \               Box<I, A>\n               Chunks<'_, T>\n             and 109\
    \ others\n     = note: required because of the requirements on the impl of `DoubleEndedIterator`\
    \ for `Enumerate<Chars<'_>>`\nnote: required by a bound in `rev`\n\nerror[E0277]:\
    \ the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n --> /tmp/tmpaopbrb13.rs:7:23\n\
    \  |\n7 |         for (p, c) in string.chars().enumerate().rev() {\n  |      \
    \                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n  |\n  = help: the following other types\
    \ implement trait `ExactSizeIterator`:\n            &mut I\n            Args\n\
    \            ArgsOs\n            ArrayChunks<'_, T, N>\n            ArrayChunksMut<'_,\
    \ T, N>\n            ArrayWindows<'_, T, N>\n            Box<I, A>\n         \
    \   Chunks<'_, T>\n          and 109 others\n  = note: required because of the\
    \ requirements on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\n\
    \  = note: required because of the requirements on the impl of `Iterator` for\
    \ `Rev<Enumerate<Chars<'_>>>`\n  = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `Rev<Enumerate<Chars<'_>>>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut prefix = Vec::with_capacity(string.length());\n\
    \    for c in string.chars() {\n        prefix.push(c);\n        prefix.push((c\
    \ + 1).to_string());\n    }\n    prefix\n}\n\nfn main() {\n    let candidate =\
    \ all_prefixes;\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"asdfgh\")), vec![String::from(\"a\"),\
    \ String::from(\"as\"), String::from(\"asd\"), String::from(\"asdf\"), String::from(\"\
    asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n --> /tmp/tmp5p_k91o5.rs:5:48\n  |\n5 |     let mut prefix =\
    \ Vec::with_capacity(string.length());\n  |                                  \
    \              ^^^^^^ help: there is an associated function with a similar name:\
    \ `len`\n\nerror[E0369]: cannot add `{integer}` to `char`\n --> /tmp/tmp5p_k91o5.rs:8:24\n\
    \  |\n8 |         prefix.push((c + 1).to_string());\n  |                     \
    \ - ^ - {integer}\n  |                      |\n  |                      char\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp5p_k91o5.rs:10:5\n   |\n4  | fn\
    \ all_prefixes(string: String) -> Vec<String> {\n   |                        \
    \            ----------- expected `Vec<String>` because of return type\n...\n\
    10 |     prefix\n   |     ^^^^^^ expected struct `String`, found `char`\n   |\n\
    \   = note: expected struct `Vec<String>`\n              found struct `Vec<char>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut prefix = vec![String::from(\"\")];\n    while\
    \ !string.is_empty() {\n        prefix.push(string.chars().next().unwrap().to_string());\n\
    \        string = string.chars().skip(1).collect();\n    }\n    prefix\n}\n\n\
    fn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `string`\n --> /tmp/tmp0scpoyso.rs:8:9\n\
    \  |\n4 | fn all_prefixes(string: String) -> Vec<String> {\n  |              \
    \   ------ help: consider making this binding mutable: `mut string`\n...\n8 |\
    \         string = string.chars().skip(1).collect();\n  |         ^^^^^^ cannot\
    \ assign to immutable argument\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut prefixes = Vec::new();\n    prefixes.push(String::from(\"\
    \"));\n    for c in string.chars() {\n        let mut prefix = prefixes[prefixes.len()\
    \ - 1];\n        for b in prefixes[prefixes.len() - 1].chars() {\n           \
    \ prefix = prefix.clone();\n            if b == c {\n                break;\n\
    \            }\n            prefix.push(b);\n        }\n        prefixes.push(prefix);\n\
    \    }\n    prefixes\n}\n\nfn main() {\n    let candidate = all_prefixes;\n  \
    \  assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n --> /tmp/tmp_32yyoku.rs:8:26\n\
    \  |\n8 |         let mut prefix = prefixes[prefixes.len() - 1];\n  |        \
    \                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |                         \
    \ |\n  |                          move occurs because value has type `String`,\
    \ which does not implement the `Copy` trait\n  |                          help:\
    \ consider borrowing here: `&prefixes[prefixes.len() - 1]`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0507`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    string\n        .chars()\n        .flat_map(|c| {\n  \
    \          c.chars().enumerate().map(|(i, c)| (c, i)).collect::<Vec<_>>()\n  \
    \      })\n        .collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate =\
    \ all_prefixes;\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"asdfgh\")), vec![String::from(\"a\"),\
    \ String::from(\"as\"), String::from(\"asd\"), String::from(\"asdf\"), String::from(\"\
    asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `chars` found for type `char` in the current\
    \ scope\n --> /tmp/tmpxw5sp4h_.rs:8:15\n  |\n8 |             c.chars().enumerate().map(|(i,\
    \ c)| (c, i)).collect::<Vec<_>>()\n  |               ^^^^^ method not found in\
    \ `char`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut prefix = Vec::new();\n    for s in string.chars()\
    \ {\n        if prefix.is_empty() {\n            prefix.push(s);\n        } else\
    \ if prefix[prefix.len() - 1] == s {\n            prefix.push(s);\n        } else\
    \ {\n            break;\n        }\n    }\n    prefix\n}\n\nfn main() {\n    let\
    \ candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"asdfgh\")), vec![String::from(\"a\"),\
    \ String::from(\"as\"), String::from(\"asd\"), String::from(\"asdf\"), String::from(\"\
    asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjvul16ls.rs:15:5\n   |\n\
    4  | fn all_prefixes(string: String) -> Vec<String> {\n   |                  \
    \                  ----------- expected `Vec<String>` because of return type\n\
    ...\n15 |     prefix\n   |     ^^^^^^ expected struct `String`, found `char`\n\
    \   |\n   = note: expected struct `Vec<String>`\n              found struct `Vec<char>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    Self::shortest_prefixes\n        .iter()\n        .zip(Self::shortest_suffixes.iter())\n\
    \        .map(|(prefix, suffix)| prefix.take(suffix.len()))\n        .collect::<Vec<String>>()\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Self`\n --> /tmp/tmpqft3acrd.rs:5:5\n\
    \  |\n5 |     Self::shortest_prefixes\n  |     ^^^^ use of undeclared type `Self`\n\
    \nerror[E0433]: failed to resolve: use of undeclared type `Self`\n --> /tmp/tmpqft3acrd.rs:7:14\n\
    \  |\n7 |         .zip(Self::shortest_suffixes.iter())\n  |              ^^^^\
    \ use of undeclared type `Self`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    string\n        .chars()\n        .filter(|c| !c.is_whitespace())\n\
    \        .take_while(|c| c != c.to_ascii_lowercase().unwrap())\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap` found for type `char` in the current\
    \ scope\n --> /tmp/tmpu3uu73rj.rs:8:53\n  |\n8 |         .take_while(|c| c !=\
    \ c.to_ascii_lowercase().unwrap())\n  |                                      \
    \               ^^^^^^ method not found in `char`\n\nerror[E0277]: a value of\
    \ type `Vec<String>` cannot be built from an iterator over elements of type `char`\n\
    \    --> /tmp/tmpu3uu73rj.rs:9:10\n     |\n9    |         .collect()\n     | \
    \         ^^^^^^^ value of type `Vec<String>` cannot be built from `std::iter::Iterator<Item=char>`\n\
    \     |\n     = help: the trait `FromIterator<char>` is not implemented for `Vec<String>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut len = string.len();\n    let mut prefixes = Vec::new();\n\
    \    prefixes.push(&string[..len]);\n    while let Some(prefix) = get_prefix(prefix,\
    \ &string[..len]) {\n        prefixes.push(prefix);\n    }\n    prefixes\n}\n\n\
    fn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `get_prefix` in this scope\n --> /tmp/tmp6f4am_v8.rs:8:30\n\
    \  |\n8 |     while let Some(prefix) = get_prefix(prefix, &string[..len]) {\n\
    \  |                              ^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `prefix` in this scope\n --> /tmp/tmp6f4am_v8.rs:8:41\n  |\n\
    8 |     while let Some(prefix) = get_prefix(prefix, &string[..len]) {\n  |   \
    \                                      ^^^^^^ help: a local variable with a similar\
    \ name exists: `prefixes`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6f4am_v8.rs:11:5\n\
    \   |\n4  | fn all_prefixes(string: String) -> Vec<String> {\n   |           \
    \                         ----------- expected `Vec<String>` because of return\
    \ type\n...\n11 |     prefixes\n   |     ^^^^^^^^ expected struct `String`, found\
    \ `&str`\n   |\n   = note: expected struct `Vec<String>`\n              found\
    \ struct `Vec<&str>`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0425.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut result = vec![];\n    for i in 1..string.len()\
    \ {\n        result.push(string.sub(0, i));\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sub` found for struct `String` in the current\
    \ scope\n --> /tmp/tmp8q08pbo3.rs:7:28\n  |\n7 |         result.push(string.sub(0,\
    \ i));\n  |                            ^^^ method not found in `String`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut prefix = vec![];\n    for s in string.chars().filter_map(|c|\
    \ match c {\n        '_' => return None,\n        c => Some((s, c))\n    }) {\n\
    \        prefix.push(s.0);\n    }\n    prefix\n}\n\nfn main() {\n    let candidate\
    \ = all_prefixes;\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"asdfgh\")), vec![String::from(\"a\"),\
    \ String::from(\"as\"), String::from(\"asd\"), String::from(\"asdf\"), String::from(\"\
    asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `s` in this scope\n --> /tmp/tmp82zzjan4.rs:8:20\n\
    \  |\n8 |         c => Some((s, c))\n  |                    ^ help: a local variable\
    \ with a similar name exists: `c`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut result: Vec<String> = vec![];\n    result.push(string.clone());\n\
    \    let mut prefix = string.clone();\n    while !prefix.is_empty() {\n      \
    \  prefix.remove(0);\n        result.push(prefix);\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `prefix`\n  --> /tmp/tmp7bdsrkou.rs:8:12\n\
    \   |\n7  |     let mut prefix = string.clone();\n   |         ---------- move\
    \ occurs because `prefix` has type `String`, which does not implement the `Copy`\
    \ trait\n8  |     while !prefix.is_empty() {\n   |            ^^^^^^^^^^^^^^^^^\
    \ value borrowed here after move\n9  |         prefix.remove(0);\n10 |       \
    \  result.push(prefix);\n   |                     ------ value moved here, in\
    \ previous iteration of loop\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 101
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut result = Vec::new();\n    let mut input_prefix\
    \ = vec![string];\n\n    while !input_prefix.is_empty() {\n        let input_prefix\
    \ = input_prefix.pop();\n\n        for prefix in input_prefix {\n            result.push(prefix);\n\
    \        }\n    }\n\n    result\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"\"]`,\n right: `[]`', /tmp/tmpv16wmq94.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976677
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    all_prefixes_helper(\n        string,\n        |i| string.as_bytes_mut().nth(i).ok().map(|b|\
    \ b.to_string()),\n        |i| {\n            string.as_bytes_mut().first_byte(i).ok()\n\
    \                .and_then(|b| {\n                    string\n               \
    \         .as_bytes_mut()\n                        .last_byte(i)\n           \
    \             .ok()\n                        .map(|b| b.to_string())\n       \
    \         })\n        })\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `all_prefixes_helper` in this scope\n\
    \ --> /tmp/tmpgq_0sjnp.rs:5:5\n  |\n5 |     all_prefixes_helper(\n  |     ^^^^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0599]: the method `nth` exists for mutable\
    \ reference `&mut [u8]`, but its trait bounds were not satisfied\n --> /tmp/tmpgq_0sjnp.rs:7:35\n\
    \  |\n7 |         |i| string.as_bytes_mut().nth(i).ok().map(|b| b.to_string()),\n\
    \  |                                   ^^^ method cannot be called on `&mut [u8]`\
    \ due to unsatisfied trait bounds\n  |\n  = note: the following trait bounds were\
    \ not satisfied:\n          `[u8]: Iterator`\n          which is required by `&mut\
    \ [u8]: Iterator`\n\nerror[E0599]: no method named `first_byte` found for mutable\
    \ reference `&mut [u8]` in the current scope\n --> /tmp/tmpgq_0sjnp.rs:9:35\n\
    \  |\n9 |             string.as_bytes_mut().first_byte(i).ok()\n  |          \
    \                         ^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `first`\n\nerror[E0599]: no method named `last_byte` found for\
    \ mutable reference `&mut [u8]` in the current scope\n  --> /tmp/tmpgq_0sjnp.rs:13:26\n\
    \   |\n13 |                         .last_byte(i)\n   |                      \
    \    ^^^^^^^^^ help: there is an associated function with a similar name: `last_mut`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    strings.prefix_suffix(string)\n}\n\nfn main() {\n    let\
    \ candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"asdfgh\")), vec![String::from(\"a\"),\
    \ String::from(\"as\"), String::from(\"asd\"), String::from(\"asdf\"), String::from(\"\
    asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `strings` in this scope\n --> /tmp/tmp1630i6hs.rs:5:5\n\
    \  |\n5 |     strings.prefix_suffix(string)\n  |     ^^^^^^^ help: a local variable\
    \ with a similar name exists: `string`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut prefixes = Vec::new();\n    let mut prefix = String::from(\"\
    \");\n    prefixes.push(prefix);\n    let mut len = string.len();\n    while len\
    \ > 0 {\n        let mut index = string.rfind(prefix);\n        let mut prefix\
    \ = String::from(\"\");\n        if index != String::npos { prefix = string[index..];\
    \ }\n        prefixes.push(prefix);\n        len -= prefix.len();\n    }\n   \
    \ prefixes\n}\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n  -->\
    \ /tmp/tmpqsohap00.rs:10:38\n   |\n10 |         let mut index = string.rfind(prefix);\n\
    \   |                                ----- ^^^^^^ expected an implementor of trait\
    \ `Pattern<'_>`\n   |                                |\n   |                 \
    \               required by a bound introduced by this call\n   |\n   = note:\
    \ the trait bound `String: Pattern<'_>` is not satisfied\n   = note: required\
    \ because of the requirements on the impl of `Pattern<'_>` for `String`\nhelp:\
    \ consider borrowing here\n   |\n10 |         let mut index = string.rfind(&prefix);\n\
    \   |                                      +\n\nerror[E0599]: no function or associated\
    \ item named `npos` found for struct `String` in the current scope\n  --> /tmp/tmpqsohap00.rs:12:29\n\
    \   |\n12 |         if index != String::npos { prefix = string[index..]; }\n \
    \  |                             ^^^^ function or associated item not found in\
    \ `String`\n\nerror[E0277]: the type `String` cannot be indexed by `RangeFrom<Option<usize>>`\n\
    \  --> /tmp/tmpqsohap00.rs:12:45\n   |\n12 |         if index != String::npos\
    \ { prefix = string[index..]; }\n   |                                        \
    \     ^^^^^^^^^^^^^^^ `String` cannot be indexed by `RangeFrom<Option<usize>>`\n\
    \   |\n   = help: the trait `Index<RangeFrom<Option<usize>>>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut prefix = String::from(\"\");\n    let mut string\
    \ = string.to_lowercase();\n    loop {\n        let prefix = prefix.to_owned();\n\
    \        if string.is_empty() {\n            break;\n        }\n        if string.len()\
    \ < prefix.len() {\n            prefix.resize_with(string.len(), |size, v| v.to_owned());\n\
    \        }\n        if prefix != string {\n            prefix.append(&string);\n\
    \        }\n        string = string.to_lowercase();\n    }\n    prefix.to_owned()\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `resize_with` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmpgu59p2ei.rs:13:20\n   |\n13 |             prefix.resize_with(string.len(),\
    \ |size, v| v.to_owned());\n   |                    ^^^^^^^^^^^ method not found\
    \ in `String`\n\nerror[E0599]: no method named `append` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpgu59p2ei.rs:16:20\n   |\n16 |          \
    \   prefix.append(&string);\n   |                    ^^^^^^ method not found in\
    \ `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgu59p2ei.rs:20:5\n\
    \   |\n4  | fn all_prefixes(string: String) -> Vec<String> {\n   |           \
    \                         ----------- expected `Vec<String>` because of return\
    \ type\n...\n20 |     prefix.to_owned()\n   |     ^^^^^^^^^^^^^^^^^ expected struct\
    \ `Vec`, found struct `String`\n   |\n   = note: expected struct `Vec<String>`\n\
    \              found struct `String`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut prefixes = vec![];\n    let mut prefix = &string;\n\
    \    while !prefix.is_empty() {\n        prefixes.push(prefix);\n        prefix\
    \ = prefix.chars().nth(prefix.is_empty() as usize + 1).unwrap();\n    }\n    prefixes\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpvuzq1igb.rs:9:18\n  |\n6 |\
    \     let mut prefix = &string;\n  |                      ------- expected due\
    \ to this value\n...\n9 |         prefix = prefix.chars().nth(prefix.is_empty()\
    \ as usize + 1).unwrap();\n  |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&String`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvuzq1igb.rs:11:5\n\
    \   |\n4  | fn all_prefixes(string: String) -> Vec<String> {\n   |           \
    \                         ----------- expected `Vec<String>` because of return\
    \ type\n...\n11 |     prefixes\n   |     ^^^^^^^^ expected struct `String`, found\
    \ `&String`\n   |\n   = note: expected struct `Vec<String>`\n              found\
    \ struct `Vec<&String>`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    string\n        .chars()\n        .filter(|&c| c.is_ascii_letter())\n\
    \        .map(String::from)\n        .collect()\n}\n\nfn main() {\n    let candidate\
    \ = all_prefixes;\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"asdfgh\")), vec![String::from(\"a\"),\
    \ String::from(\"as\"), String::from(\"asd\"), String::from(\"asdf\"), String::from(\"\
    asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for type `char` in\
    \ the current scope\n --> /tmp/tmpwgs2yw7j.rs:7:24\n  |\n7 |         .filter(|&c|\
    \ c.is_ascii_letter())\n  |                        ^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `is_ascii`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    if string.len() <= 2 {\n        return vec![string];\n\
    \    }\n\n    let mut result = vec![string];\n    for c in string.chars() {\n\
    \        for prefix in result.iter_mut() {\n            prefix.push(c);\n    \
    \        if prefix.len() > string.len() {\n                break;\n          \
    \  }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `string`\n  --> /tmp/tmpiw684nin.rs:10:14\n\
    \   |\n4  | fn all_prefixes(string: String) -> Vec<String> {\n   |           \
    \      ------ move occurs because `string` has type `String`, which does not implement\
    \ the `Copy` trait\n...\n9  |     let mut result = vec![string];\n   |       \
    \                    ------ value moved here\n10 |     for c in string.chars()\
    \ {\n   |              ^^^^^^^^^^^^^^ value borrowed here after move\n   |\n \
    \  = note: borrow occurs due to deref coercion to `str`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut prefix = String::from(\"\");\n    let mut len\
    \ = string.len();\n    let mut iter = string.chars().enumerate().rev();\n    let\
    \ mut prefix = String::from(\"\");\n\n    for &(i, c) in iter {\n        let end\
    \ = len - (i + 1);\n        prefix = prefix.push_str(&string[i..end]);\n    }\n\
    \n    prefix.to_lowercase().chars().map(|&c| c.to_string()).collect()\n}\n\nfn\
    \ main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \    --> /tmp/tmpxalg2w7j.rs:7:47\n     |\n7    |     let mut iter = string.chars().enumerate().rev();\n\
    \     |                                               ^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n     |\n     = help: the following other\
    \ types implement trait `ExactSizeIterator`:\n               &mut I\n        \
    \       Args\n               ArgsOs\n               ArrayChunks<'_, T, N>\n  \
    \             ArrayChunksMut<'_, T, N>\n               ArrayWindows<'_, T, N>\n\
    \               Box<I, A>\n               Chunks<'_, T>\n             and 109\
    \ others\n     = note: required because of the requirements on the impl of `DoubleEndedIterator`\
    \ for `Enumerate<Chars<'_>>`\nnote: required by a bound in `rev`\n\nerror[E0277]:\
    \ the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n  --> /tmp/tmpxalg2w7j.rs:10:20\n\
    \   |\n10 |     for &(i, c) in iter {\n   |                    ^^^^ the trait\
    \ `ExactSizeIterator` is not implemented for `Chars<'_>`\n   |\n   = help: the\
    \ following other types implement trait `ExactSizeIterator`:\n             &mut\
    \ I\n             Args\n             ArgsOs\n             ArrayChunks<'_, T, N>\n\
    \             ArrayChunksMut<'_, T, N>\n             ArrayWindows<'_, T, N>\n\
    \             Box<I, A>\n             Chunks<'_, T>\n           and 109 others\n\
    \   = note: required because of the requirements on the impl of `DoubleEndedIterator`\
    \ for `Enumerate<Chars<'_>>`\n   = note: required because of the requirements\
    \ on the impl of `Iterator` for `Rev<Enumerate<Chars<'_>>>`\n   = note: required\
    \ because of the requirements on the impl of `IntoIterator` for `Rev<Enumerate<Chars<'_>>>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpxalg2w7j.rs:10:9\n   |\n10 | \
    \    for &(i, c) in iter {\n   |         ^^^^^^^    ---- this expression has type\
    \ `Option<(usize, char)>`\n   |         |\n   |         expected tuple, found\
    \ reference\n   |\n   = note:  expected tuple `(usize, char)`\n           found\
    \ reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpx"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    if string.len() == 0 {\n        return vec![];\n    }\n\
    \    let mut prefix = vec![];\n    let mut string_length = string.len();\n   \
    \ while string_length > 0 {\n        prefix.push(string[string_length - 1]);\n\
    \        string_length = string_length - 1;\n    }\n    prefix\n}\n\nfn main()\
    \ {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpngtaeb5t.rs:11:21\n\
    \   |\n11 |         prefix.push(string[string_length - 1]);\n   |            \
    \         ^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n  \
    \ |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut prefixes = Vec::new();\n    for c in string.chars()\
    \ {\n        if !c.is_prefix() {\n            return prefixes;\n        }\n  \
    \      prefixes.push(c.unwrap());\n    }\n    prefixes\n}\n\nfn main() {\n   \
    \ let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\")),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\")),\
    \ vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_prefix` found for type `char` in the\
    \ current scope\n --> /tmp/tmp7cj9hw6t.rs:7:15\n  |\n7 |         if !c.is_prefix()\
    \ {\n  |               ^^^^^^^^^ method not found in `char`\n\nerror[E0599]: no\
    \ method named `unwrap` found for type `char` in the current scope\n  --> /tmp/tmp7cj9hw6t.rs:10:25\n\
    \   |\n10 |         prefixes.push(c.unwrap());\n   |                         ^^^^^^\
    \ method not found in `char`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut prefix = vec![];\n    let mut index = 0;\n   \
    \ let mut len = string.len();\n    while index < len {\n        let mut s = &string[index..];\n\
    \        let len = s.len();\n        if let Some(prefix) = (\n            prefix.iter().cloned().find(|s|\
    \ s == String::from(s[len..])),\n        ) {\n            prefix.push(string[index..(index\
    \ as usize)]);\n            prefix.sort_unstable();\n            break;\n    \
    \    }\n        if index == len {\n            prefix.push(string[index..(index\
    \ as usize)]);\n            prefix.sort_unstable();\n        }\n        index\
    \ += 1;\n    }\n    prefix\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `&T`\n  --> /tmp/tmppufonhog.rs:12:42\n\
    \   |\n12 |             prefix.iter().cloned().find(|s| s == String::from(s[len..])),\n\
    \   |                                          ^ consider giving this closure\
    \ parameter the explicit type `&T`, where the type parameter `T` is specified\n\
    \   |\n   = note: type must be known at this point\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 101
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut result = vec![];\n    let mut prefix = string;\n\
    \    while !prefix.is_empty() {\n        result.push(prefix.clone());\n      \
    \  prefix = prefix.chars().skip_while(|c| *c != 'z').take(prefix.len()).collect();\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"asdfgh\"]`,\n right: `[\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"\
    ]`', /tmp/tmppr3mv_l9.rs:17:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659976677
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    string.chars().zip(string.chars().skip(1)\n        .take_while(|&(mut\
    \ x, _)| x.is_ascii_letter())\n        .collect::<Vec<_>>()).collect()\n}\n\n\
    fn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpkl9yhd69.rs:6:23\n  |\n6 |\
    \         .take_while(|&(mut x, _)| x.is_ascii_letter())\n  |                \
    \       ^^^^^^^^^-\n  |                       |        |\n  |                \
    \       |        expected due to this\n  |                       expected `char`,\
    \ found tuple\n  |\n  = note: expected type `char`\n            found tuple `(_,\
    \ _)`\n\nerror[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `(char, char)`\n    --> /tmp/tmpkl9yhd69.rs:7:31\n   \
    \  |\n7    |         .collect::<Vec<_>>()).collect()\n     |                 \
    \              ^^^^^^^ value of type `Vec<String>` cannot be built from `std::iter::Iterator<Item=(char,\
    \ char)>`\n     |\n     = help: the trait `FromIterator<(char, char)>` is not\
    \ implemented for `Vec<String>`\n     = help: the trait `FromIterator<T>` is implemented\
    \ for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    string\n        .chars()\n        .filter_map(|c| {\n\
    \            if c.is_whitespace() {\n                Some(\"\")\n            }\
    \ else {\n                Some(String::from(c))\n            }\n        })\n \
    \       .collect()\n}\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwjbla4wi.rs:11:22\n   |\n\
    11 |                 Some(String::from(c))\n   |                      ^^^^^^^^^^^^^^^\n\
    \   |                      |\n   |                      expected `&str`, found\
    \ struct `String`\n   |                      help: consider borrowing here: `&String::from(c)`\n\
    \nerror[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n    --> /tmp/tmpwjbla4wi.rs:14:10\n     |\n14\
    \   |         .collect()\n     |          ^^^^^^^ value of type `Vec<String>`\
    \ cannot be built from `std::iter::Iterator<Item=&str>`\n     |\n     = help:\
    \ the trait `FromIterator<&str>` is not implemented for `Vec<String>`\n     =\
    \ help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    all_prefixes_helper(string.chars().collect::<Vec<_>>(),\
    \ string.len())\n}\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `all_prefixes_helper` in this scope\n\
    \ --> /tmp/tmpbpe2q6xx.rs:5:5\n  |\n5 |     all_prefixes_helper(string.chars().collect::<Vec<_>>(),\
    \ string.len())\n  |     ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    if string.len() == 0 {\n        return vec![];\n    }\n\
    \    let mut prefix = vec![\"\"];\n    let mut result = vec![];\n    while !prefix.is_empty()\
    \ {\n        result.append(&prefix[0]);\n        prefix = prefix[1..];\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpq8nv2dh5.rs:11:23\n   |\n\
    11 |         result.append(&prefix[0]);\n   |                       ^^^^^^^^^^\
    \ types differ in mutability\n   |\n   = note: expected mutable reference `&mut\
    \ Vec<_>`\n                      found reference `&&str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpq8nv2dh5.rs:12:18\n   |\n8  |     let mut prefix = vec![\"\
    \"];\n   |                      -------- expected due to this value\n...\n12 |\
    \         prefix = prefix[1..];\n   |                  ^^^^^^^^^^^- help: try\
    \ using a conversion method: `.to_vec()`\n   |                  |\n   |      \
    \            expected struct `Vec`, found slice `[&str]`\n   |\n   = note: expected\
    \ struct `Vec<&str>`\n               found slice `[&str]`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976677
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    if string.is_empty() {\n        return vec![];\n    }\n\
    \    let mut current = string.clone();\n    vec![].push((&current, &string.clone()));\n\
    \    while let Some(prefix) = current.prefix(&0) {\n        let next = current.to_lowercase();\n\
    \        if let Some(candidate) = (&current, &next) {\n            vec![].push((&candidate,\
    \ &next.clone()));\n        }\n        current = prefix;\n    }\n    vec![]\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `prefix` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpfc3swsqd.rs:10:38\n   |\n10 |     while let Some(prefix)\
    \ = current.prefix(&0) {\n   |                                      ^^^^^^ help:\
    \ there is an associated function with a similar name: `strip_prefix`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpfc3swsqd.rs:12:16\n   |\n12 |         if let\
    \ Some(candidate) = (&current, &next) {\n   |                ^^^^^^^^^^^^^^^ \
    \  ----------------- this expression has type `(&String, &String)`\n   |     \
    \           |\n   |                expected tuple, found enum `Option`\n   |\n\
    \   = note: expected tuple `(&String, &String)`\n               found enum `Option<_>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    string.iter().map(|c| c.to_string()).collect()\n}\n\n\
    fn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n --> /tmp/tmpgm7xqn7s.rs:5:12\n  |\n5 |     string.iter().map(|c| c.to_string()).collect()\n\
    \  |            ^^^^ method not found in `String`\n  |\nhelp: because of the in-memory\
    \ representation of `&str`, to obtain an `Iterator` over each of its codepoint\
    \ use method `chars`\n  |\n5 |     string.chars().map(|c| c.to_string()).collect()\n\
    \  |            ~~~~~\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    // Sort string into prefix list\n    let mut prefix_list:\
    \ Vec<_> = vec![];\n    for (i, ch) in string.chars().enumerate() {\n        if\
    \ i == 0 {\n            prefix_list.push(String::from(ch));\n        } else {\n\
    \            prefix_list.push(String::from(&string[i - 1]));\n        }\n    }\n\
    \    prefix_list.sort_by(|a, b| a.len().cmp(&b.len()));\n\n    prefix_list\n}\n\
    \nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpqxqiv741.rs:11:44\n\
    \   |\n11 |             prefix_list.push(String::from(&string[i - 1]));\n   |\
    \                                            ^^^^^^^^^^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976676
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut it = string.chars();\n    let mut prefix = String::from(\"\
    \");\n    loop {\n        let next = it.next().unwrap();\n        if next == Some('\\\
    0') {\n            break;\n        }\n        prefix.push(next.unwrap());\n  \
    \  }\n    vec![prefix]\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpbi225we5.rs:9:20\n  |\n9 |\
    \         if next == Some('\\0') {\n  |                    ^^^^^^^^^^ expected\
    \ `char`, found enum `Option`\n  |\n  = note: expected type `char`\n         \
    \    found enum `Option<char>`\n\nerror[E0599]: no method named `unwrap` found\
    \ for type `char` in the current scope\n  --> /tmp/tmpbi225we5.rs:12:26\n   |\n\
    12 |         prefix.push(next.unwrap());\n   |                          ^^^^^^\
    \ method not found in `char`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976677
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    if string.is_empty() {\n        return vec![];\n    }\n\
    \n    let mut prefix_vec = Vec::new();\n\n    for prefix in string.chars() {\n\
    \        if prefix_vec.iter().any(|s| prefix.starts_with(s)).unwrap_or(false)\
    \ {\n            return vec![];\n        }\n\n        prefix_vec.push(prefix);\n\
    \    }\n\n    prefix_vec\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `starts_with` found for type `char` in the\
    \ current scope\n  --> /tmp/tmp1id830j8.rs:12:45\n   |\n12 |         if prefix_vec.iter().any(|s|\
    \ prefix.starts_with(s)).unwrap_or(false) {\n   |                            \
    \                 ^^^^^^^^^^^ method not found in `char`\n\nerror[E0599]: no method\
    \ named `unwrap_or` found for type `bool` in the current scope\n  --> /tmp/tmp1id830j8.rs:12:61\n\
    \   |\n12 |         if prefix_vec.iter().any(|s| prefix.starts_with(s)).unwrap_or(false)\
    \ {\n   |                                                             ^^^^^^^^^\
    \ method not found in `bool`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1id830j8.rs:19:5\n\
    \   |\n4  | fn all_prefixes(string: String) -> Vec<String> {\n   |           \
    \                         ----------- expected `Vec<String>` because of return\
    \ type\n...\n19 |     prefix_vec\n   |     ^^^^^^^^^^ expected struct `String`,\
    \ found `char`\n   |\n   = note: expected struct `Vec<String>`\n             \
    \ found struct `Vec<char>`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976677
- exit_code: 1
  program: "/// Return vector of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"\
    a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String)\
    \ -> Vec<String> {\n    let mut iter = string.char_indices();\n    let mut prefixes\
    \ = Vec::new();\n    while let Some(index) = iter.next() {\n        prefixes.push(&string[index..]);\n\
    \    }\n    prefixes\n}\n\nfn main() {\n    let candidate = all_prefixes;\n  \
    \  assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `RangeFrom<(usize,\
    \ char)>`\n --> /tmp/tmpn8fl80u5.rs:8:24\n  |\n8 |         prefixes.push(&string[index..]);\n\
    \  |                        ^^^^^^^^^^^^^^^ `String` cannot be indexed by `RangeFrom<(usize,\
    \ char)>`\n  |\n  = help: the trait `Index<RangeFrom<(usize, char)>>` is not implemented\
    \ for `String`\n  = help: the following other types implement trait `Index<Idx>`:\n\
    \            <String as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n\
    \            <String as Index<RangeInclusive<usize>>>\n            <String as\
    \ Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpn8fl80u5.rs:10:5\n   |\n4  | fn\
    \ all_prefixes(string: String) -> Vec<String> {\n   |                        \
    \            ----------- expected `Vec<String>` because of return type\n...\n\
    10 |     prefixes\n   |     ^^^^^^^^ expected struct `String`, found reference\n\
    \   |\n   = note: expected struct `Vec<String>`\n              found struct `Vec<&_>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976677
